{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/robots.txt","path":"robots.txt","modified":0,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"source/img/host.png","path":"img/host.png","modified":0,"renderable":0},{"_id":"source/img/react-native.png","path":"img/react-native.png","modified":0,"renderable":0},{"_id":"themes/myNext/source/404.html","path":"404.html","modified":0,"renderable":1},{"_id":"source/img/Disqus评论系统.png","path":"img/Disqus评论系统.png","modified":0,"renderable":0},{"_id":"source/img/hexo-directory.png","path":"img/hexo-directory.png","modified":0,"renderable":0},{"_id":"source/img/hey_folks.jpg","path":"img/hey_folks.jpg","modified":0,"renderable":0},{"_id":"source/img/打赏.JPG","path":"img/打赏.JPG","modified":0,"renderable":0},{"_id":"source/img/classloader/order.png","path":"img/classloader/order.png","modified":0,"renderable":0},{"_id":"source/img/fastblur/memory_100.png","path":"img/fastblur/memory_100.png","modified":0,"renderable":0},{"_id":"source/img/fastblur/iosblur.jpg","path":"img/fastblur/iosblur.jpg","modified":0,"renderable":0},{"_id":"source/img/fastblur/memory_1.png","path":"img/fastblur/memory_1.png","modified":0,"renderable":0},{"_id":"source/img/fastblur/memory_10.png","path":"img/fastblur/memory_10.png","modified":0,"renderable":0},{"_id":"source/img/fastblur/memory_20.png","path":"img/fastblur/memory_20.png","modified":0,"renderable":0},{"_id":"source/img/fastblur/memory_200.png","path":"img/fastblur/memory_200.png","modified":0,"renderable":0},{"_id":"source/img/fastblur/memory_300.png","path":"img/fastblur/memory_300.png","modified":0,"renderable":0},{"_id":"source/img/fastblur/memory_50.png","path":"img/fastblur/memory_50.png","modified":0,"renderable":0},{"_id":"source/img/gc/garbage.png","path":"img/gc/garbage.png","modified":0,"renderable":0},{"_id":"source/img/gc/mark-compact.png","path":"img/gc/mark-compact.png","modified":0,"renderable":0},{"_id":"source/img/gc/reachable.JPG","path":"img/gc/reachable.JPG","modified":0,"renderable":0},{"_id":"source/img/gc/young_1.png","path":"img/gc/young_1.png","modified":0,"renderable":0},{"_id":"source/img/gc/young_2.png","path":"img/gc/young_2.png","modified":0,"renderable":0},{"_id":"source/img/gc/young_3.png","path":"img/gc/young_3.png","modified":0,"renderable":0},{"_id":"source/img/interesting-curve/9.jpg","path":"img/interesting-curve/9.jpg","modified":0,"renderable":0},{"_id":"source/img/leakcanary/project.png","path":"img/leakcanary/project.png","modified":0,"renderable":0},{"_id":"themes/myNext/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/myNext/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/myNext/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/myNext/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/myNext/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/myNext/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/myNext/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/myNext/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/myNext/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/myNext/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/myNext/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/myNext/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/myNext/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/myNext/source/js/bootstrap.js","path":"js/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/myNext/source/js/bootstrap.scrollspy.js","path":"js/bootstrap.scrollspy.js","modified":0,"renderable":1},{"_id":"themes/myNext/source/js/hook-duoshuo.js","path":"js/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/myNext/source/js/helpers.js","path":"js/helpers.js","modified":0,"renderable":1},{"_id":"themes/myNext/source/js/fancy-box.js","path":"js/fancy-box.js","modified":0,"renderable":1},{"_id":"themes/myNext/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/myNext/source/js/ua-parser.min.js","path":"js/ua-parser.min.js","modified":0,"renderable":1},{"_id":"source/img/annotation/warning.png","path":"img/annotation/warning.png","modified":0,"renderable":0},{"_id":"source/img/annotation/no-warning.png","path":"img/annotation/no-warning.png","modified":0,"renderable":0},{"_id":"source/img/fastblur/androidblur_2.png","path":"img/fastblur/androidblur_2.png","modified":0,"renderable":0},{"_id":"source/img/gc/copying.png","path":"img/gc/copying.png","modified":0,"renderable":0},{"_id":"source/img/fastblur/timeconsume_statisic.png","path":"img/fastblur/timeconsume_statisic.png","modified":0,"renderable":0},{"_id":"source/img/gc/mark-sweep.png","path":"img/gc/mark-sweep.png","modified":0,"renderable":0},{"_id":"source/img/interesting-curve/10.png","path":"img/interesting-curve/10.png","modified":0,"renderable":0},{"_id":"source/img/interesting-curve/3.png","path":"img/interesting-curve/3.png","modified":0,"renderable":0},{"_id":"source/img/me-and-blog.jpg","path":"img/me-and-blog.jpg","modified":0,"renderable":0},{"_id":"themes/myNext/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/myNext/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/myNext/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/myNext/source/vendors/font-awesome/bower.json","path":"vendors/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/myNext/source/vendors/font-awesome/HELP-US-OUT.txt","path":"vendors/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/myNext/source/vendors/jquery_lazyload/CONTRIBUTING.md","path":"vendors/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/myNext/source/vendors/jquery_lazyload/README.md","path":"vendors/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/myNext/source/vendors/jquery_lazyload/bower.json","path":"vendors/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/myNext/source/vendors/jquery_lazyload/jquery.scrollstop.js","path":"vendors/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/myNext/source/vendors/jquery_lazyload/jquery.lazyload.js","path":"vendors/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/myNext/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/myNext/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/myNext/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/myNext/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"source/img/fastblur/androidblur_1.png","path":"img/fastblur/androidblur_1.png","modified":0,"renderable":0},{"_id":"source/img/fastblur/test_pic.jpeg","path":"img/fastblur/test_pic.jpeg","modified":0,"renderable":0},{"_id":"themes/myNext/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":0,"renderable":1},{"_id":"source/img/interesting-curve/4.png","path":"img/interesting-curve/4.png","modified":0,"renderable":0},{"_id":"source/img/interesting-curve/5.png","path":"img/interesting-curve/5.png","modified":0,"renderable":0},{"_id":"source/img/interesting-curve/8.png","path":"img/interesting-curve/8.png","modified":0,"renderable":0},{"_id":"themes/myNext/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/myNext/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/myNext/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/myNext/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/myNext/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/myNext/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/myNext/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/myNext/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/myNext/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/myNext/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/myNext/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/myNext/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/myNext/source/vendors/font-awesome/css/font-awesome.css.map","path":"vendors/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/myNext/source/vendors/font-awesome/css/font-awesome.css","path":"vendors/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/myNext/source/vendors/font-awesome/css/font-awesome.min.css","path":"vendors/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"source/img/fastblur/fastblur_100.png","path":"img/fastblur/fastblur_100.png","modified":0,"renderable":0},{"_id":"source/img/fastblur/fastblur_20.png","path":"img/fastblur/fastblur_20.png","modified":0,"renderable":0},{"_id":"source/img/fastblur/fastblur_35.png","path":"img/fastblur/fastblur_35.png","modified":0,"renderable":0},{"_id":"source/img/fastblur/fastblur_50.png","path":"img/fastblur/fastblur_50.png","modified":0,"renderable":0},{"_id":"themes/myNext/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/myNext/source/vendors/font-awesome/fonts/FontAwesome.otf","path":"vendors/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/myNext/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/myNext/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":0,"renderable":1},{"_id":"source/img/fastblur/fastblur_10.png","path":"img/fastblur/fastblur_10.png","modified":0,"renderable":0},{"_id":"source/img/interesting-curve/1.png","path":"img/interesting-curve/1.png","modified":0,"renderable":0},{"_id":"source/img/interesting-curve/11.png","path":"img/interesting-curve/11.png","modified":0,"renderable":0},{"_id":"source/img/interesting-curve/2.png","path":"img/interesting-curve/2.png","modified":0,"renderable":0},{"_id":"source/img/interesting-curve/6.png","path":"img/interesting-curve/6.png","modified":0,"renderable":0},{"_id":"source/img/myblog.png","path":"img/myblog.png","modified":0,"renderable":0},{"_id":"themes/myNext/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/myNext/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/myNext/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/myNext/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/myNext/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/myNext/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/myNext/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"source/img/interesting-curve/7.png","path":"img/interesting-curve/7.png","modified":0,"renderable":0},{"_id":"themes/myNext/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"source/img/interesting-curve/box.gif","path":"img/interesting-curve/box.gif","modified":0,"renderable":0},{"_id":"source/img/interesting-curve/ring.gif","path":"img/interesting-curve/ring.gif","modified":0,"renderable":0},{"_id":"source/img/sjtu/library.jpg","path":"img/sjtu/library.jpg","modified":0,"renderable":0},{"_id":"source/img/sjtu/dom.jpg","path":"img/sjtu/dom.jpg","modified":0,"renderable":0},{"_id":"source/img/sjtu/laker.jpg","path":"img/sjtu/laker.jpg","modified":0,"renderable":0},{"_id":"source/img/sjtu/tuya.jpg","path":"img/sjtu/tuya.jpg","modified":0,"renderable":0},{"_id":"source/img/sjtu/huxiaohe.jpg","path":"img/sjtu/huxiaohe.jpg","modified":0,"renderable":0},{"_id":"source/img/dream.jpg","path":"img/dream.jpg","modified":0,"renderable":0},{"_id":"source/img/sjtu/library_outside.jpg","path":"img/sjtu/library_outside.jpg","modified":0,"renderable":0},{"_id":"source/img/sjtu/love.jpg","path":"img/sjtu/love.jpg","modified":0,"renderable":0},{"_id":"source/img/walk_in_sh/18.JPG","path":"img/walk_in_sh/18.JPG","modified":0,"renderable":0},{"_id":"source/img/walk_in_sh/1.JPG","path":"img/walk_in_sh/1.JPG","modified":0,"renderable":0},{"_id":"source/img/walk_in_sh/15.JPG","path":"img/walk_in_sh/15.JPG","modified":0,"renderable":0},{"_id":"source/img/walk_in_sh/2.JPG","path":"img/walk_in_sh/2.JPG","modified":0,"renderable":0},{"_id":"source/img/walk_in_sh/4.JPG","path":"img/walk_in_sh/4.JPG","modified":0,"renderable":0},{"_id":"source/img/walk_in_sh/11.JPG","path":"img/walk_in_sh/11.JPG","modified":0,"renderable":0},{"_id":"source/img/walk_in_sh/16.JPG","path":"img/walk_in_sh/16.JPG","modified":0,"renderable":0},{"_id":"source/img/walk_in_sh/17.JPG","path":"img/walk_in_sh/17.JPG","modified":0,"renderable":0},{"_id":"source/img/sjtu/hehua.jpg","path":"img/sjtu/hehua.jpg","modified":0,"renderable":0},{"_id":"source/img/walk_in_sh/7.JPG","path":"img/walk_in_sh/7.JPG","modified":0,"renderable":0},{"_id":"source/img/walk_in_sh/14.JPG","path":"img/walk_in_sh/14.JPG","modified":0,"renderable":0},{"_id":"source/img/walk_in_sh/6.JPG","path":"img/walk_in_sh/6.JPG","modified":0,"renderable":0},{"_id":"source/img/walk_in_sh/10.JPG","path":"img/walk_in_sh/10.JPG","modified":0,"renderable":0},{"_id":"source/img/walk_in_sh/3.JPG","path":"img/walk_in_sh/3.JPG","modified":0,"renderable":0},{"_id":"source/img/walk_in_sh/5.JPG","path":"img/walk_in_sh/5.JPG","modified":0,"renderable":0},{"_id":"source/img/walk_in_sh/9.JPG","path":"img/walk_in_sh/9.JPG","modified":0,"renderable":0},{"_id":"source/img/walk_in_sh/12.JPG","path":"img/walk_in_sh/12.JPG","modified":0,"renderable":0},{"_id":"source/img/walk_in_sh/13.JPG","path":"img/walk_in_sh/13.JPG","modified":0,"renderable":0},{"_id":"source/img/walk_in_sh/8.JPG","path":"img/walk_in_sh/8.JPG","modified":0,"renderable":0}],"Cache":[{"_id":"source/robots.txt","hash":"6123a9417ecb039cb56a5b45c3e0450e30196e35","modified":1543215388115},{"_id":"themes/myNext/_config.yml","hash":"f37c6cd228ca1c2d236f064921559d205373c61a","modified":1543215388141},{"_id":"themes/myNext/bower.json","hash":"4a53cab758c7d69be2ce773b2afff7dd962b7cb0","modified":1543215388141},{"_id":"themes/myNext/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1543215388141},{"_id":"themes/myNext/README.md","hash":"e170117386e13c5296748f20e4d07f6db46776cc","modified":1543215388141},{"_id":"source/favicon.ico","hash":"bb38565775f52af7d2f1f0187ed9972a7b4f09a1","modified":1543215387489},{"_id":"source/_drafts/梦想升起的地方.md","hash":"002bb2e4e78b680e316992ce7d5a7e107dd54151","modified":1543215387479},{"_id":"source/_drafts/test-draft.md","hash":"1e69132635b7246d5e923c432e03836b83a925fd","modified":1543215387479},{"_id":"source/_posts/30条Android开发建议.md","hash":"ddaeb9456aa4310996ec887a501dd6d90924ff38","modified":1543215387479},{"_id":"source/_drafts/谈谈Java的动态代理与Python的装饰器.md","hash":"a0024cfaa5d55af9016eadf17e0eaa6831aeace2","modified":1543215387479},{"_id":"source/_posts/Hey folks.md","hash":"59f4b6e7fb37894fcd1ffca2635b8736dbbffab8","modified":1543215387479},{"_id":"source/_posts/Android-架构之长连接技术.md","hash":"2bdc0d35db67143ad4a100c7c7cb4199373ae5ab","modified":1547610170850},{"_id":"source/_posts/Android-架构之高可用移动网络连接.md","hash":"a1a1bbebd1676b046f6010b95a29a998c2a7f6f8","modified":1547610222783},{"_id":"source/_posts/Hey-2018，Farewell-2017.md","hash":"41b96312cd7bfa4838696d9c20d10ae94710a506","modified":1543215387480},{"_id":"source/_posts/Java-技术之动态代理机制.md","hash":"8f92de42fa9f1b3a40d4d7b35d7a792c2487cd63","modified":1543215387480},{"_id":"source/_posts/Java-技术之反射.md","hash":"5bf2afc466895e77ec05c2632ac432b20cfb0a2f","modified":1543215387480},{"_id":"source/_posts/Java-技术之注解-Annotation.md","hash":"6018bc27f4339bb22d2b053cb1098b050dedfeb3","modified":1543215387481},{"_id":"source/_posts/Java-技术之垃圾回收机制.md","hash":"99448b5b9058a5fb7e9b33e7a53926f5a7e7b238","modified":1543215387480},{"_id":"source/_posts/Java的equals与hashcode对比分析.md","hash":"48abdcdf9e0a8728ea8a7356c2f9d1fe1d29e617","modified":1543215387481},{"_id":"source/_posts/Java-技术之类加载机制.md","hash":"e81178875538c09aaef3adafba45e8f5b363d60f","modified":1543215387481},{"_id":"source/_posts/RxLifecycle源码解析－当Activity被destory时自动暂停网络请求.md","hash":"c86aff136eea218b2d960b2d7c1d28a8c549058d","modified":1543215387481},{"_id":"source/_posts/Java里如何实现线程间通信？.md","hash":"9a8c7b4dd40d1f276459dc996e3247a909af4024","modified":1543215387481},{"_id":"source/_posts/Walk-in-ShangHai.md","hash":"8bffe144d268f1136fda3a0713ee56c3183a1e65","modified":1543215387482},{"_id":"source/_posts/《亿级-Android-架构》专栏随谈.md","hash":"017eee3da208db833060380bf867dc19078e934c","modified":1547610033390},{"_id":"source/_posts/交大－影.md","hash":"51d8dd50e77134d877ce0f1fe89eecd3b277af4d","modified":1543215387483},{"_id":"source/_posts/一种快速毛玻璃虚化效果实现.md","hash":"c527fd44a634648b69dd14418064008620386365","modified":1543215387482},{"_id":"source/_posts/今年之计.md","hash":"7d35c76a4825f90e545b1605d44b7f52a83da463","modified":1543215387483},{"_id":"source/_posts/今年之计－2017.md","hash":"9b4f48e1dfe2084045dac064d52b8c9d20d037cc","modified":1543215387483},{"_id":"source/_posts/如何在一天之内搭建以你自己名字为域名的很cool的个人博客.md","hash":"ffe907b5a8a22f066c3f917b18302f6a260e7b09","modified":1543215387484},{"_id":"source/_posts/写给移动开发者的-React-Native-指南.md","hash":"2721451b2ce569a61b86a8c9ee6df0db3db69c6e","modified":1543215387484},{"_id":"source/_posts/对未来个人技术博客的一些思考.md","hash":"1bb96d249fcc7d7511cae97896c45c4d2d2f8e55","modified":1543215387484},{"_id":"source/_posts/带你学开源项目：LeakCanary-如何检测-Activity-发生泄漏.md","hash":"9c7a55ae273a2f04615b68b51087f94cd35c7572","modified":1543215387485},{"_id":"source/_posts/带你学开源项目：Meizhi-Android之RxJava-Retrofit最佳实践.md","hash":"18c20fc3d25e890a716a98a013d12c5eccc6c99e","modified":1543215387485},{"_id":"source/_posts/带你学开源项目：OkHttp-自己动手实现okhttp.md","hash":"7ad6531db09fd6c1ff38892271dde4bf8d6f3381","modified":1543215387485},{"_id":"source/_posts/新的城市，新的开始.md","hash":"1187db93e94afcad63865fe9028852208271cdc4","modified":1543215387486},{"_id":"source/_posts/我与代码的相知相遇.md","hash":"ddf9e6200d4b73e698a2dcc16ee5d3ef04794aa0","modified":1543215387486},{"_id":"source/_posts/干货-Glow-Android-优化实践.md","hash":"262f9fc7d96bf9c9cc6276660368ea752aa7729e","modified":1543215387486},{"_id":"source/_posts/有趣的曲线在Android上的实现.md","hash":"861234a5d77b918b52bcb9b6ba7161f9b80bcc8b","modified":1543215387487},{"_id":"source/_posts/计划清单.md","hash":"69825d90a1f17bcd993d7046b6591e6141f695cc","modified":1543215387488},{"_id":"source/_posts/梦想升起的地方.md","hash":"227cbd3b8363224995ff083078e686dcc65dc56a","modified":1543215387487},{"_id":"source/_posts/独立全端开发的开源小作：简诗2-0.md","hash":"8490a4b5ffe8ce1540c35284f0bceb99112e89e3","modified":1543215387487},{"_id":"source/_posts/自己动手改造个人博客.md","hash":"f97c8fc724907485cf175bb9f2b1084886963bcd","modified":1543215387487},{"_id":"source/_posts/让普通-Java-类自动感知-Activity-Lifecycle.md","hash":"1fcb26a3941654be4634f71d50f20eac9c4369ca","modified":1543215387488},{"_id":"source/guestbook/index.md","hash":"a367851e76c80c3e94afb026f9f22ba373b054c6","modified":1543215387489},{"_id":"source/_posts/谈谈移动应用的安全性实践.md","hash":"95a6aba51202c5740c68db0b96e643ce9c0a0a02","modified":1543215387489},{"_id":"source/_posts/说一说博客.md","hash":"443e2082989cf3a0381d88311afba2ab0dd1b64d","modified":1543215387488},{"_id":"source/img/host.png","hash":"e3cd6594465e22ed3b2a872e1b63212862097011","modified":1543215387551},{"_id":"source/img/react-native.png","hash":"6525ad1cf78d893dc9e55fe34d3ef6e95f524d3f","modified":1543215387601},{"_id":"source/tags/index.md","hash":"c60250d4ddd679b6841a052c754d7756a2f0be52","modified":1543215388115},{"_id":"themes/myNext/languages/de.yml","hash":"7a8de0e5665c52a1bf168c1e7dd222c8a74fb0ab","modified":1543215388141},{"_id":"source/resume/index.md","hash":"3ec80a9ebe4686b313ff13cefc5c6d1441f139cf","modified":1543215388115},{"_id":"themes/myNext/languages/default.yml","hash":"f57623e47f533c8d53d859628fa6a368a5298a00","modified":1543215388141},{"_id":"themes/myNext/languages/en.yml","hash":"f57623e47f533c8d53d859628fa6a368a5298a00","modified":1543215388142},{"_id":"themes/myNext/languages/fr-FR.yml","hash":"2cec663601ac8d178e97aee91d967fa99a95ad4e","modified":1543215388142},{"_id":"themes/myNext/languages/pt.yml","hash":"8e38fdf3a5232b428d2e4a641666dbabab87c3d1","modified":1543215388142},{"_id":"themes/myNext/languages/ru.yml","hash":"1d1b158f9cff1b38978086043f299b3fc590e007","modified":1543215388142},{"_id":"themes/myNext/languages/zh-Hans.yml","hash":"b7030711d0fa65beaa341b7c12928d6b02f0a9bc","modified":1543215388142},{"_id":"themes/myNext/languages/zh-hk.yml","hash":"248b88c825fde8e35839f3954d38df4e72a0537c","modified":1543215388142},{"_id":"themes/myNext/languages/zh-tw.yml","hash":"42ba1d0c6b6026ba1e613ad11efb75432a8132ac","modified":1543215388143},{"_id":"themes/myNext/layout/_layout.swig","hash":"d9e4b92f35ee3e99c4f626b88ccf6d4c371dd0de","modified":1543215388143},{"_id":"themes/myNext/layout/archive.swig","hash":"0c3ce594759f347ea90a4ce592a7a18e2ae4cc5c","modified":1543215388149},{"_id":"themes/myNext/layout/category.swig","hash":"d6b3e1dc5e0b8deade9a084c463126e70188ee9b","modified":1543215388150},{"_id":"themes/myNext/layout/index.swig","hash":"9224ad59d0f0d7d658b384d181100da742d6d097","modified":1543215388150},{"_id":"themes/myNext/layout/page.swig","hash":"8019d02232a6dd1a665b6a4d2daef8e5dd2f0049","modified":1543215388150},{"_id":"themes/myNext/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1543215388151},{"_id":"themes/myNext/layout/tag.swig","hash":"aab44af54fcbc66fea4ad12b2767ffca3eadd451","modified":1543215388150},{"_id":"themes/myNext/scripts/related_posts.js","hash":"3cfae2098027d1dd7db0ff511d5cb2a9c7299b7e","modified":1543215388151},{"_id":"themes/myNext/layout/post.swig","hash":"a84457e8ced46e63bc7a8a9e0541a6ba53122a92","modified":1543215388150},{"_id":"themes/myNext/source/404.html","hash":"92155185adcc84a9f4e7035a514cd622c379ae89","modified":1543215388152},{"_id":"themes/myNext/test/.jshintrc","hash":"096ed6df627373edd820f24d46b8baf528dee61d","modified":1543215388218},{"_id":"themes/myNext/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1543215388218},{"_id":"themes/myNext/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1543215388219},{"_id":"source/img/Disqus评论系统.png","hash":"e313d38101a7a49f717ff8964c9d125eef3b284d","modified":1543215387490},{"_id":"source/img/hexo-directory.png","hash":"826cebfed96a6407234bf963baf6921c398195e1","modified":1543215387549},{"_id":"source/img/hey_folks.jpg","hash":"b0a05bc1ed1669615ead2c5c9b7947f2b0d3968c","modified":1543215387550},{"_id":"source/img/打赏.JPG","hash":"42c50223599a722587c7fafa9ce0f6c7140e1405","modified":1543215388115},{"_id":"themes/myNext/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543215388164},{"_id":"source/img/classloader/order.png","hash":"72db27f2434eb2336be54ce4f1bb6b56b868e514","modified":1543215387492},{"_id":"source/img/fastblur/memory_100.png","hash":"3232f11fdac327635a82e22f009b776030c3bc89","modified":1543215387540},{"_id":"source/img/fastblur/iosblur.jpg","hash":"b7aad38c394a049c45cc60ddee04f916479d9ddc","modified":1543215387539},{"_id":"source/img/fastblur/memory_1.png","hash":"14e397afa644bcf3dac11daabd988cca961ad5d8","modified":1543215387539},{"_id":"source/img/fastblur/memory_10.png","hash":"935d56271c8d9304161cbcf5405b8a1ee0e87062","modified":1543215387539},{"_id":"source/img/fastblur/memory_20.png","hash":"db301fb4b555e31a64a77f4b1286310ea267ca58","modified":1543215387540},{"_id":"source/img/fastblur/memory_200.png","hash":"2a07afd6a2443e17461839dded0c279e8822d86b","modified":1543215387541},{"_id":"source/img/fastblur/memory_300.png","hash":"89d3356a32b32962d364f83d5d82f6a8d7d83333","modified":1543215387541},{"_id":"source/img/fastblur/memory_50.png","hash":"62b94351e2d50d256e83ec7ec3a854e084bceade","modified":1543215387541},{"_id":"source/img/gc/garbage.png","hash":"a872b666d4e1f0dc79f87c94489348acd17105d9","modified":1543215387546},{"_id":"source/img/gc/mark-compact.png","hash":"3ac4b53d222ae7e53397e540d3b0e156d8c40933","modified":1543215387546},{"_id":"source/img/gc/reachable.JPG","hash":"73f228750a79d0f7237126e7d279542e7b98b9f4","modified":1543215387547},{"_id":"source/img/gc/young_1.png","hash":"019bd491d81551b3e7d5c20d854867b398385799","modified":1543215387548},{"_id":"source/img/gc/young_2.png","hash":"ef5664777c4a15903db46bf86517782ba7e9f9fe","modified":1543215387548},{"_id":"source/img/gc/young_3.png","hash":"dec153f322058693bb3aae00d55c47b850becdfe","modified":1543215387549},{"_id":"source/img/interesting-curve/9.jpg","hash":"02f5f09e3607c7421b0e3c35fb644cc1b32986a6","modified":1543215387579},{"_id":"source/img/leakcanary/project.png","hash":"2fd900e5946d97c1be88e7e6d29d4ccdbffdde5f","modified":1543215387597},{"_id":"themes/myNext/layout/_macro/sidebar.swig","hash":"88e179ff660874135b17d0febc91d04749053a73","modified":1543215388143},{"_id":"themes/myNext/layout/_macro/post.swig","hash":"a4f810300f839529979905f9a504f42e8da46bb3","modified":1543215388143},{"_id":"themes/myNext/layout/_macro/post-collapse.swig","hash":"9032ae9056cb19b4c2d069d66ead7abf828f9922","modified":1543215388143},{"_id":"themes/myNext/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1543215388144},{"_id":"themes/myNext/layout/_partials/footer.swig","hash":"27b2be008ec91ff35d51407131453578ee235a4f","modified":1561521844010},{"_id":"themes/myNext/layout/_partials/comments.swig","hash":"a612a4eca51ffc87b53a5470b451071a7ad6a031","modified":1543215388144},{"_id":"themes/myNext/layout/_partials/github-comments.swig","hash":"957e5701d024c3efcb8cddef3dcc61ae15428f9b","modified":1543215388144},{"_id":"themes/myNext/layout/_partials/head.swig","hash":"359729ac487afc50b7697831493a54f27f848105","modified":1543215388145},{"_id":"themes/myNext/layout/_partials/old-browsers.swig","hash":"dbbfea810bf3a2ed9c83b9a6683037175aacfc67","modified":1543215388145},{"_id":"themes/myNext/layout/_partials/header.swig","hash":"476333c49a1e7e0402a68a826f67527ac258969d","modified":1543215388145},{"_id":"themes/myNext/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1543215388145},{"_id":"themes/myNext/layout/_partials/search.swig","hash":"64f14da26792a17bc27836c4e9d83190175f36e6","modified":1543215388145},{"_id":"themes/myNext/layout/_scripts/bootstrap.scrollspy.swig","hash":"85295f126836b95f0837d03e58228bb3cf8c4490","modified":1543215388147},{"_id":"themes/myNext/layout/_scripts/analytics.swig","hash":"33ca06b9bd9a15a19432d5396b85bd319f017319","modified":1543215388146},{"_id":"themes/myNext/layout/_scripts/baidushare.swig","hash":"d726361945437cf6e48067b3dd041b7e36e98d85","modified":1543215388147},{"_id":"themes/myNext/layout/_scripts/fancy-box.swig","hash":"41b4ff1446060c88c33bf666a32277dcf12129f0","modified":1543215388148},{"_id":"themes/myNext/layout/_scripts/helpers.swig","hash":"0c7c65454e236c294be78291449bbb608c7c09f1","modified":1543215388148},{"_id":"themes/myNext/layout/_scripts/motion.swig","hash":"0d9761e3b1bb9e666ccc71bad59f035deb5a88c6","modified":1543215388149},{"_id":"themes/myNext/layout/_scripts/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1543215388149},{"_id":"themes/myNext/scripts/filters/sticky.js","hash":"6b1ea0c09105352813357d0fff4e1d3f4c821fa3","modified":1543215388151},{"_id":"themes/myNext/scripts/tags/full-image.js","hash":"3acce36db0feb11a982c6c799aa6b6b47df2827c","modified":1543215388152},{"_id":"themes/myNext/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1543215388151},{"_id":"themes/myNext/layout/_scripts/mathjax.swig","hash":"df03220eb8526e17dc9c9f17780c2d6699367181","modified":1543215388148},{"_id":"themes/myNext/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1543215388152},{"_id":"themes/myNext/source/css/main.styl","hash":"56dacee56c5eaa4b2676d196452314fb50f758aa","modified":1543215388164},{"_id":"themes/myNext/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1543215388164},{"_id":"themes/myNext/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1543215388165},{"_id":"themes/myNext/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1543215388165},{"_id":"themes/myNext/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1543215388165},{"_id":"themes/myNext/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1543215388165},{"_id":"themes/myNext/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1543215388165},{"_id":"themes/myNext/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1543215388166},{"_id":"themes/myNext/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1543215388166},{"_id":"themes/myNext/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1543215388166},{"_id":"themes/myNext/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1543215388166},{"_id":"themes/myNext/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1543215388166},{"_id":"themes/myNext/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1543215388166},{"_id":"themes/myNext/source/js/bootstrap.js","hash":"f9b637b6d064f728d7dc2b6b5058a006a4454299","modified":1543215388167},{"_id":"themes/myNext/source/js/bootstrap.scrollspy.js","hash":"ae7bdce88b515aade4eea8bf7407eec458bcd625","modified":1543215388167},{"_id":"themes/myNext/source/js/hook-duoshuo.js","hash":"ccb32e0a1acf798337c9697e1aab5484b52f9df4","modified":1543215388168},{"_id":"themes/myNext/source/js/helpers.js","hash":"c15216ef897334362789ba37464298948b2eef95","modified":1543215388168},{"_id":"themes/myNext/source/js/fancy-box.js","hash":"b5fa638ed371b5f658b0826ec4afee25d9986ef2","modified":1543215388167},{"_id":"themes/myNext/source/js/motion.js","hash":"b4132517fe499538ad725094593fb7ead8c04bf7","modified":1543215388168},{"_id":"themes/myNext/source/js/ua-parser.min.js","hash":"1148fa2bcb8b2e40c31e5f597bf794a57369a2e6","modified":1543215388168},{"_id":"source/img/annotation/warning.png","hash":"7759b40d59373b8b5eb89ef83d20b8d9323a6af3","modified":1543215387491},{"_id":"source/img/annotation/no-warning.png","hash":"1a92f328e0aa6a9a040859de0537dc1965ab7d7a","modified":1543215387490},{"_id":"source/img/fastblur/androidblur_2.png","hash":"6ea9cc7a4ce5338c9de262e064b129829d2d877a","modified":1543215387521},{"_id":"source/img/gc/copying.png","hash":"d9b1e7e76d79d84971f842c294dc8124054e6472","modified":1543215387545},{"_id":"source/img/fastblur/timeconsume_statisic.png","hash":"bbff7161a608a488990613a9df5de6dcbf9162f9","modified":1543215387544},{"_id":"source/img/gc/mark-sweep.png","hash":"5e352e55715e058db8ccd1012b4193f46c5fc378","modified":1543215387547},{"_id":"source/img/interesting-curve/10.png","hash":"901a86dc68fdb1e8c8d7e2c2ed30c03b73d565f8","modified":1543215387555},{"_id":"themes/myNext/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543215388160},{"_id":"themes/myNext/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543215388161},{"_id":"themes/myNext/source/css/_mixins/default.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543215388161},{"_id":"themes/myNext/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543215388164},{"_id":"source/img/interesting-curve/3.png","hash":"03d2eb9ef532d6b5606d89cf6c21748c317087ca","modified":1543215387563},{"_id":"source/img/me-and-blog.jpg","hash":"0dee97f7d6615ad884b262e82982db52b2a29358","modified":1543215387598},{"_id":"themes/myNext/layout/_partials/search/swiftype.swig","hash":"00c2b49f6289198b0b2b4e157e4ee783277f32a7","modified":1543215388145},{"_id":"themes/myNext/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1543215388146},{"_id":"themes/myNext/layout/_scripts/analytics/baidu-analytics.swig","hash":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1543215388146},{"_id":"themes/myNext/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1543215388146},{"_id":"themes/myNext/layout/_scripts/analytics/facebook-sdk.swig","hash":"334176d838ee528e58468d8bc74ff3a6d3f25b2b","modified":1543215388147},{"_id":"themes/myNext/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1543215388146},{"_id":"themes/myNext/layout/_scripts/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1543215388147},{"_id":"themes/myNext/layout/_scripts/comments/disqus.swig","hash":"3491d3cebabc8a28857200db28a1be65aad6adc2","modified":1543215388147},{"_id":"themes/myNext/layout/_scripts/comments/duoshuo.swig","hash":"44e3d567fd49c2a093f4a0a8af9f00542c935a58","modified":1543215388148},{"_id":"themes/myNext/layout/_scripts/pages/post-details.swig","hash":"7a34b02808f144ee4a11032ae3a149eb634a7e82","modified":1543215388149},{"_id":"themes/myNext/source/css/_mixins/base.styl","hash":"4e49707c99c8bbcfa0a607dfdaff0fbb7dffd2a3","modified":1543215388161},{"_id":"themes/myNext/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1543215388160},{"_id":"themes/myNext/source/css/_variables/base.styl","hash":"f532d6b0f961a8f3867c06e132233286f110180d","modified":1543215388164},{"_id":"themes/myNext/source/css/_variables/Mist.styl","hash":"9f8791860cc1ca724d2dfe609e8cd6abc44d6926","modified":1543215388163},{"_id":"themes/myNext/source/css/_variables/default.styl","hash":"8ec3307fe42d738b1bbda4b6419d0995f5560222","modified":1543215388164},{"_id":"themes/myNext/source/vendors/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1543215388169},{"_id":"themes/myNext/source/vendors/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1543215388173},{"_id":"themes/myNext/source/vendors/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1543215388169},{"_id":"themes/myNext/source/vendors/font-awesome/.bower.json","hash":"7da985a99674e54f514d4fd9fcd3bcea6e7e41d5","modified":1543215388174},{"_id":"themes/myNext/source/vendors/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1543215388173},{"_id":"themes/myNext/source/vendors/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1543215388174},{"_id":"themes/myNext/source/vendors/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1543215388173},{"_id":"themes/myNext/source/vendors/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1543215388173},{"_id":"themes/myNext/source/vendors/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1543215388175},{"_id":"themes/myNext/source/vendors/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1543215388176},{"_id":"themes/myNext/source/vendors/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1543215388175},{"_id":"themes/myNext/source/vendors/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1543215388183},{"_id":"themes/myNext/source/vendors/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1543215388184},{"_id":"themes/myNext/source/vendors/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1543215388184},{"_id":"themes/myNext/source/vendors/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1543215388184},{"_id":"themes/myNext/source/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1543215388185},{"_id":"themes/myNext/source/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1543215388184},{"_id":"themes/myNext/source/vendors/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1543215388185},{"_id":"themes/myNext/source/vendors/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1543215388185},{"_id":"themes/myNext/source/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1543215388188},{"_id":"themes/myNext/source/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1543215388187},{"_id":"themes/myNext/source/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1543215388188},{"_id":"themes/myNext/source/vendors/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1543215388182},{"_id":"source/img/fastblur/androidblur_1.png","hash":"dfc1003232f2bc079ad507ad9fd29e37aba3dc5e","modified":1543215387521},{"_id":"source/img/fastblur/test_pic.jpeg","hash":"19ca9f388ab26da2c071841baab3868bfba15569","modified":1543215387543},{"_id":"themes/myNext/source/css/_common/_page/home.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543215388158},{"_id":"themes/myNext/source/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1543215388183},{"_id":"source/img/interesting-curve/4.png","hash":"a54df53b47e84f7b452f8393b6b93ccb32721d08","modified":1543215387565},{"_id":"source/img/interesting-curve/5.png","hash":"b3b915d72a8c9611c39b0bb12015f2757df2046f","modified":1543215387569},{"_id":"source/img/interesting-curve/8.png","hash":"8556f52be9972440d4460018133ccb3a4dfbcf5e","modified":1543215387579},{"_id":"themes/myNext/source/css/_common/_component/back-to-top.styl","hash":"88cd66910260006aa8e9e795df4948d4b67bfa11","modified":1543215388153},{"_id":"themes/myNext/source/css/_common/_component/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1543215388153},{"_id":"themes/myNext/source/css/_common/_component/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1543215388153},{"_id":"themes/myNext/source/css/_common/_component/buttons.styl","hash":"81063e0979f04a0f9af37f321d7321dda9abf593","modified":1543215388153},{"_id":"themes/myNext/source/css/_common/_component/duoshuo.styl","hash":"2d2da815ab0981b219ea1973a4aedede48801411","modified":1543215388153},{"_id":"themes/myNext/source/css/_common/_component/gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1543215388154},{"_id":"themes/myNext/source/css/_common/_component/group-pictures.styl","hash":"1ee40743000173495728855f734081eb2b6167cc","modified":1543215388154},{"_id":"themes/myNext/source/css/_common/_component/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1543215388154},{"_id":"themes/myNext/source/css/_common/_component/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1543215388154},{"_id":"themes/myNext/source/css/_common/_component/posts-collapse.styl","hash":"6750b61236eb359028da8f2c4765f7c89b03dc9a","modified":1543215388154},{"_id":"themes/myNext/source/css/_common/_component/posts-expand.styl","hash":"672d5fa7e5b7642d86a4bda176b501508b54860f","modified":1543215388155},{"_id":"themes/myNext/source/css/_common/_component/posts-type.styl","hash":"40b593134bf96d1d6095b3439d47820659d7f10b","modified":1543215388155},{"_id":"themes/myNext/source/css/_common/_component/posts.styl","hash":"b05ac51dd266d27f12e39e59a94383fe6474b7b3","modified":1543215388155},{"_id":"themes/myNext/source/css/_common/_component/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1543215388155},{"_id":"themes/myNext/source/css/_common/_core/helpers.styl","hash":"d339d114e52a9abbc797ec236a8a770c29e288a6","modified":1543215388156},{"_id":"themes/myNext/source/css/_common/_core/base.styl","hash":"388aa7c69c97728c64941db01e0f29a88837120c","modified":1543215388156},{"_id":"themes/myNext/source/css/_common/_core/scaffolding.styl","hash":"1f8acb3331300eec696a09e7859e11f191e16d7f","modified":1543215388156},{"_id":"themes/myNext/source/css/_common/_core/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1543215388156},{"_id":"themes/myNext/source/css/_common/_core/tables.styl","hash":"5f766cf26f966dbf9dcfe681f40ab9032e3e8a08","modified":1543215388156},{"_id":"themes/myNext/source/css/_common/_fonts/icon-default.styl","hash":"8b809aef383bebaeb3f282b47675f3a364ce3569","modified":1543215388157},{"_id":"themes/myNext/source/css/_common/_fonts/icon-feather.styl","hash":"80413afacfa656322100ce1900fed1ebcd8f8f44","modified":1543215388157},{"_id":"themes/myNext/source/css/_common/_fonts/icon-fifty-shades.styl","hash":"249f75bafa26b99d272352c0646e7497ea680b39","modified":1543215388157},{"_id":"themes/myNext/source/css/_common/_fonts/icon-font.styl","hash":"ec3f86739bede393cafcd3e31052c01115ae20d6","modified":1543215388157},{"_id":"themes/myNext/source/css/_common/_fonts/icon-linecons.styl","hash":"9cdbedb3627ac941cfb063b152abe5a75c3c699a","modified":1543215388158},{"_id":"themes/myNext/source/css/_common/_section/body.styl","hash":"ca1a4766cbe25baac757c6b47a4858d221afdc40","modified":1543215388158},{"_id":"themes/myNext/source/css/_common/_section/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1543215388159},{"_id":"themes/myNext/source/css/_common/_section/header.styl","hash":"a6aa8a56f9f645ae5a76a1034f79adf73b053aa0","modified":1543215388159},{"_id":"themes/myNext/source/css/_common/_section/layout.styl","hash":"03ae7b808dde9065412968aa69916162e790455d","modified":1543215388159},{"_id":"themes/myNext/source/css/_common/_section/media.styl","hash":"fa9809d2ecc753cf32f70803c1d0821c405211f4","modified":1543215388159},{"_id":"themes/myNext/source/css/_common/_section/sidebar.styl","hash":"bc106c3e759cd752c2b4c53ac27bc5ef5e3b18ea","modified":1543215388160},{"_id":"themes/myNext/source/css/_common/_page/categories.styl","hash":"4f696a2eaeee2f214adcf273eab25c62a398077a","modified":1543215388158},{"_id":"themes/myNext/source/css/_common/_page/archive.styl","hash":"dff879f55ca65fa79c07e9098719e53eeea7ac88","modified":1543215388158},{"_id":"themes/myNext/source/css/_common/_page/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1543215388158},{"_id":"themes/myNext/source/css/_schemes/Mist/_base.styl","hash":"d50c2a9ae363d26ed2e9bc226a9dc7abeb9ace1b","modified":1543215388161},{"_id":"themes/myNext/source/css/_schemes/Mist/_header.styl","hash":"1631a430655eadb485574d1a9bedd49460988b11","modified":1543215388161},{"_id":"themes/myNext/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1543215388161},{"_id":"themes/myNext/source/css/_schemes/Mist/_menu.styl","hash":"5a8036fc61207ca0fe38c9782ed2f686fbf764be","modified":1543215388162},{"_id":"themes/myNext/source/css/_schemes/Mist/_posts-expanded.styl","hash":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1543215388162},{"_id":"themes/myNext/source/css/_schemes/Mist/index.styl","hash":"fc7d96b897290dbd93bc8c515a2058fc4c374ea7","modified":1543215388162},{"_id":"themes/myNext/source/css/_schemes/default/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1543215388162},{"_id":"themes/myNext/source/css/_schemes/default/_menu.styl","hash":"4bba29cece65ffc5122f4e052063dea4439fe4ae","modified":1543215388163},{"_id":"themes/myNext/source/css/_schemes/default/_search.styl","hash":"c524bccdc554349106d1c8be9c3f275d4c0d4281","modified":1543215388163},{"_id":"themes/myNext/source/css/_schemes/default/index.styl","hash":"159464cb8a7e01e32db9ec70dec391ec70a72f9c","modified":1543215388163},{"_id":"themes/myNext/source/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1543215388169},{"_id":"themes/myNext/source/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1543215388169},{"_id":"themes/myNext/source/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1543215388170},{"_id":"themes/myNext/source/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1543215388170},{"_id":"themes/myNext/source/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1543215388169},{"_id":"themes/myNext/source/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1543215388170},{"_id":"themes/myNext/source/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1543215388171},{"_id":"themes/myNext/source/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1543215388172},{"_id":"themes/myNext/source/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1543215388174},{"_id":"themes/myNext/source/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1543215388174},{"_id":"themes/myNext/source/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1543215388172},{"_id":"themes/myNext/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1543215388182},{"_id":"themes/myNext/source/vendors/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1543215388177},{"_id":"themes/myNext/source/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1543215388176},{"_id":"themes/myNext/source/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1543215388177},{"_id":"source/img/fastblur/fastblur_100.png","hash":"04082f0c83d266bc4a9c5051632fefb46d5b6c34","modified":1543215387527},{"_id":"source/img/fastblur/fastblur_20.png","hash":"0516ef3fc7dd353991431d0ce06e574a170a7b43","modified":1543215387532},{"_id":"source/img/fastblur/fastblur_35.png","hash":"8ed56cf4cb45e436f3c79d3d2d70763cd81febae","modified":1543215387535},{"_id":"source/img/fastblur/fastblur_50.png","hash":"db1b1ecd90c506c2fe3cb44e3bdac1167821cb0d","modified":1543215387538},{"_id":"themes/myNext/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1543215388179},{"_id":"themes/myNext/source/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1543215388178},{"_id":"themes/myNext/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1543215388181},{"_id":"themes/myNext/source/vendors/velocity/velocity.js","hash":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1543215388187},{"_id":"source/img/fastblur/fastblur_10.png","hash":"8df2d8d76e47bed7600511197b4287bbd864946e","modified":1543215387524},{"_id":"source/img/interesting-curve/1.png","hash":"6863d44d483aa141f977fb9d5a38af702b2cf231","modified":1543215387554},{"_id":"source/img/interesting-curve/11.png","hash":"fd0038404392434605fb02142aa6a319f97351bd","modified":1543215387558},{"_id":"source/img/interesting-curve/2.png","hash":"7fff0d4bfe989d410640542f73597c50288bf23a","modified":1543215387562},{"_id":"source/img/interesting-curve/6.png","hash":"4f4156cb8c4c0199120511ff407218b20affb020","modified":1543215387572},{"_id":"source/img/myblog.png","hash":"9239c9f1baa1d5073c98d07186fc791b2b466203","modified":1543215387601},{"_id":"themes/myNext/source/css/_common/_vendor/highlight/highlight.styl","hash":"6242be4307a3b3dafc14e556f51c8875c41a1ddd","modified":1543215388160},{"_id":"themes/myNext/source/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1543215388170},{"_id":"themes/myNext/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1543215388170},{"_id":"themes/myNext/source/css/_common/_vendor/highlight/theme.styl","hash":"ae19721ceee5ba460e131cb2427dae3c1ff39d6f","modified":1543215388160},{"_id":"themes/myNext/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1543215388171},{"_id":"themes/myNext/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1543215388171},{"_id":"themes/myNext/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1543215388171},{"_id":"themes/myNext/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1543215388171},{"_id":"themes/myNext/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1543215388181},{"_id":"source/img/interesting-curve/7.png","hash":"c71371378f0f51e3259ab849216fca60b1d466cf","modified":1543215387576},{"_id":"themes/myNext/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1543215388180},{"_id":"source/img/interesting-curve/box.gif","hash":"bea87ba30f13bc86cf3f141cf4d9dc7bb81dd002","modified":1543215387586},{"_id":"source/img/interesting-curve/ring.gif","hash":"b64e0003275db78257ed4e4df5f4898786fea760","modified":1543215387596},{"_id":"source/img/sjtu/library.jpg","hash":"1f34b819a61c47596df0bbf5ba3c8fdb3c6edeb6","modified":1543215387647},{"_id":"source/img/sjtu/dom.jpg","hash":"1414a03d5f7485b0627753581c611b84fa517729","modified":1543215387611},{"_id":"source/img/sjtu/laker.jpg","hash":"ad8fe5ecb4c54a6a021c6c791c5db95185f8774b","modified":1543215387641},{"_id":"source/img/sjtu/tuya.jpg","hash":"7c0ebc7343b8b67cb236cdaa3b04500b786f8648","modified":1543215387672},{"_id":"source/img/sjtu/huxiaohe.jpg","hash":"a98b2882bdbff529ac1ed52cab05b954839c1eff","modified":1543215387633},{"_id":"source/img/dream.jpg","hash":"d208197b8979b1737c532fb70ff02b6213aa2679","modified":1543215387518},{"_id":"source/img/sjtu/library_outside.jpg","hash":"0accbf6acb3d34c9c1fd85ba06638c7cef9c6a39","modified":1543215387655},{"_id":"source/img/sjtu/love.jpg","hash":"0f6157c87ed87542d84f35270f15d45cfd3483cb","modified":1543215387666},{"_id":"source/img/walk_in_sh/18.JPG","hash":"2303528eedd3f5e6e496cf746763d8a190fe63e3","modified":1543215387922},{"_id":"source/img/walk_in_sh/1.JPG","hash":"d4511cba8d8f43d7e56e6d70d8d31a1a8a0403c2","modified":1543215387697},{"_id":"source/img/walk_in_sh/15.JPG","hash":"1764912039c38d842a4fcd1ac78ed5d30700476d","modified":1543215387861},{"_id":"source/img/walk_in_sh/2.JPG","hash":"80918b9291f2878fa61acec82b18ff7843c1bfbc","modified":1543215387962},{"_id":"source/img/walk_in_sh/4.JPG","hash":"1cb83df4a9e279460c587d63ed7fdfb0d1cfc2fd","modified":1543215388004},{"_id":"source/img/walk_in_sh/11.JPG","hash":"f9c70fbb51fc368ec4f73b33a2e8183aa9f42cc9","modified":1543215387758},{"_id":"source/img/walk_in_sh/16.JPG","hash":"0b25b734a0123f14ecce4e297d05b7be4be208eb","modified":1543215387876},{"_id":"source/img/walk_in_sh/17.JPG","hash":"2881964ef4f8819c1bfa8d9295c4da5e4d06ef3e","modified":1543215387898},{"_id":"source/img/sjtu/hehua.jpg","hash":"22559174b84cad1734e19b4765ade413ee13e438","modified":1543215387625},{"_id":"source/img/walk_in_sh/7.JPG","hash":"2c2ca93821bf5d6b9745db4bedae8897a947e199","modified":1543215388075},{"_id":"source/img/walk_in_sh/14.JPG","hash":"908aa369c07dd2400753f9965c071a25737f6fcd","modified":1543215387836},{"_id":"source/img/walk_in_sh/6.JPG","hash":"9c519bc65f8109c33211b55676cc316e31c4cbfd","modified":1543215388054},{"_id":"source/img/walk_in_sh/10.JPG","hash":"c3e4831bfecdb530810d1ff9be63d5463a6032ba","modified":1543215387726},{"_id":"source/img/walk_in_sh/3.JPG","hash":"ace3a8905bc963f0a832b614703c9d3394be1388","modified":1543215387976},{"_id":"source/img/walk_in_sh/5.JPG","hash":"2df1179b56171b441705c5a47223f86a55921a47","modified":1543215388032},{"_id":"source/img/walk_in_sh/9.JPG","hash":"a190ede0354851f8ea38debf9ed2a59a464bc9ac","modified":1543215388113},{"_id":"source/img/walk_in_sh/12.JPG","hash":"863952f7a1fe8bd95039fd8670e1653fec284554","modified":1543215387785},{"_id":"source/img/walk_in_sh/13.JPG","hash":"7fac8bf1b882bfb14222a2932a066bd282f7bd5f","modified":1543215387810},{"_id":"source/img/walk_in_sh/8.JPG","hash":"0de6904c8ee70e390459aa7f1f412778fedfe92b","modified":1543215388095},{"_id":"public/baidusitemap.xml","hash":"0d582285ec5ac3d9bcd994c25f2a6546c1b8a95b","modified":1561521863741},{"_id":"public/CNAME","hash":"b6e903c363301141338985b51e3d46181253afe6","modified":1561521863767},{"_id":"public/sitemap.xml","hash":"0934e0d8a73e2bfc8347594330bcf8f814cfb743","modified":1561521883154},{"_id":"public/atom.xml","hash":"7b0ac42754db966afa8975d99937dfb0375a5d9b","modified":1561521863768},{"_id":"public/guestbook/index.html","hash":"727f7d5420b6a61e4b419aa2ecee1ddddaa19499","modified":1561521863775},{"_id":"public/tags/index.html","hash":"deb6dd6019d506d05b411d8e2cb67c34b75e1802","modified":1561521863776},{"_id":"public/resume/index.html","hash":"f52db041a4bed15ebcb776f4a889cb23c223d743","modified":1561521863776},{"_id":"public/archives/2015/index.html","hash":"446e71a2a9af6844fcedba84d835b7f02514ce50","modified":1561521863776},{"_id":"public/archives/2015/12/index.html","hash":"0aecf3096136ee313fe880fe221cbabe5f9d4d99","modified":1561521863776},{"_id":"public/archives/2016/page/2/index.html","hash":"b92f77d6489450e4a8e18c60c9b9b679afab9215","modified":1561521863776},{"_id":"public/archives/2016/01/index.html","hash":"967cba6d4986b20653e9a9d87d9cdea8ed5be742","modified":1561521863776},{"_id":"public/archives/2016/02/index.html","hash":"524fba4463c8c3aeb2da9c06f57eb3e6dd78f62b","modified":1561521863776},{"_id":"public/archives/2016/03/index.html","hash":"c72b490155482c5c9dae18b5d3af9a30d43c2daa","modified":1561521863776},{"_id":"public/archives/2016/04/index.html","hash":"1eb2f8bf09fa01693a956353773b45db8ec5c801","modified":1561521863776},{"_id":"public/archives/2016/06/index.html","hash":"3526db651d5a94d37644deb6f867cf6b2a95b0da","modified":1561521863776},{"_id":"public/archives/2016/07/index.html","hash":"a0fd9564d548370374270290e82c1c4b379fe6f9","modified":1561521863777},{"_id":"public/archives/2016/08/index.html","hash":"dab560e8f1aad74ca1dcf83fd189955c58817942","modified":1561521863777},{"_id":"public/archives/2016/11/index.html","hash":"4e6f3a26a81737aa3711efffc79e473f03469f88","modified":1561521863777},{"_id":"public/archives/2017/page/2/index.html","hash":"c61534c0cbaddbb77611c9a1362b6acdd34da6a6","modified":1561521863777},{"_id":"public/archives/2017/02/index.html","hash":"ab8eca409507024ea99bb52955527654e52a7d30","modified":1561521863777},{"_id":"public/archives/2017/03/index.html","hash":"821d689f9145d7a0b2568c1ede3e6cac127bc1dd","modified":1561521863777},{"_id":"public/archives/2017/04/index.html","hash":"46a6333df3d35ef52f3e375cccc17a3fce3f3a5a","modified":1561521863777},{"_id":"public/archives/2017/05/index.html","hash":"83636bbe845462cabfeeb79d1abd55306d458db4","modified":1561521863777},{"_id":"public/archives/2017/06/index.html","hash":"a4c2fc3a1478bb4fb2eb7c349c372f604cd86870","modified":1561521863777},{"_id":"public/archives/2017/08/index.html","hash":"c8941b47a38498f028c154bed6bca45b6516a152","modified":1561521863777},{"_id":"public/archives/2017/11/index.html","hash":"d830df9b6a0211929ce86dbe6e126a9a287b9f76","modified":1561521863777},{"_id":"public/archives/2018/index.html","hash":"47290a47dabc3eaa8b2a718320b6b684b1e469fd","modified":1561521863777},{"_id":"public/archives/2018/01/index.html","hash":"7a36d8352fa6964857312e2cdad639cea2fe125a","modified":1561521863778},{"_id":"public/archives/2018/02/index.html","hash":"aedd27318896a07267b0ba8ee0510afcebcc9397","modified":1561521863778},{"_id":"public/archives/2018/11/index.html","hash":"2202738c7330b1659a5238d9346998fb2d3c2ce1","modified":1561521863778},{"_id":"public/archives/2018/12/index.html","hash":"c859a3ae5c97cb6a56c7bef861b96254db114171","modified":1561521863778},{"_id":"public/archives/2019/index.html","hash":"21ceeb92730633641ea1c6e06a08ec040cd02724","modified":1561521863778},{"_id":"public/archives/2019/01/index.html","hash":"cfe17888c1cfa79c0cd8e52857fcc19b5115bbe3","modified":1561521863778},{"_id":"public/categories/年度计划/index.html","hash":"6faaa08c83f48215af79b04534ce701ee59340e6","modified":1561521863778},{"_id":"public/categories/摄影/index.html","hash":"01a771aa3972f87cc3b41dbb81f46cb5bc10dc38","modified":1561521863778},{"_id":"public/categories/Android/page/2/index.html","hash":"a79347385bf8c77adcf176237993faacb3ec066e","modified":1561521863778},{"_id":"public/categories/Blog/index.html","hash":"405b9008a2258214362b39b1ce4ea5f5929d8d09","modified":1561521863778},{"_id":"public/categories/随感/index.html","hash":"735b3bbc2a49e4f0bfe807fa408fb2c212513ada","modified":1561521863778},{"_id":"public/categories/Android/Performance/index.html","hash":"d30ab8957f97b920abadabf11a6dbbc99c33f370","modified":1561521863778},{"_id":"public/categories/Android/亿级Android架构/index.html","hash":"37985fc18746bcc5f93b9e2f827d973a607afcd8","modified":1561521863778},{"_id":"public/categories/Android/带你学开源项目/index.html","hash":"744aa285440158e4ef45bf5db9c0e640e1c360eb","modified":1561521863778},{"_id":"public/categories/cool-stuff/index.html","hash":"a18bdf8b29feda4a3fc93d69c90ffd51123f6a54","modified":1561521863779},{"_id":"public/categories/全栈/index.html","hash":"690e875b7844354d1e87c8abb0b1d823b3e789a3","modified":1561521863779},{"_id":"public/categories/个人博客/index.html","hash":"5f0860fef85c7848c4cce7e06b1110770aed8339","modified":1561521863779},{"_id":"public/categories/Android/安全/index.html","hash":"526195a53d9e313aa18809fc7d9b29bf6464feb5","modified":1561521863779},{"_id":"public/categories/cool-stuff/个人博客/index.html","hash":"51a881db210efaee682ea4ab13785b19473656ab","modified":1561521863779},{"_id":"public/categories/全栈/Android/index.html","hash":"55055ac3a7f6fc735102ea5901d03579672048ba","modified":1561521863779},{"_id":"public/categories/个人博客/一天变cool/index.html","hash":"137463025cf68932149767cf98d023f5af2c55ec","modified":1561521863779},{"_id":"public/categories/cool-stuff/个人博客/一天变cool/index.html","hash":"342ebb6e2ce23a4a88d7cb6416b1d48bf9afac11","modified":1561521863779},{"_id":"public/categories/全栈/Android/Server/index.html","hash":"e44a4ab134222c887fabace30e20220719743c50","modified":1561521863779},{"_id":"public/categories/React-Native/index.html","hash":"3fc0ff2fe7a3f990db6fb5508da5eaef7bdb1065","modified":1561521863779},{"_id":"public/tags/随笔/index.html","hash":"35e5cde9d48bc64f0b59ad970ba84c847a0b07ca","modified":1561521863779},{"_id":"public/tags/动态代理/index.html","hash":"26f5a471e88ca9a649f4730fcbf35da1733a44b1","modified":1561521863779},{"_id":"public/tags/welcome/index.html","hash":"b64946c6ed4326f8c0e18f30e76795ad1af6ce67","modified":1561521863779},{"_id":"public/tags/摄影/index.html","hash":"8c112ec700b718523eb64d44e0a1dfc9e995dd47","modified":1561521863779},{"_id":"public/tags/Android/page/2/index.html","hash":"6db57c19aa68b380cffcb846c99260bd0783dbd9","modified":1561521863779},{"_id":"public/tags/学习计划/index.html","hash":"d557aacee5656c2001f8d7a04233b2bb1b3aded3","modified":1561521863780},{"_id":"public/tags/cool/index.html","hash":"dcaf24d7d3cdaa6ea5f0f69b8292459f472c87da","modified":1561521863780},{"_id":"public/tags/动效/index.html","hash":"76d2b45eb0d607eb3ea85cac67baa1710cd331ce","modified":1561521863780},{"_id":"public/tags/架构/index.html","hash":"e606a3fb6304a1903d51ebbb3009354e3ff27636","modified":1561521863780},{"_id":"public/tags/高可用/index.html","hash":"921721abc2765492977ebf7c5fde67d56073199f","modified":1561521863780},{"_id":"public/tags/网络/index.html","hash":"baa293f87ba64534b88842ccb932c00581728f43","modified":1561521863780},{"_id":"public/tags/Annotation/index.html","hash":"29d8358fd5f3afb49b54a1695c9a773480382f48","modified":1561521863780},{"_id":"public/tags/RxJava/index.html","hash":"0589a368df36119902fbf477bb9dadbfe065399c","modified":1561521863780},{"_id":"public/tags/带你学开源项目/index.html","hash":"eccc8308a313098934c6888c35d1622634afad09","modified":1561521863780},{"_id":"public/tags/多线程/index.html","hash":"bb96b6c2f55e4e9ac1f62425f857389100db6791","modified":1561521863780},{"_id":"public/tags/一天变cool/index.html","hash":"c8f6f4d69d9342edf59797fbed87e59bdaed1707","modified":1561521863780},{"_id":"public/tags/个人博客/index.html","hash":"748ef5959b508490bc3da9ebc72916b2324e7818","modified":1561521863780},{"_id":"public/tags/Goodbye2015-Hi-2016/index.html","hash":"a0ff694c17b3776ef612abb647fde12dda1c7c78","modified":1561521863780},{"_id":"public/tags/GitHub/index.html","hash":"5be5483d92aa4c56e83ec6e86978ccbe978dc56c","modified":1561521863781},{"_id":"public/tags/Blog/index.html","hash":"7ea26980ced093ad71c68718e9aef1b902ab3c07","modified":1561521863781},{"_id":"public/tags/Hexo/index.html","hash":"4fd7675316e9c5f88156596f8218e9d79ff420ac","modified":1561521863781},{"_id":"public/tags/Lifecycle/index.html","hash":"7abcdbfceecda1f0d493e7097e89e2279cd8142d","modified":1561521863781},{"_id":"public/tags/长连接/index.html","hash":"a66f8ff4e4a9d13d2881af6d4284205583f0268e","modified":1561521863781},{"_id":"public/tags/内存泄漏/index.html","hash":"ae282dfc2ecbdd83c969a17e3163442610f015d9","modified":1561521863781},{"_id":"public/tags/性能优化/index.html","hash":"ab6b360867f2eff06e71a24aa628a73a0c2c5edb","modified":1561521863781},{"_id":"public/tags/React-Native/index.html","hash":"23175f0687f919ea84339a6aa50ec5782555ee95","modified":1561521863781},{"_id":"public/2019/01/16/mobile-network-connection/index.html","hash":"f6b5c6988c500fa1bb2a7b97b7bc8fe2765b54af","modified":1561521863781},{"_id":"public/2018/12/05/android-arch-long-link/index.html","hash":"1175ae9c7dddeab6a18e5ca382fa705eab360882","modified":1561521863781},{"_id":"public/2018/11/26/《亿级-Android-架构》专栏随谈/index.html","hash":"dd38a6c81e15eb72b3f36e3f8fe07e1a50355e38","modified":1561521863781},{"_id":"public/2018/02/11/java-dynamic-proxy/index.html","hash":"2608b58c0b17d0fdad5186cefc0585538c65bc48","modified":1561521863781},{"_id":"public/2018/01/26/hey-2018/index.html","hash":"45c0d7f90a1209f72ac4b0bfc236ede51dda62d9","modified":1561521863781},{"_id":"public/2017/11/09/auto-lifecycle/index.html","hash":"da505d5eb7d4ba5ecdc99cfa29ab3e9a2e07c139","modified":1561521863781},{"_id":"public/2017/08/18/new_start_hangzhou/index.html","hash":"06c3d8b7869435c66406e30155c8d3174f8a011f","modified":1561521863782},{"_id":"public/2017/06/08/rebuild-personal-blog/index.html","hash":"e5a13c2e994947b2937a024f8dc7dbd6c4291a12","modified":1561521863782},{"_id":"public/2017/05/24/Java-技术之垃圾回收机制/index.html","hash":"58b7b213e648053a434135777b288dadb020decc","modified":1561521863782},{"_id":"public/2017/05/14/dig_into_leakcanary/index.html","hash":"1e18b17100622c5c1e14cfb6bd4dbe59785fc47f","modified":1561521863782},{"_id":"public/2017/05/08/java_classloader/index.html","hash":"f4fcb5edb23a6800bb44c5e275d7aac1708961b8","modified":1561521863782},{"_id":"public/2017/05/03/Java-技术之注解-Annotation/index.html","hash":"d6d84007913c77f7abd51cd901efa7305d87b0ff","modified":1561521863782},{"_id":"public/2017/04/26/Java-技术之反射/index.html","hash":"b0267ca19a7160148cc01d554573adbfc9d48802","modified":1561521863782},{"_id":"public/2017/04/09/Java里如何实现线程间通信？/index.html","hash":"dff3c9e9f8f965540e2717d4f1b08537f09008e3","modified":1561521863782},{"_id":"public/2017/03/29/Java的equals与hashcode对比分析/index.html","hash":"ddb221746f901b27cd3ddeb5ceea487637296633","modified":1561521863782},{"_id":"public/2017/03/29/对未来个人技术博客的一些思考/index.html","hash":"b807da108a7315acdbcbd1b21825bcff8d1ba60d","modified":1561521863782},{"_id":"public/2017/03/14/写给移动开发者的-React-Native-指南/index.html","hash":"8b3782b6a826ade118123ac88211e0a6146c67e3","modified":1561521863782},{"_id":"public/2017/02/05/今年之计－2017/index.html","hash":"03b8ed32573dbf08fcd5addd34a1b1b99b2aa37e","modified":1561521863782},{"_id":"public/2016/11/26/独立全端开发的开源小作：简诗2-0/index.html","hash":"3a567ef9b1bfb9a1e1f9c7c06f91ca68c32a38eb","modified":1561521863783},{"_id":"public/2016/11/02/干货-Glow-Android-优化实践/index.html","hash":"1620316fb8e1773081fdd6a2a7bbaec593068f4d","modified":1561521863783},{"_id":"public/2016/08/30/谈谈移动应用的安全性实践/index.html","hash":"4d28984605a2ff9f8766477c749d3efde8183938","modified":1561521863783},{"_id":"public/2016/07/21/带你学开源项目：OkHttp-自己动手实现okhttp/index.html","hash":"c01eeecb7df6362da2460860e7c7c41417283f2b","modified":1561521863783},{"_id":"public/2016/07/14/RxLifecycle源码解析－当Activity被destory时自动暂停网络请求/index.html","hash":"e34248841c74ceba4c726fcb038cceea26e6d2e5","modified":1561521863783},{"_id":"public/2016/07/10/Walk-in-ShangHai/index.html","hash":"c9dfb7cc088ae5944509fa28e9f660a3be849906","modified":1561521863783},{"_id":"public/2016/06/06/梦想升起的地方/index.html","hash":"6f9eea7e418831fd2a9df900fd4dccf1a551c91c","modified":1561521863783},{"_id":"public/2016/04/13/带你学开源项目：Meizhi-Android之RxJava-Retrofit最佳实践/index.html","hash":"5c7450c5cee53655d9d63a47ebd7797f9d74e26f","modified":1561521863783},{"_id":"public/2016/03/15/30条Android开发建议/index.html","hash":"0f41d2dd03aa284ce74c090557443d89c248958d","modified":1561521863784},{"_id":"public/2016/03/12/一种快速毛玻璃虚化效果实现/index.html","hash":"80917495d96a05ec324abeb7f30673c466e56a78","modified":1561521863784},{"_id":"public/2016/02/20/计划清单/index.html","hash":"b805241cb0c26cd0e00999f9a8edcd8368288c5f","modified":1561521863784},{"_id":"public/2016/02/19/今年之计/index.html","hash":"24e9aaa624c584ee6bbd975ec55a969ac7779579","modified":1561521863784},{"_id":"public/2016/01/25/有趣的曲线在Android上的实现/index.html","hash":"9ed608271c1feb0005bf6105d93e299142dcef8d","modified":1561521863784},{"_id":"public/2016/01/02/交大－影/index.html","hash":"5f101afdee7ab6a756e62f99374a67ce259aa637","modified":1561521863784},{"_id":"public/2015/12/29/我与代码的相知相遇/index.html","hash":"286a9842b7d519cc938539a6ef512d2997fb70cc","modified":1561521863784},{"_id":"public/2015/12/07/如何在一天之内搭建以你自己名字为域名的很cool的个人博客/index.html","hash":"18f7435243573da9825cbb0e4ebfea499017a941","modified":1561521863784},{"_id":"public/2015/12/06/说一说博客/index.html","hash":"2f977f23b922f7edbc48e4e28f535efba492ffde","modified":1561521863784},{"_id":"public/2015/12/05/Hey folks/index.html","hash":"4206029c6dee7ecaf6602fedf3ae4b4022aa281b","modified":1561521863784},{"_id":"public/archives/index.html","hash":"75fc2eb7d74b4bb1ff5e7efeb5e377eff5baacce","modified":1561521863784},{"_id":"public/archives/page/2/index.html","hash":"4b3c9f6fb5f5a79d127c5439385a8eb2132328e9","modified":1561521863785},{"_id":"public/archives/page/3/index.html","hash":"2691d8f17b8d5930d53b6bf7f1aa694882489217","modified":1561521863785},{"_id":"public/archives/page/4/index.html","hash":"8a0654d3ee4754ee415e8f0bc3aa1c37f6324776","modified":1561521863785},{"_id":"public/archives/2016/index.html","hash":"e12ef5ea1d4e8bad020c5e30c7cfd7b5f7345ba7","modified":1561521863785},{"_id":"public/archives/2017/index.html","hash":"0566e1e43d75107d767324100f3ad4ba95060d6d","modified":1561521863785},{"_id":"public/categories/Android/index.html","hash":"d3867b3a2ad0492edc0423049c50a608e3e2934c","modified":1561521863785},{"_id":"public/categories/深入理解Java技术/index.html","hash":"191f04e1de29ef2a1db433dfb7895adc8e226b0a","modified":1561521863785},{"_id":"public/index.html","hash":"ed0f81869a91b0b6c4600f1af3a165540fc6b8c5","modified":1561521863785},{"_id":"public/page/2/index.html","hash":"8f9c988de769ef59cde73b4566522bf6f84cab62","modified":1561521863785},{"_id":"public/page/3/index.html","hash":"c671409770f5e03382ff73a31167315db6b6bb85","modified":1561521863786},{"_id":"public/page/4/index.html","hash":"f9ef7a6466fbf1d6a0273cc9b64bf13f68cef705","modified":1561521863786},{"_id":"public/tags/Android/index.html","hash":"ba1eacaa1ca965296dfa8669c6b7c9ec65f78c18","modified":1561521863786},{"_id":"public/tags/Java/index.html","hash":"1e12d5ecaae54370945fd5044932de39e48ab769","modified":1561521863786},{"_id":"public/post-sitemap.xml","hash":"4bf42078bd3f4f13444553b0605c77a49ea706ca","modified":1561521883185},{"_id":"public/page-sitemap.xml","hash":"407fdd6702aade08d6f2aa11360aee1e71cc4256","modified":1561521883185},{"_id":"public/category-sitemap.xml","hash":"7fda5e790f6f52b9aa271cdf84ebbf782eafbd73","modified":1561521883185},{"_id":"public/tag-sitemap.xml","hash":"d4df43a8b35039e12ae3443c13972c5e304a6372","modified":1561521883185},{"_id":"public/sitemap.xsl","hash":"4321fa69dc1b8811d32b7a1478e5603e038cea1a","modified":1561521883186}],"Category":[{"name":"Java","_id":"cjxcplsgn00083dn8ywgyzidd"},{"name":"年度计划","_id":"cjxcplsgr000e3dn82jqzs8hx"},{"name":"摄影","_id":"cjxcplsgt000i3dn8me7aqht1"},{"name":"Python","parent":"cjxcplsgn00083dn8ywgyzidd","_id":"cjxcplsgw000n3dn8wionfvvk"},{"name":"Android","_id":"cjxcplsh200133dn8bw6vgf10"},{"name":"Blog","_id":"cjxcplsh4001a3dn86estxal2"},{"name":"随感","_id":"cjxcplsh6001l3dn8yg0jfe0o"},{"name":"Performance","parent":"cjxcplsh200133dn8bw6vgf10","_id":"cjxcplsh7001s3dn89onx8wqg"},{"name":"亿级Android架构","parent":"cjxcplsh200133dn8bw6vgf10","_id":"cjxcplshw00283dn8cd312bqw"},{"name":"深入理解Java技术","_id":"cjxcplshy002c3dn8esip8heb"},{"name":"带你学开源项目","parent":"cjxcplsh200133dn8bw6vgf10","_id":"cjxcplsi800323dn8gf1uyg31"},{"name":"cool stuff","_id":"cjxcplsia003a3dn8nzhq4flz"},{"name":"全栈","_id":"cjxcplsid003o3dn86rlphq85"},{"name":"个人博客","_id":"cjxcplsif003w3dn8igycly7n"},{"name":"安全","parent":"cjxcplsh200133dn8bw6vgf10","_id":"cjxcplsig00413dn8v7tjxn34"},{"name":"个人博客","parent":"cjxcplsia003a3dn8nzhq4flz","_id":"cjxcplsig00433dn85pukq9it"},{"name":"Android","parent":"cjxcplsid003o3dn86rlphq85","_id":"cjxcplsih00483dn8yp0j3xrd"},{"name":"一天变cool","parent":"cjxcplsif003w3dn8igycly7n","_id":"cjxcplsii004c3dn8owhv7fto"},{"name":"一天变cool","parent":"cjxcplsig00433dn85pukq9it","_id":"cjxcplsii004g3dn8xm3pqwfi"},{"name":"Server","parent":"cjxcplsih00483dn8yp0j3xrd","_id":"cjxcplsij004k3dn83nxopzjx"},{"name":"React Native","_id":"cjxcplska00663dn8hkga270v"}],"Data":[],"Page":[{"title":"guestbook","date":"2015-12-05T11:21:08.000Z","_content":"","source":"guestbook/index.md","raw":"title: guestbook\ndate: 2015-12-05 19:21:08\n---\n","updated":"2018-11-26T06:56:27.489Z","path":"guestbook/index.html","comments":1,"layout":"page","_id":"cjxcplsgg00013dn8t1hmzs15","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2015-12-05T11:50:21.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"title: tags\ndate: 2015-12-05 19:50:21\ntype: \"tags\"\ncomments: false\n---\n","updated":"2018-11-26T06:56:28.115Z","path":"tags/index.html","layout":"page","_id":"cjxcplsgi00033dn8javpqmr0","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"resume","date":"2017-06-18T06:29:03.000Z","_content":"> Those who expect to reap the blessings of freedom must, like men, undergo the fatigue of supporting it.\n> 想要收获自由之果的人，必须承受维护自由的劳苦。\n>\n> Thomas Paine\n\n____________________________________\n\nHere is wingjay, living in ShangHai.\n\n**Who am I**\nSoftware Engineer in Android, React Native, Python backend, Javascript, Web Fronted, PHP.\n\n**Award**\n[Best Apps of 2016 in Play Store - Eve Android](https://play.google.com/store/info/topic?id=merch_topic_b0000b2_apps_TopicPage_bestof2016&hl=en). \nSecond place of IBM Mobile Application Development Competition, 2014.\n\n\n**Experience**\n3.5 years experience in Android & Java;\nServeral months in React Native;\n1.5 years in Python backend + Flask + Nginx + Redis + MySQL + AliYun;\nHalf year in Web fronted.\n\n**Background**\n2017/06 - Now | Android Senior Engineer | Alibaba, Inc. | HangZhou\n2015/06 - 2017/06 | Android-Server engineer | Glow | Shanghai\n2013/09 - 2016/06  | Master | Shanghai Jiao Tong University | Shanghai\n2009/09 - 2013/06  | Bachelor | Beijing Institute of Technology | Beijing\n\n**My job in Alibaba**\nDevelop a new network framework `RxApi` to make network code cleaner and more stable.\nDevelop a new RecyclerView Adapter framework: `Lego` List, which supports multi-type item, reusable ViewHolder class.\n\n\n**What I did**\nI write Android & Java [tech blogs](http://wingjay.com/).\nI open-source Android projects [jianshi + BlurImage](https://github.com/wingjay) etc.\nI read source code: OkHttp, LeakCanary, AOSP, RxLifecycle etc. (I love [Square](https://github.com/square), don't you?).\nI developed one personal Full-Stack project [jianshi 简诗](https://github.com/wingjay/jianshi) by myself. and Yeah, it's still alive, 25000 users, running on AliYun.\nI write [script](https://github.com/wingjay/hacker_scripts): shell + python + Node.js\n\n\n**Links**\nGithub: https://github.com/wingjay\nBlog: http://wingjay.com/\nEmail: [yinjiesh AT 126.com](mailto:yinjiesh@126.com)\n\n**Languages**\nChinese native\nCET-6, I also write, speak, understand English\n\n\n____________________________________\n\nThanks, here is wingjay, always open to exciting opportunity.\n\n\n","source":"resume/index.md","raw":"title: resume\ndate: 2017-06-18 14:29:03\n---\n> Those who expect to reap the blessings of freedom must, like men, undergo the fatigue of supporting it.\n> 想要收获自由之果的人，必须承受维护自由的劳苦。\n>\n> Thomas Paine\n\n____________________________________\n\nHere is wingjay, living in ShangHai.\n\n**Who am I**\nSoftware Engineer in Android, React Native, Python backend, Javascript, Web Fronted, PHP.\n\n**Award**\n[Best Apps of 2016 in Play Store - Eve Android](https://play.google.com/store/info/topic?id=merch_topic_b0000b2_apps_TopicPage_bestof2016&hl=en). \nSecond place of IBM Mobile Application Development Competition, 2014.\n\n\n**Experience**\n3.5 years experience in Android & Java;\nServeral months in React Native;\n1.5 years in Python backend + Flask + Nginx + Redis + MySQL + AliYun;\nHalf year in Web fronted.\n\n**Background**\n2017/06 - Now | Android Senior Engineer | Alibaba, Inc. | HangZhou\n2015/06 - 2017/06 | Android-Server engineer | Glow | Shanghai\n2013/09 - 2016/06  | Master | Shanghai Jiao Tong University | Shanghai\n2009/09 - 2013/06  | Bachelor | Beijing Institute of Technology | Beijing\n\n**My job in Alibaba**\nDevelop a new network framework `RxApi` to make network code cleaner and more stable.\nDevelop a new RecyclerView Adapter framework: `Lego` List, which supports multi-type item, reusable ViewHolder class.\n\n\n**What I did**\nI write Android & Java [tech blogs](http://wingjay.com/).\nI open-source Android projects [jianshi + BlurImage](https://github.com/wingjay) etc.\nI read source code: OkHttp, LeakCanary, AOSP, RxLifecycle etc. (I love [Square](https://github.com/square), don't you?).\nI developed one personal Full-Stack project [jianshi 简诗](https://github.com/wingjay/jianshi) by myself. and Yeah, it's still alive, 25000 users, running on AliYun.\nI write [script](https://github.com/wingjay/hacker_scripts): shell + python + Node.js\n\n\n**Links**\nGithub: https://github.com/wingjay\nBlog: http://wingjay.com/\nEmail: [yinjiesh AT 126.com](mailto:yinjiesh@126.com)\n\n**Languages**\nChinese native\nCET-6, I also write, speak, understand English\n\n\n____________________________________\n\nThanks, here is wingjay, always open to exciting opportunity.\n\n\n","updated":"2018-11-26T06:56:28.115Z","path":"resume/index.html","comments":1,"layout":"page","_id":"cjxcplsgk00063dn8dlzr7ezl","content":"<blockquote>\n<p>Those who expect to reap the blessings of freedom must, like men, undergo the fatigue of supporting it.<br> 想要收获自由之果的人，必须承受维护自由的劳苦。</p>\n<p>Thomas Paine</p>\n</blockquote>\n<hr>\n<p>Here is wingjay, living in ShangHai.</p>\n<p><strong>Who am I</strong><br>Software Engineer in Android, React Native, Python backend, Javascript, Web Fronted, PHP.</p>\n<p><strong>Award</strong><br><a href=\"https://play.google.com/store/info/topic?id=merch_topic_b0000b2_apps_TopicPage_bestof2016&amp;hl=en\" target=\"_blank\" rel=\"external\">Best Apps of 2016 in Play Store - Eve Android</a>.<br>Second place of IBM Mobile Application Development Competition, 2014.</p>\n<p><strong>Experience</strong><br>3.5 years experience in Android &amp; Java;<br>Serveral months in React Native;<br>1.5 years in Python backend + Flask + Nginx + Redis + MySQL + AliYun;<br>Half year in Web fronted.</p>\n<p><strong>Background</strong><br>2017/06 - Now | Android Senior Engineer | Alibaba, Inc. | HangZhou<br>2015/06 - 2017/06 | Android-Server engineer | Glow | Shanghai<br>2013/09 - 2016/06  | Master | Shanghai Jiao Tong University | Shanghai<br>2009/09 - 2013/06  | Bachelor | Beijing Institute of Technology | Beijing</p>\n<p><strong>My job in Alibaba</strong><br>Develop a new network framework <code>RxApi</code> to make network code cleaner and more stable.<br>Develop a new RecyclerView Adapter framework: <code>Lego</code> List, which supports multi-type item, reusable ViewHolder class.</p>\n<p><strong>What I did</strong><br>I write Android &amp; Java <a href=\"http://wingjay.com/\">tech blogs</a>.<br>I open-source Android projects <a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\">jianshi + BlurImage</a> etc.<br>I read source code: OkHttp, LeakCanary, AOSP, RxLifecycle etc. (I love <a href=\"https://github.com/square\" target=\"_blank\" rel=\"external\">Square</a>, don’t you?).<br>I developed one personal Full-Stack project <a href=\"https://github.com/wingjay/jianshi\" target=\"_blank\" rel=\"external\">jianshi 简诗 </a> by myself. and Yeah, it’s still alive, 25000 users, running on AliYun.<br>I write <a href=\"https://github.com/wingjay/hacker_scripts\" target=\"_blank\" rel=\"external\">script</a>: shell + python + Node.js</p>\n<p><strong>Links</strong><br>Github: <a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\">https://github.com/wingjay</a><br>Blog: <a href=\"http://wingjay.com/\">http://wingjay.com/</a><br>Email: <a href=\"mailto:yinjiesh@126.com\" target=\"_blank\" rel=\"external\">yinjiesh AT 126.com</a></p>\n<p><strong>Languages</strong><br>Chinese native<br>CET-6, I also write, speak, understand English</p>\n<hr>\n<p>Thanks, here is wingjay, always open to exciting opportunity.</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Those who expect to reap the blessings of freedom must, like men, undergo the fatigue of supporting it.<br>想要收获自由之果的人，必须承受维护自由的劳苦。</p>\n<p>Thomas Paine</p>\n</blockquote>\n<hr>\n<p>Here is wingjay, living in ShangHai.</p>\n<p><strong>Who am I</strong><br>Software Engineer in Android, React Native, Python backend, Javascript, Web Fronted, PHP.</p>\n<p><strong>Award</strong><br><a href=\"https://play.google.com/store/info/topic?id=merch_topic_b0000b2_apps_TopicPage_bestof2016&amp;hl=en\" target=\"_blank\" rel=\"external\">Best Apps of 2016 in Play Store - Eve Android</a>.<br>Second place of IBM Mobile Application Development Competition, 2014.</p>\n<p><strong>Experience</strong><br>3.5 years experience in Android &amp; Java;<br>Serveral months in React Native;<br>1.5 years in Python backend + Flask + Nginx + Redis + MySQL + AliYun;<br>Half year in Web fronted.</p>\n<p><strong>Background</strong><br>2017/06 - Now | Android Senior Engineer | Alibaba, Inc. | HangZhou<br>2015/06 - 2017/06 | Android-Server engineer | Glow | Shanghai<br>2013/09 - 2016/06  | Master | Shanghai Jiao Tong University | Shanghai<br>2009/09 - 2013/06  | Bachelor | Beijing Institute of Technology | Beijing</p>\n<p><strong>My job in Alibaba</strong><br>Develop a new network framework <code>RxApi</code> to make network code cleaner and more stable.<br>Develop a new RecyclerView Adapter framework: <code>Lego</code> List, which supports multi-type item, reusable ViewHolder class.</p>\n<p><strong>What I did</strong><br>I write Android &amp; Java <a href=\"http://wingjay.com/\">tech blogs</a>.<br>I open-source Android projects <a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\">jianshi + BlurImage</a> etc.<br>I read source code: OkHttp, LeakCanary, AOSP, RxLifecycle etc. (I love <a href=\"https://github.com/square\" target=\"_blank\" rel=\"external\">Square</a>, don’t you?).<br>I developed one personal Full-Stack project <a href=\"https://github.com/wingjay/jianshi\" target=\"_blank\" rel=\"external\">jianshi 简诗</a> by myself. and Yeah, it’s still alive, 25000 users, running on AliYun.<br>I write <a href=\"https://github.com/wingjay/hacker_scripts\" target=\"_blank\" rel=\"external\">script</a>: shell + python + Node.js</p>\n<p><strong>Links</strong><br>Github: <a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\">https://github.com/wingjay</a><br>Blog: <a href=\"http://wingjay.com/\">http://wingjay.com/</a><br>Email: <a href=\"mailto:yinjiesh@126.com\" target=\"_blank\" rel=\"external\">yinjiesh AT 126.com</a></p>\n<p><strong>Languages</strong><br>Chinese native<br>CET-6, I also write, speak, understand English</p>\n<hr>\n<p>Thanks, here is wingjay, always open to exciting opportunity.</p>\n"}],"Post":[{"title":"梦想升起的地方","_content":"\n<img src=\"https://wingjay.com/img/dream_flies/dream.jpg\" width=\"300\">\n\n好赖，我毕业了🎓。\n\n从本科毕业时懵懂迷茫的自己，到现在坚定方向不为所动的自己。\n\n两三年的磨砺，我成长了非常多。\n\n<!-- more -->\n\n还是那句话，我热爱交大的一草一木，沉静深远，热爱这里共同奋斗努力的同窗好友，热爱每位聪明上进的年轻人。\n\n这一切让我不舍怀念。\n\n然后，生命的车轮总在向前，离别是迟早的。\n\n属于交大的记忆，留在交大。\n\n此刻的我，会继续向前。\n\n在交大，我找到了自己的梦；离开交大，我会将这个梦继续坚持下去。\n\n饮水思源。","source":"_drafts/梦想升起的地方.md","raw":"title: 梦想升起的地方\ntags: \n\t- 随笔\n---\n\n<img src=\"https://wingjay.com/img/dream_flies/dream.jpg\" width=\"300\">\n\n好赖，我毕业了🎓。\n\n从本科毕业时懵懂迷茫的自己，到现在坚定方向不为所动的自己。\n\n两三年的磨砺，我成长了非常多。\n\n<!-- more -->\n\n还是那句话，我热爱交大的一草一木，沉静深远，热爱这里共同奋斗努力的同窗好友，热爱每位聪明上进的年轻人。\n\n这一切让我不舍怀念。\n\n然后，生命的车轮总在向前，离别是迟早的。\n\n属于交大的记忆，留在交大。\n\n此刻的我，会继续向前。\n\n在交大，我找到了自己的梦；离开交大，我会将这个梦继续坚持下去。\n\n饮水思源。","slug":"梦想升起的地方","published":0,"date":"2018-11-26T06:56:27.479Z","updated":"2018-11-26T06:56:27.479Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplsgd00003dn8oll1zbom","content":"<p><img src=\"https://wingjay.com/img/dream_flies/dream.jpg\" width=\"300\"></p>\n<p> 好赖，我毕业了🎓。</p>\n<p> 从本科毕业时懵懂迷茫的自己，到现在坚定方向不为所动的自己。</p>\n<p> 两三年的磨砺，我成长了非常多。</p>\n<a id=\"more\"></a>\n<p> 还是那句话，我热爱交大的一草一木，沉静深远，热爱这里共同奋斗努力的同窗好友，热爱每位聪明上进的年轻人。</p>\n<p> 这一切让我不舍怀念。</p>\n<p> 然后，生命的车轮总在向前，离别是迟早的。</p>\n<p> 属于交大的记忆，留在交大。</p>\n<p> 此刻的我，会继续向前。</p>\n<p> 在交大，我找到了自己的梦；离开交大，我会将这个梦继续坚持下去。</p>\n<p> 饮水思源。</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"https://wingjay.com/img/dream_flies/dream.jpg\" width=\"300\"></p>\n<p>好赖，我毕业了🎓。</p>\n<p>从本科毕业时懵懂迷茫的自己，到现在坚定方向不为所动的自己。</p>\n<p>两三年的磨砺，我成长了非常多。</p>","more":"<p>还是那句话，我热爱交大的一草一木，沉静深远，热爱这里共同奋斗努力的同窗好友，热爱每位聪明上进的年轻人。</p>\n<p>这一切让我不舍怀念。</p>\n<p>然后，生命的车轮总在向前，离别是迟早的。</p>\n<p>属于交大的记忆，留在交大。</p>\n<p>此刻的我，会继续向前。</p>\n<p>在交大，我找到了自己的梦；离开交大，我会将这个梦继续坚持下去。</p>\n<p>饮水思源。</p>","sticky":0},{"title":"test draft","_content":"Test Auto-Spacing Plugin: https://github.com/hexojs/hexo-filter-auto-spacing\n测试Auto Spacing插件，自动在CJK和western之间加入空格\n## 问： 关于技术精进\n问个 Android 职业发展的问题，相信这也是很多Android开发者的困惑。\n\n做了三四年Android开发了，日常开发也基本能满足需求，如何进一步精进呢？如何能有一个自己的亮点，保持自己的竞争力呢？\n\n<!-- more -->\n\n日常我也一直在保持学习比如Java，JVM，数据结构算法，设计模式，也在学一些新一点的技术比如热修复、插件化等等。很多东西看了很多遍，比如设计模式，数据结构与算法，但很多时候也就是看了就看了，很多不用到时候也忘了，并且做这些很难把自己提升到一个新的高度，很多时候反而越看越迷茫，这种情况该如何更进一步精进呢，如何提升自己的核心竞争力，能让自己在很多开发者中脱颖而出，非常感谢！\n\n目前而言我暂时想到精进的一点，就是在一个领域深钻下去。这个领域一方面未来要持续有需求，另一方面要有一定技术深度，比如音视频，我在这块持续积累两三年，把这块做成自己的亮点，是否可行呢？\n\n## wingjay 答：\n- 越学越迷茫，怎么办？\n多数同学在适应了工作要求后，会自然而然地想要追求新的高度。\n其中一部分人开始刷公众号、刷知乎、刷技术论坛，试图阅读玲琅满目的文章来提高技术实力，然而这些人一段时间后总会表示更加迷茫焦虑。\n另一部分人，去刷GitHub、刷源码、去StackOverFlow回答问题。我还蛮少看到这些人会焦虑。\n技术不是用眼睛学的，而是用手和脑来练的。\n- 别急着“学习”，去“创造”一些东西。\n学习的心态确实重要，但别只当个学生，等着别人把新技术新框架喂给你。\n如果你觉得技术实力到了一定程度，不要急着去学杂七杂八的新技术。去自己动手开发一个框架、维护一个开源项目、用“极致”的方式去解决某个问题。\n很多Android领域的同学听说过Square公司，Jake大神，和他们背后一大批强大的开源项目。他们并不是那么天资聪慧，只不过把工作中遇到的每个问题，解决到了极致。图片加载太麻烦？他们创造了Picasso；findViewById太重复太傻？他们创造了ButterKnife；没有依赖注入框架？他们创造了Dagger；Java语言存在很多弊病又没法改源码？他们参与创造并推广了Kotlin。\n你觉得Jake大神有没有达到瓶颈呢？他会不会像大家一样焦虑呢？在我看来，不会。因为他还有太多的想法要做忙，没有这么多时间去焦虑。\n\n- 专研某一个领域是否可行？\n可行，不过专研某一块的话，就像投资，要看准。风险大，回报大。\n\n## 问： 关于阿里面试的冻结期和准备\n我11年毕业，做Android5年以上，计划随时去杭州发展，目标阿里。由于现在工作不是很忙，计划用一两个月时间来复习和学习。我想知道如果我现在尝试给阿里投简历，电话面试失败了，最短多长时间还有机会再投一遍好有机会电话面试？我是应该现在就尝试下好查漏补缺还是等准备充分了再投简历以免浪费面试机会呢？望知道的兄弟告知，特别是阿里的兄弟，谢谢了\n\n## wingjay 答：\n1. 先去小点的公司面试，积累面试经验，补全知识体系；\n2. 阿里内部有很多BU，就算一个没中还可以投其他的，不用担心被冻结。当然，把你最心仪的BU面试留到你最自信的时候。\n3. 准备的时间里，不要一味看书，适度参加一些面试更能知道要学什么。\n\n## 问：对第三方库的理解在面试中的比重\n想问各位大神，在面试中对于优秀第三方库的掌握在面试里面的重要性占比是怎么样的？有时候一些库之前仅限调用api而已，无法深入到源码级别，有时候去看源码又是似懂非懂的状态，这时候肯定不敢说掌握。所以应该怎么表达自己对于第三方库的或者说优秀源码的理解。\n\n## wingjay 答：\n1. 第三方库是很重要的面试点，足够看出一个人对日常使用的框架的研究程度、学习能力和态度。\n2. “仅限调用api”，那等于不会这个库，面试时就不要提起这个库了。“只会调用API”是面试大忌，就算你用这个API做一万个项目，都不如一句对原理阐述来的好；\n3. “怎样表达对于优秀源码的理解”，不要关心“怎样表达”，面试时直接说关键原理，说出来算赢，否则就算讲的天花乱坠也没用，面试官不傻。\n\n## 问：创业公司员工如何提升技术\n一毕业就转行做Android开发，至今刚好三年，一直待的的创业公司(前后两家)。因为创业公司(一大部分哈)只看你当前能带来什么，基本不关心未来的，所以专研的技术都是随业务儿变化较快的，知识是碎且浅，自己也是学完这个学那个(OpenGL, 多媒体开发, RN, NDK.....)，都是感觉半吊子，而且平时基本都在学习，累但是感觉收货较少。请问就当前这种情况来说，我应该怎样克服，是再合理审视自己的学习安排，还是换个工作环境，亦或有其他的好办法。求指点，非常感谢。\n\n## wingjay 答：\n克服什么？学一大堆浅显的知识等于没学。三年了，努把力去大公司吧，还等什么吗？","source":"_drafts/test-draft.md","raw":"title: test draft\ntags:\n---\nTest Auto-Spacing Plugin: https://github.com/hexojs/hexo-filter-auto-spacing\n测试Auto Spacing插件，自动在CJK和western之间加入空格\n## 问： 关于技术精进\n问个 Android 职业发展的问题，相信这也是很多Android开发者的困惑。\n\n做了三四年Android开发了，日常开发也基本能满足需求，如何进一步精进呢？如何能有一个自己的亮点，保持自己的竞争力呢？\n\n<!-- more -->\n\n日常我也一直在保持学习比如Java，JVM，数据结构算法，设计模式，也在学一些新一点的技术比如热修复、插件化等等。很多东西看了很多遍，比如设计模式，数据结构与算法，但很多时候也就是看了就看了，很多不用到时候也忘了，并且做这些很难把自己提升到一个新的高度，很多时候反而越看越迷茫，这种情况该如何更进一步精进呢，如何提升自己的核心竞争力，能让自己在很多开发者中脱颖而出，非常感谢！\n\n目前而言我暂时想到精进的一点，就是在一个领域深钻下去。这个领域一方面未来要持续有需求，另一方面要有一定技术深度，比如音视频，我在这块持续积累两三年，把这块做成自己的亮点，是否可行呢？\n\n## wingjay 答：\n- 越学越迷茫，怎么办？\n多数同学在适应了工作要求后，会自然而然地想要追求新的高度。\n其中一部分人开始刷公众号、刷知乎、刷技术论坛，试图阅读玲琅满目的文章来提高技术实力，然而这些人一段时间后总会表示更加迷茫焦虑。\n另一部分人，去刷GitHub、刷源码、去StackOverFlow回答问题。我还蛮少看到这些人会焦虑。\n技术不是用眼睛学的，而是用手和脑来练的。\n- 别急着“学习”，去“创造”一些东西。\n学习的心态确实重要，但别只当个学生，等着别人把新技术新框架喂给你。\n如果你觉得技术实力到了一定程度，不要急着去学杂七杂八的新技术。去自己动手开发一个框架、维护一个开源项目、用“极致”的方式去解决某个问题。\n很多Android领域的同学听说过Square公司，Jake大神，和他们背后一大批强大的开源项目。他们并不是那么天资聪慧，只不过把工作中遇到的每个问题，解决到了极致。图片加载太麻烦？他们创造了Picasso；findViewById太重复太傻？他们创造了ButterKnife；没有依赖注入框架？他们创造了Dagger；Java语言存在很多弊病又没法改源码？他们参与创造并推广了Kotlin。\n你觉得Jake大神有没有达到瓶颈呢？他会不会像大家一样焦虑呢？在我看来，不会。因为他还有太多的想法要做忙，没有这么多时间去焦虑。\n\n- 专研某一个领域是否可行？\n可行，不过专研某一块的话，就像投资，要看准。风险大，回报大。\n\n## 问： 关于阿里面试的冻结期和准备\n我11年毕业，做Android5年以上，计划随时去杭州发展，目标阿里。由于现在工作不是很忙，计划用一两个月时间来复习和学习。我想知道如果我现在尝试给阿里投简历，电话面试失败了，最短多长时间还有机会再投一遍好有机会电话面试？我是应该现在就尝试下好查漏补缺还是等准备充分了再投简历以免浪费面试机会呢？望知道的兄弟告知，特别是阿里的兄弟，谢谢了\n\n## wingjay 答：\n1. 先去小点的公司面试，积累面试经验，补全知识体系；\n2. 阿里内部有很多BU，就算一个没中还可以投其他的，不用担心被冻结。当然，把你最心仪的BU面试留到你最自信的时候。\n3. 准备的时间里，不要一味看书，适度参加一些面试更能知道要学什么。\n\n## 问：对第三方库的理解在面试中的比重\n想问各位大神，在面试中对于优秀第三方库的掌握在面试里面的重要性占比是怎么样的？有时候一些库之前仅限调用api而已，无法深入到源码级别，有时候去看源码又是似懂非懂的状态，这时候肯定不敢说掌握。所以应该怎么表达自己对于第三方库的或者说优秀源码的理解。\n\n## wingjay 答：\n1. 第三方库是很重要的面试点，足够看出一个人对日常使用的框架的研究程度、学习能力和态度。\n2. “仅限调用api”，那等于不会这个库，面试时就不要提起这个库了。“只会调用API”是面试大忌，就算你用这个API做一万个项目，都不如一句对原理阐述来的好；\n3. “怎样表达对于优秀源码的理解”，不要关心“怎样表达”，面试时直接说关键原理，说出来算赢，否则就算讲的天花乱坠也没用，面试官不傻。\n\n## 问：创业公司员工如何提升技术\n一毕业就转行做Android开发，至今刚好三年，一直待的的创业公司(前后两家)。因为创业公司(一大部分哈)只看你当前能带来什么，基本不关心未来的，所以专研的技术都是随业务儿变化较快的，知识是碎且浅，自己也是学完这个学那个(OpenGL, 多媒体开发, RN, NDK.....)，都是感觉半吊子，而且平时基本都在学习，累但是感觉收货较少。请问就当前这种情况来说，我应该怎样克服，是再合理审视自己的学习安排，还是换个工作环境，亦或有其他的好办法。求指点，非常感谢。\n\n## wingjay 答：\n克服什么？学一大堆浅显的知识等于没学。三年了，努把力去大公司吧，还等什么吗？","slug":"test-draft","published":0,"date":"2018-11-26T06:56:27.478Z","updated":"2018-11-26T06:56:27.479Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplsgh00023dn8cru0i9m6","content":"<p>Test Auto-Spacing Plugin: <a href=\"https://github.com/hexojs/hexo-filter-auto-spacing\" target=\"_blank\" rel=\"external\">https://github.com/hexojs/hexo-filter-auto-spacing</a><br>测试 Auto Spacing 插件，自动在 CJK 和 western 之间加入空格</p>\n<h2 id=\"问：- 关于技术精进\"><a href=\"# 问：- 关于技术精进\" class=\"headerlink\" title=\"问： 关于技术精进\"></a>问： 关于技术精进 </h2><p> 问个 Android 职业发展的问题，相信这也是很多 Android 开发者的困惑。</p>\n<p>做了三四年 Android 开发了，日常开发也基本能满足需求，如何进一步精进呢？如何能有一个自己的亮点，保持自己的竞争力呢？</p>\n<a id=\"more\"></a>\n<p>日常我也一直在保持学习比如 Java，JVM，数据结构算法，设计模式，也在学一些新一点的技术比如热修复、插件化等等。很多东西看了很多遍，比如设计模式，数据结构与算法，但很多时候也就是看了就看了，很多不用到时候也忘了，并且做这些很难把自己提升到一个新的高度，很多时候反而越看越迷茫，这种情况该如何更进一步精进呢，如何提升自己的核心竞争力，能让自己在很多开发者中脱颖而出，非常感谢！</p>\n<p>目前而言我暂时想到精进的一点，就是在一个领域深钻下去。这个领域一方面未来要持续有需求，另一方面要有一定技术深度，比如音视频，我在这块持续积累两三年，把这块做成自己的亮点，是否可行呢？</p>\n<h2 id=\"wingjay- 答：\"><a href=\"#wingjay- 答：\" class=\"headerlink\" title=\"wingjay 答：\"></a>wingjay 答：</h2><ul>\n<li>越学越迷茫，怎么办？<br>多数同学在适应了工作要求后，会自然而然地想要追求新的高度。<br>其中一部分人开始刷公众号、刷知乎、刷技术论坛，试图阅读玲琅满目的文章来提高技术实力，然而这些人一段时间后总会表示更加迷茫焦虑。<br>另一部分人，去刷 GitHub、刷源码、去 StackOverFlow 回答问题。我还蛮少看到这些人会焦虑。<br>技术不是用眼睛学的，而是用手和脑来练的。</li>\n<li><p>别急着“学习”，去“创造”一些东西。<br>学习的心态确实重要，但别只当个学生，等着别人把新技术新框架喂给你。<br>如果你觉得技术实力到了一定程度，不要急着去学杂七杂八的新技术。去自己动手开发一个框架、维护一个开源项目、用“极致”的方式去解决某个问题。<br>很多 Android 领域的同学听说过 Square 公司，Jake 大神，和他们背后一大批强大的开源项目。他们并不是那么天资聪慧，只不过把工作中遇到的每个问题，解决到了极致。图片加载太麻烦？他们创造了 Picasso；findViewById 太重复太傻？他们创造了 ButterKnife；没有依赖注入框架？他们创造了 Dagger；Java 语言存在很多弊病又没法改源码？他们参与创造并推广了 Kotlin。<br>你觉得 Jake 大神有没有达到瓶颈呢？他会不会像大家一样焦虑呢？在我看来，不会。因为他还有太多的想法要做忙，没有这么多时间去焦虑。</p>\n</li>\n<li><p>专研某一个领域是否可行？<br>可行，不过专研某一块的话，就像投资，要看准。风险大，回报大。</p>\n</li>\n</ul>\n<h2 id=\"问：- 关于阿里面试的冻结期和准备\"><a href=\"# 问：- 关于阿里面试的冻结期和准备\" class=\"headerlink\" title=\"问： 关于阿里面试的冻结期和准备\"></a>问： 关于阿里面试的冻结期和准备 </h2><p> 我 11 年毕业，做 Android5 年以上，计划随时去杭州发展，目标阿里。由于现在工作不是很忙，计划用一两个月时间来复习和学习。我想知道如果我现在尝试给阿里投简历，电话面试失败了，最短多长时间还有机会再投一遍好有机会电话面试？我是应该现在就尝试下好查漏补缺还是等准备充分了再投简历以免浪费面试机会呢？望知道的兄弟告知，特别是阿里的兄弟，谢谢了</p>\n<h2 id=\"wingjay- 答：-1\"><a href=\"#wingjay- 答：-1\" class=\"headerlink\" title=\"wingjay 答：\"></a>wingjay 答：</h2><ol>\n<li>先去小点的公司面试，积累面试经验，补全知识体系；</li>\n<li>阿里内部有很多 BU，就算一个没中还可以投其他的，不用担心被冻结。当然，把你最心仪的 BU 面试留到你最自信的时候。</li>\n<li>准备的时间里，不要一味看书，适度参加一些面试更能知道要学什么。</li>\n</ol>\n<h2 id=\"问：对第三方库的理解在面试中的比重\"><a href=\"# 问：对第三方库的理解在面试中的比重\" class=\"headerlink\" title=\"问：对第三方库的理解在面试中的比重\"></a>问：对第三方库的理解在面试中的比重 </h2><p> 想问各位大神，在面试中对于优秀第三方库的掌握在面试里面的重要性占比是怎么样的？有时候一些库之前仅限调用 api 而已，无法深入到源码级别，有时候去看源码又是似懂非懂的状态，这时候肯定不敢说掌握。所以应该怎么表达自己对于第三方库的或者说优秀源码的理解。</p>\n<h2 id=\"wingjay- 答：-2\"><a href=\"#wingjay- 答：-2\" class=\"headerlink\" title=\"wingjay 答：\"></a>wingjay 答：</h2><ol>\n<li>第三方库是很重要的面试点，足够看出一个人对日常使用的框架的研究程度、学习能力和态度。</li>\n<li>“仅限调用 api”，那等于不会这个库，面试时就不要提起这个库了。“只会调用 API”是面试大忌，就算你用这个 API 做一万个项目，都不如一句对原理阐述来的好；</li>\n<li>“怎样表达对于优秀源码的理解”，不要关心“怎样表达”，面试时直接说关键原理，说出来算赢，否则就算讲的天花乱坠也没用，面试官不傻。</li>\n</ol>\n<h2 id=\"问：创业公司员工如何提升技术\"><a href=\"# 问：创业公司员工如何提升技术\" class=\"headerlink\" title=\"问：创业公司员工如何提升技术\"></a>问：创业公司员工如何提升技术 </h2><p> 一毕业就转行做 Android 开发，至今刚好三年，一直待的的创业公司 (前后两家)。因为创业公司(一大部分哈) 只看你当前能带来什么，基本不关心未来的，所以专研的技术都是随业务儿变化较快的，知识是碎且浅，自己也是学完这个学那个(OpenGL, 多媒体开发, RN, NDK…..)，都是感觉半吊子，而且平时基本都在学习，累但是感觉收货较少。请问就当前这种情况来说，我应该怎样克服，是再合理审视自己的学习安排，还是换个工作环境，亦或有其他的好办法。求指点，非常感谢。</p>\n<h2 id=\"wingjay- 答：-3\"><a href=\"#wingjay- 答：-3\" class=\"headerlink\" title=\"wingjay 答：\"></a>wingjay 答：</h2><p>克服什么？学一大堆浅显的知识等于没学。三年了，努把力去大公司吧，还等什么吗？</p>\n","site":{"data":{}},"excerpt":"<p>Test Auto-Spacing Plugin: <a href=\"https://github.com/hexojs/hexo-filter-auto-spacing\" target=\"_blank\" rel=\"external\">https://github.com/hexojs/hexo-filter-auto-spacing</a><br>测试Auto Spacing插件，自动在CJK和western之间加入空格</p>\n<h2 id=\"问：-关于技术精进\"><a href=\"#问：-关于技术精进\" class=\"headerlink\" title=\"问： 关于技术精进\"></a>问： 关于技术精进</h2><p>问个 Android 职业发展的问题，相信这也是很多Android开发者的困惑。</p>\n<p>做了三四年Android开发了，日常开发也基本能满足需求，如何进一步精进呢？如何能有一个自己的亮点，保持自己的竞争力呢？</p>","more":"<p>日常我也一直在保持学习比如Java，JVM，数据结构算法，设计模式，也在学一些新一点的技术比如热修复、插件化等等。很多东西看了很多遍，比如设计模式，数据结构与算法，但很多时候也就是看了就看了，很多不用到时候也忘了，并且做这些很难把自己提升到一个新的高度，很多时候反而越看越迷茫，这种情况该如何更进一步精进呢，如何提升自己的核心竞争力，能让自己在很多开发者中脱颖而出，非常感谢！</p>\n<p>目前而言我暂时想到精进的一点，就是在一个领域深钻下去。这个领域一方面未来要持续有需求，另一方面要有一定技术深度，比如音视频，我在这块持续积累两三年，把这块做成自己的亮点，是否可行呢？</p>\n<h2 id=\"wingjay-答：\"><a href=\"#wingjay-答：\" class=\"headerlink\" title=\"wingjay 答：\"></a>wingjay 答：</h2><ul>\n<li>越学越迷茫，怎么办？<br>多数同学在适应了工作要求后，会自然而然地想要追求新的高度。<br>其中一部分人开始刷公众号、刷知乎、刷技术论坛，试图阅读玲琅满目的文章来提高技术实力，然而这些人一段时间后总会表示更加迷茫焦虑。<br>另一部分人，去刷GitHub、刷源码、去StackOverFlow回答问题。我还蛮少看到这些人会焦虑。<br>技术不是用眼睛学的，而是用手和脑来练的。</li>\n<li><p>别急着“学习”，去“创造”一些东西。<br>学习的心态确实重要，但别只当个学生，等着别人把新技术新框架喂给你。<br>如果你觉得技术实力到了一定程度，不要急着去学杂七杂八的新技术。去自己动手开发一个框架、维护一个开源项目、用“极致”的方式去解决某个问题。<br>很多Android领域的同学听说过Square公司，Jake大神，和他们背后一大批强大的开源项目。他们并不是那么天资聪慧，只不过把工作中遇到的每个问题，解决到了极致。图片加载太麻烦？他们创造了Picasso；findViewById太重复太傻？他们创造了ButterKnife；没有依赖注入框架？他们创造了Dagger；Java语言存在很多弊病又没法改源码？他们参与创造并推广了Kotlin。<br>你觉得Jake大神有没有达到瓶颈呢？他会不会像大家一样焦虑呢？在我看来，不会。因为他还有太多的想法要做忙，没有这么多时间去焦虑。</p>\n</li>\n<li><p>专研某一个领域是否可行？<br>可行，不过专研某一块的话，就像投资，要看准。风险大，回报大。</p>\n</li>\n</ul>\n<h2 id=\"问：-关于阿里面试的冻结期和准备\"><a href=\"#问：-关于阿里面试的冻结期和准备\" class=\"headerlink\" title=\"问： 关于阿里面试的冻结期和准备\"></a>问： 关于阿里面试的冻结期和准备</h2><p>我11年毕业，做Android5年以上，计划随时去杭州发展，目标阿里。由于现在工作不是很忙，计划用一两个月时间来复习和学习。我想知道如果我现在尝试给阿里投简历，电话面试失败了，最短多长时间还有机会再投一遍好有机会电话面试？我是应该现在就尝试下好查漏补缺还是等准备充分了再投简历以免浪费面试机会呢？望知道的兄弟告知，特别是阿里的兄弟，谢谢了</p>\n<h2 id=\"wingjay-答：-1\"><a href=\"#wingjay-答：-1\" class=\"headerlink\" title=\"wingjay 答：\"></a>wingjay 答：</h2><ol>\n<li>先去小点的公司面试，积累面试经验，补全知识体系；</li>\n<li>阿里内部有很多BU，就算一个没中还可以投其他的，不用担心被冻结。当然，把你最心仪的BU面试留到你最自信的时候。</li>\n<li>准备的时间里，不要一味看书，适度参加一些面试更能知道要学什么。</li>\n</ol>\n<h2 id=\"问：对第三方库的理解在面试中的比重\"><a href=\"#问：对第三方库的理解在面试中的比重\" class=\"headerlink\" title=\"问：对第三方库的理解在面试中的比重\"></a>问：对第三方库的理解在面试中的比重</h2><p>想问各位大神，在面试中对于优秀第三方库的掌握在面试里面的重要性占比是怎么样的？有时候一些库之前仅限调用api而已，无法深入到源码级别，有时候去看源码又是似懂非懂的状态，这时候肯定不敢说掌握。所以应该怎么表达自己对于第三方库的或者说优秀源码的理解。</p>\n<h2 id=\"wingjay-答：-2\"><a href=\"#wingjay-答：-2\" class=\"headerlink\" title=\"wingjay 答：\"></a>wingjay 答：</h2><ol>\n<li>第三方库是很重要的面试点，足够看出一个人对日常使用的框架的研究程度、学习能力和态度。</li>\n<li>“仅限调用api”，那等于不会这个库，面试时就不要提起这个库了。“只会调用API”是面试大忌，就算你用这个API做一万个项目，都不如一句对原理阐述来的好；</li>\n<li>“怎样表达对于优秀源码的理解”，不要关心“怎样表达”，面试时直接说关键原理，说出来算赢，否则就算讲的天花乱坠也没用，面试官不傻。</li>\n</ol>\n<h2 id=\"问：创业公司员工如何提升技术\"><a href=\"#问：创业公司员工如何提升技术\" class=\"headerlink\" title=\"问：创业公司员工如何提升技术\"></a>问：创业公司员工如何提升技术</h2><p>一毕业就转行做Android开发，至今刚好三年，一直待的的创业公司(前后两家)。因为创业公司(一大部分哈)只看你当前能带来什么，基本不关心未来的，所以专研的技术都是随业务儿变化较快的，知识是碎且浅，自己也是学完这个学那个(OpenGL, 多媒体开发, RN, NDK…..)，都是感觉半吊子，而且平时基本都在学习，累但是感觉收货较少。请问就当前这种情况来说，我应该怎样克服，是再合理审视自己的学习安排，还是换个工作环境，亦或有其他的好办法。求指点，非常感谢。</p>\n<h2 id=\"wingjay-答：-3\"><a href=\"#wingjay-答：-3\" class=\"headerlink\" title=\"wingjay 答：\"></a>wingjay 答：</h2><p>克服什么？学一大堆浅显的知识等于没学。三年了，努把力去大公司吧，还等什么吗？</p>","sticky":0},{"title":"谈谈 Java 的动态代理与 Python 的装饰器","date":"2018-02-05T13:29:43.000Z","commentIssueId":null,"_content":"在使用Java动态代理时，在一些具体场景下明显感觉到和Python的装饰器有异曲同工之妙。二者同为面向切面编程思想，把独立的函数逻辑抽取成独立切面，从而达到在不影响原有逻辑的前提下，复用相同的切面代码。\n\n下面会针对一个具体的应用场景，分别在Java动态代理机制和Python装饰器模式两个不同角度进行实现，最终加深对两种语法特性和对面向切面编程思想的理解。\n\n## 场景\n函数运行耗时记录\n\n\n## 通过Java动态代理来进行实现\n### 常规Java实现\n\n\n### 基于动态代理实现\n\n## 通过Python装饰器来进行实现\n\n## 面向切面编程的意义","source":"_drafts/谈谈Java的动态代理与Python的装饰器.md","raw":"title: 谈谈Java的动态代理与Python的装饰器\ndate: 2018-02-05 21:29:43\npermalink: java-dynamic-programming-python-decorator\ncategories:\n\t- Java\n\t- Python\ntags:\n\t- 动态代理\n\t- 装饰器\n\t- 面向切面编程\ncommentIssueId:\n---\n在使用Java动态代理时，在一些具体场景下明显感觉到和Python的装饰器有异曲同工之妙。二者同为面向切面编程思想，把独立的函数逻辑抽取成独立切面，从而达到在不影响原有逻辑的前提下，复用相同的切面代码。\n\n下面会针对一个具体的应用场景，分别在Java动态代理机制和Python装饰器模式两个不同角度进行实现，最终加深对两种语法特性和对面向切面编程思想的理解。\n\n## 场景\n函数运行耗时记录\n\n\n## 通过Java动态代理来进行实现\n### 常规Java实现\n\n\n### 基于动态代理实现\n\n## 通过Python装饰器来进行实现\n\n## 面向切面编程的意义","slug":"java-dynamic-programming-python-decorator","published":0,"updated":"2018-11-26T06:56:27.479Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplsgk00053dn8hdxyzemz","content":"<p>在使用 Java 动态代理时，在一些具体场景下明显感觉到和 Python 的装饰器有异曲同工之妙。二者同为面向切面编程思想，把独立的函数逻辑抽取成独立切面，从而达到在不影响原有逻辑的前提下，复用相同的切面代码。</p>\n<p>下面会针对一个具体的应用场景，分别在 Java 动态代理机制和 Python 装饰器模式两个不同角度进行实现，最终加深对两种语法特性和对面向切面编程思想的理解。</p>\n<h2 id=\"场景\"><a href=\"# 场景\" class=\"headerlink\" title=\"场景\"></a>场景 </h2><p> 函数运行耗时记录</p>\n<h2 id=\"通过 Java 动态代理来进行实现\"><a href=\"# 通过 Java 动态代理来进行实现\" class=\"headerlink\" title=\"通过 Java 动态代理来进行实现\"></a>通过 Java 动态代理来进行实现 </h2><h3 id=\"常规 Java 实现\"><a href=\"# 常规 Java 实现\" class=\"headerlink\" title=\"常规 Java 实现\"></a> 常规 Java 实现 </h3><h3 id=\"基于动态代理实现\"><a href=\"# 基于动态代理实现\" class=\"headerlink\" title=\"基于动态代理实现\"></a> 基于动态代理实现 </h3><h2 id=\"通过 Python 装饰器来进行实现\"><a href=\"# 通过 Python 装饰器来进行实现\" class=\"headerlink\" title=\"通过 Python 装饰器来进行实现\"></a> 通过 Python 装饰器来进行实现 </h2><h2 id=\"面向切面编程的意义\"><a href=\"# 面向切面编程的意义\" class=\"headerlink\" title=\"面向切面编程的意义\"></a> 面向切面编程的意义</h2>","site":{"data":{}},"excerpt":"","more":"<p>在使用Java动态代理时，在一些具体场景下明显感觉到和Python的装饰器有异曲同工之妙。二者同为面向切面编程思想，把独立的函数逻辑抽取成独立切面，从而达到在不影响原有逻辑的前提下，复用相同的切面代码。</p>\n<p>下面会针对一个具体的应用场景，分别在Java动态代理机制和Python装饰器模式两个不同角度进行实现，最终加深对两种语法特性和对面向切面编程思想的理解。</p>\n<h2 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h2><p>函数运行耗时记录</p>\n<h2 id=\"通过Java动态代理来进行实现\"><a href=\"#通过Java动态代理来进行实现\" class=\"headerlink\" title=\"通过Java动态代理来进行实现\"></a>通过Java动态代理来进行实现</h2><h3 id=\"常规Java实现\"><a href=\"#常规Java实现\" class=\"headerlink\" title=\"常规Java实现\"></a>常规Java实现</h3><h3 id=\"基于动态代理实现\"><a href=\"#基于动态代理实现\" class=\"headerlink\" title=\"基于动态代理实现\"></a>基于动态代理实现</h3><h2 id=\"通过Python装饰器来进行实现\"><a href=\"#通过Python装饰器来进行实现\" class=\"headerlink\" title=\"通过Python装饰器来进行实现\"></a>通过Python装饰器来进行实现</h2><h2 id=\"面向切面编程的意义\"><a href=\"#面向切面编程的意义\" class=\"headerlink\" title=\"面向切面编程的意义\"></a>面向切面编程的意义</h2>","sticky":0},{"title":"Hey folks","date":"2015-12-05T13:39:28.000Z","commentIssueId":null,"_content":"\n![Hey folks](/img/hey_folks.jpg)\n\nHi, I'm Jay! Welcome!\n\nThis is my first post here and I will write more here. Interested with me? Keep your eyes here!\n\nThanks!","source":"_posts/Hey folks.md","raw":"title: Hey folks\ntags: welcome\ndate: 2015-12-05 21:39:28\ncommentIssueId:  \n---\n\n![Hey folks](/img/hey_folks.jpg)\n\nHi, I'm Jay! Welcome!\n\nThis is my first post here and I will write more here. Interested with me? Keep your eyes here!\n\nThanks!","slug":"Hey folks","published":1,"updated":"2018-11-26T06:56:27.479Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplsgl00073dn8y93ic0ci","content":"<p><img src=\"/img/hey_folks.jpg\" alt=\"Hey folks\"></p>\n<p>Hi, I’m Jay! Welcome!</p>\n<p>This is my first post here and I will write more here. Interested with me? Keep your eyes here!</p>\n<p>Thanks!</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/img/hey_folks.jpg\" alt=\"Hey folks\"></p>\n<p>Hi, I’m Jay! Welcome!</p>\n<p>This is my first post here and I will write more here. Interested with me? Keep your eyes here!</p>\n<p>Thanks!</p>\n","sticky":0},{"title":"Hey 2018，Farewell 2017","date":"2018-01-26T13:30:01.000Z","commentIssueId":27,"_content":"很久没抽出时间来写博客了，加入阿里后确实是忙，忙，忙。有不少业务提出的挑战，也有更多个人技术上的追求与挑战。\n\n今天难得周日有空，跑公司找个安静角落，整理下2017年的技术感悟与成长，展望下2018年的规划。\n\n\n<!-- more -->\n\n\n## 回顾2017\n### 入坑 React Native，熟悉前端开发：React、Vue\n上半年在Glow时，为了达到快速迭代，我们调研了多种Hybrid开发方案：React Native，Weex，Cordova等，并最终入坑了React Native。\n\n最初担心RN学习成本太高，性能太差，所以也是一步步摸着走。不过用了一段时间后，解决了一些性能问题，最终的效果是非常满意的。学习曲线不算很陡，而且性能也在不断优化中。虽然RN框架还处在快速迭代中，不过F家的库还是蛮值得信任的。\n\n与此同时也顺手把React和Vue学习了一遍，印象最深的是两个框架背后的数据视图绑定思想：通过改动一个js变量的值，该变量对应的View也会跟着变化。另外，它们带来的前端开发方式和以前手写html,css,js完全不同。JSX的方式让开发者主要关注在js层代码，而html,css组件成为了一个个独立模块，比起过去，开发者可以更方便管理每个View的显示及其背后的逻辑。\n\n当时写过一篇[《写给移动开发者的 React Native 指南》](http://wingjay.com/2017/03/14/%E5%86%99%E7%BB%99%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-React-Native-%E6%8C%87%E5%8D%97/)，给感兴趣的小伙伴。\n\n### 加入阿里，开发多套基础Android框架\n下半年加入阿里后，在团队里做了多套框架的开发，比如网络请求框架RxApi，多type列表框架Lego，自动感应Lifecycle框架等等。这些框架在代码层面更加简洁，也提高了整体代码稳定性。\n\n其中个人觉得比较有意思的是Lego框架，全新的设计思想。它可以把一个复杂列表的实现变得像搭积木一样，通过一个string key，底层自动基于运行时注解找到对应的ViewHolder。现在新的大版本的首页所有列表都基于Lego开发，团队的人都觉得用的挺爽的，而且整个首页所有列表都轻松实现了服务端随时配置，少量的代码，高度的动态性。\n\nLego框架近期等大版本开发完后就会进入集团开源流程，之后会对外开源。\n\n### 带领小团队快速开发\n由于业务需求，团队需要完成一个全新的与Android无关的业务（C++与前端相关），而且涉及到跨端协同（移动端、前端和桌面端）开发。老大让我负责这个新项目，和另外几位同学一起开发。\n\n技术领域对我而言是全新的，而且也涉及到不少团队协同的工作和项目管理的工作。而且我带了一个很优秀的研究生实习生，善于发问、学习能力强，很像之前我在Glow实习时跟着一位靠谱Manager的状态，只不过当时是实习生，现在角色对调了。因此我也更感谢当时的Manager的耐心指导，我也努力以同样的状态来做这样一位管理者。\n\n在带领团队过程中，也切实感受到了一个技术团队的氛围、对代码的追求、发问精神、积极的工作状态对于整个团队和产品而言都是非常重要的。\n\n这个项目从最初的迷茫摸索经过两三个月，到现在产品初步成型了。这个过程中，个人成长角度上：\n1. 提高了自己对全新技术领域的学习和适应能力；\n2. 团队管理和项目管理的能力；\n3. 从零设计实现一个完整的系统：数据库文件管理、网络请求、JsBridge、线程进程管理、性能优化等；\n4. 具备多端思维是非常有益的，由于我有过前端、后端、移动端的开发背景，在开发一个全新系统时，可以从全盘考虑系统设计，达到更优。\n\n\n\n## 展望2018\n明年挑战还是很多，我也一直在思考和调整个人的发展方向。阿里是一个不错的平台，如果能遇到一个赏识你的老大和团队，一定要抓住机会好好奋斗一把。\n","source":"_posts/Hey-2018，Farewell-2017.md","raw":"title: Hey 2018，Farewell 2017\ndate: 2018-01-26 21:30:01\npermalink: hey-2018\ncategories:\n\t- 年度计划\ntags:\ncommentIssueId: 27\n---\n很久没抽出时间来写博客了，加入阿里后确实是忙，忙，忙。有不少业务提出的挑战，也有更多个人技术上的追求与挑战。\n\n今天难得周日有空，跑公司找个安静角落，整理下2017年的技术感悟与成长，展望下2018年的规划。\n\n\n<!-- more -->\n\n\n## 回顾2017\n### 入坑 React Native，熟悉前端开发：React、Vue\n上半年在Glow时，为了达到快速迭代，我们调研了多种Hybrid开发方案：React Native，Weex，Cordova等，并最终入坑了React Native。\n\n最初担心RN学习成本太高，性能太差，所以也是一步步摸着走。不过用了一段时间后，解决了一些性能问题，最终的效果是非常满意的。学习曲线不算很陡，而且性能也在不断优化中。虽然RN框架还处在快速迭代中，不过F家的库还是蛮值得信任的。\n\n与此同时也顺手把React和Vue学习了一遍，印象最深的是两个框架背后的数据视图绑定思想：通过改动一个js变量的值，该变量对应的View也会跟着变化。另外，它们带来的前端开发方式和以前手写html,css,js完全不同。JSX的方式让开发者主要关注在js层代码，而html,css组件成为了一个个独立模块，比起过去，开发者可以更方便管理每个View的显示及其背后的逻辑。\n\n当时写过一篇[《写给移动开发者的 React Native 指南》](http://wingjay.com/2017/03/14/%E5%86%99%E7%BB%99%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-React-Native-%E6%8C%87%E5%8D%97/)，给感兴趣的小伙伴。\n\n### 加入阿里，开发多套基础Android框架\n下半年加入阿里后，在团队里做了多套框架的开发，比如网络请求框架RxApi，多type列表框架Lego，自动感应Lifecycle框架等等。这些框架在代码层面更加简洁，也提高了整体代码稳定性。\n\n其中个人觉得比较有意思的是Lego框架，全新的设计思想。它可以把一个复杂列表的实现变得像搭积木一样，通过一个string key，底层自动基于运行时注解找到对应的ViewHolder。现在新的大版本的首页所有列表都基于Lego开发，团队的人都觉得用的挺爽的，而且整个首页所有列表都轻松实现了服务端随时配置，少量的代码，高度的动态性。\n\nLego框架近期等大版本开发完后就会进入集团开源流程，之后会对外开源。\n\n### 带领小团队快速开发\n由于业务需求，团队需要完成一个全新的与Android无关的业务（C++与前端相关），而且涉及到跨端协同（移动端、前端和桌面端）开发。老大让我负责这个新项目，和另外几位同学一起开发。\n\n技术领域对我而言是全新的，而且也涉及到不少团队协同的工作和项目管理的工作。而且我带了一个很优秀的研究生实习生，善于发问、学习能力强，很像之前我在Glow实习时跟着一位靠谱Manager的状态，只不过当时是实习生，现在角色对调了。因此我也更感谢当时的Manager的耐心指导，我也努力以同样的状态来做这样一位管理者。\n\n在带领团队过程中，也切实感受到了一个技术团队的氛围、对代码的追求、发问精神、积极的工作状态对于整个团队和产品而言都是非常重要的。\n\n这个项目从最初的迷茫摸索经过两三个月，到现在产品初步成型了。这个过程中，个人成长角度上：\n1. 提高了自己对全新技术领域的学习和适应能力；\n2. 团队管理和项目管理的能力；\n3. 从零设计实现一个完整的系统：数据库文件管理、网络请求、JsBridge、线程进程管理、性能优化等；\n4. 具备多端思维是非常有益的，由于我有过前端、后端、移动端的开发背景，在开发一个全新系统时，可以从全盘考虑系统设计，达到更优。\n\n\n\n## 展望2018\n明年挑战还是很多，我也一直在思考和调整个人的发展方向。阿里是一个不错的平台，如果能遇到一个赏识你的老大和团队，一定要抓住机会好好奋斗一把。\n","slug":"hey-2018","published":1,"updated":"2018-11-26T06:56:27.480Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplsgo00093dn82a5ephae","content":"<p>很久没抽出时间来写博客了，加入阿里后确实是忙，忙，忙。有不少业务提出的挑战，也有更多个人技术上的追求与挑战。</p>\n<p>今天难得周日有空，跑公司找个安静角落，整理下 2017 年的技术感悟与成长，展望下 2018 年的规划。</p>\n<a id=\"more\"></a>\n<h2 id=\"回顾 2017\"><a href=\"# 回顾 2017\" class=\"headerlink\" title=\"回顾 2017\"></a>回顾 2017</h2><h3 id=\"入坑 -React-Native，熟悉前端开发：React、Vue\"><a href=\"# 入坑 -React-Native，熟悉前端开发：React、Vue\" class=\"headerlink\" title=\"入坑 React Native，熟悉前端开发：React、Vue\"></a>入坑 React Native，熟悉前端开发：React、Vue</h3><p>上半年在 Glow 时，为了达到快速迭代，我们调研了多种 Hybrid 开发方案：React Native，Weex，Cordova 等，并最终入坑了 React Native。</p>\n<p>最初担心 RN 学习成本太高，性能太差，所以也是一步步摸着走。不过用了一段时间后，解决了一些性能问题，最终的效果是非常满意的。学习曲线不算很陡，而且性能也在不断优化中。虽然 RN 框架还处在快速迭代中，不过 F 家的库还是蛮值得信任的。</p>\n<p>与此同时也顺手把 React 和 Vue 学习了一遍，印象最深的是两个框架背后的数据视图绑定思想：通过改动一个 js 变量的值，该变量对应的 View 也会跟着变化。另外，它们带来的前端开发方式和以前手写 html,css,js 完全不同。JSX 的方式让开发者主要关注在 js 层代码，而 html,css 组件成为了一个个独立模块，比起过去，开发者可以更方便管理每个 View 的显示及其背后的逻辑。</p>\n<p>当时写过一篇<a href=\"http://wingjay.com/2017/03/14/%E5%86%99%E7%BB%99%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-React-Native-%E6%8C%87%E5%8D%97/\">《写给移动开发者的 React Native 指南》</a>，给感兴趣的小伙伴。</p>\n<h3 id=\"加入阿里，开发多套基础 Android 框架\"><a href=\"# 加入阿里，开发多套基础 Android 框架\" class=\"headerlink\" title=\"加入阿里，开发多套基础 Android 框架\"></a>加入阿里，开发多套基础 Android 框架 </h3><p> 下半年加入阿里后，在团队里做了多套框架的开发，比如网络请求框架 RxApi，多 type 列表框架 Lego，自动感应 Lifecycle 框架等等。这些框架在代码层面更加简洁，也提高了整体代码稳定性。</p>\n<p>其中个人觉得比较有意思的是 Lego 框架，全新的设计思想。它可以把一个复杂列表的实现变得像搭积木一样，通过一个 string key，底层自动基于运行时注解找到对应的 ViewHolder。现在新的大版本的首页所有列表都基于 Lego 开发，团队的人都觉得用的挺爽的，而且整个首页所有列表都轻松实现了服务端随时配置，少量的代码，高度的动态性。</p>\n<p>Lego 框架近期等大版本开发完后就会进入集团开源流程，之后会对外开源。</p>\n<h3 id=\"带领小团队快速开发\"><a href=\"# 带领小团队快速开发\" class=\"headerlink\" title=\"带领小团队快速开发\"></a>带领小团队快速开发 </h3><p> 由于业务需求，团队需要完成一个全新的与 Android 无关的业务（C++ 与前端相关），而且涉及到跨端协同（移动端、前端和桌面端）开发。老大让我负责这个新项目，和另外几位同学一起开发。</p>\n<p>技术领域对我而言是全新的，而且也涉及到不少团队协同的工作和项目管理的工作。而且我带了一个很优秀的研究生实习生，善于发问、学习能力强，很像之前我在 Glow 实习时跟着一位靠谱 Manager 的状态，只不过当时是实习生，现在角色对调了。因此我也更感谢当时的 Manager 的耐心指导，我也努力以同样的状态来做这样一位管理者。</p>\n<p>在带领团队过程中，也切实感受到了一个技术团队的氛围、对代码的追求、发问精神、积极的工作状态对于整个团队和产品而言都是非常重要的。</p>\n<p>这个项目从最初的迷茫摸索经过两三个月，到现在产品初步成型了。这个过程中，个人成长角度上：</p>\n<ol>\n<li>提高了自己对全新技术领域的学习和适应能力；</li>\n<li>团队管理和项目管理的能力；</li>\n<li>从零设计实现一个完整的系统：数据库文件管理、网络请求、JsBridge、线程进程管理、性能优化等；</li>\n<li>具备多端思维是非常有益的，由于我有过前端、后端、移动端的开发背景，在开发一个全新系统时，可以从全盘考虑系统设计，达到更优。</li>\n</ol>\n<h2 id=\"展望 2018\"><a href=\"# 展望 2018\" class=\"headerlink\" title=\"展望 2018\"></a>展望 2018</h2><p>明年挑战还是很多，我也一直在思考和调整个人的发展方向。阿里是一个不错的平台，如果能遇到一个赏识你的老大和团队，一定要抓住机会好好奋斗一把。</p>\n","site":{"data":{}},"excerpt":"<p>很久没抽出时间来写博客了，加入阿里后确实是忙，忙，忙。有不少业务提出的挑战，也有更多个人技术上的追求与挑战。</p>\n<p>今天难得周日有空，跑公司找个安静角落，整理下2017年的技术感悟与成长，展望下2018年的规划。</p>","more":"<h2 id=\"回顾2017\"><a href=\"#回顾2017\" class=\"headerlink\" title=\"回顾2017\"></a>回顾2017</h2><h3 id=\"入坑-React-Native，熟悉前端开发：React、Vue\"><a href=\"#入坑-React-Native，熟悉前端开发：React、Vue\" class=\"headerlink\" title=\"入坑 React Native，熟悉前端开发：React、Vue\"></a>入坑 React Native，熟悉前端开发：React、Vue</h3><p>上半年在Glow时，为了达到快速迭代，我们调研了多种Hybrid开发方案：React Native，Weex，Cordova等，并最终入坑了React Native。</p>\n<p>最初担心RN学习成本太高，性能太差，所以也是一步步摸着走。不过用了一段时间后，解决了一些性能问题，最终的效果是非常满意的。学习曲线不算很陡，而且性能也在不断优化中。虽然RN框架还处在快速迭代中，不过F家的库还是蛮值得信任的。</p>\n<p>与此同时也顺手把React和Vue学习了一遍，印象最深的是两个框架背后的数据视图绑定思想：通过改动一个js变量的值，该变量对应的View也会跟着变化。另外，它们带来的前端开发方式和以前手写html,css,js完全不同。JSX的方式让开发者主要关注在js层代码，而html,css组件成为了一个个独立模块，比起过去，开发者可以更方便管理每个View的显示及其背后的逻辑。</p>\n<p>当时写过一篇<a href=\"http://wingjay.com/2017/03/14/%E5%86%99%E7%BB%99%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-React-Native-%E6%8C%87%E5%8D%97/\">《写给移动开发者的 React Native 指南》</a>，给感兴趣的小伙伴。</p>\n<h3 id=\"加入阿里，开发多套基础Android框架\"><a href=\"#加入阿里，开发多套基础Android框架\" class=\"headerlink\" title=\"加入阿里，开发多套基础Android框架\"></a>加入阿里，开发多套基础Android框架</h3><p>下半年加入阿里后，在团队里做了多套框架的开发，比如网络请求框架RxApi，多type列表框架Lego，自动感应Lifecycle框架等等。这些框架在代码层面更加简洁，也提高了整体代码稳定性。</p>\n<p>其中个人觉得比较有意思的是Lego框架，全新的设计思想。它可以把一个复杂列表的实现变得像搭积木一样，通过一个string key，底层自动基于运行时注解找到对应的ViewHolder。现在新的大版本的首页所有列表都基于Lego开发，团队的人都觉得用的挺爽的，而且整个首页所有列表都轻松实现了服务端随时配置，少量的代码，高度的动态性。</p>\n<p>Lego框架近期等大版本开发完后就会进入集团开源流程，之后会对外开源。</p>\n<h3 id=\"带领小团队快速开发\"><a href=\"#带领小团队快速开发\" class=\"headerlink\" title=\"带领小团队快速开发\"></a>带领小团队快速开发</h3><p>由于业务需求，团队需要完成一个全新的与Android无关的业务（C++与前端相关），而且涉及到跨端协同（移动端、前端和桌面端）开发。老大让我负责这个新项目，和另外几位同学一起开发。</p>\n<p>技术领域对我而言是全新的，而且也涉及到不少团队协同的工作和项目管理的工作。而且我带了一个很优秀的研究生实习生，善于发问、学习能力强，很像之前我在Glow实习时跟着一位靠谱Manager的状态，只不过当时是实习生，现在角色对调了。因此我也更感谢当时的Manager的耐心指导，我也努力以同样的状态来做这样一位管理者。</p>\n<p>在带领团队过程中，也切实感受到了一个技术团队的氛围、对代码的追求、发问精神、积极的工作状态对于整个团队和产品而言都是非常重要的。</p>\n<p>这个项目从最初的迷茫摸索经过两三个月，到现在产品初步成型了。这个过程中，个人成长角度上：</p>\n<ol>\n<li>提高了自己对全新技术领域的学习和适应能力；</li>\n<li>团队管理和项目管理的能力；</li>\n<li>从零设计实现一个完整的系统：数据库文件管理、网络请求、JsBridge、线程进程管理、性能优化等；</li>\n<li>具备多端思维是非常有益的，由于我有过前端、后端、移动端的开发背景，在开发一个全新系统时，可以从全盘考虑系统设计，达到更优。</li>\n</ol>\n<h2 id=\"展望2018\"><a href=\"#展望2018\" class=\"headerlink\" title=\"展望2018\"></a>展望2018</h2><p>明年挑战还是很多，我也一直在思考和调整个人的发展方向。阿里是一个不错的平台，如果能遇到一个赏识你的老大和团队，一定要抓住机会好好奋斗一把。</p>","sticky":0},{"title":"Walk in ShangHai","date":"2016-07-10T08:11:38.000Z","commentIssueId":null,"_content":" \n> 魔都是座有趣的城市，每条街道都有故事。\n\n<!-- more -->\n\n天气：阴\n目的地：淮海中路＋陕西南路\n\n<img src=\"http://wingjay.com/img/walk_in_sh/1.JPG\">\n\n\n<img src=\"http://wingjay.com/img/walk_in_sh/2.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/3.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/4.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/5.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/6.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/7.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/8.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/10.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/11.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/12.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/13.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/14.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/15.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/16.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/17.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/18.JPG\">\n\n每座城市，都有自己独特的魅力。","source":"_posts/Walk-in-ShangHai.md","raw":"title: Walk in ShangHai\ndate: 2016-07-10 16:11:38\ncategories:\n  - 摄影\ntags:\n\t- 摄影\ncommentIssueId:  \t\n---\n \n> 魔都是座有趣的城市，每条街道都有故事。\n\n<!-- more -->\n\n天气：阴\n目的地：淮海中路＋陕西南路\n\n<img src=\"http://wingjay.com/img/walk_in_sh/1.JPG\">\n\n\n<img src=\"http://wingjay.com/img/walk_in_sh/2.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/3.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/4.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/5.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/6.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/7.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/8.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/10.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/11.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/12.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/13.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/14.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/15.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/16.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/17.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/18.JPG\">\n\n每座城市，都有自己独特的魅力。","slug":"Walk-in-ShangHai","published":1,"updated":"2018-11-26T06:56:27.482Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplsgp000c3dn8y3a6c7xf","content":"<blockquote>\n<p>魔都是座有趣的城市，每条街道都有故事。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>天气：阴 <br> 目的地：淮海中路＋陕西南路</p>\n<p><img src=\"http://wingjay.com/img/walk_in_sh/1.JPG\"></p>\n<p><img src=\"http://wingjay.com/img/walk_in_sh/2.JPG\"><br><img src=\"http://wingjay.com/img/walk_in_sh/3.JPG\"><br><img src=\"http://wingjay.com/img/walk_in_sh/4.JPG\"><br><img src=\"http://wingjay.com/img/walk_in_sh/5.JPG\"><br><img src=\"http://wingjay.com/img/walk_in_sh/6.JPG\"><br><img src=\"http://wingjay.com/img/walk_in_sh/7.JPG\"><br><img src=\"http://wingjay.com/img/walk_in_sh/8.JPG\"><br><img src=\"http://wingjay.com/img/walk_in_sh/10.JPG\"><br><img src=\"http://wingjay.com/img/walk_in_sh/11.JPG\"><br><img src=\"http://wingjay.com/img/walk_in_sh/12.JPG\"><br><img src=\"http://wingjay.com/img/walk_in_sh/13.JPG\"><br><img src=\"http://wingjay.com/img/walk_in_sh/14.JPG\"><br><img src=\"http://wingjay.com/img/walk_in_sh/15.JPG\"><br><img src=\"http://wingjay.com/img/walk_in_sh/16.JPG\"><br><img src=\"http://wingjay.com/img/walk_in_sh/17.JPG\"><br><img src=\"http://wingjay.com/img/walk_in_sh/18.JPG\"></p>\n<p>每座城市，都有自己独特的魅力。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>魔都是座有趣的城市，每条街道都有故事。</p>\n</blockquote>","more":"<p>天气：阴<br>目的地：淮海中路＋陕西南路</p>\n<p><img src=\"http://wingjay.com/img/walk_in_sh/1.JPG\"></p>\n<p><img src=\"http://wingjay.com/img/walk_in_sh/2.JPG\"><br><img src=\"http://wingjay.com/img/walk_in_sh/3.JPG\"><br><img src=\"http://wingjay.com/img/walk_in_sh/4.JPG\"><br><img src=\"http://wingjay.com/img/walk_in_sh/5.JPG\"><br><img src=\"http://wingjay.com/img/walk_in_sh/6.JPG\"><br><img src=\"http://wingjay.com/img/walk_in_sh/7.JPG\"><br><img src=\"http://wingjay.com/img/walk_in_sh/8.JPG\"><br><img src=\"http://wingjay.com/img/walk_in_sh/10.JPG\"><br><img src=\"http://wingjay.com/img/walk_in_sh/11.JPG\"><br><img src=\"http://wingjay.com/img/walk_in_sh/12.JPG\"><br><img src=\"http://wingjay.com/img/walk_in_sh/13.JPG\"><br><img src=\"http://wingjay.com/img/walk_in_sh/14.JPG\"><br><img src=\"http://wingjay.com/img/walk_in_sh/15.JPG\"><br><img src=\"http://wingjay.com/img/walk_in_sh/16.JPG\"><br><img src=\"http://wingjay.com/img/walk_in_sh/17.JPG\"><br><img src=\"http://wingjay.com/img/walk_in_sh/18.JPG\"></p>\n<p>每座城市，都有自己独特的魅力。</p>","sticky":0},{"title":"sjtu","date":"2016-01-02T08:31:11.000Z","commentIssueId":null,"_content":"> 交大像个奋进的年轻人，我觉得和我挺像。\n\n<!-- more -->\n周六，元旦刚过。\n\n校园内空空荡荡，图书馆内座无虚席。\n\n<img src=\"/img/sjtu/library.jpg\" width=\"300\">\n\n也罢，找不到座位，就出去逛逛咱交大满园的秋色吧，顺便体验一把新入手6s的照相性能。\n\n\n![](/img/sjtu/library_outside.jpg)\n\n不得不说咱的图书馆融入了“天圆地方”的建筑理念，耐看。\n\n\n![](/img/sjtu/laker.jpg)\n\n下午斜斜夕阳和静静的湖水，真想找个椅子听听音乐休憩一番\n\n![](/img/sjtu/hehua.jpg)\n\n炎炎夏日的烂漫荷花如今也破败不堪。\n\n![](/img/sjtu/tuya.jpg)\n\n交大特色涂鸦墙，记载了多少岁月的印记，和青春的不羁。\n\n![](/img/sjtu/love.jpg)\n\n校园爱情，真美。一生若能遇到一个真爱，你不得不好好珍惜。\n\n![](/img/sjtu/huxiaohe.jpg)\n\n校园内静静流淌的护校河，让我想起曾在干旱的帝都，路上连水洼都难觅。\n\n![](/img/sjtu/dom.jpg)\n\n说实话交大的住宿条件不错，空调＋套间。唯一遗憾的是住在一楼的我们很需要阳光！\n\n交大很优美，很沉静。\n\n交大的同学们很聪明，很踏实。\n\n在交大的岁月很短暂，却很珍贵。\n","source":"_posts/交大－影.md","raw":"title: sjtu\ncategories:\n  - 摄影\ntags:\n  - 摄影\ndate: 2016-01-02 16:31:11\ncommentIssueId: \n---\n> 交大像个奋进的年轻人，我觉得和我挺像。\n\n<!-- more -->\n周六，元旦刚过。\n\n校园内空空荡荡，图书馆内座无虚席。\n\n<img src=\"/img/sjtu/library.jpg\" width=\"300\">\n\n也罢，找不到座位，就出去逛逛咱交大满园的秋色吧，顺便体验一把新入手6s的照相性能。\n\n\n![](/img/sjtu/library_outside.jpg)\n\n不得不说咱的图书馆融入了“天圆地方”的建筑理念，耐看。\n\n\n![](/img/sjtu/laker.jpg)\n\n下午斜斜夕阳和静静的湖水，真想找个椅子听听音乐休憩一番\n\n![](/img/sjtu/hehua.jpg)\n\n炎炎夏日的烂漫荷花如今也破败不堪。\n\n![](/img/sjtu/tuya.jpg)\n\n交大特色涂鸦墙，记载了多少岁月的印记，和青春的不羁。\n\n![](/img/sjtu/love.jpg)\n\n校园爱情，真美。一生若能遇到一个真爱，你不得不好好珍惜。\n\n![](/img/sjtu/huxiaohe.jpg)\n\n校园内静静流淌的护校河，让我想起曾在干旱的帝都，路上连水洼都难觅。\n\n![](/img/sjtu/dom.jpg)\n\n说实话交大的住宿条件不错，空调＋套间。唯一遗憾的是住在一楼的我们很需要阳光！\n\n交大很优美，很沉静。\n\n交大的同学们很聪明，很踏实。\n\n在交大的岁月很短暂，却很珍贵。\n","slug":"交大－影","published":1,"updated":"2018-11-26T06:56:27.483Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplsgr000d3dn841i2sxre","content":"<blockquote>\n<p> 交大像个奋进的年轻人，我觉得和我挺像。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p> 周六，元旦刚过。</p>\n<p> 校园内空空荡荡，图书馆内座无虚席。</p>\n<p><img src=\"/img/sjtu/library.jpg\" width=\"300\"></p>\n<p> 也罢，找不到座位，就出去逛逛咱交大满园的秋色吧，顺便体验一把新入手 6s 的照相性能。</p>\n<p><img src=\"/img/sjtu/library_outside.jpg\" alt=\"\"></p>\n<p> 不得不说咱的图书馆融入了“天圆地方”的建筑理念，耐看。</p>\n<p><img src=\"/img/sjtu/laker.jpg\" alt=\"\"></p>\n<p> 下午斜斜夕阳和静静的湖水，真想找个椅子听听音乐休憩一番 </p>\n<p><img src=\"/img/sjtu/hehua.jpg\" alt=\"\"></p>\n<p> 炎炎夏日的烂漫荷花如今也破败不堪。</p>\n<p><img src=\"/img/sjtu/tuya.jpg\" alt=\"\"></p>\n<p> 交大特色涂鸦墙，记载了多少岁月的印记，和青春的不羁。</p>\n<p><img src=\"/img/sjtu/love.jpg\" alt=\"\"></p>\n<p> 校园爱情，真美。一生若能遇到一个真爱，你不得不好好珍惜。</p>\n<p><img src=\"/img/sjtu/huxiaohe.jpg\" alt=\"\"></p>\n<p> 校园内静静流淌的护校河，让我想起曾在干旱的帝都，路上连水洼都难觅。</p>\n<p><img src=\"/img/sjtu/dom.jpg\" alt=\"\"></p>\n<p> 说实话交大的住宿条件不错，空调＋套间。唯一遗憾的是住在一楼的我们很需要阳光！</p>\n<p> 交大很优美，很沉静。</p>\n<p> 交大的同学们很聪明，很踏实。</p>\n<p> 在交大的岁月很短暂，却很珍贵。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>交大像个奋进的年轻人，我觉得和我挺像。</p>\n</blockquote>","more":"<p>周六，元旦刚过。</p>\n<p>校园内空空荡荡，图书馆内座无虚席。</p>\n<p><img src=\"/img/sjtu/library.jpg\" width=\"300\"></p>\n<p>也罢，找不到座位，就出去逛逛咱交大满园的秋色吧，顺便体验一把新入手6s的照相性能。</p>\n<p><img src=\"/img/sjtu/library_outside.jpg\" alt=\"\"></p>\n<p>不得不说咱的图书馆融入了“天圆地方”的建筑理念，耐看。</p>\n<p><img src=\"/img/sjtu/laker.jpg\" alt=\"\"></p>\n<p>下午斜斜夕阳和静静的湖水，真想找个椅子听听音乐休憩一番</p>\n<p><img src=\"/img/sjtu/hehua.jpg\" alt=\"\"></p>\n<p>炎炎夏日的烂漫荷花如今也破败不堪。</p>\n<p><img src=\"/img/sjtu/tuya.jpg\" alt=\"\"></p>\n<p>交大特色涂鸦墙，记载了多少岁月的印记，和青春的不羁。</p>\n<p><img src=\"/img/sjtu/love.jpg\" alt=\"\"></p>\n<p>校园爱情，真美。一生若能遇到一个真爱，你不得不好好珍惜。</p>\n<p><img src=\"/img/sjtu/huxiaohe.jpg\" alt=\"\"></p>\n<p>校园内静静流淌的护校河，让我想起曾在干旱的帝都，路上连水洼都难觅。</p>\n<p><img src=\"/img/sjtu/dom.jpg\" alt=\"\"></p>\n<p>说实话交大的住宿条件不错，空调＋套间。唯一遗憾的是住在一楼的我们很需要阳光！</p>\n<p>交大很优美，很沉静。</p>\n<p>交大的同学们很聪明，很踏实。</p>\n<p>在交大的岁月很短暂，却很珍贵。</p>","sticky":0},{"title":"一种快速毛玻璃虚化效果实现","date":"2016-03-12T01:30:50.000Z","commentIssueId":18,"_content":"> 在 Android 上也能实现毛玻璃效果？性能如何？\n\n<!-- more -->\n<img src=\"http://wingjay.com/img/fastblur/iosblur.jpg\" width=\"300\">\n\n在iOS设备上我们随处可见毛玻璃效果，而且最近越来越多的场合应用到了这种美观的虚化效果，包括本人的一个开源项目[BlureImageView](https://github.com/wingjay/BlurImageView)也是受此启发。所以，恰到好处的虚化效果能很好的改善用户体验，而且也能让你的app显得更加优雅。\n\n不过，我们目前在android上很少见到毛玻璃效果，我认为很重要的原因是性能问题，虚化一张图片所需要的时间会因设备而异，如果为了虚化使得用户需要刻意等待，那么就是弊大于利。另外，Google官方提供的renderScript一般只是做一些小幅度的虚化，很难达到毛玻璃这类深度虚化效果。\n\n所以本文的角度是能够在android设备上快速实现毛玻璃效果。\n\n\n![blur1](/img/fastblur/androidblur_1.png)\n![blur2](/img/fastblur/androidblur_2.png)\n\n### StackBlur\n首先，为了实现毛玻璃效果，本文采用的是[`StackBlur`模糊算法](http://www.quasimondo.com/StackBlurForCanvas/StackBlurDemo.html)，这种算法应用非常广泛，能得到非常良好的毛玻璃效果。在这里，我们使用的是它的Java实现代码[FastBlur.java](https://github.com/wingjay/BlurImageView/blob/master/blurimageviewlib/src/main/java/com/wingjay/blurimageviewlib/FastBlurUtil.java)。\n\n\tpublic static Bitmap doBlur(Bitmap sentBitmap, int radius, boolean canReuseInBitmap)\n可以看出，使用方法非常简单，传入待虚化的bitmap、虚化程序(一般为8)、和是否重用flag。\n\n然后，如果要对上面这张图片进行虚化，我们可以通过把它转化成bitmap传入虚化，看起来很简单就解决了，但事实并非如此。\n\n### OOM\n如果直接把一张大图传入，很容易就会发生OOM内存溢出\n\n\t03-11 21:02:02.014 16727-16742/com.wingjay.jayandroid I/art: Clamp target GC heap from 109MB to 96MB\n\t03-11 21:02:02.026 16727-16727/com.wingjay.jayandroid I/art: Clamp target GC heap from 109MB to 96MB\n\t03-11 21:02:02.030 16727-16727/com.wingjay.jayandroid I/art: Clamp target GC heap from 109MB to 96MB\n\t03-11 21:02:02.031 16727-16727/com.wingjay.jayandroid I/art: Forcing collection of SoftReferences for 30MB allocation\n\t03-11 21:02:02.035 16727-16727/com.wingjay.jayandroid I/art: Clamp target GC heap from 109MB to 96MB\n\t03-11 21:02:02.036 16727-16727/com.wingjay.jayandroid E/art: Throwing OutOfMemoryError \"Failed to allocate a 32175012 byte allocation with 2648672 free bytes and 2MB until OOM\"\n\t03-11 21:02:02.036 16727-16727/com.wingjay.jayandroid D/AndroidRuntime: Shutting down VM\n这是我直接对原图进行虚化得到的log信息。可以看出当虚化开始时，虚拟机开始不断进行内存回收，包括把所有软引用的内存回收。然而，仍然导致了内存溢出。\n\n那就意味着我只能虚化小图，这样才能防止内存溢出。但是我并不想换其他图，那么，我们就应该把这张图`缩放`。\n\n### ReScale\n\n\tpublic static Bitmap createScaledBitmap(Bitmap src, int dstWidth, int dstHeight, boolean filter) {}\n我们可以利用这个function来进行bitmap的缩放。其中前三个参数很明显，其中宽高我们可以选择为原图尺寸的1/10；第四个filter是指缩放的效果，filter为true则会得到一个边缘平滑的bitmap，反之，则会得到边缘锯齿、pixelrelated的bitmap。这里我们要对缩放的图片进行虚化，所以无所谓边缘效果，`filter=false`。\n\n所以，我们要使用\n\n\tint scaleRatio = 10;\n\tint blurRadius = 8;\n\tBitmap scaledBitmap = Bitmap.createScaledBitmap(originBitmap,\n        originBitmap.getWidth() / scaleRatio,\n        originBitmap.getHeight() / scaleRatio,\n        false);\n\tBitmap blurBitmap = FastBlur.doBlur(scaledBitmap, blurRadius, true);\n    imageView.setScaleType(ImageView.ScaleType.CENTER_CROP);\n    imageView.setImageBitmap(blurBitmap);\n可以得到如下效果:\n![scaleRatio_10](/img/fastblur/fastblur_10.png)\n\n从图中可以看出，首先可以确定思路是对的；然后，可以看出毛玻璃效果还不是特别的明显。为了得到如iOS那样的虚化效果，我们有两种方法：\n\n- 增大scaleRatio缩放比，使用一样更小的bitmap去虚化可以得到更好的模糊效果，而且有利于占用内存的减小；\n- 增大blurRadius，可以得到更高程度的虚化，不过会导致CPU更加intensive\n\n这里本人通过`增大缩放比`来实验。\n\n- scaleRatio = 20\n![scaleRatio_20](/img/fastblur/fastblur_20.png)\n- scaleRatio = 35\n![scaleRatio_35](/img/fastblur/fastblur_35.png)\n- scaleRatio = 50\n![scaleRatio_50](/img/fastblur/fastblur_50.png)\n- scaleRatio = 100\n![scaleRatio_100](/img/fastblur/fastblur_100.png)\n\n通过上面对比图我们可以找出最适合自己的虚化效果。\n\n### Performance analysis\n那么，要实现这样的效果，是否具有损害用户体验的风险呢？下面，我们从`消耗时间`和`占据内存`的角度来进行分析。\n\n#### Time Consuming\n为了分析虚化一张图片所消耗的时间，本文通过同时虚化`100`来获取平均消耗时间。以期对虚化耗时和不同缩放比对耗时的影响得到一定的认识。\n\n\tlong start = System.currentTimeMillis();\n    Bitmap scaledBitmap, blurBitmap;\n    int scaleRatio = 10;\n    int loopCount = 100\n    for (int i=0; i<loopCount; i++) {\n      scaledBitmap = Bitmap.createScaledBitmap(originBitmap,\n          originBitmap.getWidth() / scaleRatio,\n          originBitmap.getHeight() / scaleRatio,\n          false);\n      blurBitmap = FastBlur.doBlur(scaledBitmap, 8, true);\n    }\n    Log.i(\"blurtime\", String.valueOf(System.currentTimeMillis() - start));\n\n- scaleRatio = 10: 耗时`887ms`，平均耗时`8.87ms`;\n- scaleRatio = 20: 耗时`224ms`，平均耗时`2.24ms`;\n- scaleRatio = 35: 耗时`99ms`，平均耗时`0.99ms`;\n- scaleRatio = 50: 耗时`55ms`，平均耗时`0.55ms`;\n- scaleRatio = 100: 耗时`29ms`，平均耗时`0.29ms`;\n\n为了方便读者了解效果，我通过多组数据拟合了下面的曲线：\n![](/img/fastblur/timeconsume_statisic.png)\n\n从该模拟图可以看出时间随着缩放比的增大而不断减小，当缩放比达到30以上时所消耗的时间不到1ms，因此，我认为应该是完全不会产生时延破坏用户体验的。\n\n#### Memory Consuming\n既然时间没问题，那么，主要问题：内存占用就来了，所以我们需要考察生成一张虚化图片所占用的内存。\n\n为了测试对一张图片进行虚化所占用内存的变化，我们改变虚化次数，即修改上面的`loopCount`并观察对内存的变化。其中scaleRatio = 10，以获得相对较大的内存消耗。\n\n- loopCount = 1\n![](/img/fastblur/memory_1.png)\n- loopCount = 10\n![](/img/fastblur/memory_10.png)\n- loopCount = 20\n![](/img/fastblur/memory_20.png)\n- loopCount = 50\n![](/img/fastblur/memory_50.png)\n- loopCount = 100\n![](/img/fastblur/memory_100.png)\n- loopCount = 300\n![](/img/fastblur/memory_300.png)\n\n从上面的内存消耗图，可以看出虚化的确会占用一定内存，如果大量的虚化同时发生，则会由于UI线程突然加载很多bitmap而导致内存抖动。\n\n#### Conclusion\n希望大家如果有其他测试方法或者意见多多留言，从而继续改进性能。\n\n附上本文所采用的![测试图](/img/fastblur/test_pic.jpeg)\n\n谢谢！\n\nwingjay\n\n\n\n\n\n欢迎各位关注\n[我的Github](https://github.com/wingjay): <https://github.com/wingjay> \n和 \n[我的个人博客](http://wingjay.com): <http://wingjay.com>\n和\n[我的简书](http://www.jianshu.com/users/da333fd63fe5/latest_articles): <http://www.jianshu.com/users/da333fd63fe5/latest_articles>\n和\n[微博 iam_wingjay](http://weibo.com/u/1625892654): <http://weibo.com/u/1625892654>\n如果有问题，可以给我留言或发邮件<mailto:yinjiesh@126.com>\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n\n\n","source":"_posts/一种快速毛玻璃虚化效果实现.md","raw":"title: 一种快速毛玻璃虚化效果实现\ndate: 2016-03-12 09:30:50\ncategories:\n  - Android\n  - Performance\ntags:\n\t- Android\ncommentIssueId: 18  \n---\n> 在 Android 上也能实现毛玻璃效果？性能如何？\n\n<!-- more -->\n<img src=\"http://wingjay.com/img/fastblur/iosblur.jpg\" width=\"300\">\n\n在iOS设备上我们随处可见毛玻璃效果，而且最近越来越多的场合应用到了这种美观的虚化效果，包括本人的一个开源项目[BlureImageView](https://github.com/wingjay/BlurImageView)也是受此启发。所以，恰到好处的虚化效果能很好的改善用户体验，而且也能让你的app显得更加优雅。\n\n不过，我们目前在android上很少见到毛玻璃效果，我认为很重要的原因是性能问题，虚化一张图片所需要的时间会因设备而异，如果为了虚化使得用户需要刻意等待，那么就是弊大于利。另外，Google官方提供的renderScript一般只是做一些小幅度的虚化，很难达到毛玻璃这类深度虚化效果。\n\n所以本文的角度是能够在android设备上快速实现毛玻璃效果。\n\n\n![blur1](/img/fastblur/androidblur_1.png)\n![blur2](/img/fastblur/androidblur_2.png)\n\n### StackBlur\n首先，为了实现毛玻璃效果，本文采用的是[`StackBlur`模糊算法](http://www.quasimondo.com/StackBlurForCanvas/StackBlurDemo.html)，这种算法应用非常广泛，能得到非常良好的毛玻璃效果。在这里，我们使用的是它的Java实现代码[FastBlur.java](https://github.com/wingjay/BlurImageView/blob/master/blurimageviewlib/src/main/java/com/wingjay/blurimageviewlib/FastBlurUtil.java)。\n\n\tpublic static Bitmap doBlur(Bitmap sentBitmap, int radius, boolean canReuseInBitmap)\n可以看出，使用方法非常简单，传入待虚化的bitmap、虚化程序(一般为8)、和是否重用flag。\n\n然后，如果要对上面这张图片进行虚化，我们可以通过把它转化成bitmap传入虚化，看起来很简单就解决了，但事实并非如此。\n\n### OOM\n如果直接把一张大图传入，很容易就会发生OOM内存溢出\n\n\t03-11 21:02:02.014 16727-16742/com.wingjay.jayandroid I/art: Clamp target GC heap from 109MB to 96MB\n\t03-11 21:02:02.026 16727-16727/com.wingjay.jayandroid I/art: Clamp target GC heap from 109MB to 96MB\n\t03-11 21:02:02.030 16727-16727/com.wingjay.jayandroid I/art: Clamp target GC heap from 109MB to 96MB\n\t03-11 21:02:02.031 16727-16727/com.wingjay.jayandroid I/art: Forcing collection of SoftReferences for 30MB allocation\n\t03-11 21:02:02.035 16727-16727/com.wingjay.jayandroid I/art: Clamp target GC heap from 109MB to 96MB\n\t03-11 21:02:02.036 16727-16727/com.wingjay.jayandroid E/art: Throwing OutOfMemoryError \"Failed to allocate a 32175012 byte allocation with 2648672 free bytes and 2MB until OOM\"\n\t03-11 21:02:02.036 16727-16727/com.wingjay.jayandroid D/AndroidRuntime: Shutting down VM\n这是我直接对原图进行虚化得到的log信息。可以看出当虚化开始时，虚拟机开始不断进行内存回收，包括把所有软引用的内存回收。然而，仍然导致了内存溢出。\n\n那就意味着我只能虚化小图，这样才能防止内存溢出。但是我并不想换其他图，那么，我们就应该把这张图`缩放`。\n\n### ReScale\n\n\tpublic static Bitmap createScaledBitmap(Bitmap src, int dstWidth, int dstHeight, boolean filter) {}\n我们可以利用这个function来进行bitmap的缩放。其中前三个参数很明显，其中宽高我们可以选择为原图尺寸的1/10；第四个filter是指缩放的效果，filter为true则会得到一个边缘平滑的bitmap，反之，则会得到边缘锯齿、pixelrelated的bitmap。这里我们要对缩放的图片进行虚化，所以无所谓边缘效果，`filter=false`。\n\n所以，我们要使用\n\n\tint scaleRatio = 10;\n\tint blurRadius = 8;\n\tBitmap scaledBitmap = Bitmap.createScaledBitmap(originBitmap,\n        originBitmap.getWidth() / scaleRatio,\n        originBitmap.getHeight() / scaleRatio,\n        false);\n\tBitmap blurBitmap = FastBlur.doBlur(scaledBitmap, blurRadius, true);\n    imageView.setScaleType(ImageView.ScaleType.CENTER_CROP);\n    imageView.setImageBitmap(blurBitmap);\n可以得到如下效果:\n![scaleRatio_10](/img/fastblur/fastblur_10.png)\n\n从图中可以看出，首先可以确定思路是对的；然后，可以看出毛玻璃效果还不是特别的明显。为了得到如iOS那样的虚化效果，我们有两种方法：\n\n- 增大scaleRatio缩放比，使用一样更小的bitmap去虚化可以得到更好的模糊效果，而且有利于占用内存的减小；\n- 增大blurRadius，可以得到更高程度的虚化，不过会导致CPU更加intensive\n\n这里本人通过`增大缩放比`来实验。\n\n- scaleRatio = 20\n![scaleRatio_20](/img/fastblur/fastblur_20.png)\n- scaleRatio = 35\n![scaleRatio_35](/img/fastblur/fastblur_35.png)\n- scaleRatio = 50\n![scaleRatio_50](/img/fastblur/fastblur_50.png)\n- scaleRatio = 100\n![scaleRatio_100](/img/fastblur/fastblur_100.png)\n\n通过上面对比图我们可以找出最适合自己的虚化效果。\n\n### Performance analysis\n那么，要实现这样的效果，是否具有损害用户体验的风险呢？下面，我们从`消耗时间`和`占据内存`的角度来进行分析。\n\n#### Time Consuming\n为了分析虚化一张图片所消耗的时间，本文通过同时虚化`100`来获取平均消耗时间。以期对虚化耗时和不同缩放比对耗时的影响得到一定的认识。\n\n\tlong start = System.currentTimeMillis();\n    Bitmap scaledBitmap, blurBitmap;\n    int scaleRatio = 10;\n    int loopCount = 100\n    for (int i=0; i<loopCount; i++) {\n      scaledBitmap = Bitmap.createScaledBitmap(originBitmap,\n          originBitmap.getWidth() / scaleRatio,\n          originBitmap.getHeight() / scaleRatio,\n          false);\n      blurBitmap = FastBlur.doBlur(scaledBitmap, 8, true);\n    }\n    Log.i(\"blurtime\", String.valueOf(System.currentTimeMillis() - start));\n\n- scaleRatio = 10: 耗时`887ms`，平均耗时`8.87ms`;\n- scaleRatio = 20: 耗时`224ms`，平均耗时`2.24ms`;\n- scaleRatio = 35: 耗时`99ms`，平均耗时`0.99ms`;\n- scaleRatio = 50: 耗时`55ms`，平均耗时`0.55ms`;\n- scaleRatio = 100: 耗时`29ms`，平均耗时`0.29ms`;\n\n为了方便读者了解效果，我通过多组数据拟合了下面的曲线：\n![](/img/fastblur/timeconsume_statisic.png)\n\n从该模拟图可以看出时间随着缩放比的增大而不断减小，当缩放比达到30以上时所消耗的时间不到1ms，因此，我认为应该是完全不会产生时延破坏用户体验的。\n\n#### Memory Consuming\n既然时间没问题，那么，主要问题：内存占用就来了，所以我们需要考察生成一张虚化图片所占用的内存。\n\n为了测试对一张图片进行虚化所占用内存的变化，我们改变虚化次数，即修改上面的`loopCount`并观察对内存的变化。其中scaleRatio = 10，以获得相对较大的内存消耗。\n\n- loopCount = 1\n![](/img/fastblur/memory_1.png)\n- loopCount = 10\n![](/img/fastblur/memory_10.png)\n- loopCount = 20\n![](/img/fastblur/memory_20.png)\n- loopCount = 50\n![](/img/fastblur/memory_50.png)\n- loopCount = 100\n![](/img/fastblur/memory_100.png)\n- loopCount = 300\n![](/img/fastblur/memory_300.png)\n\n从上面的内存消耗图，可以看出虚化的确会占用一定内存，如果大量的虚化同时发生，则会由于UI线程突然加载很多bitmap而导致内存抖动。\n\n#### Conclusion\n希望大家如果有其他测试方法或者意见多多留言，从而继续改进性能。\n\n附上本文所采用的![测试图](/img/fastblur/test_pic.jpeg)\n\n谢谢！\n\nwingjay\n\n\n\n\n\n欢迎各位关注\n[我的Github](https://github.com/wingjay): <https://github.com/wingjay> \n和 \n[我的个人博客](http://wingjay.com): <http://wingjay.com>\n和\n[我的简书](http://www.jianshu.com/users/da333fd63fe5/latest_articles): <http://www.jianshu.com/users/da333fd63fe5/latest_articles>\n和\n[微博 iam_wingjay](http://weibo.com/u/1625892654): <http://weibo.com/u/1625892654>\n如果有问题，可以给我留言或发邮件<mailto:yinjiesh@126.com>\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n\n\n","slug":"一种快速毛玻璃虚化效果实现","published":1,"updated":"2018-11-26T06:56:27.482Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplsgs000g3dn82j36ht1z","content":"<blockquote>\n<p>在 Android 上也能实现毛玻璃效果？性能如何？</p>\n</blockquote>\n<a id=\"more\"></a>\n<p><img src=\"http://wingjay.com/img/fastblur/iosblur.jpg\" width=\"300\"></p>\n<p>在 iOS 设备上我们随处可见毛玻璃效果，而且最近越来越多的场合应用到了这种美观的虚化效果，包括本人的一个开源项目 <a href=\"https://github.com/wingjay/BlurImageView\" target=\"_blank\" rel=\"external\">BlureImageView</a> 也是受此启发。所以，恰到好处的虚化效果能很好的改善用户体验，而且也能让你的 app 显得更加优雅。</p>\n<p>不过，我们目前在 android 上很少见到毛玻璃效果，我认为很重要的原因是性能问题，虚化一张图片所需要的时间会因设备而异，如果为了虚化使得用户需要刻意等待，那么就是弊大于利。另外，Google 官方提供的 renderScript 一般只是做一些小幅度的虚化，很难达到毛玻璃这类深度虚化效果。</p>\n<p>所以本文的角度是能够在 android 设备上快速实现毛玻璃效果。</p>\n<p><img src=\"/img/fastblur/androidblur_1.png\" alt=\"blur1\"><br><img src=\"/img/fastblur/androidblur_2.png\" alt=\"blur2\"></p>\n<h3 id=\"StackBlur\"><a href=\"#StackBlur\" class=\"headerlink\" title=\"StackBlur\"></a>StackBlur</h3><p>首先，为了实现毛玻璃效果，本文采用的是 <a href=\"http://www.quasimondo.com/StackBlurForCanvas/StackBlurDemo.html\" target=\"_blank\" rel=\"external\"><code>StackBlur</code> 模糊算法</a>，这种算法应用非常广泛，能得到非常良好的毛玻璃效果。在这里，我们使用的是它的 Java 实现代码<a href=\"https://github.com/wingjay/BlurImageView/blob/master/blurimageviewlib/src/main/java/com/wingjay/blurimageviewlib/FastBlurUtil.java\" target=\"_blank\" rel=\"external\">FastBlur.java</a>。</p>\n<pre><code>public static Bitmap doBlur(Bitmap sentBitmap, int radius, boolean canReuseInBitmap)\n</code></pre><p>可以看出，使用方法非常简单，传入待虚化的 bitmap、虚化程序(一般为 8)、和是否重用 flag。</p>\n<p>然后，如果要对上面这张图片进行虚化，我们可以通过把它转化成 bitmap 传入虚化，看起来很简单就解决了，但事实并非如此。</p>\n<h3 id=\"OOM\"><a href=\"#OOM\" class=\"headerlink\" title=\"OOM\"></a>OOM</h3><p>如果直接把一张大图传入，很容易就会发生 OOM 内存溢出</p>\n<pre><code>03-11 21:02:02.014 16727-16742/com.wingjay.jayandroid I/art: Clamp target GC heap from 109MB to 96MB\n03-11 21:02:02.026 16727-16727/com.wingjay.jayandroid I/art: Clamp target GC heap from 109MB to 96MB\n03-11 21:02:02.030 16727-16727/com.wingjay.jayandroid I/art: Clamp target GC heap from 109MB to 96MB\n03-11 21:02:02.031 16727-16727/com.wingjay.jayandroid I/art: Forcing collection of SoftReferences for 30MB allocation\n03-11 21:02:02.035 16727-16727/com.wingjay.jayandroid I/art: Clamp target GC heap from 109MB to 96MB\n03-11 21:02:02.036 16727-16727/com.wingjay.jayandroid E/art: Throwing OutOfMemoryError &quot;Failed to allocate a 32175012 byte allocation with 2648672 free bytes and 2MB until OOM&quot;\n03-11 21:02:02.036 16727-16727/com.wingjay.jayandroid D/AndroidRuntime: Shutting down VM\n</code></pre><p>这是我直接对原图进行虚化得到的 log 信息。可以看出当虚化开始时，虚拟机开始不断进行内存回收，包括把所有软引用的内存回收。然而，仍然导致了内存溢出。</p>\n<p>那就意味着我只能虚化小图，这样才能防止内存溢出。但是我并不想换其他图，那么，我们就应该把这张图 <code> 缩放</code>。</p>\n<h3 id=\"ReScale\"><a href=\"#ReScale\" class=\"headerlink\" title=\"ReScale\"></a>ReScale</h3><pre><code>public static Bitmap createScaledBitmap(Bitmap src, int dstWidth, int dstHeight, boolean filter) {}\n</code></pre><p>我们可以利用这个 function 来进行 bitmap 的缩放。其中前三个参数很明显，其中宽高我们可以选择为原图尺寸的 1/10；第四个 filter 是指缩放的效果，filter 为 true 则会得到一个边缘平滑的 bitmap，反之，则会得到边缘锯齿、pixelrelated 的 bitmap。这里我们要对缩放的图片进行虚化，所以无所谓边缘效果，<code>filter=false</code>。</p>\n<p>所以，我们要使用</p>\n<pre><code>int scaleRatio = 10;\nint blurRadius = 8;\nBitmap scaledBitmap = Bitmap.createScaledBitmap(originBitmap,\n    originBitmap.getWidth() / scaleRatio,\n    originBitmap.getHeight() / scaleRatio,\n    false);\nBitmap blurBitmap = FastBlur.doBlur(scaledBitmap, blurRadius, true);\nimageView.setScaleType(ImageView.ScaleType.CENTER_CROP);\nimageView.setImageBitmap(blurBitmap);\n</code></pre><p>可以得到如下效果:<br><img src=\"/img/fastblur/fastblur_10.png\" alt=\"scaleRatio_10\"></p>\n<p>从图中可以看出，首先可以确定思路是对的；然后，可以看出毛玻璃效果还不是特别的明显。为了得到如 iOS 那样的虚化效果，我们有两种方法：</p>\n<ul>\n<li>增大 scaleRatio 缩放比，使用一样更小的 bitmap 去虚化可以得到更好的模糊效果，而且有利于占用内存的减小；</li>\n<li>增大 blurRadius，可以得到更高程度的虚化，不过会导致 CPU 更加 intensive</li>\n</ul>\n<p>这里本人通过 <code> 增大缩放比 </code> 来实验。</p>\n<ul>\n<li>scaleRatio = 20<br><img src=\"/img/fastblur/fastblur_20.png\" alt=\"scaleRatio_20\"></li>\n<li>scaleRatio = 35<br><img src=\"/img/fastblur/fastblur_35.png\" alt=\"scaleRatio_35\"></li>\n<li>scaleRatio = 50<br><img src=\"/img/fastblur/fastblur_50.png\" alt=\"scaleRatio_50\"></li>\n<li>scaleRatio = 100<br><img src=\"/img/fastblur/fastblur_100.png\" alt=\"scaleRatio_100\"></li>\n</ul>\n<p>通过上面对比图我们可以找出最适合自己的虚化效果。</p>\n<h3 id=\"Performance-analysis\"><a href=\"#Performance-analysis\" class=\"headerlink\" title=\"Performance analysis\"></a>Performance analysis</h3><p>那么，要实现这样的效果，是否具有损害用户体验的风险呢？下面，我们从 <code> 消耗时间 </code> 和<code>占据内存 </code> 的角度来进行分析。</p>\n<h4 id=\"Time-Consuming\"><a href=\"#Time-Consuming\" class=\"headerlink\" title=\"Time Consuming\"></a>Time Consuming</h4><p>为了分析虚化一张图片所消耗的时间，本文通过同时虚化 <code>100</code> 来获取平均消耗时间。以期对虚化耗时和不同缩放比对耗时的影响得到一定的认识。</p>\n<pre><code>long start = System.currentTimeMillis();\nBitmap scaledBitmap, blurBitmap;\nint scaleRatio = 10;\nint loopCount = 100\nfor (int i=0; i&lt;loopCount; i++) {\n  scaledBitmap = Bitmap.createScaledBitmap(originBitmap,\n      originBitmap.getWidth() / scaleRatio,\n      originBitmap.getHeight() / scaleRatio,\n      false);\n  blurBitmap = FastBlur.doBlur(scaledBitmap, 8, true);\n}\nLog.i(&quot;blurtime&quot;, String.valueOf(System.currentTimeMillis() - start));\n</code></pre><ul>\n<li>scaleRatio = 10: 耗时<code>887ms</code>，平均耗时<code>8.87ms</code>;</li>\n<li>scaleRatio = 20: 耗时<code>224ms</code>，平均耗时<code>2.24ms</code>;</li>\n<li>scaleRatio = 35: 耗时<code>99ms</code>，平均耗时<code>0.99ms</code>;</li>\n<li>scaleRatio = 50: 耗时<code>55ms</code>，平均耗时<code>0.55ms</code>;</li>\n<li>scaleRatio = 100: 耗时<code>29ms</code>，平均耗时<code>0.29ms</code>;</li>\n</ul>\n<p>为了方便读者了解效果，我通过多组数据拟合了下面的曲线：<br><img src=\"/img/fastblur/timeconsume_statisic.png\" alt=\"\"></p>\n<p>从该模拟图可以看出时间随着缩放比的增大而不断减小，当缩放比达到 30 以上时所消耗的时间不到 1ms，因此，我认为应该是完全不会产生时延破坏用户体验的。</p>\n<h4 id=\"Memory-Consuming\"><a href=\"#Memory-Consuming\" class=\"headerlink\" title=\"Memory Consuming\"></a>Memory Consuming</h4><p>既然时间没问题，那么，主要问题：内存占用就来了，所以我们需要考察生成一张虚化图片所占用的内存。</p>\n<p>为了测试对一张图片进行虚化所占用内存的变化，我们改变虚化次数，即修改上面的 <code>loopCount</code> 并观察对内存的变化。其中 scaleRatio = 10，以获得相对较大的内存消耗。</p>\n<ul>\n<li>loopCount = 1<br><img src=\"/img/fastblur/memory_1.png\" alt=\"\"></li>\n<li>loopCount = 10<br><img src=\"/img/fastblur/memory_10.png\" alt=\"\"></li>\n<li>loopCount = 20<br><img src=\"/img/fastblur/memory_20.png\" alt=\"\"></li>\n<li>loopCount = 50<br><img src=\"/img/fastblur/memory_50.png\" alt=\"\"></li>\n<li>loopCount = 100<br><img src=\"/img/fastblur/memory_100.png\" alt=\"\"></li>\n<li>loopCount = 300<br><img src=\"/img/fastblur/memory_300.png\" alt=\"\"></li>\n</ul>\n<p>从上面的内存消耗图，可以看出虚化的确会占用一定内存，如果大量的虚化同时发生，则会由于 UI 线程突然加载很多 bitmap 而导致内存抖动。</p>\n<h4 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h4><p>希望大家如果有其他测试方法或者意见多多留言，从而继续改进性能。</p>\n<p>附上本文所采用的<img src=\"/img/fastblur/test_pic.jpeg\" alt=\"测试图\"></p>\n<p>谢谢！</p>\n<p>wingjay</p>\n<p>欢迎各位关注 <br><a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\"> 我的 Github</a>: <a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\">https://github.com/wingjay</a><br>和 <br><a href=\"http://wingjay.com\"> 我的个人博客 </a>: <a href=\"http://wingjay.com\">http://wingjay.com</a><br> 和<br><a href=\"http://www.jianshu.com/users/da333fd63fe5/latest_articles\" target=\"_blank\" rel=\"external\">我的简书 </a>: <a href=\"http://www.jianshu.com/users/da333fd63fe5/latest_articles\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/users/da333fd63fe5/latest_articles</a><br> 和<br><a href=\"http://weibo.com/u/1625892654\" target=\"_blank\" rel=\"external\">微博 iam_wingjay</a>: <a href=\"http://weibo.com/u/1625892654\" target=\"_blank\" rel=\"external\">http://weibo.com/u/1625892654</a><br>如果有问题，可以给我留言或发邮件<a href=\"&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#x79;&#105;&#110;&#106;&#x69;&#x65;&#x73;&#x68;&#64;&#49;&#50;&#54;&#46;&#x63;&#111;&#x6d;\">&#x79;&#105;&#110;&#106;&#x69;&#x65;&#x73;&#x68;&#64;&#49;&#50;&#54;&#46;&#x63;&#111;&#x6d;</a></p>\n<p><img src=\"https://avatars0.githubusercontent.com/u/9619875?v=3&amp;s=460\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>在 Android 上也能实现毛玻璃效果？性能如何？</p>\n</blockquote>","more":"<p><img src=\"http://wingjay.com/img/fastblur/iosblur.jpg\" width=\"300\"></p>\n<p>在iOS设备上我们随处可见毛玻璃效果，而且最近越来越多的场合应用到了这种美观的虚化效果，包括本人的一个开源项目<a href=\"https://github.com/wingjay/BlurImageView\" target=\"_blank\" rel=\"external\">BlureImageView</a>也是受此启发。所以，恰到好处的虚化效果能很好的改善用户体验，而且也能让你的app显得更加优雅。</p>\n<p>不过，我们目前在android上很少见到毛玻璃效果，我认为很重要的原因是性能问题，虚化一张图片所需要的时间会因设备而异，如果为了虚化使得用户需要刻意等待，那么就是弊大于利。另外，Google官方提供的renderScript一般只是做一些小幅度的虚化，很难达到毛玻璃这类深度虚化效果。</p>\n<p>所以本文的角度是能够在android设备上快速实现毛玻璃效果。</p>\n<p><img src=\"/img/fastblur/androidblur_1.png\" alt=\"blur1\"><br><img src=\"/img/fastblur/androidblur_2.png\" alt=\"blur2\"></p>\n<h3 id=\"StackBlur\"><a href=\"#StackBlur\" class=\"headerlink\" title=\"StackBlur\"></a>StackBlur</h3><p>首先，为了实现毛玻璃效果，本文采用的是<a href=\"http://www.quasimondo.com/StackBlurForCanvas/StackBlurDemo.html\" target=\"_blank\" rel=\"external\"><code>StackBlur</code>模糊算法</a>，这种算法应用非常广泛，能得到非常良好的毛玻璃效果。在这里，我们使用的是它的Java实现代码<a href=\"https://github.com/wingjay/BlurImageView/blob/master/blurimageviewlib/src/main/java/com/wingjay/blurimageviewlib/FastBlurUtil.java\" target=\"_blank\" rel=\"external\">FastBlur.java</a>。</p>\n<pre><code>public static Bitmap doBlur(Bitmap sentBitmap, int radius, boolean canReuseInBitmap)\n</code></pre><p>可以看出，使用方法非常简单，传入待虚化的bitmap、虚化程序(一般为8)、和是否重用flag。</p>\n<p>然后，如果要对上面这张图片进行虚化，我们可以通过把它转化成bitmap传入虚化，看起来很简单就解决了，但事实并非如此。</p>\n<h3 id=\"OOM\"><a href=\"#OOM\" class=\"headerlink\" title=\"OOM\"></a>OOM</h3><p>如果直接把一张大图传入，很容易就会发生OOM内存溢出</p>\n<pre><code>03-11 21:02:02.014 16727-16742/com.wingjay.jayandroid I/art: Clamp target GC heap from 109MB to 96MB\n03-11 21:02:02.026 16727-16727/com.wingjay.jayandroid I/art: Clamp target GC heap from 109MB to 96MB\n03-11 21:02:02.030 16727-16727/com.wingjay.jayandroid I/art: Clamp target GC heap from 109MB to 96MB\n03-11 21:02:02.031 16727-16727/com.wingjay.jayandroid I/art: Forcing collection of SoftReferences for 30MB allocation\n03-11 21:02:02.035 16727-16727/com.wingjay.jayandroid I/art: Clamp target GC heap from 109MB to 96MB\n03-11 21:02:02.036 16727-16727/com.wingjay.jayandroid E/art: Throwing OutOfMemoryError &quot;Failed to allocate a 32175012 byte allocation with 2648672 free bytes and 2MB until OOM&quot;\n03-11 21:02:02.036 16727-16727/com.wingjay.jayandroid D/AndroidRuntime: Shutting down VM\n</code></pre><p>这是我直接对原图进行虚化得到的log信息。可以看出当虚化开始时，虚拟机开始不断进行内存回收，包括把所有软引用的内存回收。然而，仍然导致了内存溢出。</p>\n<p>那就意味着我只能虚化小图，这样才能防止内存溢出。但是我并不想换其他图，那么，我们就应该把这张图<code>缩放</code>。</p>\n<h3 id=\"ReScale\"><a href=\"#ReScale\" class=\"headerlink\" title=\"ReScale\"></a>ReScale</h3><pre><code>public static Bitmap createScaledBitmap(Bitmap src, int dstWidth, int dstHeight, boolean filter) {}\n</code></pre><p>我们可以利用这个function来进行bitmap的缩放。其中前三个参数很明显，其中宽高我们可以选择为原图尺寸的1/10；第四个filter是指缩放的效果，filter为true则会得到一个边缘平滑的bitmap，反之，则会得到边缘锯齿、pixelrelated的bitmap。这里我们要对缩放的图片进行虚化，所以无所谓边缘效果，<code>filter=false</code>。</p>\n<p>所以，我们要使用</p>\n<pre><code>int scaleRatio = 10;\nint blurRadius = 8;\nBitmap scaledBitmap = Bitmap.createScaledBitmap(originBitmap,\n    originBitmap.getWidth() / scaleRatio,\n    originBitmap.getHeight() / scaleRatio,\n    false);\nBitmap blurBitmap = FastBlur.doBlur(scaledBitmap, blurRadius, true);\nimageView.setScaleType(ImageView.ScaleType.CENTER_CROP);\nimageView.setImageBitmap(blurBitmap);\n</code></pre><p>可以得到如下效果:<br><img src=\"/img/fastblur/fastblur_10.png\" alt=\"scaleRatio_10\"></p>\n<p>从图中可以看出，首先可以确定思路是对的；然后，可以看出毛玻璃效果还不是特别的明显。为了得到如iOS那样的虚化效果，我们有两种方法：</p>\n<ul>\n<li>增大scaleRatio缩放比，使用一样更小的bitmap去虚化可以得到更好的模糊效果，而且有利于占用内存的减小；</li>\n<li>增大blurRadius，可以得到更高程度的虚化，不过会导致CPU更加intensive</li>\n</ul>\n<p>这里本人通过<code>增大缩放比</code>来实验。</p>\n<ul>\n<li>scaleRatio = 20<br><img src=\"/img/fastblur/fastblur_20.png\" alt=\"scaleRatio_20\"></li>\n<li>scaleRatio = 35<br><img src=\"/img/fastblur/fastblur_35.png\" alt=\"scaleRatio_35\"></li>\n<li>scaleRatio = 50<br><img src=\"/img/fastblur/fastblur_50.png\" alt=\"scaleRatio_50\"></li>\n<li>scaleRatio = 100<br><img src=\"/img/fastblur/fastblur_100.png\" alt=\"scaleRatio_100\"></li>\n</ul>\n<p>通过上面对比图我们可以找出最适合自己的虚化效果。</p>\n<h3 id=\"Performance-analysis\"><a href=\"#Performance-analysis\" class=\"headerlink\" title=\"Performance analysis\"></a>Performance analysis</h3><p>那么，要实现这样的效果，是否具有损害用户体验的风险呢？下面，我们从<code>消耗时间</code>和<code>占据内存</code>的角度来进行分析。</p>\n<h4 id=\"Time-Consuming\"><a href=\"#Time-Consuming\" class=\"headerlink\" title=\"Time Consuming\"></a>Time Consuming</h4><p>为了分析虚化一张图片所消耗的时间，本文通过同时虚化<code>100</code>来获取平均消耗时间。以期对虚化耗时和不同缩放比对耗时的影响得到一定的认识。</p>\n<pre><code>long start = System.currentTimeMillis();\nBitmap scaledBitmap, blurBitmap;\nint scaleRatio = 10;\nint loopCount = 100\nfor (int i=0; i&lt;loopCount; i++) {\n  scaledBitmap = Bitmap.createScaledBitmap(originBitmap,\n      originBitmap.getWidth() / scaleRatio,\n      originBitmap.getHeight() / scaleRatio,\n      false);\n  blurBitmap = FastBlur.doBlur(scaledBitmap, 8, true);\n}\nLog.i(&quot;blurtime&quot;, String.valueOf(System.currentTimeMillis() - start));\n</code></pre><ul>\n<li>scaleRatio = 10: 耗时<code>887ms</code>，平均耗时<code>8.87ms</code>;</li>\n<li>scaleRatio = 20: 耗时<code>224ms</code>，平均耗时<code>2.24ms</code>;</li>\n<li>scaleRatio = 35: 耗时<code>99ms</code>，平均耗时<code>0.99ms</code>;</li>\n<li>scaleRatio = 50: 耗时<code>55ms</code>，平均耗时<code>0.55ms</code>;</li>\n<li>scaleRatio = 100: 耗时<code>29ms</code>，平均耗时<code>0.29ms</code>;</li>\n</ul>\n<p>为了方便读者了解效果，我通过多组数据拟合了下面的曲线：<br><img src=\"/img/fastblur/timeconsume_statisic.png\" alt=\"\"></p>\n<p>从该模拟图可以看出时间随着缩放比的增大而不断减小，当缩放比达到30以上时所消耗的时间不到1ms，因此，我认为应该是完全不会产生时延破坏用户体验的。</p>\n<h4 id=\"Memory-Consuming\"><a href=\"#Memory-Consuming\" class=\"headerlink\" title=\"Memory Consuming\"></a>Memory Consuming</h4><p>既然时间没问题，那么，主要问题：内存占用就来了，所以我们需要考察生成一张虚化图片所占用的内存。</p>\n<p>为了测试对一张图片进行虚化所占用内存的变化，我们改变虚化次数，即修改上面的<code>loopCount</code>并观察对内存的变化。其中scaleRatio = 10，以获得相对较大的内存消耗。</p>\n<ul>\n<li>loopCount = 1<br><img src=\"/img/fastblur/memory_1.png\" alt=\"\"></li>\n<li>loopCount = 10<br><img src=\"/img/fastblur/memory_10.png\" alt=\"\"></li>\n<li>loopCount = 20<br><img src=\"/img/fastblur/memory_20.png\" alt=\"\"></li>\n<li>loopCount = 50<br><img src=\"/img/fastblur/memory_50.png\" alt=\"\"></li>\n<li>loopCount = 100<br><img src=\"/img/fastblur/memory_100.png\" alt=\"\"></li>\n<li>loopCount = 300<br><img src=\"/img/fastblur/memory_300.png\" alt=\"\"></li>\n</ul>\n<p>从上面的内存消耗图，可以看出虚化的确会占用一定内存，如果大量的虚化同时发生，则会由于UI线程突然加载很多bitmap而导致内存抖动。</p>\n<h4 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h4><p>希望大家如果有其他测试方法或者意见多多留言，从而继续改进性能。</p>\n<p>附上本文所采用的<img src=\"/img/fastblur/test_pic.jpeg\" alt=\"测试图\"></p>\n<p>谢谢！</p>\n<p>wingjay</p>\n<p>欢迎各位关注<br><a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\">我的Github</a>: <a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\">https://github.com/wingjay</a><br>和<br><a href=\"http://wingjay.com\">我的个人博客</a>: <a href=\"http://wingjay.com\">http://wingjay.com</a><br>和<br><a href=\"http://www.jianshu.com/users/da333fd63fe5/latest_articles\" target=\"_blank\" rel=\"external\">我的简书</a>: <a href=\"http://www.jianshu.com/users/da333fd63fe5/latest_articles\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/users/da333fd63fe5/latest_articles</a><br>和<br><a href=\"http://weibo.com/u/1625892654\" target=\"_blank\" rel=\"external\">微博 iam_wingjay</a>: <a href=\"http://weibo.com/u/1625892654\" target=\"_blank\" rel=\"external\">http://weibo.com/u/1625892654</a><br>如果有问题，可以给我留言或发邮件<a href=\"&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#x79;&#105;&#110;&#106;&#x69;&#x65;&#x73;&#x68;&#64;&#49;&#50;&#54;&#46;&#x63;&#111;&#x6d;\">&#x79;&#105;&#110;&#106;&#x69;&#x65;&#x73;&#x68;&#64;&#49;&#50;&#54;&#46;&#x63;&#111;&#x6d;</a></p>\n<p><img src=\"https://avatars0.githubusercontent.com/u/9619875?v=3&amp;s=460\" alt=\"\"></p>","sticky":0},{"title":"今年之计","date":"2016-02-19T08:39:37.000Z","commentIssueId":null,"_content":"> 2016年我的计划\n\n<!-- more -->\n\n![今年之计](https://drscdn.500px.org/photo/40352952/q%3D80_m%3D2000/b8ea73af7f5aef17d99af0e0bf1ee1b0)\n\n结束了家中热闹的腊月，提早返回校中，好好为今年做一番规划。\n\n俗话说得好：一年之计在于春。\n\n今年两件事：\n\n1. 毕业\n2. 步入职场\n\n## 毕业\n关于毕业之事此不多言，已尽最大努力，后望一切顺利。\n\n## 职业\n对于职业能力方面，下面几点是今年的重点：\n\n#### Android技术\n1. 公司。作为一家创业公司的Android developer，今年会花大量的时间在工作中不断提高自己的android技术水平。\n\n2. 研究。工作中的技术学习一般都是任务驱动型，即以解决实际问题为最终目标，这种做法的缺陷是很多时候难以对某个问题进行深入研究。所以，之后要加强这方面的研究，即在工作中解决实际问题后应抽时间来进行细细研究，整理入博客中。\n\n3. 开源。开源项目要保持下去。记录工作中自己开发的不错的组件等积极开源，并多多维护。\n\n4. 翻译。多翻译国外优秀文章，一方面扩展视野，另一方面提高英语。\n\n#### 机器学习\n作为一门互联网职业人员，我显然明白技术的日新月异和更新换代实属必然。\n所以，在夯实Android技术之外，还应该抽出时间来学习其它技术。此处本人选择机器学习作为一个方向来充实自己，准备通过对google提供的在线课程和TensorFlow工具进行较为深入的学习。\n\n[Udacity TensorFlow by Google](udacity.com/course/deep-learning--ud730)\n[Udacity博客](blog.udacity.com/2016/01/putting-deep-learning-to-work.html)\n\n#### 设计与艺术\n无论是为了产品开发或个人审美，都值得花时间提高自己的设计艺术方面的嗅觉与敏感度。\n另外，将设计与技术结合起来，更不失为一件妙事。\n这一步主要通过阅读书籍，浏览设计网站与app来感知。\n\n这里有一些不错的资源：\n[Processing资源](http://mp.weixin.qq.com/s?__biz=MzA5OTgyMDk3Mg==&mid=402850288&idx=1&sn=9bd2856a17128c857d2b864293d0f94d&scene=23&srcid=0216rQN75xcQeFJPiNvNHdin#rd)\n\n#### 英语\n这个就不多提了，无论阅读还是口语都需要提高！\n\n上面这四点，是今年的核心。每一点都还需要细化并渗入到以后的工作学习中，争取有实质性提高。\n\n## 生活\n一个不懂的享受生活的人是悲哀的，因为他会丧失很多的幸福感。\n因此，后面我会开始注重培养自己的爱好，参加一些有意思的活动，结交一些有想法的朋友。\n\n#### 体育\n篮球羽毛球爬山户外，都是我喜欢的，希望以后在周末多抽空参与相关活动。\n平日里可以参与跑步、健身等活动。\n\n只有拥有强健体魄才能更加乐观，更加懂得感悟生活的美。\n\n#### 健康饮食\n一方面注重营养均衡，不要像以前只为好吃。（当然，好吃还是很重要哒）\n另一方面要适量，保持好的体型，拒绝肥胖。\n\n## 阅读\n下面是今年要读书籍的大类，具体还待更新：\n\n1. 技术：Android、机器学习\n2. 艺术设计\n[Nature of Code online](http://natureofcode.com/book/introduction/)\n3. 历史\n\n\n\n\n","source":"_posts/今年之计.md","raw":"title: 今年之计\ndate: 2016-02-19 16:39:37\ncategories:\n  - 年度计划\ntags: \n\t- 学习计划\ncommentIssueId: \t\n---\n> 2016年我的计划\n\n<!-- more -->\n\n![今年之计](https://drscdn.500px.org/photo/40352952/q%3D80_m%3D2000/b8ea73af7f5aef17d99af0e0bf1ee1b0)\n\n结束了家中热闹的腊月，提早返回校中，好好为今年做一番规划。\n\n俗话说得好：一年之计在于春。\n\n今年两件事：\n\n1. 毕业\n2. 步入职场\n\n## 毕业\n关于毕业之事此不多言，已尽最大努力，后望一切顺利。\n\n## 职业\n对于职业能力方面，下面几点是今年的重点：\n\n#### Android技术\n1. 公司。作为一家创业公司的Android developer，今年会花大量的时间在工作中不断提高自己的android技术水平。\n\n2. 研究。工作中的技术学习一般都是任务驱动型，即以解决实际问题为最终目标，这种做法的缺陷是很多时候难以对某个问题进行深入研究。所以，之后要加强这方面的研究，即在工作中解决实际问题后应抽时间来进行细细研究，整理入博客中。\n\n3. 开源。开源项目要保持下去。记录工作中自己开发的不错的组件等积极开源，并多多维护。\n\n4. 翻译。多翻译国外优秀文章，一方面扩展视野，另一方面提高英语。\n\n#### 机器学习\n作为一门互联网职业人员，我显然明白技术的日新月异和更新换代实属必然。\n所以，在夯实Android技术之外，还应该抽出时间来学习其它技术。此处本人选择机器学习作为一个方向来充实自己，准备通过对google提供的在线课程和TensorFlow工具进行较为深入的学习。\n\n[Udacity TensorFlow by Google](udacity.com/course/deep-learning--ud730)\n[Udacity博客](blog.udacity.com/2016/01/putting-deep-learning-to-work.html)\n\n#### 设计与艺术\n无论是为了产品开发或个人审美，都值得花时间提高自己的设计艺术方面的嗅觉与敏感度。\n另外，将设计与技术结合起来，更不失为一件妙事。\n这一步主要通过阅读书籍，浏览设计网站与app来感知。\n\n这里有一些不错的资源：\n[Processing资源](http://mp.weixin.qq.com/s?__biz=MzA5OTgyMDk3Mg==&mid=402850288&idx=1&sn=9bd2856a17128c857d2b864293d0f94d&scene=23&srcid=0216rQN75xcQeFJPiNvNHdin#rd)\n\n#### 英语\n这个就不多提了，无论阅读还是口语都需要提高！\n\n上面这四点，是今年的核心。每一点都还需要细化并渗入到以后的工作学习中，争取有实质性提高。\n\n## 生活\n一个不懂的享受生活的人是悲哀的，因为他会丧失很多的幸福感。\n因此，后面我会开始注重培养自己的爱好，参加一些有意思的活动，结交一些有想法的朋友。\n\n#### 体育\n篮球羽毛球爬山户外，都是我喜欢的，希望以后在周末多抽空参与相关活动。\n平日里可以参与跑步、健身等活动。\n\n只有拥有强健体魄才能更加乐观，更加懂得感悟生活的美。\n\n#### 健康饮食\n一方面注重营养均衡，不要像以前只为好吃。（当然，好吃还是很重要哒）\n另一方面要适量，保持好的体型，拒绝肥胖。\n\n## 阅读\n下面是今年要读书籍的大类，具体还待更新：\n\n1. 技术：Android、机器学习\n2. 艺术设计\n[Nature of Code online](http://natureofcode.com/book/introduction/)\n3. 历史\n\n\n\n\n","slug":"今年之计","published":1,"updated":"2018-11-26T06:56:27.483Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplsgs000h3dn8mmkfszoo","content":"<blockquote>\n<p>2016 年我的计划</p>\n</blockquote>\n<a id=\"more\"></a>\n<p><img src=\"https://drscdn.500px.org/photo/40352952/q%3D80_m%3D2000/b8ea73af7f5aef17d99af0e0bf1ee1b0\" alt=\"今年之计\"></p>\n<p>结束了家中热闹的腊月，提早返回校中，好好为今年做一番规划。</p>\n<p>俗话说得好：一年之计在于春。</p>\n<p>今年两件事：</p>\n<ol>\n<li>毕业</li>\n<li>步入职场</li>\n</ol>\n<h2 id=\"毕业\"><a href=\"# 毕业\" class=\"headerlink\" title=\"毕业\"></a>毕业 </h2><p> 关于毕业之事此不多言，已尽最大努力，后望一切顺利。</p>\n<h2 id=\"职业\"><a href=\"# 职业\" class=\"headerlink\" title=\"职业\"></a>职业 </h2><p> 对于职业能力方面，下面几点是今年的重点：</p>\n<h4 id=\"Android 技术\"><a href=\"#Android 技术\" class=\"headerlink\" title=\"Android 技术\"></a>Android 技术</h4><ol>\n<li><p>公司。作为一家创业公司的 Android developer，今年会花大量的时间在工作中不断提高自己的 android 技术水平。</p>\n</li>\n<li><p>研究。工作中的技术学习一般都是任务驱动型，即以解决实际问题为最终目标，这种做法的缺陷是很多时候难以对某个问题进行深入研究。所以，之后要加强这方面的研究，即在工作中解决实际问题后应抽时间来进行细细研究，整理入博客中。</p>\n</li>\n<li><p>开源。开源项目要保持下去。记录工作中自己开发的不错的组件等积极开源，并多多维护。</p>\n</li>\n<li><p>翻译。多翻译国外优秀文章，一方面扩展视野，另一方面提高英语。</p>\n</li>\n</ol>\n<h4 id=\"机器学习\"><a href=\"# 机器学习\" class=\"headerlink\" title=\"机器学习\"></a>机器学习 </h4><p> 作为一门互联网职业人员，我显然明白技术的日新月异和更新换代实属必然。<br>所以，在夯实 Android 技术之外，还应该抽出时间来学习其它技术。此处本人选择机器学习作为一个方向来充实自己，准备通过对 google 提供的在线课程和 TensorFlow 工具进行较为深入的学习。</p>\n<p><a href=\"udacity.com/course/deep-learning--ud730\">Udacity TensorFlow by Google</a><br><a href=\"blog.udacity.com/2016/01/putting-deep-learning-to-work.html\">Udacity 博客</a></p>\n<h4 id=\"设计与艺术\"><a href=\"# 设计与艺术\" class=\"headerlink\" title=\"设计与艺术\"></a>设计与艺术 </h4><p> 无论是为了产品开发或个人审美，都值得花时间提高自己的设计艺术方面的嗅觉与敏感度。<br>另外，将设计与技术结合起来，更不失为一件妙事。<br>这一步主要通过阅读书籍，浏览设计网站与 app 来感知。</p>\n<p>这里有一些不错的资源：<br><a href=\"http://mp.weixin.qq.com/s?__biz=MzA5OTgyMDk3Mg==&amp;mid=402850288&amp;idx=1&amp;sn=9bd2856a17128c857d2b864293d0f94d&amp;scene=23&amp;srcid=0216rQN75xcQeFJPiNvNHdin#rd\" target=\"_blank\" rel=\"external\">Processing 资源</a></p>\n<h4 id=\"英语\"><a href=\"# 英语\" class=\"headerlink\" title=\"英语\"></a>英语 </h4><p> 这个就不多提了，无论阅读还是口语都需要提高！</p>\n<p>上面这四点，是今年的核心。每一点都还需要细化并渗入到以后的工作学习中，争取有实质性提高。</p>\n<h2 id=\"生活\"><a href=\"# 生活\" class=\"headerlink\" title=\"生活\"></a>生活 </h2><p> 一个不懂的享受生活的人是悲哀的，因为他会丧失很多的幸福感。<br>因此，后面我会开始注重培养自己的爱好，参加一些有意思的活动，结交一些有想法的朋友。</p>\n<h4 id=\"体育\"><a href=\"# 体育\" class=\"headerlink\" title=\"体育\"></a>体育 </h4><p> 篮球羽毛球爬山户外，都是我喜欢的，希望以后在周末多抽空参与相关活动。<br>平日里可以参与跑步、健身等活动。</p>\n<p>只有拥有强健体魄才能更加乐观，更加懂得感悟生活的美。</p>\n<h4 id=\"健康饮食\"><a href=\"# 健康饮食\" class=\"headerlink\" title=\"健康饮食\"></a>健康饮食 </h4><p> 一方面注重营养均衡，不要像以前只为好吃。（当然，好吃还是很重要哒）<br>另一方面要适量，保持好的体型，拒绝肥胖。</p>\n<h2 id=\"阅读\"><a href=\"# 阅读\" class=\"headerlink\" title=\"阅读\"></a>阅读 </h2><p> 下面是今年要读书籍的大类，具体还待更新：</p>\n<ol>\n<li>技术：Android、机器学习</li>\n<li>艺术设计<br><a href=\"http://natureofcode.com/book/introduction/\" target=\"_blank\" rel=\"external\">Nature of Code online</a></li>\n<li>历史</li>\n</ol>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>2016年我的计划</p>\n</blockquote>","more":"<p><img src=\"https://drscdn.500px.org/photo/40352952/q%3D80_m%3D2000/b8ea73af7f5aef17d99af0e0bf1ee1b0\" alt=\"今年之计\"></p>\n<p>结束了家中热闹的腊月，提早返回校中，好好为今年做一番规划。</p>\n<p>俗话说得好：一年之计在于春。</p>\n<p>今年两件事：</p>\n<ol>\n<li>毕业</li>\n<li>步入职场</li>\n</ol>\n<h2 id=\"毕业\"><a href=\"#毕业\" class=\"headerlink\" title=\"毕业\"></a>毕业</h2><p>关于毕业之事此不多言，已尽最大努力，后望一切顺利。</p>\n<h2 id=\"职业\"><a href=\"#职业\" class=\"headerlink\" title=\"职业\"></a>职业</h2><p>对于职业能力方面，下面几点是今年的重点：</p>\n<h4 id=\"Android技术\"><a href=\"#Android技术\" class=\"headerlink\" title=\"Android技术\"></a>Android技术</h4><ol>\n<li><p>公司。作为一家创业公司的Android developer，今年会花大量的时间在工作中不断提高自己的android技术水平。</p>\n</li>\n<li><p>研究。工作中的技术学习一般都是任务驱动型，即以解决实际问题为最终目标，这种做法的缺陷是很多时候难以对某个问题进行深入研究。所以，之后要加强这方面的研究，即在工作中解决实际问题后应抽时间来进行细细研究，整理入博客中。</p>\n</li>\n<li><p>开源。开源项目要保持下去。记录工作中自己开发的不错的组件等积极开源，并多多维护。</p>\n</li>\n<li><p>翻译。多翻译国外优秀文章，一方面扩展视野，另一方面提高英语。</p>\n</li>\n</ol>\n<h4 id=\"机器学习\"><a href=\"#机器学习\" class=\"headerlink\" title=\"机器学习\"></a>机器学习</h4><p>作为一门互联网职业人员，我显然明白技术的日新月异和更新换代实属必然。<br>所以，在夯实Android技术之外，还应该抽出时间来学习其它技术。此处本人选择机器学习作为一个方向来充实自己，准备通过对google提供的在线课程和TensorFlow工具进行较为深入的学习。</p>\n<p><a href=\"udacity.com/course/deep-learning--ud730\">Udacity TensorFlow by Google</a><br><a href=\"blog.udacity.com/2016/01/putting-deep-learning-to-work.html\">Udacity博客</a></p>\n<h4 id=\"设计与艺术\"><a href=\"#设计与艺术\" class=\"headerlink\" title=\"设计与艺术\"></a>设计与艺术</h4><p>无论是为了产品开发或个人审美，都值得花时间提高自己的设计艺术方面的嗅觉与敏感度。<br>另外，将设计与技术结合起来，更不失为一件妙事。<br>这一步主要通过阅读书籍，浏览设计网站与app来感知。</p>\n<p>这里有一些不错的资源：<br><a href=\"http://mp.weixin.qq.com/s?__biz=MzA5OTgyMDk3Mg==&amp;mid=402850288&amp;idx=1&amp;sn=9bd2856a17128c857d2b864293d0f94d&amp;scene=23&amp;srcid=0216rQN75xcQeFJPiNvNHdin#rd\" target=\"_blank\" rel=\"external\">Processing资源</a></p>\n<h4 id=\"英语\"><a href=\"#英语\" class=\"headerlink\" title=\"英语\"></a>英语</h4><p>这个就不多提了，无论阅读还是口语都需要提高！</p>\n<p>上面这四点，是今年的核心。每一点都还需要细化并渗入到以后的工作学习中，争取有实质性提高。</p>\n<h2 id=\"生活\"><a href=\"#生活\" class=\"headerlink\" title=\"生活\"></a>生活</h2><p>一个不懂的享受生活的人是悲哀的，因为他会丧失很多的幸福感。<br>因此，后面我会开始注重培养自己的爱好，参加一些有意思的活动，结交一些有想法的朋友。</p>\n<h4 id=\"体育\"><a href=\"#体育\" class=\"headerlink\" title=\"体育\"></a>体育</h4><p>篮球羽毛球爬山户外，都是我喜欢的，希望以后在周末多抽空参与相关活动。<br>平日里可以参与跑步、健身等活动。</p>\n<p>只有拥有强健体魄才能更加乐观，更加懂得感悟生活的美。</p>\n<h4 id=\"健康饮食\"><a href=\"#健康饮食\" class=\"headerlink\" title=\"健康饮食\"></a>健康饮食</h4><p>一方面注重营养均衡，不要像以前只为好吃。（当然，好吃还是很重要哒）<br>另一方面要适量，保持好的体型，拒绝肥胖。</p>\n<h2 id=\"阅读\"><a href=\"#阅读\" class=\"headerlink\" title=\"阅读\"></a>阅读</h2><p>下面是今年要读书籍的大类，具体还待更新：</p>\n<ol>\n<li>技术：Android、机器学习</li>\n<li>艺术设计<br><a href=\"http://natureofcode.com/book/introduction/\" target=\"_blank\" rel=\"external\">Nature of Code online</a></li>\n<li>历史</li>\n</ol>","sticky":0},{"title":"今年之计－2017","date":"2017-02-05T14:17:23.000Z","commentIssueId":null,"_content":"> 2017年我的计划\n\n<!-- more -->\n\n按照习惯，每一年开初都要回顾过去，制定新一年的计划。\n\n## 回顾 2016\n2016年是我的一个大年，完成了毕业和入职的交替，从学生到职场人员。\n\n下面对 16 年提出的各个计划给个小结：\n\n#### 毕业\n虽然有惊有险，比较艰难，但最终还是顺利毕业，并把户口落在了魔都。\n\n#### Android技术\n公司：个人感觉对现有的 Android 技术还算熟练，在日常开发中也没有遇到很大困难和挑战，也对一些少见的 bug 有了一定的经验，并对性能优化有了更多的认识。\n\n研究：业余时间写了三篇开源项目分析的文章。有点少，新的一年要做更多技术方面的深入研究，比如分析 Android 系统某些机制的源码；分析优质开源项目的源码。\n\n开源：去年完成了全端的 简诗 v2.0 开发，https://github.com/wingjay/jianshi，目前有 1.4k 左右的 star。对于 Android 和服务器开发有了一个较为全面的认识吧。\n\n翻译：16年底重新维护了我的个人公众号：大公司技术博客。主要对一些大公司优质的官方技术博客或者 Medium 上的好文章进行翻译推送。目前已经推送了 6 篇翻译文章。\n\n#### 机器学习\n这一方面没有做很多工作，主要是因为其入门的门槛较高，而自己又没有找到一个合理的进入方式开始学习。\n\n#### 设计与艺术\n有适当阅读一些文章，浏览一些艺术设计来提高下自己这方面的修养。不过，并未投入足够的时间。\n\n#### 英语\n英语阅读：在平常搜索问题时以英文搜索为主，而且持续不断阅读英文技术文章、翻译等等，现在基本能达到不错阅读理解水平。\n\n口语：去年报名了在线口语提高班，进行了一个月左右的课程，口语方面虽没有很大飞跃，不过现在对常用句型基本上比较熟练了。而且，2017年还会继续口语课程。\n\n#### 生活\n这一点做的不够。\n\n去年和同事开玩笑说，我是个没有生活的人。没有合理利用自己的空闲时间，如周末偶尔会做做饭，其他时候就是看看剧打打游戏，并没有很好的去感受生活。\n\n#### 体育\n一年里除了偶尔打打羽毛球，非常缺乏体育锻炼。去年年底时去办了张一年的健身卡，目前已经持续了一个月左右的健身，平均两天一次健身：半小时跑步 ＋ 半小时无氧运行。\n\n#### 健康饮食\n由于整日坐着工作，颈椎有点毛病，而且出现了肥胖的问题，身体脂肪含量高，肌肉比例偏低。采取的措施是不吃太饱 ＋ 不吃夜宵。\n\n#### 阅读\n基本没有深入读什么书籍，不够。\n\n\n## 计划 2017\n下面对 2017 做一些计划。\n\n#### 技术\n1. Java + Android研究基础。基础知识是自己的弱项，必须对 Java 和 Android 很多基础的理论进行深入的学习了解，不要只会只用 API。\n\n2. 前沿进展。了解 Android 的最新的技术，作为一名 Android 工程师，必须对 Android 最新的技术保持实时更新了解。\n\n3. AI学习。在人工智能方面可以通过阅读文章、上在线课程来进行入门。\n\n#### 开源\n对 简诗 可以再做一些新的功能，尝试一些 Android 和 服务器开发的不同的技术点，拓宽自己的技术视野。\n\n#### 公众号\n继续保持 两日一更 的节奏，可以去阅读 Medium 上的文章，Hacker News 或者 Reddit 上的讨论，各大公司的新技术文章进行阅读翻译并推送。争取一年内达到上万读者。\n\n#### 理财、金融阅读学习\n对理财和金融方面进行了解学习，自己开始理财，学习基本的金融知识。\n\n除了技术方面，今年主要要多读一些经济金融方面的书籍。了解整个社会的经济是如何发展的。\n\n#### 个人盈利\n争取把我的业余工作转化出一定的收益。比如持续去维护简诗的开发、公众号的文章推送，如果能在做这些事情的时候得到一些金钱方面的回报，就能良性地提高我的内驱动力。这样才是一个理性的业余工作方式，毕竟一味的对外输出总是容易丧失动力。\n\n盈利方案：\n\n1. 简诗 首先要继续提高新用户数和用户留存，把简诗做成世界上最干净最好用的竖排古典写作工具。然后，通过提供一些付费功能如自定义印章等，或者定制简诗风格的笔记本来进行盈利。\n\n2. 公众号 方面，先尽可能吸引聚集较多的高质量读者，对国外技术、新闻、讨论感兴趣的一批人，然后再提供一些其它的推送服务给他们。\n\n#### 生活：旅游 ＋ 体育健身 ＋ 饮食 ＋ 早起\n1. 旅游\n今年，我要至少旅游国内五座城市。要了解城市的历史，整座城市的规划，城市的经济发展方式，这座城市人民特有的民风文化。每次旅行要做好足够的准备，去有意义的地方，旅行后要有一篇文章记录。\n\n2. 体育健身\n尽可能保持每周至少 三 次健身，改善自己的脂肪和肌肉的比例，必须要恢复到正常状态。 \n\n3. 饮食\n不要花太多时间在吃方面，只要吃饱、吃健康就行，不要花太多时间在好吃的食物上。\n\n4. 早起\n为了提高阅读量，我可以每天早起一个小时来阅读文章或者金融书籍。扩充知识面，同时可以维护好公众号。\n\n#### 驾照\n如果今年时间足够，可以去考虑报名参加上海这里的驾照考试。\n\n以上是 2017 年大体的计划，之后还要进行更加详细的规划，可以参考定制自己的季度目标和每月目标来进行督促。\n\n\n\n","source":"_posts/今年之计－2017.md","raw":"title: 今年之计－2017\ndate: 2017-02-05 22:17:23\ncategories:\n  - 年度计划\ntags:\ncommentIssueId: \n---\n> 2017年我的计划\n\n<!-- more -->\n\n按照习惯，每一年开初都要回顾过去，制定新一年的计划。\n\n## 回顾 2016\n2016年是我的一个大年，完成了毕业和入职的交替，从学生到职场人员。\n\n下面对 16 年提出的各个计划给个小结：\n\n#### 毕业\n虽然有惊有险，比较艰难，但最终还是顺利毕业，并把户口落在了魔都。\n\n#### Android技术\n公司：个人感觉对现有的 Android 技术还算熟练，在日常开发中也没有遇到很大困难和挑战，也对一些少见的 bug 有了一定的经验，并对性能优化有了更多的认识。\n\n研究：业余时间写了三篇开源项目分析的文章。有点少，新的一年要做更多技术方面的深入研究，比如分析 Android 系统某些机制的源码；分析优质开源项目的源码。\n\n开源：去年完成了全端的 简诗 v2.0 开发，https://github.com/wingjay/jianshi，目前有 1.4k 左右的 star。对于 Android 和服务器开发有了一个较为全面的认识吧。\n\n翻译：16年底重新维护了我的个人公众号：大公司技术博客。主要对一些大公司优质的官方技术博客或者 Medium 上的好文章进行翻译推送。目前已经推送了 6 篇翻译文章。\n\n#### 机器学习\n这一方面没有做很多工作，主要是因为其入门的门槛较高，而自己又没有找到一个合理的进入方式开始学习。\n\n#### 设计与艺术\n有适当阅读一些文章，浏览一些艺术设计来提高下自己这方面的修养。不过，并未投入足够的时间。\n\n#### 英语\n英语阅读：在平常搜索问题时以英文搜索为主，而且持续不断阅读英文技术文章、翻译等等，现在基本能达到不错阅读理解水平。\n\n口语：去年报名了在线口语提高班，进行了一个月左右的课程，口语方面虽没有很大飞跃，不过现在对常用句型基本上比较熟练了。而且，2017年还会继续口语课程。\n\n#### 生活\n这一点做的不够。\n\n去年和同事开玩笑说，我是个没有生活的人。没有合理利用自己的空闲时间，如周末偶尔会做做饭，其他时候就是看看剧打打游戏，并没有很好的去感受生活。\n\n#### 体育\n一年里除了偶尔打打羽毛球，非常缺乏体育锻炼。去年年底时去办了张一年的健身卡，目前已经持续了一个月左右的健身，平均两天一次健身：半小时跑步 ＋ 半小时无氧运行。\n\n#### 健康饮食\n由于整日坐着工作，颈椎有点毛病，而且出现了肥胖的问题，身体脂肪含量高，肌肉比例偏低。采取的措施是不吃太饱 ＋ 不吃夜宵。\n\n#### 阅读\n基本没有深入读什么书籍，不够。\n\n\n## 计划 2017\n下面对 2017 做一些计划。\n\n#### 技术\n1. Java + Android研究基础。基础知识是自己的弱项，必须对 Java 和 Android 很多基础的理论进行深入的学习了解，不要只会只用 API。\n\n2. 前沿进展。了解 Android 的最新的技术，作为一名 Android 工程师，必须对 Android 最新的技术保持实时更新了解。\n\n3. AI学习。在人工智能方面可以通过阅读文章、上在线课程来进行入门。\n\n#### 开源\n对 简诗 可以再做一些新的功能，尝试一些 Android 和 服务器开发的不同的技术点，拓宽自己的技术视野。\n\n#### 公众号\n继续保持 两日一更 的节奏，可以去阅读 Medium 上的文章，Hacker News 或者 Reddit 上的讨论，各大公司的新技术文章进行阅读翻译并推送。争取一年内达到上万读者。\n\n#### 理财、金融阅读学习\n对理财和金融方面进行了解学习，自己开始理财，学习基本的金融知识。\n\n除了技术方面，今年主要要多读一些经济金融方面的书籍。了解整个社会的经济是如何发展的。\n\n#### 个人盈利\n争取把我的业余工作转化出一定的收益。比如持续去维护简诗的开发、公众号的文章推送，如果能在做这些事情的时候得到一些金钱方面的回报，就能良性地提高我的内驱动力。这样才是一个理性的业余工作方式，毕竟一味的对外输出总是容易丧失动力。\n\n盈利方案：\n\n1. 简诗 首先要继续提高新用户数和用户留存，把简诗做成世界上最干净最好用的竖排古典写作工具。然后，通过提供一些付费功能如自定义印章等，或者定制简诗风格的笔记本来进行盈利。\n\n2. 公众号 方面，先尽可能吸引聚集较多的高质量读者，对国外技术、新闻、讨论感兴趣的一批人，然后再提供一些其它的推送服务给他们。\n\n#### 生活：旅游 ＋ 体育健身 ＋ 饮食 ＋ 早起\n1. 旅游\n今年，我要至少旅游国内五座城市。要了解城市的历史，整座城市的规划，城市的经济发展方式，这座城市人民特有的民风文化。每次旅行要做好足够的准备，去有意义的地方，旅行后要有一篇文章记录。\n\n2. 体育健身\n尽可能保持每周至少 三 次健身，改善自己的脂肪和肌肉的比例，必须要恢复到正常状态。 \n\n3. 饮食\n不要花太多时间在吃方面，只要吃饱、吃健康就行，不要花太多时间在好吃的食物上。\n\n4. 早起\n为了提高阅读量，我可以每天早起一个小时来阅读文章或者金融书籍。扩充知识面，同时可以维护好公众号。\n\n#### 驾照\n如果今年时间足够，可以去考虑报名参加上海这里的驾照考试。\n\n以上是 2017 年大体的计划，之后还要进行更加详细的规划，可以参考定制自己的季度目标和每月目标来进行督促。\n\n\n\n","slug":"今年之计－2017","published":1,"updated":"2018-11-26T06:56:27.483Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplsgt000k3dn89w7fx7pp","content":"<blockquote>\n<p>2017 年我的计划</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>按照习惯，每一年开初都要回顾过去，制定新一年的计划。</p>\n<h2 id=\"回顾 -2016\"><a href=\"# 回顾 -2016\" class=\"headerlink\" title=\"回顾 2016\"></a>回顾 2016</h2><p>2016 年是我的一个大年，完成了毕业和入职的交替，从学生到职场人员。</p>\n<p>下面对 16 年提出的各个计划给个小结：</p>\n<h4 id=\"毕业\"><a href=\"# 毕业\" class=\"headerlink\" title=\"毕业\"></a>毕业 </h4><p> 虽然有惊有险，比较艰难，但最终还是顺利毕业，并把户口落在了魔都。</p>\n<h4 id=\"Android 技术\"><a href=\"#Android 技术\" class=\"headerlink\" title=\"Android 技术\"></a>Android 技术 </h4><p> 公司：个人感觉对现有的 Android 技术还算熟练，在日常开发中也没有遇到很大困难和挑战，也对一些少见的 bug 有了一定的经验，并对性能优化有了更多的认识。</p>\n<p>研究：业余时间写了三篇开源项目分析的文章。有点少，新的一年要做更多技术方面的深入研究，比如分析 Android 系统某些机制的源码；分析优质开源项目的源码。</p>\n<p>开源：去年完成了全端的 简诗 v2.0 开发，<a href=\"https://github.com/wingjay/jianshi，目前有\" target=\"_blank\" rel=\"external\">https://github.com/wingjay/jianshi，目前有</a> 1.4k 左右的 star。对于 Android 和服务器开发有了一个较为全面的认识吧。</p>\n<p>翻译：16 年底重新维护了我的个人公众号：大公司技术博客。主要对一些大公司优质的官方技术博客或者 Medium 上的好文章进行翻译推送。目前已经推送了 6 篇翻译文章。</p>\n<h4 id=\"机器学习\"><a href=\"# 机器学习\" class=\"headerlink\" title=\"机器学习\"></a>机器学习 </h4><p> 这一方面没有做很多工作，主要是因为其入门的门槛较高，而自己又没有找到一个合理的进入方式开始学习。</p>\n<h4 id=\"设计与艺术\"><a href=\"# 设计与艺术\" class=\"headerlink\" title=\"设计与艺术\"></a>设计与艺术 </h4><p> 有适当阅读一些文章，浏览一些艺术设计来提高下自己这方面的修养。不过，并未投入足够的时间。</p>\n<h4 id=\"英语\"><a href=\"# 英语\" class=\"headerlink\" title=\"英语\"></a>英语 </h4><p> 英语阅读：在平常搜索问题时以英文搜索为主，而且持续不断阅读英文技术文章、翻译等等，现在基本能达到不错阅读理解水平。</p>\n<p>口语：去年报名了在线口语提高班，进行了一个月左右的课程，口语方面虽没有很大飞跃，不过现在对常用句型基本上比较熟练了。而且，2017 年还会继续口语课程。</p>\n<h4 id=\"生活\"><a href=\"# 生活\" class=\"headerlink\" title=\"生活\"></a>生活 </h4><p> 这一点做的不够。</p>\n<p>去年和同事开玩笑说，我是个没有生活的人。没有合理利用自己的空闲时间，如周末偶尔会做做饭，其他时候就是看看剧打打游戏，并没有很好的去感受生活。</p>\n<h4 id=\"体育\"><a href=\"# 体育\" class=\"headerlink\" title=\"体育\"></a>体育 </h4><p> 一年里除了偶尔打打羽毛球，非常缺乏体育锻炼。去年年底时去办了张一年的健身卡，目前已经持续了一个月左右的健身，平均两天一次健身：半小时跑步 ＋ 半小时无氧运行。</p>\n<h4 id=\"健康饮食\"><a href=\"# 健康饮食\" class=\"headerlink\" title=\"健康饮食\"></a>健康饮食 </h4><p> 由于整日坐着工作，颈椎有点毛病，而且出现了肥胖的问题，身体脂肪含量高，肌肉比例偏低。采取的措施是不吃太饱 ＋ 不吃夜宵。</p>\n<h4 id=\"阅读\"><a href=\"# 阅读\" class=\"headerlink\" title=\"阅读\"></a>阅读 </h4><p> 基本没有深入读什么书籍，不够。</p>\n<h2 id=\"计划 -2017\"><a href=\"# 计划 -2017\" class=\"headerlink\" title=\"计划 2017\"></a>计划 2017</h2><p>下面对 2017 做一些计划。</p>\n<h4 id=\"技术\"><a href=\"# 技术\" class=\"headerlink\" title=\"技术\"></a>技术</h4><ol>\n<li><p>Java + Android 研究基础。基础知识是自己的弱项，必须对 Java 和 Android 很多基础的理论进行深入的学习了解，不要只会只用 API。</p>\n</li>\n<li><p>前沿进展。了解 Android 的最新的技术，作为一名 Android 工程师，必须对 Android 最新的技术保持实时更新了解。</p>\n</li>\n<li><p>AI 学习。在人工智能方面可以通过阅读文章、上在线课程来进行入门。</p>\n</li>\n</ol>\n<h4 id=\"开源\"><a href=\"# 开源\" class=\"headerlink\" title=\"开源\"></a>开源 </h4><p> 对 简诗 可以再做一些新的功能，尝试一些 Android 和 服务器开发的不同的技术点，拓宽自己的技术视野。</p>\n<h4 id=\"公众号\"><a href=\"# 公众号\" class=\"headerlink\" title=\"公众号\"></a>公众号 </h4><p> 继续保持 两日一更 的节奏，可以去阅读 Medium 上的文章，Hacker News 或者 Reddit 上的讨论，各大公司的新技术文章进行阅读翻译并推送。争取一年内达到上万读者。</p>\n<h4 id=\"理财、金融阅读学习\"><a href=\"# 理财、金融阅读学习\" class=\"headerlink\" title=\"理财、金融阅读学习\"></a>理财、金融阅读学习 </h4><p> 对理财和金融方面进行了解学习，自己开始理财，学习基本的金融知识。</p>\n<p>除了技术方面，今年主要要多读一些经济金融方面的书籍。了解整个社会的经济是如何发展的。</p>\n<h4 id=\"个人盈利\"><a href=\"# 个人盈利\" class=\"headerlink\" title=\"个人盈利\"></a>个人盈利 </h4><p> 争取把我的业余工作转化出一定的收益。比如持续去维护简诗的开发、公众号的文章推送，如果能在做这些事情的时候得到一些金钱方面的回报，就能良性地提高我的内驱动力。这样才是一个理性的业余工作方式，毕竟一味的对外输出总是容易丧失动力。</p>\n<p>盈利方案：</p>\n<ol>\n<li><p>简诗 首先要继续提高新用户数和用户留存，把简诗做成世界上最干净最好用的竖排古典写作工具。然后，通过提供一些付费功能如自定义印章等，或者定制简诗风格的笔记本来进行盈利。</p>\n</li>\n<li><p>公众号 方面，先尽可能吸引聚集较多的高质量读者，对国外技术、新闻、讨论感兴趣的一批人，然后再提供一些其它的推送服务给他们。</p>\n</li>\n</ol>\n<h4 id=\"生活：旅游 -＋- 体育健身 -＋- 饮食 -＋- 早起\"><a href=\"# 生活：旅游 -＋- 体育健身 -＋- 饮食 -＋- 早起\" class=\"headerlink\" title=\"生活：旅游 ＋ 体育健身 ＋ 饮食 ＋ 早起\"></a>生活：旅游 ＋ 体育健身 ＋ 饮食 ＋ 早起</h4><ol>\n<li><p>旅游 <br> 今年，我要至少旅游国内五座城市。要了解城市的历史，整座城市的规划，城市的经济发展方式，这座城市人民特有的民风文化。每次旅行要做好足够的准备，去有意义的地方，旅行后要有一篇文章记录。</p>\n</li>\n<li><p>体育健身 <br> 尽可能保持每周至少 三 次健身，改善自己的脂肪和肌肉的比例，必须要恢复到正常状态。 </p>\n</li>\n<li><p>饮食 <br> 不要花太多时间在吃方面，只要吃饱、吃健康就行，不要花太多时间在好吃的食物上。</p>\n</li>\n<li><p>早起 <br> 为了提高阅读量，我可以每天早起一个小时来阅读文章或者金融书籍。扩充知识面，同时可以维护好公众号。</p>\n</li>\n</ol>\n<h4 id=\"驾照\"><a href=\"# 驾照\" class=\"headerlink\" title=\"驾照\"></a>驾照 </h4><p> 如果今年时间足够，可以去考虑报名参加上海这里的驾照考试。</p>\n<p>以上是 2017 年大体的计划，之后还要进行更加详细的规划，可以参考定制自己的季度目标和每月目标来进行督促。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>2017年我的计划</p>\n</blockquote>","more":"<p>按照习惯，每一年开初都要回顾过去，制定新一年的计划。</p>\n<h2 id=\"回顾-2016\"><a href=\"#回顾-2016\" class=\"headerlink\" title=\"回顾 2016\"></a>回顾 2016</h2><p>2016年是我的一个大年，完成了毕业和入职的交替，从学生到职场人员。</p>\n<p>下面对 16 年提出的各个计划给个小结：</p>\n<h4 id=\"毕业\"><a href=\"#毕业\" class=\"headerlink\" title=\"毕业\"></a>毕业</h4><p>虽然有惊有险，比较艰难，但最终还是顺利毕业，并把户口落在了魔都。</p>\n<h4 id=\"Android技术\"><a href=\"#Android技术\" class=\"headerlink\" title=\"Android技术\"></a>Android技术</h4><p>公司：个人感觉对现有的 Android 技术还算熟练，在日常开发中也没有遇到很大困难和挑战，也对一些少见的 bug 有了一定的经验，并对性能优化有了更多的认识。</p>\n<p>研究：业余时间写了三篇开源项目分析的文章。有点少，新的一年要做更多技术方面的深入研究，比如分析 Android 系统某些机制的源码；分析优质开源项目的源码。</p>\n<p>开源：去年完成了全端的 简诗 v2.0 开发，<a href=\"https://github.com/wingjay/jianshi，目前有\" target=\"_blank\" rel=\"external\">https://github.com/wingjay/jianshi，目前有</a> 1.4k 左右的 star。对于 Android 和服务器开发有了一个较为全面的认识吧。</p>\n<p>翻译：16年底重新维护了我的个人公众号：大公司技术博客。主要对一些大公司优质的官方技术博客或者 Medium 上的好文章进行翻译推送。目前已经推送了 6 篇翻译文章。</p>\n<h4 id=\"机器学习\"><a href=\"#机器学习\" class=\"headerlink\" title=\"机器学习\"></a>机器学习</h4><p>这一方面没有做很多工作，主要是因为其入门的门槛较高，而自己又没有找到一个合理的进入方式开始学习。</p>\n<h4 id=\"设计与艺术\"><a href=\"#设计与艺术\" class=\"headerlink\" title=\"设计与艺术\"></a>设计与艺术</h4><p>有适当阅读一些文章，浏览一些艺术设计来提高下自己这方面的修养。不过，并未投入足够的时间。</p>\n<h4 id=\"英语\"><a href=\"#英语\" class=\"headerlink\" title=\"英语\"></a>英语</h4><p>英语阅读：在平常搜索问题时以英文搜索为主，而且持续不断阅读英文技术文章、翻译等等，现在基本能达到不错阅读理解水平。</p>\n<p>口语：去年报名了在线口语提高班，进行了一个月左右的课程，口语方面虽没有很大飞跃，不过现在对常用句型基本上比较熟练了。而且，2017年还会继续口语课程。</p>\n<h4 id=\"生活\"><a href=\"#生活\" class=\"headerlink\" title=\"生活\"></a>生活</h4><p>这一点做的不够。</p>\n<p>去年和同事开玩笑说，我是个没有生活的人。没有合理利用自己的空闲时间，如周末偶尔会做做饭，其他时候就是看看剧打打游戏，并没有很好的去感受生活。</p>\n<h4 id=\"体育\"><a href=\"#体育\" class=\"headerlink\" title=\"体育\"></a>体育</h4><p>一年里除了偶尔打打羽毛球，非常缺乏体育锻炼。去年年底时去办了张一年的健身卡，目前已经持续了一个月左右的健身，平均两天一次健身：半小时跑步 ＋ 半小时无氧运行。</p>\n<h4 id=\"健康饮食\"><a href=\"#健康饮食\" class=\"headerlink\" title=\"健康饮食\"></a>健康饮食</h4><p>由于整日坐着工作，颈椎有点毛病，而且出现了肥胖的问题，身体脂肪含量高，肌肉比例偏低。采取的措施是不吃太饱 ＋ 不吃夜宵。</p>\n<h4 id=\"阅读\"><a href=\"#阅读\" class=\"headerlink\" title=\"阅读\"></a>阅读</h4><p>基本没有深入读什么书籍，不够。</p>\n<h2 id=\"计划-2017\"><a href=\"#计划-2017\" class=\"headerlink\" title=\"计划 2017\"></a>计划 2017</h2><p>下面对 2017 做一些计划。</p>\n<h4 id=\"技术\"><a href=\"#技术\" class=\"headerlink\" title=\"技术\"></a>技术</h4><ol>\n<li><p>Java + Android研究基础。基础知识是自己的弱项，必须对 Java 和 Android 很多基础的理论进行深入的学习了解，不要只会只用 API。</p>\n</li>\n<li><p>前沿进展。了解 Android 的最新的技术，作为一名 Android 工程师，必须对 Android 最新的技术保持实时更新了解。</p>\n</li>\n<li><p>AI学习。在人工智能方面可以通过阅读文章、上在线课程来进行入门。</p>\n</li>\n</ol>\n<h4 id=\"开源\"><a href=\"#开源\" class=\"headerlink\" title=\"开源\"></a>开源</h4><p>对 简诗 可以再做一些新的功能，尝试一些 Android 和 服务器开发的不同的技术点，拓宽自己的技术视野。</p>\n<h4 id=\"公众号\"><a href=\"#公众号\" class=\"headerlink\" title=\"公众号\"></a>公众号</h4><p>继续保持 两日一更 的节奏，可以去阅读 Medium 上的文章，Hacker News 或者 Reddit 上的讨论，各大公司的新技术文章进行阅读翻译并推送。争取一年内达到上万读者。</p>\n<h4 id=\"理财、金融阅读学习\"><a href=\"#理财、金融阅读学习\" class=\"headerlink\" title=\"理财、金融阅读学习\"></a>理财、金融阅读学习</h4><p>对理财和金融方面进行了解学习，自己开始理财，学习基本的金融知识。</p>\n<p>除了技术方面，今年主要要多读一些经济金融方面的书籍。了解整个社会的经济是如何发展的。</p>\n<h4 id=\"个人盈利\"><a href=\"#个人盈利\" class=\"headerlink\" title=\"个人盈利\"></a>个人盈利</h4><p>争取把我的业余工作转化出一定的收益。比如持续去维护简诗的开发、公众号的文章推送，如果能在做这些事情的时候得到一些金钱方面的回报，就能良性地提高我的内驱动力。这样才是一个理性的业余工作方式，毕竟一味的对外输出总是容易丧失动力。</p>\n<p>盈利方案：</p>\n<ol>\n<li><p>简诗 首先要继续提高新用户数和用户留存，把简诗做成世界上最干净最好用的竖排古典写作工具。然后，通过提供一些付费功能如自定义印章等，或者定制简诗风格的笔记本来进行盈利。</p>\n</li>\n<li><p>公众号 方面，先尽可能吸引聚集较多的高质量读者，对国外技术、新闻、讨论感兴趣的一批人，然后再提供一些其它的推送服务给他们。</p>\n</li>\n</ol>\n<h4 id=\"生活：旅游-＋-体育健身-＋-饮食-＋-早起\"><a href=\"#生活：旅游-＋-体育健身-＋-饮食-＋-早起\" class=\"headerlink\" title=\"生活：旅游 ＋ 体育健身 ＋ 饮食 ＋ 早起\"></a>生活：旅游 ＋ 体育健身 ＋ 饮食 ＋ 早起</h4><ol>\n<li><p>旅游<br>今年，我要至少旅游国内五座城市。要了解城市的历史，整座城市的规划，城市的经济发展方式，这座城市人民特有的民风文化。每次旅行要做好足够的准备，去有意义的地方，旅行后要有一篇文章记录。</p>\n</li>\n<li><p>体育健身<br>尽可能保持每周至少 三 次健身，改善自己的脂肪和肌肉的比例，必须要恢复到正常状态。 </p>\n</li>\n<li><p>饮食<br>不要花太多时间在吃方面，只要吃饱、吃健康就行，不要花太多时间在好吃的食物上。</p>\n</li>\n<li><p>早起<br>为了提高阅读量，我可以每天早起一个小时来阅读文章或者金融书籍。扩充知识面，同时可以维护好公众号。</p>\n</li>\n</ol>\n<h4 id=\"驾照\"><a href=\"#驾照\" class=\"headerlink\" title=\"驾照\"></a>驾照</h4><p>如果今年时间足够，可以去考虑报名参加上海这里的驾照考试。</p>\n<p>以上是 2017 年大体的计划，之后还要进行更加详细的规划，可以参考定制自己的季度目标和每月目标来进行督促。</p>","sticky":0},{"title":"对未来个人技术博客的一些思考","date":"2017-03-29T10:16:25.000Z","commentIssueId":9,"_content":"\n> 2016年自己的博客产出并不多，主要原因是自己希望在博客中只分享技术干货，而非泛泛而谈，所以一直克制自己写文的想法。不过这里其实存在一个漏洞，那就是平常的开发过程中并没有那么多的难题要解决，也就导致工作中并不能提供那么多干货素材。因此，我才来重新考虑自己2017年的博客计划和方向。\n\n<!-- more -->\n\n## 回顾\n目前我在 Glow 工作了快两年时间，这两年我的技术成长主要在：\n\n1. Android 应用层开发，能够写出更加简洁、封装性更好的代码，对于常见的第三方框架 OkHttp, Dagger, RxJava 等一定的实践了解，并在这些框架的基础上进行二次封装到底层公共库里，在 Android 性能优化方面积累了一些经验，熟悉了不少 App 运维监控的工具如 Fabric；\n2. Python 服务端业务逻辑开发，学习了 Python 语言和 Flask 框架，对于后台的微服务化有一些了解，熟悉后台的架构设计、缓存设计，熟悉 Redis 这款优秀的数据库，业余时间自己开发的简诗服务端也算是自己的一个实践。\n\n## 博客规划\n### Java深入学习\n1. 读完 Effective Java，整理相关代码到 GitHub 上；\n2. 深入研究多线程编程，从基础概念着手，学会使用，再了解原理；\n3. 学习 JVM 工作原理，如何优化；\n4. 阿里发布的 Java 文档可以挑一些点分析下；\n\n### Android深入学习\n1. 写代码来实验进程间通信；\n2. 了解组件化；\n3. 了解multidex，打包，热修复等技术；\n\n### 效率工具\n分享一些能够较大提高工作效率的工具。\n\n### 阅读\n从别人的博客里找灵感 \nhttps://qifuguang.me/archives/page/8/\nhttps://blog.dreamtobe.cn/\nhttp://droidyue.com/blog/archives/index.html\nhttp://kaedea.com/archives/\nhttp://blog.zhaiyifan.cn/\nhttp://liwenkun.me/\nhttp://gavinliu.cn/archives/\n\n\n## 一些题目\n下面列出一些有意思的题目，之后要逐次完成。\n\n好了，准备开始我的2017填坑之旅了。\n\n## 已完成\n- [Java] [equals() 和 hashcode() 对比分析](http://wingjay.com/2017/03/29/Java%E7%9A%84equals%E4%B8%8Ehashcode%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/)\n- [Java] [Java 里如何实现线程间通信？](http://wingjay.com/2017/04/09/Java%E9%87%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%9F/)\n- [Java] [Java 技术之反射](http://wingjay.com/2017/04/26/Java-%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%8F%8D%E5%B0%84/)\n- [Java] [Java 技术之注解 Annotation](http://wingjay.com/2017/05/03/Java-%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%B3%A8%E8%A7%A3-Annotation/)\n- [Java] [Java 技术之类加载机制](http://wingjay.com/2017/05/08/java_classloader/)\n- [Java] [Java 技术之垃圾回收机制](http://wingjay.com/2017/05/24/Java-%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/)\n- [Android] [带你学开源项目：LeakCanary- 如何检测 Activity 是否泄漏](http://wingjay.com/2017/05/14/dig\\_into\\_leakcanary/)\n- [Tool] [自己动手改造个人博客](http://wingjay.com/2017/06/08/rebuild-personal-blog/)\n\n\n## 待完成\n#### 近期\n- [Glow] React Native 数据通信方式 http://www.lcode.org/react-native-android/ 集成到已有app，back button如何handle，native navigation，pubsub模式，数据传递，reactcontext是什么，native module\n- [源码] Gson解析\n- [Java] 进程间通信\n- [效率] 多行编辑模式(sublime + Android studio), handy 的一些命令，terminal-notifier\n- [Java] Java 编译执行流程\n- [Android] 代码混淆机制\n- [Java] 多线程同步安全机制\n- [Android] Android提供的注解 http://droidyue.com/blog/2016/08/14/android-annnotation/\n- [Android] apk 打包流程\n- [Android] 多线程比较：AsyncTask, HandlerThread, ThreadPool, IntentService。（普通Thread 运行完就自动关闭了，而HandlerThread则会有一个looper在内部，调用handlerThread.start()后它就会一直在后台运行，需要它时用handler发一个message过去就行，随时都可以发message让它在后台干活。相比之下，AsyncTask也类似一次性的，后台执行完，回到UI线程运行下，就彻底结束了，不能一直在后台运行且随时与UI交互。）\n\n\n\n\n#### 后期\n- [Java] Java 如何实现字符串拼接 （http://droidyue.com/blog/2014/08/30/java-details-string-concatenation/）\n- [Tool] 使用 iterm 和 tmux\n- [效率] 用Python脚本来格式化你的文章，英文自动前后空格\n- [Android] window Activity 的关系，启动一个 Activity 会发生什么，什么是 DecorView PhoneWindow\n- [Android] Binder 如何充当中间者来传输数据\n- [Android] 谈谈 Monkey test 有什么用\n- [Tool] slack 发微博，terminal-notifier 工具\n- [Android] 为什么需要 multi-dex，为什么是65535\n- [Android] 什么是 aar 文件，与 apk jar 的区别\n- [Android] Davlik Jvm 的区别，什么更适合移动端\n- [Android] adb shell 进入后的世界，如何查看 cache，lurcache\n- [java]java性能优化的数据结构 CopyOnWrite\n- [Java] final 关键字, Lock与synchrnoize 区别,  不可变类\n\n\n","source":"_posts/对未来个人技术博客的一些思考.md","raw":"title: 对未来个人技术博客的一些思考\ndate: 2017-03-29 18:16:25\ncategories:\n  - Blog\ntags: 随笔\ncommentIssueId: 9\n---\n\n> 2016年自己的博客产出并不多，主要原因是自己希望在博客中只分享技术干货，而非泛泛而谈，所以一直克制自己写文的想法。不过这里其实存在一个漏洞，那就是平常的开发过程中并没有那么多的难题要解决，也就导致工作中并不能提供那么多干货素材。因此，我才来重新考虑自己2017年的博客计划和方向。\n\n<!-- more -->\n\n## 回顾\n目前我在 Glow 工作了快两年时间，这两年我的技术成长主要在：\n\n1. Android 应用层开发，能够写出更加简洁、封装性更好的代码，对于常见的第三方框架 OkHttp, Dagger, RxJava 等一定的实践了解，并在这些框架的基础上进行二次封装到底层公共库里，在 Android 性能优化方面积累了一些经验，熟悉了不少 App 运维监控的工具如 Fabric；\n2. Python 服务端业务逻辑开发，学习了 Python 语言和 Flask 框架，对于后台的微服务化有一些了解，熟悉后台的架构设计、缓存设计，熟悉 Redis 这款优秀的数据库，业余时间自己开发的简诗服务端也算是自己的一个实践。\n\n## 博客规划\n### Java深入学习\n1. 读完 Effective Java，整理相关代码到 GitHub 上；\n2. 深入研究多线程编程，从基础概念着手，学会使用，再了解原理；\n3. 学习 JVM 工作原理，如何优化；\n4. 阿里发布的 Java 文档可以挑一些点分析下；\n\n### Android深入学习\n1. 写代码来实验进程间通信；\n2. 了解组件化；\n3. 了解multidex，打包，热修复等技术；\n\n### 效率工具\n分享一些能够较大提高工作效率的工具。\n\n### 阅读\n从别人的博客里找灵感 \nhttps://qifuguang.me/archives/page/8/\nhttps://blog.dreamtobe.cn/\nhttp://droidyue.com/blog/archives/index.html\nhttp://kaedea.com/archives/\nhttp://blog.zhaiyifan.cn/\nhttp://liwenkun.me/\nhttp://gavinliu.cn/archives/\n\n\n## 一些题目\n下面列出一些有意思的题目，之后要逐次完成。\n\n好了，准备开始我的2017填坑之旅了。\n\n## 已完成\n- [Java] [equals() 和 hashcode() 对比分析](http://wingjay.com/2017/03/29/Java%E7%9A%84equals%E4%B8%8Ehashcode%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/)\n- [Java] [Java 里如何实现线程间通信？](http://wingjay.com/2017/04/09/Java%E9%87%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%9F/)\n- [Java] [Java 技术之反射](http://wingjay.com/2017/04/26/Java-%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%8F%8D%E5%B0%84/)\n- [Java] [Java 技术之注解 Annotation](http://wingjay.com/2017/05/03/Java-%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%B3%A8%E8%A7%A3-Annotation/)\n- [Java] [Java 技术之类加载机制](http://wingjay.com/2017/05/08/java_classloader/)\n- [Java] [Java 技术之垃圾回收机制](http://wingjay.com/2017/05/24/Java-%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/)\n- [Android] [带你学开源项目：LeakCanary- 如何检测 Activity 是否泄漏](http://wingjay.com/2017/05/14/dig\\_into\\_leakcanary/)\n- [Tool] [自己动手改造个人博客](http://wingjay.com/2017/06/08/rebuild-personal-blog/)\n\n\n## 待完成\n#### 近期\n- [Glow] React Native 数据通信方式 http://www.lcode.org/react-native-android/ 集成到已有app，back button如何handle，native navigation，pubsub模式，数据传递，reactcontext是什么，native module\n- [源码] Gson解析\n- [Java] 进程间通信\n- [效率] 多行编辑模式(sublime + Android studio), handy 的一些命令，terminal-notifier\n- [Java] Java 编译执行流程\n- [Android] 代码混淆机制\n- [Java] 多线程同步安全机制\n- [Android] Android提供的注解 http://droidyue.com/blog/2016/08/14/android-annnotation/\n- [Android] apk 打包流程\n- [Android] 多线程比较：AsyncTask, HandlerThread, ThreadPool, IntentService。（普通Thread 运行完就自动关闭了，而HandlerThread则会有一个looper在内部，调用handlerThread.start()后它就会一直在后台运行，需要它时用handler发一个message过去就行，随时都可以发message让它在后台干活。相比之下，AsyncTask也类似一次性的，后台执行完，回到UI线程运行下，就彻底结束了，不能一直在后台运行且随时与UI交互。）\n\n\n\n\n#### 后期\n- [Java] Java 如何实现字符串拼接 （http://droidyue.com/blog/2014/08/30/java-details-string-concatenation/）\n- [Tool] 使用 iterm 和 tmux\n- [效率] 用Python脚本来格式化你的文章，英文自动前后空格\n- [Android] window Activity 的关系，启动一个 Activity 会发生什么，什么是 DecorView PhoneWindow\n- [Android] Binder 如何充当中间者来传输数据\n- [Android] 谈谈 Monkey test 有什么用\n- [Tool] slack 发微博，terminal-notifier 工具\n- [Android] 为什么需要 multi-dex，为什么是65535\n- [Android] 什么是 aar 文件，与 apk jar 的区别\n- [Android] Davlik Jvm 的区别，什么更适合移动端\n- [Android] adb shell 进入后的世界，如何查看 cache，lurcache\n- [java]java性能优化的数据结构 CopyOnWrite\n- [Java] final 关键字, Lock与synchrnoize 区别,  不可变类\n\n\n","slug":"对未来个人技术博客的一些思考","published":1,"updated":"2018-11-26T06:56:27.484Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplsgv000l3dn8itqt92ab","content":"<blockquote>\n<p>2016 年自己的博客产出并不多，主要原因是自己希望在博客中只分享技术干货，而非泛泛而谈，所以一直克制自己写文的想法。不过这里其实存在一个漏洞，那就是平常的开发过程中并没有那么多的难题要解决，也就导致工作中并不能提供那么多干货素材。因此，我才来重新考虑自己 2017 年的博客计划和方向。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"回顾\"><a href=\"# 回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾 </h2><p> 目前我在 Glow 工作了快两年时间，这两年我的技术成长主要在：</p>\n<ol>\n<li>Android 应用层开发，能够写出更加简洁、封装性更好的代码，对于常见的第三方框架 OkHttp, Dagger, RxJava 等一定的实践了解，并在这些框架的基础上进行二次封装到底层公共库里，在 Android 性能优化方面积累了一些经验，熟悉了不少 App 运维监控的工具如 Fabric；</li>\n<li>Python 服务端业务逻辑开发，学习了 Python 语言和 Flask 框架，对于后台的微服务化有一些了解，熟悉后台的架构设计、缓存设计，熟悉 Redis 这款优秀的数据库，业余时间自己开发的简诗服务端也算是自己的一个实践。</li>\n</ol>\n<h2 id=\"博客规划\"><a href=\"# 博客规划\" class=\"headerlink\" title=\"博客规划\"></a>博客规划</h2><h3 id=\"Java 深入学习\"><a href=\"#Java 深入学习\" class=\"headerlink\" title=\"Java 深入学习\"></a>Java 深入学习</h3><ol>\n<li>读完 Effective Java，整理相关代码到 GitHub 上；</li>\n<li>深入研究多线程编程，从基础概念着手，学会使用，再了解原理；</li>\n<li>学习 JVM 工作原理，如何优化；</li>\n<li>阿里发布的 Java 文档可以挑一些点分析下；</li>\n</ol>\n<h3 id=\"Android 深入学习\"><a href=\"#Android 深入学习\" class=\"headerlink\" title=\"Android 深入学习\"></a>Android 深入学习</h3><ol>\n<li>写代码来实验进程间通信；</li>\n<li>了解组件化；</li>\n<li>了解 multidex，打包，热修复等技术；</li>\n</ol>\n<h3 id=\"效率工具\"><a href=\"# 效率工具\" class=\"headerlink\" title=\"效率工具\"></a>效率工具 </h3><p> 分享一些能够较大提高工作效率的工具。</p>\n<h3 id=\"阅读\"><a href=\"# 阅读\" class=\"headerlink\" title=\"阅读\"></a>阅读 </h3><p> 从别人的博客里找灵感<br><a href=\"https://qifuguang.me/archives/page/8/\" target=\"_blank\" rel=\"external\">https://qifuguang.me/archives/page/8/</a><br><a href=\"https://blog.dreamtobe.cn/\" target=\"_blank\" rel=\"external\">https://blog.dreamtobe.cn/</a><br><a href=\"http://droidyue.com/blog/archives/index.html\" target=\"_blank\" rel=\"external\">http://droidyue.com/blog/archives/index.html</a><br><a href=\"http://kaedea.com/archives/\" target=\"_blank\" rel=\"external\">http://kaedea.com/archives/</a><br><a href=\"http://blog.zhaiyifan.cn/\" target=\"_blank\" rel=\"external\">http://blog.zhaiyifan.cn/</a><br><a href=\"http://liwenkun.me/\" target=\"_blank\" rel=\"external\">http://liwenkun.me/</a><br><a href=\"http://gavinliu.cn/archives/\" target=\"_blank\" rel=\"external\">http://gavinliu.cn/archives/</a></p>\n<h2 id=\"一些题目\"><a href=\"# 一些题目\" class=\"headerlink\" title=\"一些题目\"></a>一些题目 </h2><p> 下面列出一些有意思的题目，之后要逐次完成。</p>\n<p>好了，准备开始我的 2017 填坑之旅了。</p>\n<h2 id=\"已完成\"><a href=\"# 已完成\" class=\"headerlink\" title=\"已完成\"></a>已完成</h2><ul>\n<li>[Java] <a href=\"http://wingjay.com/2017/03/29/Java%E7%9A%84equals%E4%B8%8Ehashcode%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/\">equals() 和 hashcode() 对比分析</a></li>\n<li>[Java] <a href=\"http://wingjay.com/2017/04/09/Java%E9%87%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%9F/\">Java 里如何实现线程间通信？</a></li>\n<li>[Java] <a href=\"http://wingjay.com/2017/04/26/Java-%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%8F%8D%E5%B0%84/\">Java 技术之反射</a></li>\n<li>[Java] <a href=\"http://wingjay.com/2017/05/03/Java-%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%B3%A8%E8%A7%A3-Annotation/\">Java 技术之注解 Annotation</a></li>\n<li>[Java] <a href=\"http://wingjay.com/2017/05/08/java_classloader/\">Java 技术之类加载机制</a></li>\n<li>[Java] <a href=\"http://wingjay.com/2017/05/24/Java-%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/\">Java 技术之垃圾回收机制</a></li>\n<li>[Android] <a href=\"http://wingjay.com/2017/05/14/dig\\_into\\_leakcanary/\">带你学开源项目：LeakCanary- 如何检测 Activity 是否泄漏</a></li>\n<li>[Tool] <a href=\"http://wingjay.com/2017/06/08/rebuild-personal-blog/\">自己动手改造个人博客</a></li>\n</ul>\n<h2 id=\"待完成\"><a href=\"# 待完成\" class=\"headerlink\" title=\"待完成\"></a>待完成 </h2><h4 id=\"近期\"><a href=\"# 近期\" class=\"headerlink\" title=\"近期\"></a> 近期</h4><ul>\n<li>[Glow] React Native 数据通信方式 <a href=\"http://www.lcode.org/react-native-android/\" target=\"_blank\" rel=\"external\">http://www.lcode.org/react-native-android/</a> 集成到已有 app，back button 如何 handle，native navigation，pubsub 模式，数据传递，reactcontext 是什么，native module</li>\n<li>[源码] Gson 解析</li>\n<li>[Java] 进程间通信</li>\n<li>[效率] 多行编辑模式(sublime + Android studio), handy 的一些命令，terminal-notifier</li>\n<li>[Java] Java 编译执行流程</li>\n<li>[Android] 代码混淆机制</li>\n<li>[Java] 多线程同步安全机制</li>\n<li>[Android] Android 提供的注解 <a href=\"http://droidyue.com/blog/2016/08/14/android-annnotation/\" target=\"_blank\" rel=\"external\">http://droidyue.com/blog/2016/08/14/android-annnotation/</a></li>\n<li>[Android] apk 打包流程</li>\n<li>[Android] 多线程比较：AsyncTask, HandlerThread, ThreadPool, IntentService。（普通 Thread 运行完就自动关闭了，而 HandlerThread 则会有一个 looper 在内部，调用 handlerThread.start()后它就会一直在后台运行，需要它时用 handler 发一个 message 过去就行，随时都可以发 message 让它在后台干活。相比之下，AsyncTask 也类似一次性的，后台执行完，回到 UI 线程运行下，就彻底结束了，不能一直在后台运行且随时与 UI 交互。）</li>\n</ul>\n<h4 id=\"后期\"><a href=\"# 后期\" class=\"headerlink\" title=\"后期\"></a>后期</h4><ul>\n<li>[Java] Java 如何实现字符串拼接 （<a href=\"http://droidyue.com/blog/2014/08/30/java-details-string-concatenation/）\" target=\"_blank\" rel=\"external\">http://droidyue.com/blog/2014/08/30/java-details-string-concatenation/）</a></li>\n<li>[Tool] 使用 iterm 和 tmux</li>\n<li>[效率] 用 Python 脚本来格式化你的文章，英文自动前后空格</li>\n<li>[Android] window Activity 的关系，启动一个 Activity 会发生什么，什么是 DecorView PhoneWindow</li>\n<li>[Android] Binder 如何充当中间者来传输数据</li>\n<li>[Android] 谈谈 Monkey test 有什么用</li>\n<li>[Tool] slack 发微博，terminal-notifier 工具</li>\n<li>[Android] 为什么需要 multi-dex，为什么是 65535</li>\n<li>[Android] 什么是 aar 文件，与 apk jar 的区别</li>\n<li>[Android] Davlik Jvm 的区别，什么更适合移动端</li>\n<li>[Android] adb shell 进入后的世界，如何查看 cache，lurcache</li>\n<li>[java]java 性能优化的数据结构 CopyOnWrite</li>\n<li>[Java] final 关键字, Lock 与 synchrnoize 区别,  不可变类</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>2016年自己的博客产出并不多，主要原因是自己希望在博客中只分享技术干货，而非泛泛而谈，所以一直克制自己写文的想法。不过这里其实存在一个漏洞，那就是平常的开发过程中并没有那么多的难题要解决，也就导致工作中并不能提供那么多干货素材。因此，我才来重新考虑自己2017年的博客计划和方向。</p>\n</blockquote>","more":"<h2 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h2><p>目前我在 Glow 工作了快两年时间，这两年我的技术成长主要在：</p>\n<ol>\n<li>Android 应用层开发，能够写出更加简洁、封装性更好的代码，对于常见的第三方框架 OkHttp, Dagger, RxJava 等一定的实践了解，并在这些框架的基础上进行二次封装到底层公共库里，在 Android 性能优化方面积累了一些经验，熟悉了不少 App 运维监控的工具如 Fabric；</li>\n<li>Python 服务端业务逻辑开发，学习了 Python 语言和 Flask 框架，对于后台的微服务化有一些了解，熟悉后台的架构设计、缓存设计，熟悉 Redis 这款优秀的数据库，业余时间自己开发的简诗服务端也算是自己的一个实践。</li>\n</ol>\n<h2 id=\"博客规划\"><a href=\"#博客规划\" class=\"headerlink\" title=\"博客规划\"></a>博客规划</h2><h3 id=\"Java深入学习\"><a href=\"#Java深入学习\" class=\"headerlink\" title=\"Java深入学习\"></a>Java深入学习</h3><ol>\n<li>读完 Effective Java，整理相关代码到 GitHub 上；</li>\n<li>深入研究多线程编程，从基础概念着手，学会使用，再了解原理；</li>\n<li>学习 JVM 工作原理，如何优化；</li>\n<li>阿里发布的 Java 文档可以挑一些点分析下；</li>\n</ol>\n<h3 id=\"Android深入学习\"><a href=\"#Android深入学习\" class=\"headerlink\" title=\"Android深入学习\"></a>Android深入学习</h3><ol>\n<li>写代码来实验进程间通信；</li>\n<li>了解组件化；</li>\n<li>了解multidex，打包，热修复等技术；</li>\n</ol>\n<h3 id=\"效率工具\"><a href=\"#效率工具\" class=\"headerlink\" title=\"效率工具\"></a>效率工具</h3><p>分享一些能够较大提高工作效率的工具。</p>\n<h3 id=\"阅读\"><a href=\"#阅读\" class=\"headerlink\" title=\"阅读\"></a>阅读</h3><p>从别人的博客里找灵感<br><a href=\"https://qifuguang.me/archives/page/8/\" target=\"_blank\" rel=\"external\">https://qifuguang.me/archives/page/8/</a><br><a href=\"https://blog.dreamtobe.cn/\" target=\"_blank\" rel=\"external\">https://blog.dreamtobe.cn/</a><br><a href=\"http://droidyue.com/blog/archives/index.html\" target=\"_blank\" rel=\"external\">http://droidyue.com/blog/archives/index.html</a><br><a href=\"http://kaedea.com/archives/\" target=\"_blank\" rel=\"external\">http://kaedea.com/archives/</a><br><a href=\"http://blog.zhaiyifan.cn/\" target=\"_blank\" rel=\"external\">http://blog.zhaiyifan.cn/</a><br><a href=\"http://liwenkun.me/\" target=\"_blank\" rel=\"external\">http://liwenkun.me/</a><br><a href=\"http://gavinliu.cn/archives/\" target=\"_blank\" rel=\"external\">http://gavinliu.cn/archives/</a></p>\n<h2 id=\"一些题目\"><a href=\"#一些题目\" class=\"headerlink\" title=\"一些题目\"></a>一些题目</h2><p>下面列出一些有意思的题目，之后要逐次完成。</p>\n<p>好了，准备开始我的2017填坑之旅了。</p>\n<h2 id=\"已完成\"><a href=\"#已完成\" class=\"headerlink\" title=\"已完成\"></a>已完成</h2><ul>\n<li>[Java] <a href=\"http://wingjay.com/2017/03/29/Java%E7%9A%84equals%E4%B8%8Ehashcode%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/\">equals() 和 hashcode() 对比分析</a></li>\n<li>[Java] <a href=\"http://wingjay.com/2017/04/09/Java%E9%87%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%9F/\">Java 里如何实现线程间通信？</a></li>\n<li>[Java] <a href=\"http://wingjay.com/2017/04/26/Java-%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%8F%8D%E5%B0%84/\">Java 技术之反射</a></li>\n<li>[Java] <a href=\"http://wingjay.com/2017/05/03/Java-%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%B3%A8%E8%A7%A3-Annotation/\">Java 技术之注解 Annotation</a></li>\n<li>[Java] <a href=\"http://wingjay.com/2017/05/08/java_classloader/\">Java 技术之类加载机制</a></li>\n<li>[Java] <a href=\"http://wingjay.com/2017/05/24/Java-%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/\">Java 技术之垃圾回收机制</a></li>\n<li>[Android] <a href=\"http://wingjay.com/2017/05/14/dig\\_into\\_leakcanary/\">带你学开源项目：LeakCanary- 如何检测 Activity 是否泄漏</a></li>\n<li>[Tool] <a href=\"http://wingjay.com/2017/06/08/rebuild-personal-blog/\">自己动手改造个人博客</a></li>\n</ul>\n<h2 id=\"待完成\"><a href=\"#待完成\" class=\"headerlink\" title=\"待完成\"></a>待完成</h2><h4 id=\"近期\"><a href=\"#近期\" class=\"headerlink\" title=\"近期\"></a>近期</h4><ul>\n<li>[Glow] React Native 数据通信方式 <a href=\"http://www.lcode.org/react-native-android/\" target=\"_blank\" rel=\"external\">http://www.lcode.org/react-native-android/</a> 集成到已有app，back button如何handle，native navigation，pubsub模式，数据传递，reactcontext是什么，native module</li>\n<li>[源码] Gson解析</li>\n<li>[Java] 进程间通信</li>\n<li>[效率] 多行编辑模式(sublime + Android studio), handy 的一些命令，terminal-notifier</li>\n<li>[Java] Java 编译执行流程</li>\n<li>[Android] 代码混淆机制</li>\n<li>[Java] 多线程同步安全机制</li>\n<li>[Android] Android提供的注解 <a href=\"http://droidyue.com/blog/2016/08/14/android-annnotation/\" target=\"_blank\" rel=\"external\">http://droidyue.com/blog/2016/08/14/android-annnotation/</a></li>\n<li>[Android] apk 打包流程</li>\n<li>[Android] 多线程比较：AsyncTask, HandlerThread, ThreadPool, IntentService。（普通Thread 运行完就自动关闭了，而HandlerThread则会有一个looper在内部，调用handlerThread.start()后它就会一直在后台运行，需要它时用handler发一个message过去就行，随时都可以发message让它在后台干活。相比之下，AsyncTask也类似一次性的，后台执行完，回到UI线程运行下，就彻底结束了，不能一直在后台运行且随时与UI交互。）</li>\n</ul>\n<h4 id=\"后期\"><a href=\"#后期\" class=\"headerlink\" title=\"后期\"></a>后期</h4><ul>\n<li>[Java] Java 如何实现字符串拼接 （<a href=\"http://droidyue.com/blog/2014/08/30/java-details-string-concatenation/）\" target=\"_blank\" rel=\"external\">http://droidyue.com/blog/2014/08/30/java-details-string-concatenation/）</a></li>\n<li>[Tool] 使用 iterm 和 tmux</li>\n<li>[效率] 用Python脚本来格式化你的文章，英文自动前后空格</li>\n<li>[Android] window Activity 的关系，启动一个 Activity 会发生什么，什么是 DecorView PhoneWindow</li>\n<li>[Android] Binder 如何充当中间者来传输数据</li>\n<li>[Android] 谈谈 Monkey test 有什么用</li>\n<li>[Tool] slack 发微博，terminal-notifier 工具</li>\n<li>[Android] 为什么需要 multi-dex，为什么是65535</li>\n<li>[Android] 什么是 aar 文件，与 apk jar 的区别</li>\n<li>[Android] Davlik Jvm 的区别，什么更适合移动端</li>\n<li>[Android] adb shell 进入后的世界，如何查看 cache，lurcache</li>\n<li>[java]java性能优化的数据结构 CopyOnWrite</li>\n<li>[Java] final 关键字, Lock与synchrnoize 区别,  不可变类</li>\n</ul>","sticky":0},{"title":"新的城市，新的开始","date":"2017-08-18T08:07:54.000Z","commentIssueId":21,"_content":"> 新一站：杭州，阿里巴巴。\n\n<!-- more -->\n\n由于最近换工作，有一段时间没更博了。\n\n其实很舍不得 Glow，在 Glow 的两年，自己不仅在技术上有了很大的进步，更认识了很多优秀的朋友。\n\n目前已经来杭州阿里一个多月了，最深的印象就是无比炎热的气候，简直了。\n\n不过这里的同事都很好，而且内网有非常多优质的学习资源。\n\n并不觉得阿里像外界传说那样，过度严苛的价值观、严重的加班、死气沉沉之类的。反之，这里上班时间自由（早上10点），晚上不会刻意加班，完成任务就可以走，有足够的个人时间，工作氛围也很友好。不知道其他部门怎么样，至少我所在的部门更像一家创业公司：不刻板、努力、互助。\n\n很期待自己在这里能不断成长，发挥潜力，精深技术，同时认识一帮好友。\n\n先这样，后面干货技术博客会继续更新起来。\n\n\n> 想要来阿里工作的小伙伴，可以找我内推哦。yinjiesh # 126.com","source":"_posts/新的城市，新的开始.md","raw":"title: 新的城市，新的开始\ndate: 2017-08-18 16:07:54\npermalink: new_start_hangzhou\ncategories:\n\t- 年度计划\ntags: 随笔\ncommentIssueId: 21\n---\n> 新一站：杭州，阿里巴巴。\n\n<!-- more -->\n\n由于最近换工作，有一段时间没更博了。\n\n其实很舍不得 Glow，在 Glow 的两年，自己不仅在技术上有了很大的进步，更认识了很多优秀的朋友。\n\n目前已经来杭州阿里一个多月了，最深的印象就是无比炎热的气候，简直了。\n\n不过这里的同事都很好，而且内网有非常多优质的学习资源。\n\n并不觉得阿里像外界传说那样，过度严苛的价值观、严重的加班、死气沉沉之类的。反之，这里上班时间自由（早上10点），晚上不会刻意加班，完成任务就可以走，有足够的个人时间，工作氛围也很友好。不知道其他部门怎么样，至少我所在的部门更像一家创业公司：不刻板、努力、互助。\n\n很期待自己在这里能不断成长，发挥潜力，精深技术，同时认识一帮好友。\n\n先这样，后面干货技术博客会继续更新起来。\n\n\n> 想要来阿里工作的小伙伴，可以找我内推哦。yinjiesh # 126.com","slug":"new_start_hangzhou","published":1,"updated":"2018-11-26T06:56:27.486Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplsgx000p3dn8nu86dwhe","content":"<blockquote>\n<p> 新一站：杭州，阿里巴巴。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p> 由于最近换工作，有一段时间没更博了。</p>\n<p> 其实很舍不得 Glow，在 Glow 的两年，自己不仅在技术上有了很大的进步，更认识了很多优秀的朋友。</p>\n<p> 目前已经来杭州阿里一个多月了，最深的印象就是无比炎热的气候，简直了。</p>\n<p> 不过这里的同事都很好，而且内网有非常多优质的学习资源。</p>\n<p> 并不觉得阿里像外界传说那样，过度严苛的价值观、严重的加班、死气沉沉之类的。反之，这里上班时间自由（早上 10 点），晚上不会刻意加班，完成任务就可以走，有足够的个人时间，工作氛围也很友好。不知道其他部门怎么样，至少我所在的部门更像一家创业公司：不刻板、努力、互助。</p>\n<p> 很期待自己在这里能不断成长，发挥潜力，精深技术，同时认识一帮好友。</p>\n<p> 先这样，后面干货技术博客会继续更新起来。</p>\n<blockquote>\n<p> 想要来阿里工作的小伙伴，可以找我内推哦。yinjiesh # 126.com</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>新一站：杭州，阿里巴巴。</p>\n</blockquote>","more":"<p>由于最近换工作，有一段时间没更博了。</p>\n<p>其实很舍不得 Glow，在 Glow 的两年，自己不仅在技术上有了很大的进步，更认识了很多优秀的朋友。</p>\n<p>目前已经来杭州阿里一个多月了，最深的印象就是无比炎热的气候，简直了。</p>\n<p>不过这里的同事都很好，而且内网有非常多优质的学习资源。</p>\n<p>并不觉得阿里像外界传说那样，过度严苛的价值观、严重的加班、死气沉沉之类的。反之，这里上班时间自由（早上10点），晚上不会刻意加班，完成任务就可以走，有足够的个人时间，工作氛围也很友好。不知道其他部门怎么样，至少我所在的部门更像一家创业公司：不刻板、努力、互助。</p>\n<p>很期待自己在这里能不断成长，发挥潜力，精深技术，同时认识一帮好友。</p>\n<p>先这样，后面干货技术博客会继续更新起来。</p>\n<blockquote>\n<p>想要来阿里工作的小伙伴，可以找我内推哦。yinjiesh # 126.com</p>\n</blockquote>","sticky":0},{"title":"有趣的曲线在 Android 上的实现","date":"2016-01-25T10:41:43.000Z","commentIssueId":19,"_content":"> 简单的数学原理其实很有趣\n\n<!-- more -->\n直接上图：\n<img src=\"/img/interesting-curve/7.png\" width=\"300\">\n\n几日前在OF Course公众号看到一篇蛮有意思的文章－[简单法则的魅力](http://mp.weixin.qq.com/s?__biz=MzA4NTc5MDU5OQ==&mid=411441608&idx=1&sn=5e846a882f58a7ba1b5312bdbeaafccf&scene=23&srcid=0120GiYhMXjmNDoN9MFQj7f5#rd)，觉得里面的动效很有意思，能够基于简单的数学法则通过修改几个参数便画出千变万化的优美的曲线，实在有趣。而且这篇文章里还给出了代码，简直给力。\n\n于是忍不住，自己动手实现了一下，动态效果图如图，下面给出本人随意得出的其它曲线。\n\n\n\n<img src=\"/img/interesting-curve/ring.gif\" width=\"300\">\n<img src=\"/img/interesting-curve/box.gif\" width=\"300\">\n<img src=\"/img/interesting-curve/1.png\" width=\"300\">\n<img src=\"/img/interesting-curve/2.png\" width=\"300\">\n<img src=\"/img/interesting-curve/3.png\" width=\"300\">\n<img src=\"/img/interesting-curve/4.png\" width=\"300\">\n<img src=\"/img/interesting-curve/5.png\" width=\"300\">\n<img src=\"/img/interesting-curve/6.png\" width=\"300\">\n<img src=\"/img/interesting-curve/7.png\" width=\"300\">\n<img src=\"/img/interesting-curve/8.png\" width=\"300\">\n<img src=\"/img/interesting-curve/9.jpg\" width=\"300\">\n<img src=\"/img/interesting-curve/10.png\" width=\"300\">\n<img src=\"/img/interesting-curve/11.png\" width=\"300\">","source":"_posts/有趣的曲线在Android上的实现.md","raw":"title: 有趣的曲线在Android上的实现\ncategories:\n  - Android\n  - Performance\ntags:\n  - cool\n  - 动效\ndate: 2016-01-25 18:41:43\ncommentIssueId: 19\n---\n> 简单的数学原理其实很有趣\n\n<!-- more -->\n直接上图：\n<img src=\"/img/interesting-curve/7.png\" width=\"300\">\n\n几日前在OF Course公众号看到一篇蛮有意思的文章－[简单法则的魅力](http://mp.weixin.qq.com/s?__biz=MzA4NTc5MDU5OQ==&mid=411441608&idx=1&sn=5e846a882f58a7ba1b5312bdbeaafccf&scene=23&srcid=0120GiYhMXjmNDoN9MFQj7f5#rd)，觉得里面的动效很有意思，能够基于简单的数学法则通过修改几个参数便画出千变万化的优美的曲线，实在有趣。而且这篇文章里还给出了代码，简直给力。\n\n于是忍不住，自己动手实现了一下，动态效果图如图，下面给出本人随意得出的其它曲线。\n\n\n\n<img src=\"/img/interesting-curve/ring.gif\" width=\"300\">\n<img src=\"/img/interesting-curve/box.gif\" width=\"300\">\n<img src=\"/img/interesting-curve/1.png\" width=\"300\">\n<img src=\"/img/interesting-curve/2.png\" width=\"300\">\n<img src=\"/img/interesting-curve/3.png\" width=\"300\">\n<img src=\"/img/interesting-curve/4.png\" width=\"300\">\n<img src=\"/img/interesting-curve/5.png\" width=\"300\">\n<img src=\"/img/interesting-curve/6.png\" width=\"300\">\n<img src=\"/img/interesting-curve/7.png\" width=\"300\">\n<img src=\"/img/interesting-curve/8.png\" width=\"300\">\n<img src=\"/img/interesting-curve/9.jpg\" width=\"300\">\n<img src=\"/img/interesting-curve/10.png\" width=\"300\">\n<img src=\"/img/interesting-curve/11.png\" width=\"300\">","slug":"有趣的曲线在Android上的实现","published":1,"updated":"2018-11-26T06:56:27.487Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplsgy000s3dn87nkonqzq","content":"<blockquote>\n<p> 简单的数学原理其实很有趣 </p>\n</blockquote>\n<a id=\"more\"></a>\n<p> 直接上图：<br><img src=\"/img/interesting-curve/7.png\" width=\"300\"></p>\n<p> 几日前在 OF Course 公众号看到一篇蛮有意思的文章－<a href=\"http://mp.weixin.qq.com/s?__biz=MzA4NTc5MDU5OQ==&amp;mid=411441608&amp;idx=1&amp;sn=5e846a882f58a7ba1b5312bdbeaafccf&amp;scene=23&amp;srcid=0120GiYhMXjmNDoN9MFQj7f5#rd\" target=\"_blank\" rel=\"external\"> 简单法则的魅力 </a>，觉得里面的动效很有意思，能够基于简单的数学法则通过修改几个参数便画出千变万化的优美的曲线，实在有趣。而且这篇文章里还给出了代码，简直给力。</p>\n<p> 于是忍不住，自己动手实现了一下，动态效果图如图，下面给出本人随意得出的其它曲线。</p>\n<p><img src=\"/img/interesting-curve/ring.gif\" width=\"300\"><br><img src=\"/img/interesting-curve/box.gif\" width=\"300\"><br><img src=\"/img/interesting-curve/1.png\" width=\"300\"><br><img src=\"/img/interesting-curve/2.png\" width=\"300\"><br><img src=\"/img/interesting-curve/3.png\" width=\"300\"><br><img src=\"/img/interesting-curve/4.png\" width=\"300\"><br><img src=\"/img/interesting-curve/5.png\" width=\"300\"><br><img src=\"/img/interesting-curve/6.png\" width=\"300\"><br><img src=\"/img/interesting-curve/7.png\" width=\"300\"><br><img src=\"/img/interesting-curve/8.png\" width=\"300\"><br><img src=\"/img/interesting-curve/9.jpg\" width=\"300\"><br><img src=\"/img/interesting-curve/10.png\" width=\"300\"><br><img src=\"/img/interesting-curve/11.png\" width=\"300\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>简单的数学原理其实很有趣</p>\n</blockquote>","more":"<p>直接上图：<br><img src=\"/img/interesting-curve/7.png\" width=\"300\"></p>\n<p>几日前在OF Course公众号看到一篇蛮有意思的文章－<a href=\"http://mp.weixin.qq.com/s?__biz=MzA4NTc5MDU5OQ==&amp;mid=411441608&amp;idx=1&amp;sn=5e846a882f58a7ba1b5312bdbeaafccf&amp;scene=23&amp;srcid=0120GiYhMXjmNDoN9MFQj7f5#rd\" target=\"_blank\" rel=\"external\">简单法则的魅力</a>，觉得里面的动效很有意思，能够基于简单的数学法则通过修改几个参数便画出千变万化的优美的曲线，实在有趣。而且这篇文章里还给出了代码，简直给力。</p>\n<p>于是忍不住，自己动手实现了一下，动态效果图如图，下面给出本人随意得出的其它曲线。</p>\n<p><img src=\"/img/interesting-curve/ring.gif\" width=\"300\"><br><img src=\"/img/interesting-curve/box.gif\" width=\"300\"><br><img src=\"/img/interesting-curve/1.png\" width=\"300\"><br><img src=\"/img/interesting-curve/2.png\" width=\"300\"><br><img src=\"/img/interesting-curve/3.png\" width=\"300\"><br><img src=\"/img/interesting-curve/4.png\" width=\"300\"><br><img src=\"/img/interesting-curve/5.png\" width=\"300\"><br><img src=\"/img/interesting-curve/6.png\" width=\"300\"><br><img src=\"/img/interesting-curve/7.png\" width=\"300\"><br><img src=\"/img/interesting-curve/8.png\" width=\"300\"><br><img src=\"/img/interesting-curve/9.jpg\" width=\"300\"><br><img src=\"/img/interesting-curve/10.png\" width=\"300\"><br><img src=\"/img/interesting-curve/11.png\" width=\"300\"></p>","sticky":0},{"title":"计划清单","date":"2016-02-20T11:09:52.000Z","commentIssueId":22,"_content":"\n本文长期更新，主要给自己用来记录计划要做的事项。\n\n<!-- more -->\n\n## 开源\n1. Android Fab\n\n2. 弹幕——好奇心日报\n\n## 博客\n1. Android - Drawable与bitmap、canvas、paint的关系\n2. SparseArray vs. HashMap LruCache on Android platform\n3. 100 Days of Google Dev series & Google I/O\n已完成：\n02 The Magic of LRU Cache\n进行中：\n65 Fun with ArrayMaps\n79 SparseArray Family Ties\n51 Smaller Pixel Formats\n59 Smaller PNG Files\n61 Android Development Patterns\n62 Re-using Bitmaps\n64 Android Performance Patterns – Performance Anxiety\n86 The price of ENUMs\n93 Double Layout Taxation\n100 Trimming and Sharing Memory\n排队：\n03 Google Play Services 7.5\n04 Push Notifications on the Open Web to increase engagement\n09 Using LINT for Performance Tips\n10 Supercharging page load\n11 Fingerprint and payments APIs\n12 Store Listing Experiments for Google Play\n16 Hidden Cost of Transparency\n17 Analyzing your App with Google Analytics\n20 New APIs in M for Android for Work\n21 Google Search for Developers\n23 Avoiding Allocations in onDraw()\n30 Strict Mode\n32 Promote your Apps with Google AdWords\n37 Custom Views and Performance\n38 Google’s International Fonts Noto\n41 Build a video chat app for Android, iOS and the Web\n44 Batching Background Work Until Later\n48 Introduction to the Physical Web\n72 Beware Autoboxing\n74 Google Play services 7.8\n75 Chat with Heidi Dohse about Cloud in Healthcare\n81 Introducing Face Detection in the Google Vision APIs\n88 Use WordPress APIs and Android Volley to build native apps\n89 Docker and Containers\n90 Developing for Android 6.0 Marshmallow\n95 Learn how to scale your applications with Google Compute Engine\n96 Chat with Sunil Vemuri about OK, Google\nhttps://www.youtube.com/watch?v=R5ON3iwx78M&index=2&list=PLOU2XLYxmsIJDPXCTt5TLDu67271PruEk\nhttp://www.ithome.com.tw/news/98805\nhttps://www.udacity.com/google\n\n4. Udacity TensorFlow by Google\n\n## idea\n1. 学习leancloud搭建后台，使用python flask，参考\nhttp://drakeet.me/leancloud-engine-guide\nhttp://drakeet.me/create-telegram-bot-with-python\n2. 开发个人微信公众号\n","source":"_posts/计划清单.md","raw":"title: 计划清单\ncategories:\n  - 年度计划\ndate: 2016-02-20 19:09:52\ntags:\ncommentIssueId: 22\n---\n\n本文长期更新，主要给自己用来记录计划要做的事项。\n\n<!-- more -->\n\n## 开源\n1. Android Fab\n\n2. 弹幕——好奇心日报\n\n## 博客\n1. Android - Drawable与bitmap、canvas、paint的关系\n2. SparseArray vs. HashMap LruCache on Android platform\n3. 100 Days of Google Dev series & Google I/O\n已完成：\n02 The Magic of LRU Cache\n进行中：\n65 Fun with ArrayMaps\n79 SparseArray Family Ties\n51 Smaller Pixel Formats\n59 Smaller PNG Files\n61 Android Development Patterns\n62 Re-using Bitmaps\n64 Android Performance Patterns – Performance Anxiety\n86 The price of ENUMs\n93 Double Layout Taxation\n100 Trimming and Sharing Memory\n排队：\n03 Google Play Services 7.5\n04 Push Notifications on the Open Web to increase engagement\n09 Using LINT for Performance Tips\n10 Supercharging page load\n11 Fingerprint and payments APIs\n12 Store Listing Experiments for Google Play\n16 Hidden Cost of Transparency\n17 Analyzing your App with Google Analytics\n20 New APIs in M for Android for Work\n21 Google Search for Developers\n23 Avoiding Allocations in onDraw()\n30 Strict Mode\n32 Promote your Apps with Google AdWords\n37 Custom Views and Performance\n38 Google’s International Fonts Noto\n41 Build a video chat app for Android, iOS and the Web\n44 Batching Background Work Until Later\n48 Introduction to the Physical Web\n72 Beware Autoboxing\n74 Google Play services 7.8\n75 Chat with Heidi Dohse about Cloud in Healthcare\n81 Introducing Face Detection in the Google Vision APIs\n88 Use WordPress APIs and Android Volley to build native apps\n89 Docker and Containers\n90 Developing for Android 6.0 Marshmallow\n95 Learn how to scale your applications with Google Compute Engine\n96 Chat with Sunil Vemuri about OK, Google\nhttps://www.youtube.com/watch?v=R5ON3iwx78M&index=2&list=PLOU2XLYxmsIJDPXCTt5TLDu67271PruEk\nhttp://www.ithome.com.tw/news/98805\nhttps://www.udacity.com/google\n\n4. Udacity TensorFlow by Google\n\n## idea\n1. 学习leancloud搭建后台，使用python flask，参考\nhttp://drakeet.me/leancloud-engine-guide\nhttp://drakeet.me/create-telegram-bot-with-python\n2. 开发个人微信公众号\n","slug":"计划清单","published":1,"updated":"2018-11-26T06:56:27.488Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplsgz000w3dn84vfzg0y9","content":"<p> 本文长期更新，主要给自己用来记录计划要做的事项。</p>\n<a id=\"more\"></a>\n<h2 id=\"开源\"><a href=\"# 开源\" class=\"headerlink\" title=\"开源\"></a> 开源 </h2><ol>\n<li><p>Android Fab</p>\n</li>\n<li><p> 弹幕——好奇心日报 </p>\n</li>\n</ol>\n<h2 id=\"博客\"><a href=\"# 博客\" class=\"headerlink\" title=\"博客\"></a> 博客 </h2><ol>\n<li>Android - Drawable 与 bitmap、canvas、paint 的关系 </li>\n<li>SparseArray vs. HashMap LruCache on Android platform</li>\n<li><p>100 Days of Google Dev series &amp; Google I/O<br> 已完成：<br>02 The Magic of LRU Cache<br> 进行中：<br>65 Fun with ArrayMaps<br>79 SparseArray Family Ties<br>51 Smaller Pixel Formats<br>59 Smaller PNG Files<br>61 Android Development Patterns<br>62 Re-using Bitmaps<br>64 Android Performance Patterns – Performance Anxiety<br>86 The price of ENUMs<br>93 Double Layout Taxation<br>100 Trimming and Sharing Memory<br> 排队：<br>03 Google Play Services 7.5<br>04 Push Notifications on the Open Web to increase engagement<br>09 Using LINT for Performance Tips<br>10 Supercharging page load<br>11 Fingerprint and payments APIs<br>12 Store Listing Experiments for Google Play<br>16 Hidden Cost of Transparency<br>17 Analyzing your App with Google Analytics<br>20 New APIs in M for Android for Work<br>21 Google Search for Developers<br>23 Avoiding Allocations in onDraw()<br>30 Strict Mode<br>32 Promote your Apps with Google AdWords<br>37 Custom Views and Performance<br>38 Google’s International Fonts Noto<br>41 Build a video chat app for Android, iOS and the Web<br>44 Batching Background Work Until Later<br>48 Introduction to the Physical Web<br>72 Beware Autoboxing<br>74 Google Play services 7.8<br>75 Chat with Heidi Dohse about Cloud in Healthcare<br>81 Introducing Face Detection in the Google Vision APIs<br>88 Use WordPress APIs and Android Volley to build native apps<br>89 Docker and Containers<br>90 Developing for Android 6.0 Marshmallow<br>95 Learn how to scale your applications with Google Compute Engine<br>96 Chat with Sunil Vemuri about OK, Google<br><a href=\"https://www.youtube.com/watch?v=R5ON3iwx78M&amp;index=2&amp;list=PLOU2XLYxmsIJDPXCTt5TLDu67271PruEk\" target=\"_blank\" rel=\"external\">https://www.youtube.com/watch?v=R5ON3iwx78M&amp;index=2&amp;list=PLOU2XLYxmsIJDPXCTt5TLDu67271PruEk</a><br><a href=\"http://www.ithome.com.tw/news/98805\" target=\"_blank\" rel=\"external\">http://www.ithome.com.tw/news/98805</a><br><a href=\"https://www.udacity.com/google\" target=\"_blank\" rel=\"external\">https://www.udacity.com/google</a></p>\n</li>\n<li><p>Udacity TensorFlow by Google</p>\n</li>\n</ol>\n<h2 id=\"idea\"><a href=\"#idea\" class=\"headerlink\" title=\"idea\"></a>idea</h2><ol>\n<li> 学习 leancloud 搭建后台，使用 python flask，参考 <br><a href=\"http://drakeet.me/leancloud-engine-guide\" target=\"_blank\" rel=\"external\">http://drakeet.me/leancloud-engine-guide</a><br><a href=\"http://drakeet.me/create-telegram-bot-with-python\" target=\"_blank\" rel=\"external\">http://drakeet.me/create-telegram-bot-with-python</a></li>\n<li> 开发个人微信公众号 </li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>本文长期更新，主要给自己用来记录计划要做的事项。</p>","more":"<h2 id=\"开源\"><a href=\"#开源\" class=\"headerlink\" title=\"开源\"></a>开源</h2><ol>\n<li><p>Android Fab</p>\n</li>\n<li><p>弹幕——好奇心日报</p>\n</li>\n</ol>\n<h2 id=\"博客\"><a href=\"#博客\" class=\"headerlink\" title=\"博客\"></a>博客</h2><ol>\n<li>Android - Drawable与bitmap、canvas、paint的关系</li>\n<li>SparseArray vs. HashMap LruCache on Android platform</li>\n<li><p>100 Days of Google Dev series &amp; Google I/O<br>已完成：<br>02 The Magic of LRU Cache<br>进行中：<br>65 Fun with ArrayMaps<br>79 SparseArray Family Ties<br>51 Smaller Pixel Formats<br>59 Smaller PNG Files<br>61 Android Development Patterns<br>62 Re-using Bitmaps<br>64 Android Performance Patterns – Performance Anxiety<br>86 The price of ENUMs<br>93 Double Layout Taxation<br>100 Trimming and Sharing Memory<br>排队：<br>03 Google Play Services 7.5<br>04 Push Notifications on the Open Web to increase engagement<br>09 Using LINT for Performance Tips<br>10 Supercharging page load<br>11 Fingerprint and payments APIs<br>12 Store Listing Experiments for Google Play<br>16 Hidden Cost of Transparency<br>17 Analyzing your App with Google Analytics<br>20 New APIs in M for Android for Work<br>21 Google Search for Developers<br>23 Avoiding Allocations in onDraw()<br>30 Strict Mode<br>32 Promote your Apps with Google AdWords<br>37 Custom Views and Performance<br>38 Google’s International Fonts Noto<br>41 Build a video chat app for Android, iOS and the Web<br>44 Batching Background Work Until Later<br>48 Introduction to the Physical Web<br>72 Beware Autoboxing<br>74 Google Play services 7.8<br>75 Chat with Heidi Dohse about Cloud in Healthcare<br>81 Introducing Face Detection in the Google Vision APIs<br>88 Use WordPress APIs and Android Volley to build native apps<br>89 Docker and Containers<br>90 Developing for Android 6.0 Marshmallow<br>95 Learn how to scale your applications with Google Compute Engine<br>96 Chat with Sunil Vemuri about OK, Google<br><a href=\"https://www.youtube.com/watch?v=R5ON3iwx78M&amp;index=2&amp;list=PLOU2XLYxmsIJDPXCTt5TLDu67271PruEk\" target=\"_blank\" rel=\"external\">https://www.youtube.com/watch?v=R5ON3iwx78M&amp;index=2&amp;list=PLOU2XLYxmsIJDPXCTt5TLDu67271PruEk</a><br><a href=\"http://www.ithome.com.tw/news/98805\" target=\"_blank\" rel=\"external\">http://www.ithome.com.tw/news/98805</a><br><a href=\"https://www.udacity.com/google\" target=\"_blank\" rel=\"external\">https://www.udacity.com/google</a></p>\n</li>\n<li><p>Udacity TensorFlow by Google</p>\n</li>\n</ol>\n<h2 id=\"idea\"><a href=\"#idea\" class=\"headerlink\" title=\"idea\"></a>idea</h2><ol>\n<li>学习leancloud搭建后台，使用python flask，参考<br><a href=\"http://drakeet.me/leancloud-engine-guide\" target=\"_blank\" rel=\"external\">http://drakeet.me/leancloud-engine-guide</a><br><a href=\"http://drakeet.me/create-telegram-bot-with-python\" target=\"_blank\" rel=\"external\">http://drakeet.me/create-telegram-bot-with-python</a></li>\n<li>开发个人微信公众号</li>\n</ol>","sticky":0},{"title":"梦想升起的地方","date":"2016-06-06T14:42:14.000Z","commentIssueId":null,"_content":"> 交大，你赋予了我很多。\n\n<!-- more -->\n\n![](http://wingjay.com/img/dream.jpg)\n\n好赖，我毕业了🎓。\n\n从本科毕业时懵懂迷茫的自己，到现在坚定方向不为所动的自己。\n\n两三年的磨砺，我成长了非常多。\n\n\n还是那句话，我热爱交大的一草一木，沉静深远，热爱这里共同奋斗努力的同窗好友，热爱每位聪明上进的年轻人。\n\n这一切让我不舍怀念。\n\n然后，生命的车轮总在向前，离别是迟早的。\n\n属于交大的记忆，留在交大。\n\n此刻的我，会继续向前。\n\n在交大，我找到了自己的梦；离开交大，我会将这个梦继续坚持下去。\n\n饮水思源。","source":"_posts/梦想升起的地方.md","raw":"title: 梦想升起的地方\ncategories:\n  - 随感\ntags:\n  - 随笔\ndate: 2016-06-06 22:42:14\ncommentIssueId: \n---\n> 交大，你赋予了我很多。\n\n<!-- more -->\n\n![](http://wingjay.com/img/dream.jpg)\n\n好赖，我毕业了🎓。\n\n从本科毕业时懵懂迷茫的自己，到现在坚定方向不为所动的自己。\n\n两三年的磨砺，我成长了非常多。\n\n\n还是那句话，我热爱交大的一草一木，沉静深远，热爱这里共同奋斗努力的同窗好友，热爱每位聪明上进的年轻人。\n\n这一切让我不舍怀念。\n\n然后，生命的车轮总在向前，离别是迟早的。\n\n属于交大的记忆，留在交大。\n\n此刻的我，会继续向前。\n\n在交大，我找到了自己的梦；离开交大，我会将这个梦继续坚持下去。\n\n饮水思源。","slug":"梦想升起的地方","published":1,"updated":"2018-11-26T06:56:27.487Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplsh100103dn817mk112f","content":"<blockquote>\n<p> 交大，你赋予了我很多。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p><img src=\"http://wingjay.com/img/dream.jpg\" alt=\"\"></p>\n<p> 好赖，我毕业了🎓。</p>\n<p> 从本科毕业时懵懂迷茫的自己，到现在坚定方向不为所动的自己。</p>\n<p> 两三年的磨砺，我成长了非常多。</p>\n<p> 还是那句话，我热爱交大的一草一木，沉静深远，热爱这里共同奋斗努力的同窗好友，热爱每位聪明上进的年轻人。</p>\n<p> 这一切让我不舍怀念。</p>\n<p> 然后，生命的车轮总在向前，离别是迟早的。</p>\n<p> 属于交大的记忆，留在交大。</p>\n<p> 此刻的我，会继续向前。</p>\n<p> 在交大，我找到了自己的梦；离开交大，我会将这个梦继续坚持下去。</p>\n<p> 饮水思源。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>交大，你赋予了我很多。</p>\n</blockquote>","more":"<p><img src=\"http://wingjay.com/img/dream.jpg\" alt=\"\"></p>\n<p>好赖，我毕业了🎓。</p>\n<p>从本科毕业时懵懂迷茫的自己，到现在坚定方向不为所动的自己。</p>\n<p>两三年的磨砺，我成长了非常多。</p>\n<p>还是那句话，我热爱交大的一草一木，沉静深远，热爱这里共同奋斗努力的同窗好友，热爱每位聪明上进的年轻人。</p>\n<p>这一切让我不舍怀念。</p>\n<p>然后，生命的车轮总在向前，离别是迟早的。</p>\n<p>属于交大的记忆，留在交大。</p>\n<p>此刻的我，会继续向前。</p>\n<p>在交大，我找到了自己的梦；离开交大，我会将这个梦继续坚持下去。</p>\n<p>饮水思源。</p>","sticky":0},{"title":"说一说我和博客","date":"2015-12-06T13:39:28.000Z","commentIssueId":null,"_content":"> 博客是个人的一方净土，记录技术成长，记录生活态度\n\n<!-- more -->\n\n![说一说我和博客](/img/me-and-blog.jpg)\n\n## 我和博客的那些事\n一直以来在各种平台上写过博客。\n\n最早在新浪、博客园。那时的博客是以笔记摘要为主，看一本书，摘抄几句话，即成一文。写多了，慢慢感觉意义不大，也极少回顾。或者说，写那些博客没有个人的思考，故果断弃之。\n\n然后，开始在[简书](http://www.jianshu.com/users/da333fd63fe5/latest_articles)上写，逐渐记录自己的思考和技术为主，如在学习Android中对系统机制的思考和总结。在简书上也偶有佳作得到大家的喜欢，比如[如何在一天之内完成一款具备cool属性的Android产品](http://www.jianshu.com/p/cf496fc408b2)、[如何阅读Android系统源码－收藏必备](http://www.jianshu.com/p/b3580904d298)。这也激励了我更加努力并分享出更多优质的原创内容。另外，最近也开通了Medium博客平台，不过那上面主要写英文文章，此不细讲。\n\n然后，就是大家看到的个人博客网站。前夜，洗澡后头发没干，就乘机坐在被窝里搭了自己的博客。以前觉得个人博客和简书这类公共博客没什么差异，不过现在却发觉个人博客令人思想更自由，可以记录一切，更不怕随着博客平台的更换而丢失。\n\n\n## 介绍下我的博客\n介绍博客之前，要先麻烦朋友记住一个名字：wingjay。为什么要记住它呢，因为域名是：wingjay.com啊！哈哈（冷）。\n\n目前我的博客内容是同时挂载在两个地方GitHub、GitCafe以同时支持两个域名访问。在此我要感谢这二位，让我省去一笔购买服务器的开销，也同时保证了国内国外都能正常访问。\n\n我的博客主要会包括**技术、艺术和思考**。\n\n - 技术，有两种。一是自己工作中接触到的技术如Android和服务器开发。另一种是自己认为很cool的技术，难道不是每个有追求的人都希望自己变得更cool吗？\n - 艺术，讲不清，包含很多。比如美好的移动设计或工业设计，比如一组让人心静的摄影作品，比如一杯凛冽粗暴的伏特加。这些都是我心中的艺术。\n - 思考，同样讲不清。不过我可以肯定的是，我的博客里每个文字都会出自自己的思考。比如对大爷大妈手牵手的思考，比如对某水果台各类脑残剧和琅琊榜对比的思考，比如对Google和Apple之争的思考。太多了。\n\n## 我为什么要写作\n我认为有两点。\n\n1. 博客是程序员的简历之一。对程序员而言，大多数人都是通过你的博客来认识你。而且，多写博客能促使我们去专研问题并与人分享，同时通过他人反馈来改善自我。\n2. 热爱。通过写作，我们可以记录思考，记录生活，记录技术成长。这难道不是一件很正能量的事情吗？\n\n## 我的写作风格\n简单，直接，文艺\n\n\n\n\n逗逼\n","source":"_posts/说一说博客.md","raw":"title: 说一说我和博客\ndate: 2015-12-06 21:39:28\ncategories:\n  - Blog\ntags: 随笔\ncommentIssueId:  \n---\n> 博客是个人的一方净土，记录技术成长，记录生活态度\n\n<!-- more -->\n\n![说一说我和博客](/img/me-and-blog.jpg)\n\n## 我和博客的那些事\n一直以来在各种平台上写过博客。\n\n最早在新浪、博客园。那时的博客是以笔记摘要为主，看一本书，摘抄几句话，即成一文。写多了，慢慢感觉意义不大，也极少回顾。或者说，写那些博客没有个人的思考，故果断弃之。\n\n然后，开始在[简书](http://www.jianshu.com/users/da333fd63fe5/latest_articles)上写，逐渐记录自己的思考和技术为主，如在学习Android中对系统机制的思考和总结。在简书上也偶有佳作得到大家的喜欢，比如[如何在一天之内完成一款具备cool属性的Android产品](http://www.jianshu.com/p/cf496fc408b2)、[如何阅读Android系统源码－收藏必备](http://www.jianshu.com/p/b3580904d298)。这也激励了我更加努力并分享出更多优质的原创内容。另外，最近也开通了Medium博客平台，不过那上面主要写英文文章，此不细讲。\n\n然后，就是大家看到的个人博客网站。前夜，洗澡后头发没干，就乘机坐在被窝里搭了自己的博客。以前觉得个人博客和简书这类公共博客没什么差异，不过现在却发觉个人博客令人思想更自由，可以记录一切，更不怕随着博客平台的更换而丢失。\n\n\n## 介绍下我的博客\n介绍博客之前，要先麻烦朋友记住一个名字：wingjay。为什么要记住它呢，因为域名是：wingjay.com啊！哈哈（冷）。\n\n目前我的博客内容是同时挂载在两个地方GitHub、GitCafe以同时支持两个域名访问。在此我要感谢这二位，让我省去一笔购买服务器的开销，也同时保证了国内国外都能正常访问。\n\n我的博客主要会包括**技术、艺术和思考**。\n\n - 技术，有两种。一是自己工作中接触到的技术如Android和服务器开发。另一种是自己认为很cool的技术，难道不是每个有追求的人都希望自己变得更cool吗？\n - 艺术，讲不清，包含很多。比如美好的移动设计或工业设计，比如一组让人心静的摄影作品，比如一杯凛冽粗暴的伏特加。这些都是我心中的艺术。\n - 思考，同样讲不清。不过我可以肯定的是，我的博客里每个文字都会出自自己的思考。比如对大爷大妈手牵手的思考，比如对某水果台各类脑残剧和琅琊榜对比的思考，比如对Google和Apple之争的思考。太多了。\n\n## 我为什么要写作\n我认为有两点。\n\n1. 博客是程序员的简历之一。对程序员而言，大多数人都是通过你的博客来认识你。而且，多写博客能促使我们去专研问题并与人分享，同时通过他人反馈来改善自我。\n2. 热爱。通过写作，我们可以记录思考，记录生活，记录技术成长。这难道不是一件很正能量的事情吗？\n\n## 我的写作风格\n简单，直接，文艺\n\n\n\n\n逗逼\n","slug":"说一说博客","published":1,"updated":"2018-11-26T06:56:27.488Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplsh200143dn8nh69xj4z","content":"<blockquote>\n<p>博客是个人的一方净土，记录技术成长，记录生活态度</p>\n</blockquote>\n<a id=\"more\"></a>\n<p><img src=\"/img/me-and-blog.jpg\" alt=\"说一说我和博客\"></p>\n<h2 id=\"我和博客的那些事\"><a href=\"# 我和博客的那些事\" class=\"headerlink\" title=\"我和博客的那些事\"></a>我和博客的那些事 </h2><p> 一直以来在各种平台上写过博客。</p>\n<p>最早在新浪、博客园。那时的博客是以笔记摘要为主，看一本书，摘抄几句话，即成一文。写多了，慢慢感觉意义不大，也极少回顾。或者说，写那些博客没有个人的思考，故果断弃之。</p>\n<p>然后，开始在 <a href=\"http://www.jianshu.com/users/da333fd63fe5/latest_articles\" target=\"_blank\" rel=\"external\"> 简书 </a> 上写，逐渐记录自己的思考和技术为主，如在学习 Android 中对系统机制的思考和总结。在简书上也偶有佳作得到大家的喜欢，比如 <a href=\"http://www.jianshu.com/p/cf496fc408b2\" target=\"_blank\" rel=\"external\"> 如何在一天之内完成一款具备 cool 属性的 Android 产品 </a>、<a href=\"http://www.jianshu.com/p/b3580904d298\" target=\"_blank\" rel=\"external\"> 如何阅读 Android 系统源码－收藏必备</a>。这也激励了我更加努力并分享出更多优质的原创内容。另外，最近也开通了 Medium 博客平台，不过那上面主要写英文文章，此不细讲。</p>\n<p>然后，就是大家看到的个人博客网站。前夜，洗澡后头发没干，就乘机坐在被窝里搭了自己的博客。以前觉得个人博客和简书这类公共博客没什么差异，不过现在却发觉个人博客令人思想更自由，可以记录一切，更不怕随着博客平台的更换而丢失。</p>\n<h2 id=\"介绍下我的博客\"><a href=\"# 介绍下我的博客\" class=\"headerlink\" title=\"介绍下我的博客\"></a>介绍下我的博客 </h2><p> 介绍博客之前，要先麻烦朋友记住一个名字：wingjay。为什么要记住它呢，因为域名是：wingjay.com 啊！哈哈（冷）。</p>\n<p>目前我的博客内容是同时挂载在两个地方 GitHub、GitCafe 以同时支持两个域名访问。在此我要感谢这二位，让我省去一笔购买服务器的开销，也同时保证了国内国外都能正常访问。</p>\n<p>我的博客主要会包括 <strong> 技术、艺术和思考</strong>。</p>\n<ul>\n<li>技术，有两种。一是自己工作中接触到的技术如 Android 和服务器开发。另一种是自己认为很 cool 的技术，难道不是每个有追求的人都希望自己变得更 cool 吗？</li>\n<li>艺术，讲不清，包含很多。比如美好的移动设计或工业设计，比如一组让人心静的摄影作品，比如一杯凛冽粗暴的伏特加。这些都是我心中的艺术。</li>\n<li>思考，同样讲不清。不过我可以肯定的是，我的博客里每个文字都会出自自己的思考。比如对大爷大妈手牵手的思考，比如对某水果台各类脑残剧和琅琊榜对比的思考，比如对 Google 和 Apple 之争的思考。太多了。</li>\n</ul>\n<h2 id=\"我为什么要写作\"><a href=\"# 我为什么要写作\" class=\"headerlink\" title=\"我为什么要写作\"></a>我为什么要写作 </h2><p> 我认为有两点。</p>\n<ol>\n<li>博客是程序员的简历之一。对程序员而言，大多数人都是通过你的博客来认识你。而且，多写博客能促使我们去专研问题并与人分享，同时通过他人反馈来改善自我。</li>\n<li>热爱。通过写作，我们可以记录思考，记录生活，记录技术成长。这难道不是一件很正能量的事情吗？</li>\n</ol>\n<h2 id=\"我的写作风格\"><a href=\"# 我的写作风格\" class=\"headerlink\" title=\"我的写作风格\"></a>我的写作风格 </h2><p> 简单，直接，文艺</p>\n<p>逗逼</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>博客是个人的一方净土，记录技术成长，记录生活态度</p>\n</blockquote>","more":"<p><img src=\"/img/me-and-blog.jpg\" alt=\"说一说我和博客\"></p>\n<h2 id=\"我和博客的那些事\"><a href=\"#我和博客的那些事\" class=\"headerlink\" title=\"我和博客的那些事\"></a>我和博客的那些事</h2><p>一直以来在各种平台上写过博客。</p>\n<p>最早在新浪、博客园。那时的博客是以笔记摘要为主，看一本书，摘抄几句话，即成一文。写多了，慢慢感觉意义不大，也极少回顾。或者说，写那些博客没有个人的思考，故果断弃之。</p>\n<p>然后，开始在<a href=\"http://www.jianshu.com/users/da333fd63fe5/latest_articles\" target=\"_blank\" rel=\"external\">简书</a>上写，逐渐记录自己的思考和技术为主，如在学习Android中对系统机制的思考和总结。在简书上也偶有佳作得到大家的喜欢，比如<a href=\"http://www.jianshu.com/p/cf496fc408b2\" target=\"_blank\" rel=\"external\">如何在一天之内完成一款具备cool属性的Android产品</a>、<a href=\"http://www.jianshu.com/p/b3580904d298\" target=\"_blank\" rel=\"external\">如何阅读Android系统源码－收藏必备</a>。这也激励了我更加努力并分享出更多优质的原创内容。另外，最近也开通了Medium博客平台，不过那上面主要写英文文章，此不细讲。</p>\n<p>然后，就是大家看到的个人博客网站。前夜，洗澡后头发没干，就乘机坐在被窝里搭了自己的博客。以前觉得个人博客和简书这类公共博客没什么差异，不过现在却发觉个人博客令人思想更自由，可以记录一切，更不怕随着博客平台的更换而丢失。</p>\n<h2 id=\"介绍下我的博客\"><a href=\"#介绍下我的博客\" class=\"headerlink\" title=\"介绍下我的博客\"></a>介绍下我的博客</h2><p>介绍博客之前，要先麻烦朋友记住一个名字：wingjay。为什么要记住它呢，因为域名是：wingjay.com啊！哈哈（冷）。</p>\n<p>目前我的博客内容是同时挂载在两个地方GitHub、GitCafe以同时支持两个域名访问。在此我要感谢这二位，让我省去一笔购买服务器的开销，也同时保证了国内国外都能正常访问。</p>\n<p>我的博客主要会包括<strong>技术、艺术和思考</strong>。</p>\n<ul>\n<li>技术，有两种。一是自己工作中接触到的技术如Android和服务器开发。另一种是自己认为很cool的技术，难道不是每个有追求的人都希望自己变得更cool吗？</li>\n<li>艺术，讲不清，包含很多。比如美好的移动设计或工业设计，比如一组让人心静的摄影作品，比如一杯凛冽粗暴的伏特加。这些都是我心中的艺术。</li>\n<li>思考，同样讲不清。不过我可以肯定的是，我的博客里每个文字都会出自自己的思考。比如对大爷大妈手牵手的思考，比如对某水果台各类脑残剧和琅琊榜对比的思考，比如对Google和Apple之争的思考。太多了。</li>\n</ul>\n<h2 id=\"我为什么要写作\"><a href=\"#我为什么要写作\" class=\"headerlink\" title=\"我为什么要写作\"></a>我为什么要写作</h2><p>我认为有两点。</p>\n<ol>\n<li>博客是程序员的简历之一。对程序员而言，大多数人都是通过你的博客来认识你。而且，多写博客能促使我们去专研问题并与人分享，同时通过他人反馈来改善自我。</li>\n<li>热爱。通过写作，我们可以记录思考，记录生活，记录技术成长。这难道不是一件很正能量的事情吗？</li>\n</ol>\n<h2 id=\"我的写作风格\"><a href=\"#我的写作风格\" class=\"headerlink\" title=\"我的写作风格\"></a>我的写作风格</h2><p>简单，直接，文艺</p>\n<p>逗逼</p>","sticky":0},{"title":"30 条 Android 开发建议","date":"2016-03-15T04:03:03.000Z","commentIssueId":17,"_content":">    There are two kinds of people ：\n     those who learn the hard way and those who learn by taking someone’s advice. \n\n<!-- more -->\n\n本文主要用来收集Android开发中积累的一些宝贵经验，这些经验中有一些约定熟成且经过检验的建议，有一些结合最新技术的实践。无论是菜鸟还是大神，都应该学会阅读别人的经验，并结合自己的思考转化成对自己有用的知识，这才是最快的成长之路。另外，对于这些建议，我会尽量翔实的进行说明以确保能够顺利快速应用到实际开发中。\n\n## 介绍\n下面以这篇文章：[Building Android Apps — 30 things that experience made me learn the hard way](https://medium.com/@cesarmcferreira/building-android-apps-30-things-that-experience-made-me-learn-the-hard-way-313680430bf9#.efowqynql)为核心，对其中提出的每一点建议进行较为深入的分析探究，最终整理成一篇完整的文章。当然，本文还在不断更新中。\n\n#### 第三方库 \n在你添加每一个third party library之前，请认真考虑是否真的需要这个library。\n#### OverDraw\n如果用户看不到，那就不要进行绘制(draw)，或者说，不要`过度绘制 OverDraw`\n`OverDraw`会导致GPU浪费，也会导致app的速度变慢。为了减少这种危害，我们可以利用[`Debug GPU Overdraw Tool`](http://developer.android.com/tools/performance/debug-gpu-overdraw/index.html)来观察app里的绘制情况，然后可以使用[Hierarchy Viewer](http://developer.android.com/tools/performance/hierarchy-viewer/index.html)来进行优化。 \n#### 数据库\n除非不得不，否则不要使用`database`\n#### 65k methods limit\n`Dalvik 65K methods limit`你很快就会遇到的，不过放心，[`multidexing`](https://medium.com/@rotxed/dex-skys-the-limit-no-65k-methods-is-28e6cb40cf71)会帮助你。\n什么是`Dalvik 65K methods limit`？我们知道，我们写完java code之后，dx tool会把java编译成Dalivik虚拟机能识别的`DEX`文件，这个文件里最多能够索引`65536个method`。关于这个有两点要注意：\n1. 这些method是指能够`索引(reference)`到的，而不是`定义(define)`的。或者说，如果你定义了一个方法，但这个方法并没有被调用，那么就不算在内。\n2. 这些method不仅仅是开发人员自己写的，还包括所有第三方library里面的method。\n\n所以，我们总共可以索引`65536`个方法，包括自己写的和引入第三方库里的。\n那么，我们如何能快速知道我们的app里已经有多少个method了呢？    \n- bash script: [dex-method-counts](https://github.com/mihaip/dex-method-counts)。这个工具可以快速计算，并且提供一个清晰的视图来阅读。\n- [dex.sh](https://gist.github.com/JakeWharton/6002797) by Jake Wharton。这个工具由于采用了递归算法，所以耗时比较长。(Jake大神还写了一篇有趣的分析文章[Play Services 5.0 Is A Monolith Abomination](http://jakewharton.com/play-services-is-a-monolith/)，针对Play Services 5.0太大的问题进行了分析，有空时我再翻译下给各位。虽然[Play Services 6.5已经模块化，更加轻量级了](http://android-developers.blogspot.it/2014/12/google-play-services-and-dex-method.html)）。\n     \n现在，既然我们已经知道了自家app里的method数了，那么如何来处理这种情况呢？\n- [Multidex](http://developer.android.com/tools/building/multidex.html)，官方提供的解决方案，[这篇文章](http://blog.osom.info/2014/10/multi-dex-to-rescue-from-infamous-65536.html)里有详细的使用方法，此不赘述。\n- [ProGuard](http://developer.android.com/tools/help/proguard.html)\n`ProGuard`可以把code里unnecessary的method移除，压缩apk，当然还有`代码混淆`的奇效。\n- 再创建一个`DEX File`。把app里可以独立的模块或code提取出来，放到一个独立的dex文件里，你可以使用[Custom ClassLoader](http://android-developers.blogspot.it/2011/07/custom-class-loading-in-dalvik.html)来加载这些类，然后使用`接口`或`反射`来调用这些方法。不过，这个过程还是比较麻烦的。\n\n#### `RxJava, RxAndroid & Retrolambda`\n使用前可以通过[这篇gist](https://gist.github.com/cesarferreira/510aa2456dc0879f559f#file-rxjava-md)来了解[RxJava](https://github.com/ReactiveX/RxJava)＋[RxAndroid](https://github.com/ReactiveX/RxAndroid)＋[Retrolambda](https://github.com/orfjackal/retrolambda)的结合用法。这个组合可以优雅的在不同线程中处理事务，同时能够方便的实现数据流动和及时响应，而且Retrolambda能够精简你的code。其中，核心的两个概念是`Observables`和`Subscribers`，前者对外提供数据，后者监听并消费这些数据。\n另外，这里有一个看起来不错的项目[Learning RxJava for Android by example](https://github.com/kaushikgopal/RxJava-Android-Samples)，等空闲时再去阅读下code。\n\n#### `Retrofit` ＋ RxJava\n利用[Retrofit](http://square.github.io/retrofit/)与RxJava结合，为你的app提供网络请求服务。\n你可以参考这个[超赞的例子](https://gist.github.com/cesarferreira/da1e8fc5742ab1e581b7)，让你快速感受二者结合使用方法。\n\n#### 按`feature`来分package，而不是按`layer`\n这是这篇文章提出的一个点，文中认为分package就像公司安排座位，要按照`team`来分而不是按照每个人的职位来分，即按照负责一个app的`developer、designer、pm`坐在一起，而不是把所有`developer`坐在一起，所有`designer`坐在一起。所以，原文作者认为把一个feature相关的如`Activity ` `adapter`等都放在一起。\n\n不过，我认为按feature也有坏处，那就是`复用`，拿adapter来讲，一个app里很多adapter是类似且可以复用的，如果我们把各个adapter拆倒各个角落里，就很难提取其中的关联来创建一个`BaseAdapter`了。而且，`不同feature之间也有很多公用的东西`，比如一个自定义view，那就很难界定应该放在哪个feature包里了。相反，我们把所有自定义view放在一起，这样也有助于我们发现某些自定义view的区别，然后在refactor时可以提取公用的东西来`复用`。\n\n关于这点，欢迎读者给出自己意见。\n\n#### Gradle 加速\n参考[这篇文章](https://medium.com/the-engineering-team/speeding-up-gradle-builds-619c442113cb#.vpoaqdivn)来加速你的Gradle\n\n#### 架构：使用clean Architecture\n这里有两篇优质文章:[Architecting Android…The clean way?](http://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/)和[Architecting Android…The evolution](http://fernandocejas.com/2015/07/18/architecting-android-the-evolution/) 分别介绍并用code实现了一个Clean架构。后面我也会专门分析下这种架构，因为对于任何一个project而言，最初的好的架构是非常重要的！所以，如果你想提高自己，那么`架构`这一关是必经之路。\n\n#### 测试你的app\n虽然做测试需要花费你不少时间，但一旦你完成了这一步，以后的开发会更加快速，app也会更加稳定。\n这里有个哥们，[对`unit test`进行了细致的点评](http://stackoverflow.com/a/67500/794485)。\n\n#### 使用`依赖注入`神器`Dagger`\n如果你不知道什么是`依赖注入`，你可以先读一下这篇文章[Dependency injection on Android: Dagger (Part 1)](http://antonioleiva.com/dependency-injection-android-dagger-part-1/)，或者这篇[依赖注入](https://github.com/android-cn/blog/tree/master/java/dependency-injection)。简单来说，依赖注入替代了传统创建对象的`new`操作，当需要创建一个class的实例时，使用依赖注入从外部直接获取一个实例，具体这个实例是如何创建的不需要关心，由一个对象库统一管理每个对象的创建过程，并直接对外提供对象。这样做的好处是我们不用管实例是怎么创建的，这种抽象可以使得每个对象的创建过程变得可扩展性，只要在对象库里修改一次，那么所有用到这个实例的地方都随之变更。例如在测试时，我们希望某个mock某个对象的数据，就可以修改注入的对象。\n\n依赖注入有不少工具，不过[Dagger2](http://google.github.io/dagger/)使用的是`编译时代码生成(code generation)`方式而不是`反射(reflection)`，所以它的性能比较出众。[这篇文章](http://fernandocejas.com/2015/04/11/tasting-dagger-2-on-android/)有对Dagger2的实践和分析。\n\n#### EditText\n[对EditText使用合适的输入类型](http://developer.android.com/training/keyboard-input/style.html)\n\n#### 关注新的开源library\n你可以通过[Android Arsenal](http://android-arsenal.com/cc)来保持对开源项目的关注，同时利用这个工具[dryrun](https://github.com/cesarferreira/dryrun)来快速将开源项目跑在genymotion以看到实际效果。\n\n#### Service\n如果你创建了Service，那么一旦这个Service完成了自己的使命，就应该立即清理掉它\n\n#### AccountManager\n使用[AccountManager](http://developer.android.com/reference/android/accounts/AccountManager.html)来统一管理用户的帐号密码。\n\n#### 使用`持续集成CI(Continuous Integration)`来编译并发布你的beta和release build\n持续集成可以帮助你方便的编译并发布项目，不过，不要去搭建你们自己的CI服务器，因为你需要花费太多的时间来处理硬盘空间、安全问题和预防SSL攻击等问题。你可以尝试Jenkins、circleci、 travis 或者 shippable，这些价格并不贵，而且能帮你省很多事情。\n\n#### 自动发布到Play Store\n你可以使用这个工具[gradle-play-publisher](https://github.com/Triple-T/gradle-play-publisher)来帮助你自动上传apk到Play Store上\n\n#### 开始考虑用svg替代png\n理由很简单，android developer应该很熟悉每次导入一张图片时都需要生成四五种不同大小的png图片并放入到对应文件夹。与其维护这么多图片，显然使用一张svg图片更加方便。而且，google也在不断提供相关的支持，除了基本的[Vector Drawable](http://developer.android.com/tools/help/vector-asset-studio.html)，从最新的[Support Library](http://android-developers.blogspot.com/2016/02/android-support-library-232.html)我们也能看到google也在鼓励developer们使用svg。\n\n不过，svg也有自己的限制，比如它比较适合小icon，因为它最终会生成bitmap加载以供显示，所以这需要一定的cpu支持。当然总体来讲svg还是更优的，至少大家可以不用再维护四五张不同尺寸的图片了。\n\n#### 将一些library的类进行抽象，从而方便后期替换library\n例如，一旦我们打log会使用`Log.i()`，但是，如果后面我们突然想换成`Timber.i()`就会很麻烦，需要一个个log找到来替换。但是，如果我们抽象出一个`AppLogger`来，全部调用`AppLogger.i()`来记log，那么我们只要简单的在`AppLogger`内部替换掉具体实现就可以了。\n\n#### 监控网络连接类型，区分`移动数据流量`和`Wi-Fi`；同样，可以监控`电量`和`充电状态`\n对于不同网络类型，我们可以动态改变我们的UI，比如大图可以选择在`Wi-Fi`下才加载，而在`移动数据流量`则不加载。对于`电量`也是类似的逻辑。用户一定会很感谢app做的这种自适应的。\n\n#### User Interface is like a joke.If you have to explain it, it's not that good.\n\n#### 先写slow但是right的代码，再去进行优化\n\n## 小结\n本文长期更新，会保持跟踪最新的技术和研究实践经验，为大家提供有效有用的经验，少走坑。\n\n谢谢！\n\nwingjay\n\n\n\n\n\n欢迎各位关注\n[我的Github](https://github.com/wingjay): <https://github.com/wingjay> \n和 \n[我的个人博客](http://wingjay.com): <http://wingjay.com>\n和\n[我的简书](http://www.jianshu.com/users/da333fd63fe5/latest_articles): <http://www.jianshu.com/users/da333fd63fe5/latest_articles>\n和\n[微博 iam_wingjay](http://weibo.com/u/1625892654): <http://weibo.com/u/1625892654>\n如果有问题，可以给我留言或发邮件<mailto:yinjiesh@126.com>\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n","source":"_posts/30条Android开发建议.md","raw":"title: 30条Android开发建议\ndate: 2016-03-15 12:03:03\ncategories:\n  - Android\ntags: \n\t- Android\ncommentIssueId: 17\t\n---\n>    There are two kinds of people ：\n     those who learn the hard way and those who learn by taking someone’s advice. \n\n<!-- more -->\n\n本文主要用来收集Android开发中积累的一些宝贵经验，这些经验中有一些约定熟成且经过检验的建议，有一些结合最新技术的实践。无论是菜鸟还是大神，都应该学会阅读别人的经验，并结合自己的思考转化成对自己有用的知识，这才是最快的成长之路。另外，对于这些建议，我会尽量翔实的进行说明以确保能够顺利快速应用到实际开发中。\n\n## 介绍\n下面以这篇文章：[Building Android Apps — 30 things that experience made me learn the hard way](https://medium.com/@cesarmcferreira/building-android-apps-30-things-that-experience-made-me-learn-the-hard-way-313680430bf9#.efowqynql)为核心，对其中提出的每一点建议进行较为深入的分析探究，最终整理成一篇完整的文章。当然，本文还在不断更新中。\n\n#### 第三方库 \n在你添加每一个third party library之前，请认真考虑是否真的需要这个library。\n#### OverDraw\n如果用户看不到，那就不要进行绘制(draw)，或者说，不要`过度绘制 OverDraw`\n`OverDraw`会导致GPU浪费，也会导致app的速度变慢。为了减少这种危害，我们可以利用[`Debug GPU Overdraw Tool`](http://developer.android.com/tools/performance/debug-gpu-overdraw/index.html)来观察app里的绘制情况，然后可以使用[Hierarchy Viewer](http://developer.android.com/tools/performance/hierarchy-viewer/index.html)来进行优化。 \n#### 数据库\n除非不得不，否则不要使用`database`\n#### 65k methods limit\n`Dalvik 65K methods limit`你很快就会遇到的，不过放心，[`multidexing`](https://medium.com/@rotxed/dex-skys-the-limit-no-65k-methods-is-28e6cb40cf71)会帮助你。\n什么是`Dalvik 65K methods limit`？我们知道，我们写完java code之后，dx tool会把java编译成Dalivik虚拟机能识别的`DEX`文件，这个文件里最多能够索引`65536个method`。关于这个有两点要注意：\n1. 这些method是指能够`索引(reference)`到的，而不是`定义(define)`的。或者说，如果你定义了一个方法，但这个方法并没有被调用，那么就不算在内。\n2. 这些method不仅仅是开发人员自己写的，还包括所有第三方library里面的method。\n\n所以，我们总共可以索引`65536`个方法，包括自己写的和引入第三方库里的。\n那么，我们如何能快速知道我们的app里已经有多少个method了呢？    \n- bash script: [dex-method-counts](https://github.com/mihaip/dex-method-counts)。这个工具可以快速计算，并且提供一个清晰的视图来阅读。\n- [dex.sh](https://gist.github.com/JakeWharton/6002797) by Jake Wharton。这个工具由于采用了递归算法，所以耗时比较长。(Jake大神还写了一篇有趣的分析文章[Play Services 5.0 Is A Monolith Abomination](http://jakewharton.com/play-services-is-a-monolith/)，针对Play Services 5.0太大的问题进行了分析，有空时我再翻译下给各位。虽然[Play Services 6.5已经模块化，更加轻量级了](http://android-developers.blogspot.it/2014/12/google-play-services-and-dex-method.html)）。\n     \n现在，既然我们已经知道了自家app里的method数了，那么如何来处理这种情况呢？\n- [Multidex](http://developer.android.com/tools/building/multidex.html)，官方提供的解决方案，[这篇文章](http://blog.osom.info/2014/10/multi-dex-to-rescue-from-infamous-65536.html)里有详细的使用方法，此不赘述。\n- [ProGuard](http://developer.android.com/tools/help/proguard.html)\n`ProGuard`可以把code里unnecessary的method移除，压缩apk，当然还有`代码混淆`的奇效。\n- 再创建一个`DEX File`。把app里可以独立的模块或code提取出来，放到一个独立的dex文件里，你可以使用[Custom ClassLoader](http://android-developers.blogspot.it/2011/07/custom-class-loading-in-dalvik.html)来加载这些类，然后使用`接口`或`反射`来调用这些方法。不过，这个过程还是比较麻烦的。\n\n#### `RxJava, RxAndroid & Retrolambda`\n使用前可以通过[这篇gist](https://gist.github.com/cesarferreira/510aa2456dc0879f559f#file-rxjava-md)来了解[RxJava](https://github.com/ReactiveX/RxJava)＋[RxAndroid](https://github.com/ReactiveX/RxAndroid)＋[Retrolambda](https://github.com/orfjackal/retrolambda)的结合用法。这个组合可以优雅的在不同线程中处理事务，同时能够方便的实现数据流动和及时响应，而且Retrolambda能够精简你的code。其中，核心的两个概念是`Observables`和`Subscribers`，前者对外提供数据，后者监听并消费这些数据。\n另外，这里有一个看起来不错的项目[Learning RxJava for Android by example](https://github.com/kaushikgopal/RxJava-Android-Samples)，等空闲时再去阅读下code。\n\n#### `Retrofit` ＋ RxJava\n利用[Retrofit](http://square.github.io/retrofit/)与RxJava结合，为你的app提供网络请求服务。\n你可以参考这个[超赞的例子](https://gist.github.com/cesarferreira/da1e8fc5742ab1e581b7)，让你快速感受二者结合使用方法。\n\n#### 按`feature`来分package，而不是按`layer`\n这是这篇文章提出的一个点，文中认为分package就像公司安排座位，要按照`team`来分而不是按照每个人的职位来分，即按照负责一个app的`developer、designer、pm`坐在一起，而不是把所有`developer`坐在一起，所有`designer`坐在一起。所以，原文作者认为把一个feature相关的如`Activity ` `adapter`等都放在一起。\n\n不过，我认为按feature也有坏处，那就是`复用`，拿adapter来讲，一个app里很多adapter是类似且可以复用的，如果我们把各个adapter拆倒各个角落里，就很难提取其中的关联来创建一个`BaseAdapter`了。而且，`不同feature之间也有很多公用的东西`，比如一个自定义view，那就很难界定应该放在哪个feature包里了。相反，我们把所有自定义view放在一起，这样也有助于我们发现某些自定义view的区别，然后在refactor时可以提取公用的东西来`复用`。\n\n关于这点，欢迎读者给出自己意见。\n\n#### Gradle 加速\n参考[这篇文章](https://medium.com/the-engineering-team/speeding-up-gradle-builds-619c442113cb#.vpoaqdivn)来加速你的Gradle\n\n#### 架构：使用clean Architecture\n这里有两篇优质文章:[Architecting Android…The clean way?](http://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/)和[Architecting Android…The evolution](http://fernandocejas.com/2015/07/18/architecting-android-the-evolution/) 分别介绍并用code实现了一个Clean架构。后面我也会专门分析下这种架构，因为对于任何一个project而言，最初的好的架构是非常重要的！所以，如果你想提高自己，那么`架构`这一关是必经之路。\n\n#### 测试你的app\n虽然做测试需要花费你不少时间，但一旦你完成了这一步，以后的开发会更加快速，app也会更加稳定。\n这里有个哥们，[对`unit test`进行了细致的点评](http://stackoverflow.com/a/67500/794485)。\n\n#### 使用`依赖注入`神器`Dagger`\n如果你不知道什么是`依赖注入`，你可以先读一下这篇文章[Dependency injection on Android: Dagger (Part 1)](http://antonioleiva.com/dependency-injection-android-dagger-part-1/)，或者这篇[依赖注入](https://github.com/android-cn/blog/tree/master/java/dependency-injection)。简单来说，依赖注入替代了传统创建对象的`new`操作，当需要创建一个class的实例时，使用依赖注入从外部直接获取一个实例，具体这个实例是如何创建的不需要关心，由一个对象库统一管理每个对象的创建过程，并直接对外提供对象。这样做的好处是我们不用管实例是怎么创建的，这种抽象可以使得每个对象的创建过程变得可扩展性，只要在对象库里修改一次，那么所有用到这个实例的地方都随之变更。例如在测试时，我们希望某个mock某个对象的数据，就可以修改注入的对象。\n\n依赖注入有不少工具，不过[Dagger2](http://google.github.io/dagger/)使用的是`编译时代码生成(code generation)`方式而不是`反射(reflection)`，所以它的性能比较出众。[这篇文章](http://fernandocejas.com/2015/04/11/tasting-dagger-2-on-android/)有对Dagger2的实践和分析。\n\n#### EditText\n[对EditText使用合适的输入类型](http://developer.android.com/training/keyboard-input/style.html)\n\n#### 关注新的开源library\n你可以通过[Android Arsenal](http://android-arsenal.com/cc)来保持对开源项目的关注，同时利用这个工具[dryrun](https://github.com/cesarferreira/dryrun)来快速将开源项目跑在genymotion以看到实际效果。\n\n#### Service\n如果你创建了Service，那么一旦这个Service完成了自己的使命，就应该立即清理掉它\n\n#### AccountManager\n使用[AccountManager](http://developer.android.com/reference/android/accounts/AccountManager.html)来统一管理用户的帐号密码。\n\n#### 使用`持续集成CI(Continuous Integration)`来编译并发布你的beta和release build\n持续集成可以帮助你方便的编译并发布项目，不过，不要去搭建你们自己的CI服务器，因为你需要花费太多的时间来处理硬盘空间、安全问题和预防SSL攻击等问题。你可以尝试Jenkins、circleci、 travis 或者 shippable，这些价格并不贵，而且能帮你省很多事情。\n\n#### 自动发布到Play Store\n你可以使用这个工具[gradle-play-publisher](https://github.com/Triple-T/gradle-play-publisher)来帮助你自动上传apk到Play Store上\n\n#### 开始考虑用svg替代png\n理由很简单，android developer应该很熟悉每次导入一张图片时都需要生成四五种不同大小的png图片并放入到对应文件夹。与其维护这么多图片，显然使用一张svg图片更加方便。而且，google也在不断提供相关的支持，除了基本的[Vector Drawable](http://developer.android.com/tools/help/vector-asset-studio.html)，从最新的[Support Library](http://android-developers.blogspot.com/2016/02/android-support-library-232.html)我们也能看到google也在鼓励developer们使用svg。\n\n不过，svg也有自己的限制，比如它比较适合小icon，因为它最终会生成bitmap加载以供显示，所以这需要一定的cpu支持。当然总体来讲svg还是更优的，至少大家可以不用再维护四五张不同尺寸的图片了。\n\n#### 将一些library的类进行抽象，从而方便后期替换library\n例如，一旦我们打log会使用`Log.i()`，但是，如果后面我们突然想换成`Timber.i()`就会很麻烦，需要一个个log找到来替换。但是，如果我们抽象出一个`AppLogger`来，全部调用`AppLogger.i()`来记log，那么我们只要简单的在`AppLogger`内部替换掉具体实现就可以了。\n\n#### 监控网络连接类型，区分`移动数据流量`和`Wi-Fi`；同样，可以监控`电量`和`充电状态`\n对于不同网络类型，我们可以动态改变我们的UI，比如大图可以选择在`Wi-Fi`下才加载，而在`移动数据流量`则不加载。对于`电量`也是类似的逻辑。用户一定会很感谢app做的这种自适应的。\n\n#### User Interface is like a joke.If you have to explain it, it's not that good.\n\n#### 先写slow但是right的代码，再去进行优化\n\n## 小结\n本文长期更新，会保持跟踪最新的技术和研究实践经验，为大家提供有效有用的经验，少走坑。\n\n谢谢！\n\nwingjay\n\n\n\n\n\n欢迎各位关注\n[我的Github](https://github.com/wingjay): <https://github.com/wingjay> \n和 \n[我的个人博客](http://wingjay.com): <http://wingjay.com>\n和\n[我的简书](http://www.jianshu.com/users/da333fd63fe5/latest_articles): <http://www.jianshu.com/users/da333fd63fe5/latest_articles>\n和\n[微博 iam_wingjay](http://weibo.com/u/1625892654): <http://weibo.com/u/1625892654>\n如果有问题，可以给我留言或发邮件<mailto:yinjiesh@126.com>\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n","slug":"30条Android开发建议","published":1,"updated":"2018-11-26T06:56:27.479Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplsht00213dn8vcmo5skd","content":"<blockquote>\n<p>   There are two kinds of people ：<br>     those who learn the hard way and those who learn by taking someone’s advice. </p>\n</blockquote>\n<a id=\"more\"></a>\n<p>本文主要用来收集 Android 开发中积累的一些宝贵经验，这些经验中有一些约定熟成且经过检验的建议，有一些结合最新技术的实践。无论是菜鸟还是大神，都应该学会阅读别人的经验，并结合自己的思考转化成对自己有用的知识，这才是最快的成长之路。另外，对于这些建议，我会尽量翔实的进行说明以确保能够顺利快速应用到实际开发中。</p>\n<h2 id=\"介绍\"><a href=\"# 介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍 </h2><p> 下面以这篇文章：<a href=\"https://medium.com/@cesarmcferreira/building-android-apps-30-things-that-experience-made-me-learn-the-hard-way-313680430bf9#.efowqynql\" target=\"_blank\" rel=\"external\">Building Android Apps — 30 things that experience made me learn the hard way</a>为核心，对其中提出的每一点建议进行较为深入的分析探究，最终整理成一篇完整的文章。当然，本文还在不断更新中。</p>\n<h4 id=\"第三方库\"><a href=\"# 第三方库\" class=\"headerlink\" title=\"第三方库\"></a>第三方库 </h4><p> 在你添加每一个 third party library 之前，请认真考虑是否真的需要这个 library。</p>\n<h4 id=\"OverDraw\"><a href=\"#OverDraw\" class=\"headerlink\" title=\"OverDraw\"></a>OverDraw</h4><p>如果用户看不到，那就不要进行绘制 (draw)，或者说，不要<code> 过度绘制 OverDraw</code><br><code>OverDraw</code>会导致 GPU 浪费，也会导致 app 的速度变慢。为了减少这种危害，我们可以利用 <a href=\"http://developer.android.com/tools/performance/debug-gpu-overdraw/index.html\" target=\"_blank\" rel=\"external\"><code>Debug GPU Overdraw Tool</code></a> 来观察 app 里的绘制情况，然后可以使用 <a href=\"http://developer.android.com/tools/performance/hierarchy-viewer/index.html\" target=\"_blank\" rel=\"external\">Hierarchy Viewer</a> 来进行优化。 </p>\n<h4 id=\"数据库\"><a href=\"# 数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库 </h4><p> 除非不得不，否则不要使用<code>database</code></p>\n<h4 id=\"65k-methods-limit\"><a href=\"#65k-methods-limit\" class=\"headerlink\" title=\"65k methods limit\"></a>65k methods limit</h4><p><code>Dalvik 65K methods limit</code>你很快就会遇到的，不过放心，<a href=\"https://medium.com/@rotxed/dex-skys-the-limit-no-65k-methods-is-28e6cb40cf71\" target=\"_blank\" rel=\"external\"><code>multidexing</code></a>会帮助你。<br>什么是 <code>Dalvik 65K methods limit</code>？我们知道，我们写完 java code 之后，dx tool 会把 java 编译成 Dalivik 虚拟机能识别的<code>DEX</code> 文件，这个文件里最多能够索引<code>65536 个 method</code>。关于这个有两点要注意：</p>\n<ol>\n<li>这些 method 是指能够 <code> 索引 (reference)</code> 到的，而不是 <code> 定义 (define)</code> 的。或者说，如果你定义了一个方法，但这个方法并没有被调用，那么就不算在内。</li>\n<li>这些 method 不仅仅是开发人员自己写的，还包括所有第三方 library 里面的 method。</li>\n</ol>\n<p>所以，我们总共可以索引 <code>65536</code> 个方法，包括自己写的和引入第三方库里的。<br>那么，我们如何能快速知道我们的 app 里已经有多少个 method 了呢？    </p>\n<ul>\n<li>bash script: <a href=\"https://github.com/mihaip/dex-method-counts\" target=\"_blank\" rel=\"external\">dex-method-counts</a>。这个工具可以快速计算，并且提供一个清晰的视图来阅读。</li>\n<li><a href=\"https://gist.github.com/JakeWharton/6002797\" target=\"_blank\" rel=\"external\">dex.sh</a> by Jake Wharton。这个工具由于采用了递归算法，所以耗时比较长。(Jake 大神还写了一篇有趣的分析文章<a href=\"http://jakewharton.com/play-services-is-a-monolith/\" target=\"_blank\" rel=\"external\">Play Services 5.0 Is A Monolith Abomination</a>，针对 Play Services 5.0 太大的问题进行了分析，有空时我再翻译下给各位。虽然<a href=\"http://android-developers.blogspot.it/2014/12/google-play-services-and-dex-method.html\" target=\"_blank\" rel=\"external\">Play Services 6.5 已经模块化，更加轻量级了</a>）。</li>\n</ul>\n<p>现在，既然我们已经知道了自家 app 里的 method 数了，那么如何来处理这种情况呢？</p>\n<ul>\n<li><a href=\"http://developer.android.com/tools/building/multidex.html\" target=\"_blank\" rel=\"external\">Multidex</a>，官方提供的解决方案，<a href=\"http://blog.osom.info/2014/10/multi-dex-to-rescue-from-infamous-65536.html\" target=\"_blank\" rel=\"external\">这篇文章 </a> 里有详细的使用方法，此不赘述。</li>\n<li><a href=\"http://developer.android.com/tools/help/proguard.html\" target=\"_blank\" rel=\"external\">ProGuard</a><br><code>ProGuard</code>可以把 code 里 unnecessary 的 method 移除，压缩 apk，当然还有 <code> 代码混淆 </code> 的奇效。</li>\n<li>再创建一个 <code>DEX File</code>。把 app 里可以独立的模块或 code 提取出来，放到一个独立的 dex 文件里，你可以使用<a href=\"http://android-developers.blogspot.it/2011/07/custom-class-loading-in-dalvik.html\" target=\"_blank\" rel=\"external\">Custom ClassLoader</a> 来加载这些类，然后使用 <code> 接口 </code> 或<code>反射 </code> 来调用这些方法。不过，这个过程还是比较麻烦的。</li>\n</ul>\n<h4 id=\"RxJava-RxAndroid-amp-Retrolambda\"><a href=\"#RxJava-RxAndroid-amp-Retrolambda\" class=\"headerlink\" title=\"RxJava, RxAndroid &amp; Retrolambda\"></a><code>RxJava, RxAndroid &amp; Retrolambda</code></h4><p>使用前可以通过 <a href=\"https://gist.github.com/cesarferreira/510aa2456dc0879f559f#file-rxjava-md\" target=\"_blank\" rel=\"external\"> 这篇 gist</a>来了解 <a href=\"https://github.com/ReactiveX/RxJava\" target=\"_blank\" rel=\"external\">RxJava</a>＋<a href=\"https://github.com/ReactiveX/RxAndroid\" target=\"_blank\" rel=\"external\">RxAndroid</a>＋<a href=\"https://github.com/orfjackal/retrolambda\" target=\"_blank\" rel=\"external\">Retrolambda</a> 的结合用法。这个组合可以优雅的在不同线程中处理事务，同时能够方便的实现数据流动和及时响应，而且 Retrolambda 能够精简你的 code。其中，核心的两个概念是 <code>Observables</code> 和<code>Subscribers</code>，前者对外提供数据，后者监听并消费这些数据。<br>另外，这里有一个看起来不错的项目<a href=\"https://github.com/kaushikgopal/RxJava-Android-Samples\" target=\"_blank\" rel=\"external\">Learning RxJava for Android by example</a>，等空闲时再去阅读下 code。</p>\n<h4 id=\"Retrofit-＋-RxJava\"><a href=\"#Retrofit-＋-RxJava\" class=\"headerlink\" title=\"Retrofit ＋ RxJava\"></a><code>Retrofit</code> ＋ RxJava</h4><p>利用 <a href=\"http://square.github.io/retrofit/\" target=\"_blank\" rel=\"external\">Retrofit</a> 与 RxJava 结合，为你的 app 提供网络请求服务。<br>你可以参考这个 <a href=\"https://gist.github.com/cesarferreira/da1e8fc5742ab1e581b7\" target=\"_blank\" rel=\"external\"> 超赞的例子</a>，让你快速感受二者结合使用方法。</p>\n<h4 id=\"按 feature 来分 package，而不是按 layer\"><a href=\"# 按 feature 来分 package，而不是按 layer\" class=\"headerlink\" title=\"按 feature 来分 package，而不是按 layer\"></a>按 <code>feature</code> 来分 package，而不是按 <code>layer</code></h4><p> 这是这篇文章提出的一个点，文中认为分 package 就像公司安排座位，要按照 <code>team</code> 来分而不是按照每个人的职位来分，即按照负责一个 app 的 <code>developer、designer、pm</code> 坐在一起，而不是把所有 <code>developer</code> 坐在一起，所有 <code>designer</code> 坐在一起。所以，原文作者认为把一个 feature 相关的如 <code>Activity</code> <code>adapter</code> 等都放在一起。</p>\n<p>不过，我认为按 feature 也有坏处，那就是 <code> 复用 </code>，拿 adapter 来讲，一个 app 里很多 adapter 是类似且可以复用的，如果我们把各个 adapter 拆倒各个角落里，就很难提取其中的关联来创建一个<code>BaseAdapter</code> 了。而且，<code>不同 feature 之间也有很多公用的东西 </code>，比如一个自定义 view，那就很难界定应该放在哪个 feature 包里了。相反，我们把所有自定义 view 放在一起，这样也有助于我们发现某些自定义 view 的区别，然后在 refactor 时可以提取公用的东西来<code> 复用</code>。</p>\n<p>关于这点，欢迎读者给出自己意见。</p>\n<h4 id=\"Gradle- 加速\"><a href=\"#Gradle- 加速\" class=\"headerlink\" title=\"Gradle 加速\"></a>Gradle 加速 </h4><p> 参考 <a href=\"https://medium.com/the-engineering-team/speeding-up-gradle-builds-619c442113cb#.vpoaqdivn\" target=\"_blank\" rel=\"external\"> 这篇文章 </a> 来加速你的 Gradle</p>\n<h4 id=\"架构：使用 clean-Architecture\"><a href=\"# 架构：使用 clean-Architecture\" class=\"headerlink\" title=\"架构：使用 clean Architecture\"></a>架构：使用 clean Architecture</h4><p>这里有两篇优质文章:<a href=\"http://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/\" target=\"_blank\" rel=\"external\">Architecting Android…The clean way?</a>和 <a href=\"http://fernandocejas.com/2015/07/18/architecting-android-the-evolution/\" target=\"_blank\" rel=\"external\">Architecting Android…The evolution</a> 分别介绍并用 code 实现了一个 Clean 架构。后面我也会专门分析下这种架构，因为对于任何一个 project 而言，最初的好的架构是非常重要的！所以，如果你想提高自己，那么<code> 架构 </code> 这一关是必经之路。</p>\n<h4 id=\"测试你的 app\"><a href=\"# 测试你的 app\" class=\"headerlink\" title=\"测试你的 app\"></a>测试你的 app</h4><p>虽然做测试需要花费你不少时间，但一旦你完成了这一步，以后的开发会更加快速，app 也会更加稳定。<br>这里有个哥们，<a href=\"http://stackoverflow.com/a/67500/794485\" target=\"_blank\" rel=\"external\">对 <code>unit test</code> 进行了细致的点评</a>。</p>\n<h4 id=\"使用依赖注入神器 Dagger\"><a href=\"# 使用依赖注入神器 Dagger\" class=\"headerlink\" title=\"使用依赖注入神器 Dagger\"></a>使用 <code> 依赖注入 </code> 神器 <code>Dagger</code></h4><p> 如果你不知道什么是 <code> 依赖注入 </code>，你可以先读一下这篇文章<a href=\"http://antonioleiva.com/dependency-injection-android-dagger-part-1/\" target=\"_blank\" rel=\"external\">Dependency injection on Android: Dagger (Part 1)</a>，或者这篇<a href=\"https://github.com/android-cn/blog/tree/master/java/dependency-injection\" target=\"_blank\" rel=\"external\"> 依赖注入 </a>。简单来说，依赖注入替代了传统创建对象的<code>new</code> 操作，当需要创建一个 class 的实例时，使用依赖注入从外部直接获取一个实例，具体这个实例是如何创建的不需要关心，由一个对象库统一管理每个对象的创建过程，并直接对外提供对象。这样做的好处是我们不用管实例是怎么创建的，这种抽象可以使得每个对象的创建过程变得可扩展性，只要在对象库里修改一次，那么所有用到这个实例的地方都随之变更。例如在测试时，我们希望某个 mock 某个对象的数据，就可以修改注入的对象。</p>\n<p>依赖注入有不少工具，不过 <a href=\"http://google.github.io/dagger/\" target=\"_blank\" rel=\"external\">Dagger2</a> 使用的是 <code> 编译时代码生成 (code generation)</code> 方式而不是 <code> 反射 (reflection)</code>，所以它的性能比较出众。<a href=\"http://fernandocejas.com/2015/04/11/tasting-dagger-2-on-android/\" target=\"_blank\" rel=\"external\"> 这篇文章 </a> 有对 Dagger2 的实践和分析。</p>\n<h4 id=\"EditText\"><a href=\"#EditText\" class=\"headerlink\" title=\"EditText\"></a>EditText</h4><p><a href=\"http://developer.android.com/training/keyboard-input/style.html\" target=\"_blank\" rel=\"external\">对 EditText 使用合适的输入类型</a></p>\n<h4 id=\"关注新的开源 library\"><a href=\"# 关注新的开源 library\" class=\"headerlink\" title=\"关注新的开源 library\"></a>关注新的开源 library</h4><p>你可以通过 <a href=\"http://android-arsenal.com/cc\" target=\"_blank\" rel=\"external\">Android Arsenal</a> 来保持对开源项目的关注，同时利用这个工具 <a href=\"https://github.com/cesarferreira/dryrun\" target=\"_blank\" rel=\"external\">dryrun</a> 来快速将开源项目跑在 genymotion 以看到实际效果。</p>\n<h4 id=\"Service\"><a href=\"#Service\" class=\"headerlink\" title=\"Service\"></a>Service</h4><p>如果你创建了 Service，那么一旦这个 Service 完成了自己的使命，就应该立即清理掉它</p>\n<h4 id=\"AccountManager\"><a href=\"#AccountManager\" class=\"headerlink\" title=\"AccountManager\"></a>AccountManager</h4><p>使用 <a href=\"http://developer.android.com/reference/android/accounts/AccountManager.html\" target=\"_blank\" rel=\"external\">AccountManager</a> 来统一管理用户的帐号密码。</p>\n<h4 id=\"使用持续集成 CI-Continuous-Integration- 来编译并发布你的 beta 和 release-build\"><a href=\"# 使用持续集成 CI-Continuous-Integration- 来编译并发布你的 beta 和 release-build\" class=\"headerlink\" title=\"使用持续集成 CI(Continuous Integration)来编译并发布你的 beta 和 release build\"></a>使用 <code> 持续集成 CI(Continuous Integration)</code>来编译并发布你的 beta 和 release build</h4><p>持续集成可以帮助你方便的编译并发布项目，不过，不要去搭建你们自己的 CI 服务器，因为你需要花费太多的时间来处理硬盘空间、安全问题和预防 SSL 攻击等问题。你可以尝试 Jenkins、circleci、 travis 或者 shippable，这些价格并不贵，而且能帮你省很多事情。</p>\n<h4 id=\"自动发布到 Play-Store\"><a href=\"# 自动发布到 Play-Store\" class=\"headerlink\" title=\"自动发布到 Play Store\"></a>自动发布到 Play Store</h4><p>你可以使用这个工具 <a href=\"https://github.com/Triple-T/gradle-play-publisher\" target=\"_blank\" rel=\"external\">gradle-play-publisher</a> 来帮助你自动上传 apk 到 Play Store 上</p>\n<h4 id=\"开始考虑用 svg 替代 png\"><a href=\"# 开始考虑用 svg 替代 png\" class=\"headerlink\" title=\"开始考虑用 svg 替代 png\"></a>开始考虑用 svg 替代 png</h4><p>理由很简单，android developer 应该很熟悉每次导入一张图片时都需要生成四五种不同大小的 png 图片并放入到对应文件夹。与其维护这么多图片，显然使用一张 svg 图片更加方便。而且，google 也在不断提供相关的支持，除了基本的 <a href=\"http://developer.android.com/tools/help/vector-asset-studio.html\" target=\"_blank\" rel=\"external\">Vector Drawable</a>，从最新的<a href=\"http://android-developers.blogspot.com/2016/02/android-support-library-232.html\" target=\"_blank\" rel=\"external\">Support Library</a> 我们也能看到 google 也在鼓励 developer 们使用 svg。</p>\n<p>不过，svg 也有自己的限制，比如它比较适合小 icon，因为它最终会生成 bitmap 加载以供显示，所以这需要一定的 cpu 支持。当然总体来讲 svg 还是更优的，至少大家可以不用再维护四五张不同尺寸的图片了。</p>\n<h4 id=\"将一些 library 的类进行抽象，从而方便后期替换 library\"><a href=\"# 将一些 library 的类进行抽象，从而方便后期替换 library\" class=\"headerlink\" title=\"将一些 library 的类进行抽象，从而方便后期替换 library\"></a>将一些 library 的类进行抽象，从而方便后期替换 library</h4><p>例如，一旦我们打 log 会使用 <code>Log.i()</code>，但是，如果后面我们突然想换成<code>Timber.i()</code> 就会很麻烦，需要一个个 log 找到来替换。但是，如果我们抽象出一个 <code>AppLogger</code> 来，全部调用 <code>AppLogger.i()</code> 来记 log，那么我们只要简单的在 <code>AppLogger</code> 内部替换掉具体实现就可以了。</p>\n<h4 id=\"监控网络连接类型，区分移动数据流量和 Wi-Fi；同样，可以监控电量和充电状态\"><a href=\"# 监控网络连接类型，区分移动数据流量和 Wi-Fi；同样，可以监控电量和充电状态\" class=\"headerlink\" title=\"监控网络连接类型，区分移动数据流量和 Wi-Fi；同样，可以监控电量和充电状态\"></a>监控网络连接类型，区分 <code> 移动数据流量 </code> 和<code>Wi-Fi</code>；同样，可以监控 <code> 电量 </code> 和<code>充电状态 </code></h4><p> 对于不同网络类型，我们可以动态改变我们的 UI，比如大图可以选择在 <code>Wi-Fi</code> 下才加载，而在 <code> 移动数据流量 </code> 则不加载。对于 <code> 电量 </code> 也是类似的逻辑。用户一定会很感谢 app 做的这种自适应的。</p>\n<h4 id=\"User-Interface-is-like-a-joke-If-you-have-to-explain-it-it’s-not-that-good\"><a href=\"#User-Interface-is-like-a-joke-If-you-have-to-explain-it-it’s-not-that-good\" class=\"headerlink\" title=\"User Interface is like a joke.If you have to explain it, it’s not that good.\"></a>User Interface is like a joke.If you have to explain it, it’s not that good.</h4><h4 id=\"先写 slow 但是 right 的代码，再去进行优化\"><a href=\"# 先写 slow 但是 right 的代码，再去进行优化\" class=\"headerlink\" title=\"先写 slow 但是 right 的代码，再去进行优化\"></a>先写 slow 但是 right 的代码，再去进行优化 </h4><h2 id=\"小结\"><a href=\"# 小结\" class=\"headerlink\" title=\"小结\"></a> 小结 </h2><p> 本文长期更新，会保持跟踪最新的技术和研究实践经验，为大家提供有效有用的经验，少走坑。</p>\n<p>谢谢！</p>\n<p>wingjay</p>\n<p>欢迎各位关注 <br><a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\"> 我的 Github</a>: <a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\">https://github.com/wingjay</a><br>和 <br><a href=\"http://wingjay.com\"> 我的个人博客 </a>: <a href=\"http://wingjay.com\">http://wingjay.com</a><br> 和<br><a href=\"http://www.jianshu.com/users/da333fd63fe5/latest_articles\" target=\"_blank\" rel=\"external\">我的简书 </a>: <a href=\"http://www.jianshu.com/users/da333fd63fe5/latest_articles\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/users/da333fd63fe5/latest_articles</a><br> 和<br><a href=\"http://weibo.com/u/1625892654\" target=\"_blank\" rel=\"external\">微博 iam_wingjay</a>: <a href=\"http://weibo.com/u/1625892654\" target=\"_blank\" rel=\"external\">http://weibo.com/u/1625892654</a><br>如果有问题，可以给我留言或发邮件<a href=\"&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x79;&#105;&#x6e;&#x6a;&#105;&#101;&#x73;&#104;&#x40;&#x31;&#x32;&#x36;&#x2e;&#99;&#111;&#109;\">&#x79;&#105;&#x6e;&#x6a;&#105;&#101;&#x73;&#104;&#x40;&#x31;&#x32;&#x36;&#x2e;&#99;&#111;&#109;</a></p>\n<p><img src=\"https://avatars0.githubusercontent.com/u/9619875?v=3&amp;s=460\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>   There are two kinds of people ：<br>     those who learn the hard way and those who learn by taking someone’s advice. </p>\n</blockquote>","more":"<p>本文主要用来收集Android开发中积累的一些宝贵经验，这些经验中有一些约定熟成且经过检验的建议，有一些结合最新技术的实践。无论是菜鸟还是大神，都应该学会阅读别人的经验，并结合自己的思考转化成对自己有用的知识，这才是最快的成长之路。另外，对于这些建议，我会尽量翔实的进行说明以确保能够顺利快速应用到实际开发中。</p>\n<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>下面以这篇文章：<a href=\"https://medium.com/@cesarmcferreira/building-android-apps-30-things-that-experience-made-me-learn-the-hard-way-313680430bf9#.efowqynql\" target=\"_blank\" rel=\"external\">Building Android Apps — 30 things that experience made me learn the hard way</a>为核心，对其中提出的每一点建议进行较为深入的分析探究，最终整理成一篇完整的文章。当然，本文还在不断更新中。</p>\n<h4 id=\"第三方库\"><a href=\"#第三方库\" class=\"headerlink\" title=\"第三方库\"></a>第三方库</h4><p>在你添加每一个third party library之前，请认真考虑是否真的需要这个library。</p>\n<h4 id=\"OverDraw\"><a href=\"#OverDraw\" class=\"headerlink\" title=\"OverDraw\"></a>OverDraw</h4><p>如果用户看不到，那就不要进行绘制(draw)，或者说，不要<code>过度绘制 OverDraw</code><br><code>OverDraw</code>会导致GPU浪费，也会导致app的速度变慢。为了减少这种危害，我们可以利用<a href=\"http://developer.android.com/tools/performance/debug-gpu-overdraw/index.html\" target=\"_blank\" rel=\"external\"><code>Debug GPU Overdraw Tool</code></a>来观察app里的绘制情况，然后可以使用<a href=\"http://developer.android.com/tools/performance/hierarchy-viewer/index.html\" target=\"_blank\" rel=\"external\">Hierarchy Viewer</a>来进行优化。 </p>\n<h4 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h4><p>除非不得不，否则不要使用<code>database</code></p>\n<h4 id=\"65k-methods-limit\"><a href=\"#65k-methods-limit\" class=\"headerlink\" title=\"65k methods limit\"></a>65k methods limit</h4><p><code>Dalvik 65K methods limit</code>你很快就会遇到的，不过放心，<a href=\"https://medium.com/@rotxed/dex-skys-the-limit-no-65k-methods-is-28e6cb40cf71\" target=\"_blank\" rel=\"external\"><code>multidexing</code></a>会帮助你。<br>什么是<code>Dalvik 65K methods limit</code>？我们知道，我们写完java code之后，dx tool会把java编译成Dalivik虚拟机能识别的<code>DEX</code>文件，这个文件里最多能够索引<code>65536个method</code>。关于这个有两点要注意：</p>\n<ol>\n<li>这些method是指能够<code>索引(reference)</code>到的，而不是<code>定义(define)</code>的。或者说，如果你定义了一个方法，但这个方法并没有被调用，那么就不算在内。</li>\n<li>这些method不仅仅是开发人员自己写的，还包括所有第三方library里面的method。</li>\n</ol>\n<p>所以，我们总共可以索引<code>65536</code>个方法，包括自己写的和引入第三方库里的。<br>那么，我们如何能快速知道我们的app里已经有多少个method了呢？    </p>\n<ul>\n<li>bash script: <a href=\"https://github.com/mihaip/dex-method-counts\" target=\"_blank\" rel=\"external\">dex-method-counts</a>。这个工具可以快速计算，并且提供一个清晰的视图来阅读。</li>\n<li><a href=\"https://gist.github.com/JakeWharton/6002797\" target=\"_blank\" rel=\"external\">dex.sh</a> by Jake Wharton。这个工具由于采用了递归算法，所以耗时比较长。(Jake大神还写了一篇有趣的分析文章<a href=\"http://jakewharton.com/play-services-is-a-monolith/\" target=\"_blank\" rel=\"external\">Play Services 5.0 Is A Monolith Abomination</a>，针对Play Services 5.0太大的问题进行了分析，有空时我再翻译下给各位。虽然<a href=\"http://android-developers.blogspot.it/2014/12/google-play-services-and-dex-method.html\" target=\"_blank\" rel=\"external\">Play Services 6.5已经模块化，更加轻量级了</a>）。</li>\n</ul>\n<p>现在，既然我们已经知道了自家app里的method数了，那么如何来处理这种情况呢？</p>\n<ul>\n<li><a href=\"http://developer.android.com/tools/building/multidex.html\" target=\"_blank\" rel=\"external\">Multidex</a>，官方提供的解决方案，<a href=\"http://blog.osom.info/2014/10/multi-dex-to-rescue-from-infamous-65536.html\" target=\"_blank\" rel=\"external\">这篇文章</a>里有详细的使用方法，此不赘述。</li>\n<li><a href=\"http://developer.android.com/tools/help/proguard.html\" target=\"_blank\" rel=\"external\">ProGuard</a><br><code>ProGuard</code>可以把code里unnecessary的method移除，压缩apk，当然还有<code>代码混淆</code>的奇效。</li>\n<li>再创建一个<code>DEX File</code>。把app里可以独立的模块或code提取出来，放到一个独立的dex文件里，你可以使用<a href=\"http://android-developers.blogspot.it/2011/07/custom-class-loading-in-dalvik.html\" target=\"_blank\" rel=\"external\">Custom ClassLoader</a>来加载这些类，然后使用<code>接口</code>或<code>反射</code>来调用这些方法。不过，这个过程还是比较麻烦的。</li>\n</ul>\n<h4 id=\"RxJava-RxAndroid-amp-Retrolambda\"><a href=\"#RxJava-RxAndroid-amp-Retrolambda\" class=\"headerlink\" title=\"RxJava, RxAndroid &amp; Retrolambda\"></a><code>RxJava, RxAndroid &amp; Retrolambda</code></h4><p>使用前可以通过<a href=\"https://gist.github.com/cesarferreira/510aa2456dc0879f559f#file-rxjava-md\" target=\"_blank\" rel=\"external\">这篇gist</a>来了解<a href=\"https://github.com/ReactiveX/RxJava\" target=\"_blank\" rel=\"external\">RxJava</a>＋<a href=\"https://github.com/ReactiveX/RxAndroid\" target=\"_blank\" rel=\"external\">RxAndroid</a>＋<a href=\"https://github.com/orfjackal/retrolambda\" target=\"_blank\" rel=\"external\">Retrolambda</a>的结合用法。这个组合可以优雅的在不同线程中处理事务，同时能够方便的实现数据流动和及时响应，而且Retrolambda能够精简你的code。其中，核心的两个概念是<code>Observables</code>和<code>Subscribers</code>，前者对外提供数据，后者监听并消费这些数据。<br>另外，这里有一个看起来不错的项目<a href=\"https://github.com/kaushikgopal/RxJava-Android-Samples\" target=\"_blank\" rel=\"external\">Learning RxJava for Android by example</a>，等空闲时再去阅读下code。</p>\n<h4 id=\"Retrofit-＋-RxJava\"><a href=\"#Retrofit-＋-RxJava\" class=\"headerlink\" title=\"Retrofit ＋ RxJava\"></a><code>Retrofit</code> ＋ RxJava</h4><p>利用<a href=\"http://square.github.io/retrofit/\" target=\"_blank\" rel=\"external\">Retrofit</a>与RxJava结合，为你的app提供网络请求服务。<br>你可以参考这个<a href=\"https://gist.github.com/cesarferreira/da1e8fc5742ab1e581b7\" target=\"_blank\" rel=\"external\">超赞的例子</a>，让你快速感受二者结合使用方法。</p>\n<h4 id=\"按feature来分package，而不是按layer\"><a href=\"#按feature来分package，而不是按layer\" class=\"headerlink\" title=\"按feature来分package，而不是按layer\"></a>按<code>feature</code>来分package，而不是按<code>layer</code></h4><p>这是这篇文章提出的一个点，文中认为分package就像公司安排座位，要按照<code>team</code>来分而不是按照每个人的职位来分，即按照负责一个app的<code>developer、designer、pm</code>坐在一起，而不是把所有<code>developer</code>坐在一起，所有<code>designer</code>坐在一起。所以，原文作者认为把一个feature相关的如<code>Activity</code> <code>adapter</code>等都放在一起。</p>\n<p>不过，我认为按feature也有坏处，那就是<code>复用</code>，拿adapter来讲，一个app里很多adapter是类似且可以复用的，如果我们把各个adapter拆倒各个角落里，就很难提取其中的关联来创建一个<code>BaseAdapter</code>了。而且，<code>不同feature之间也有很多公用的东西</code>，比如一个自定义view，那就很难界定应该放在哪个feature包里了。相反，我们把所有自定义view放在一起，这样也有助于我们发现某些自定义view的区别，然后在refactor时可以提取公用的东西来<code>复用</code>。</p>\n<p>关于这点，欢迎读者给出自己意见。</p>\n<h4 id=\"Gradle-加速\"><a href=\"#Gradle-加速\" class=\"headerlink\" title=\"Gradle 加速\"></a>Gradle 加速</h4><p>参考<a href=\"https://medium.com/the-engineering-team/speeding-up-gradle-builds-619c442113cb#.vpoaqdivn\" target=\"_blank\" rel=\"external\">这篇文章</a>来加速你的Gradle</p>\n<h4 id=\"架构：使用clean-Architecture\"><a href=\"#架构：使用clean-Architecture\" class=\"headerlink\" title=\"架构：使用clean Architecture\"></a>架构：使用clean Architecture</h4><p>这里有两篇优质文章:<a href=\"http://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/\" target=\"_blank\" rel=\"external\">Architecting Android…The clean way?</a>和<a href=\"http://fernandocejas.com/2015/07/18/architecting-android-the-evolution/\" target=\"_blank\" rel=\"external\">Architecting Android…The evolution</a> 分别介绍并用code实现了一个Clean架构。后面我也会专门分析下这种架构，因为对于任何一个project而言，最初的好的架构是非常重要的！所以，如果你想提高自己，那么<code>架构</code>这一关是必经之路。</p>\n<h4 id=\"测试你的app\"><a href=\"#测试你的app\" class=\"headerlink\" title=\"测试你的app\"></a>测试你的app</h4><p>虽然做测试需要花费你不少时间，但一旦你完成了这一步，以后的开发会更加快速，app也会更加稳定。<br>这里有个哥们，<a href=\"http://stackoverflow.com/a/67500/794485\" target=\"_blank\" rel=\"external\">对<code>unit test</code>进行了细致的点评</a>。</p>\n<h4 id=\"使用依赖注入神器Dagger\"><a href=\"#使用依赖注入神器Dagger\" class=\"headerlink\" title=\"使用依赖注入神器Dagger\"></a>使用<code>依赖注入</code>神器<code>Dagger</code></h4><p>如果你不知道什么是<code>依赖注入</code>，你可以先读一下这篇文章<a href=\"http://antonioleiva.com/dependency-injection-android-dagger-part-1/\" target=\"_blank\" rel=\"external\">Dependency injection on Android: Dagger (Part 1)</a>，或者这篇<a href=\"https://github.com/android-cn/blog/tree/master/java/dependency-injection\" target=\"_blank\" rel=\"external\">依赖注入</a>。简单来说，依赖注入替代了传统创建对象的<code>new</code>操作，当需要创建一个class的实例时，使用依赖注入从外部直接获取一个实例，具体这个实例是如何创建的不需要关心，由一个对象库统一管理每个对象的创建过程，并直接对外提供对象。这样做的好处是我们不用管实例是怎么创建的，这种抽象可以使得每个对象的创建过程变得可扩展性，只要在对象库里修改一次，那么所有用到这个实例的地方都随之变更。例如在测试时，我们希望某个mock某个对象的数据，就可以修改注入的对象。</p>\n<p>依赖注入有不少工具，不过<a href=\"http://google.github.io/dagger/\" target=\"_blank\" rel=\"external\">Dagger2</a>使用的是<code>编译时代码生成(code generation)</code>方式而不是<code>反射(reflection)</code>，所以它的性能比较出众。<a href=\"http://fernandocejas.com/2015/04/11/tasting-dagger-2-on-android/\" target=\"_blank\" rel=\"external\">这篇文章</a>有对Dagger2的实践和分析。</p>\n<h4 id=\"EditText\"><a href=\"#EditText\" class=\"headerlink\" title=\"EditText\"></a>EditText</h4><p><a href=\"http://developer.android.com/training/keyboard-input/style.html\" target=\"_blank\" rel=\"external\">对EditText使用合适的输入类型</a></p>\n<h4 id=\"关注新的开源library\"><a href=\"#关注新的开源library\" class=\"headerlink\" title=\"关注新的开源library\"></a>关注新的开源library</h4><p>你可以通过<a href=\"http://android-arsenal.com/cc\" target=\"_blank\" rel=\"external\">Android Arsenal</a>来保持对开源项目的关注，同时利用这个工具<a href=\"https://github.com/cesarferreira/dryrun\" target=\"_blank\" rel=\"external\">dryrun</a>来快速将开源项目跑在genymotion以看到实际效果。</p>\n<h4 id=\"Service\"><a href=\"#Service\" class=\"headerlink\" title=\"Service\"></a>Service</h4><p>如果你创建了Service，那么一旦这个Service完成了自己的使命，就应该立即清理掉它</p>\n<h4 id=\"AccountManager\"><a href=\"#AccountManager\" class=\"headerlink\" title=\"AccountManager\"></a>AccountManager</h4><p>使用<a href=\"http://developer.android.com/reference/android/accounts/AccountManager.html\" target=\"_blank\" rel=\"external\">AccountManager</a>来统一管理用户的帐号密码。</p>\n<h4 id=\"使用持续集成CI-Continuous-Integration-来编译并发布你的beta和release-build\"><a href=\"#使用持续集成CI-Continuous-Integration-来编译并发布你的beta和release-build\" class=\"headerlink\" title=\"使用持续集成CI(Continuous Integration)来编译并发布你的beta和release build\"></a>使用<code>持续集成CI(Continuous Integration)</code>来编译并发布你的beta和release build</h4><p>持续集成可以帮助你方便的编译并发布项目，不过，不要去搭建你们自己的CI服务器，因为你需要花费太多的时间来处理硬盘空间、安全问题和预防SSL攻击等问题。你可以尝试Jenkins、circleci、 travis 或者 shippable，这些价格并不贵，而且能帮你省很多事情。</p>\n<h4 id=\"自动发布到Play-Store\"><a href=\"#自动发布到Play-Store\" class=\"headerlink\" title=\"自动发布到Play Store\"></a>自动发布到Play Store</h4><p>你可以使用这个工具<a href=\"https://github.com/Triple-T/gradle-play-publisher\" target=\"_blank\" rel=\"external\">gradle-play-publisher</a>来帮助你自动上传apk到Play Store上</p>\n<h4 id=\"开始考虑用svg替代png\"><a href=\"#开始考虑用svg替代png\" class=\"headerlink\" title=\"开始考虑用svg替代png\"></a>开始考虑用svg替代png</h4><p>理由很简单，android developer应该很熟悉每次导入一张图片时都需要生成四五种不同大小的png图片并放入到对应文件夹。与其维护这么多图片，显然使用一张svg图片更加方便。而且，google也在不断提供相关的支持，除了基本的<a href=\"http://developer.android.com/tools/help/vector-asset-studio.html\" target=\"_blank\" rel=\"external\">Vector Drawable</a>，从最新的<a href=\"http://android-developers.blogspot.com/2016/02/android-support-library-232.html\" target=\"_blank\" rel=\"external\">Support Library</a>我们也能看到google也在鼓励developer们使用svg。</p>\n<p>不过，svg也有自己的限制，比如它比较适合小icon，因为它最终会生成bitmap加载以供显示，所以这需要一定的cpu支持。当然总体来讲svg还是更优的，至少大家可以不用再维护四五张不同尺寸的图片了。</p>\n<h4 id=\"将一些library的类进行抽象，从而方便后期替换library\"><a href=\"#将一些library的类进行抽象，从而方便后期替换library\" class=\"headerlink\" title=\"将一些library的类进行抽象，从而方便后期替换library\"></a>将一些library的类进行抽象，从而方便后期替换library</h4><p>例如，一旦我们打log会使用<code>Log.i()</code>，但是，如果后面我们突然想换成<code>Timber.i()</code>就会很麻烦，需要一个个log找到来替换。但是，如果我们抽象出一个<code>AppLogger</code>来，全部调用<code>AppLogger.i()</code>来记log，那么我们只要简单的在<code>AppLogger</code>内部替换掉具体实现就可以了。</p>\n<h4 id=\"监控网络连接类型，区分移动数据流量和Wi-Fi；同样，可以监控电量和充电状态\"><a href=\"#监控网络连接类型，区分移动数据流量和Wi-Fi；同样，可以监控电量和充电状态\" class=\"headerlink\" title=\"监控网络连接类型，区分移动数据流量和Wi-Fi；同样，可以监控电量和充电状态\"></a>监控网络连接类型，区分<code>移动数据流量</code>和<code>Wi-Fi</code>；同样，可以监控<code>电量</code>和<code>充电状态</code></h4><p>对于不同网络类型，我们可以动态改变我们的UI，比如大图可以选择在<code>Wi-Fi</code>下才加载，而在<code>移动数据流量</code>则不加载。对于<code>电量</code>也是类似的逻辑。用户一定会很感谢app做的这种自适应的。</p>\n<h4 id=\"User-Interface-is-like-a-joke-If-you-have-to-explain-it-it’s-not-that-good\"><a href=\"#User-Interface-is-like-a-joke-If-you-have-to-explain-it-it’s-not-that-good\" class=\"headerlink\" title=\"User Interface is like a joke.If you have to explain it, it’s not that good.\"></a>User Interface is like a joke.If you have to explain it, it’s not that good.</h4><h4 id=\"先写slow但是right的代码，再去进行优化\"><a href=\"#先写slow但是right的代码，再去进行优化\" class=\"headerlink\" title=\"先写slow但是right的代码，再去进行优化\"></a>先写slow但是right的代码，再去进行优化</h4><h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>本文长期更新，会保持跟踪最新的技术和研究实践经验，为大家提供有效有用的经验，少走坑。</p>\n<p>谢谢！</p>\n<p>wingjay</p>\n<p>欢迎各位关注<br><a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\">我的Github</a>: <a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\">https://github.com/wingjay</a><br>和<br><a href=\"http://wingjay.com\">我的个人博客</a>: <a href=\"http://wingjay.com\">http://wingjay.com</a><br>和<br><a href=\"http://www.jianshu.com/users/da333fd63fe5/latest_articles\" target=\"_blank\" rel=\"external\">我的简书</a>: <a href=\"http://www.jianshu.com/users/da333fd63fe5/latest_articles\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/users/da333fd63fe5/latest_articles</a><br>和<br><a href=\"http://weibo.com/u/1625892654\" target=\"_blank\" rel=\"external\">微博 iam_wingjay</a>: <a href=\"http://weibo.com/u/1625892654\" target=\"_blank\" rel=\"external\">http://weibo.com/u/1625892654</a><br>如果有问题，可以给我留言或发邮件<a href=\"&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x79;&#105;&#x6e;&#x6a;&#105;&#101;&#x73;&#104;&#x40;&#x31;&#x32;&#x36;&#x2e;&#99;&#111;&#109;\">&#x79;&#105;&#x6e;&#x6a;&#105;&#101;&#x73;&#104;&#x40;&#x31;&#x32;&#x36;&#x2e;&#99;&#111;&#109;</a></p>\n<p><img src=\"https://avatars0.githubusercontent.com/u/9619875?v=3&amp;s=460\" alt=\"\"></p>","sticky":0},{"title":"Android 架构之高可用移动网络连接","date":"2019-01-16T03:36:02.000Z","commentIssueId":33,"_content":"\n读者好，前面我们在[《Android 架构之网络连接与加速》](https://xiaozhuanlan.com/topic/6982074351)和[《Android 架构之长连接技术》](https://xiaozhuanlan.com/topic/3758142906)两篇文章中，讲解了`Http短连接、TCP长连接、连接复用与速度优化、数据压缩`等方面的知识点。不过，真实的网络环境是很复杂的，存在各种各样的因素会导致网络服务不可用，比如DNS劫持、服务器宕机、弱网等。换言之，如果服务都不可用，那上面这些优化也就没有意义了。\n\n因此，本文主要谈一下在真实的网络环境下，存在哪些常见的网络不可用原因，以及大多数公司是如何解决并兜底，从而达到`高可用连接`这个目标的。\n\n文章会从下面几方面进行阐述：\n- DNS劫持与可靠IP获取\n    - HttpDNS\n    - 内置IP列表+自动测速\n- IP列表的缓存更新策略\n- IP列表可用性兜底策略\n- 针对弱网的多IP复合连接测速\n- 自主网络诊断\n\n<!-- more -->\n\n## DNS劫持与可靠IP获取\n我们知道，大多数的网络请求第一步就是DNS过程，经过1-RTT的时间将域名转化为IP地址，然后再去发起请求。但是，有相关经验的开发者应该了解，DNS过程不仅耗时不稳定（3G下200ms，4G下100ms），而且可能解析失败，甚至被劫持，将用户导入到了错误的IP地址。如果攻击者自己做一个仿冒的网站，劫持你的DNS并将IP转到这个假网站上，可能会造成很大的用户数据泄漏和公司品牌损失。\n\n为了解决这个问题，获得可靠的IP列表，现有大厂会采用下面一些方案：\n#### 1. HTTPDNS\n比如阿里云和腾讯云都推出了自己的HttpDNS服务，在全国多地部署相关的服务器提供安全解析DNS服务。\n\n基本的原理就是通过发起Http请求到HttpDNS服务器，获取某个域名对应的可用IP列表。这个IP列表可以根据用户当前的地点进行返回，而且默认会进行IP测速，按速度排序。同时，伴随这IP列表，服务器还会下发一个缓存有效时间 TTL，有了这个时间，客户端可以放心的将IP列表缓存在本地，并在即将过期前及时去更新IP列表，保证每次网络请求都可以使用**当前最优**的IP地址。\n\n#### 2. 内置IP列表+自动测速\n当然，自建HttpDNS服务需要一定规模的机房部署、大量的客户端测速数据上报、全球IP库收集等，需要不少的投入。因此，有些公司比如**携程**就采用了更加轻量一点的方案：`内置IP列表`。\n\n具体原理如下：\n\n在APK打包时会内置一份IP列表进去。当App启动时，这些IP的权重相同，此时会随机从里面获取IP来使用。但是这有个问题，对不同地区的用户而言，最优IP肯定是不同的。比如对于上海的用户而言，上海区服务器的IP肯定是最快的，而对于深圳的用户而言，华南区IP才是最快的。因此，在App运行过程中，我们会通过依次对IP列表逐个进行**Ping测速**，根据测速结果动态变更IP的权重，然后提供给网络连接使用。\n\n![](https://user-gold-cdn.xitu.io/2019/1/16/16854a8022fae7a7?w=500&h=500&f=gif&s=2452895)\n## IP列表的缓存更新策略\n通过`HttpDNS或内置IP列表`的方案，我们可以为网络层提供一份相对可靠的IP地址作为缓存，每次需要发起请求时，直接从缓存里读取这份IP列表即可建立IP直连。\n\n那新的问题来了，移动网络是在不断变化的。最常见的场景，比如我们从Wi-Fi切换到了4G，获取进入电梯后从4G降级成3G，或者我们从A Wi-Fi换到了B Wi-Fi，这都意味着我们的**网络链路变更**了。那么，`之前缓存的IP列表是否仍然可用，或者仍然最优呢？`\n\n显然并不一定，比如从Wi-Fi切到了移动4G，背后整条网络链路都不同了，之前的IP列表很有可能不是最优的了，极端情况下可能某些IP地址也不可用了。因此，我们需要最好IP列表的及时更新，保证无论网络如何切换，我们都能使用最优的IP地址列表。\n\n具体有下面几种方式：\n1. 定时器监听HttpDNS返回的`TTL过期时间`。当IP列表即将过期前，发起请求获取下一轮的IP列表并进行更新；\n2. 监控网络连接状态，网络链路切换，比如Wi-Fi/3G/4G转换，如果是Wi-Fi，还可以监控SSID信息变更（针对不同的Wi-Fi热点），及时触发IP列表刷新；在异步更新过程中，可以仍然使用旧缓存IP提供服务；\n3. 配置中心下发，这种有时会用在服务器分流，比如某台服务器压力过大，可以通过配置中心系统下发新的IP列表给客户端访问。\n\n另外，IP列表缓存应该对不同网络类型、网络标识有对应的一份缓存，可以使用`网络类型（3G、4G、Wi-Fi等）+网络标识（SSID、ispCode等）`作为`缓存Key`，当网络切换时，使用Key去查询缓存。\n\n这些缓存可以持久化到多个文件，以Key作为文件名，同时可以基于当前网络状态，缓存一份IP列表到内存供使用，当网络状态变化，则刷新内存缓存。\n\n![](https://user-gold-cdn.xitu.io/2019/1/16/16854a8022cf2833?w=1280&h=852&f=jpeg&s=142010)\n\n## IP列表可用性兜底策略\n通过更新机制，我们可以保证本地IP列表缓存动态更新的及时性。那么，`如果HttpDNS服务器出现故障呢，或者首次打开App，HttpDNS还没有完成，或者大面积DNS劫持等，怎么办呢？`\n\n所以说，除了及时获取最优IP列表，我们还要考虑，如果获取不到IP列表，如何进行兜底？保证用户的网络请求不受影响。\n\n在线上运行中，可以采取下面四组IP兜底策略，按优先级排列如下：\n- HttpDNS IP：即大厂自建的HttpDNS服务获取动态IP；\n- DNS IP：即常规Local DNS获取IP；\n- Auth IP：通过配置下发的动态保底IP列表；\n- Hardcode IP：本地写死的保底IP列表\n\n前面两种动态IP不用多说，大家都清楚，这两者可以动态获取IP，效果最好。但是，如果发生故障，导致这两个方案都不可用，比如大面积DNS劫持之类的，这时客户端必须能够自动降级到`静态兜底IP`，保证网络服务可用。\n\n但这也可能存在一个问题，就是`静态兜底IP`对应服务器访问量可能会突然暴增，如果峰值太高可能造成更大的危害如`雪崩`。因此，除了内置静态兜底IP，还需要为客户端提供一个可通过`配置动态下发`的`兜底IP列表`，可以做到负载均衡，将流量分散到不同机器上。而且这些静态IP贵精不贵多，并且要有高可用的后台服务保证，作为全局网络服务的兜底。\n\n## 针对弱网的多IP复合连接测速\n通过上面的几套方案，可以保证用户能够`高可用的获取最优IP列表`，提高用户访问速度，而且能应对各种复杂的网络状态。\n\n那么现在考虑这样一种情况，上面的IP列表我们能够正常的获取，但是，**用户处于弱网状态下，IP连接成功率很低，怎么办呢？**\n\n针对弱网一般有两种方式：\n- 串行连接：先连接第一个IP，直到发生了超时，再去对第二个IP建连；\n- 并行连接：同时对多个IP建立连接，哪个连成功了就用哪个；\n\n这两种方案的缺点是：串行连接可能需要很长时间的试错，才能找到可用的IP，而且这里还取决于如何选择超时时间，如果超时时间较长，则需要很长时间才能找到可用IP；如果很短，则可能会漏掉一些相对优质的IP，不断去尝试新IP，恶性循环；而并行连接则会对服务端造成极大的连接负载压力和一定程度的浪费，对于电量也有一定程度开销。\n\n因此，这里我们介绍下`Mars里的复合连接策略`作为学习参考：\n\n![](https://user-gold-cdn.xitu.io/2019/1/16/16854a80252a5bf8?w=640&h=296&f=png&s=114867)\n\n在弱网状态下，依次发起对5组IP+Port的连接，10s作为超时时间。当前一个连接发起了4s钟还未成功，则立即发起下一个连接，以此类推。当其中有一个连接建立成功，则立即停止其他连接。这样的方式可以兼备串行连接和并行连接的优势：较快找到可用IP，同时对于服务器不会造成过大的连接压力。至于这个超时时间10s，则可以通过上报数据来动态统计，找到一个合理的超时时间。\n\n![](https://user-gold-cdn.xitu.io/2019/1/16/16854a802525d5dc?w=1000&h=666&f=jpeg&s=247647)\n\n## 自主网络诊断\n在真实的线上环境我们发现，即使IP和后台服务均有效，仍有一部分用户的网络连接会出现失败。而此时单纯从IP地址已经分析不出原因，很有可能是该用户的网络链路上存在问题导致连接失败。\n\n这时就需要我们主动去探测这个用户的网络连接并诊断整条连接链路。\n\n因此，为了准确了解线上网络错误的用户的真实情况，我们会在客户端里内置网络诊断策略，通过`Ping`或者`TraceRoute`探测用户手机到服务器的整条网络链路上的情况，并将数据存储上报，用于分析用户的真实网络错误原因。\n\n[Ping](https://zh.wikipedia.org/wiki/Ping)大家比较熟悉，目的是为了测试另一台主机是否可达，向目标主机发送Echo包并等待回包；而[TraceRoute](https://zh.wikipedia.org/wiki/Traceroute)可以获取数据包在IP网络经过的路由器的IP地址，原理如下：\n- 程序是利用增加存活时间（TTL）值来实现其功能的。每当数据包经过一个路由器，其存活时间就会减1。当其存活时间是0时，主机便取消数据包，并发送一个ICMP TTL数据包给原数据包的发出者。\n- 程序发出的首3个数据包TTL值是1，之后3个是2，如此类推，它便得到一连串数据包路径。注意IP不保证每个数据包走的路径都一样。\n\n在Android上一般有两种方式来实现这个诊断：\n1. 通过后台线程执行ping命令的方式，模拟traceroute的过程；\n2. 通过编译开源网络检测库`iputils`C代码的方式对traceroute进行了套接字发送ICMP报文模拟。\n\n感兴趣的可以参考文末提供的开源项目`LDNetDiagnoService`，通过诊断可以把日志上报用于分析，并作出相关的调整和优化。\n\n\n## 小结\n本文针对如何提高网络连接的高可用性做了讲解和分析，线上方案最重要考虑的就是兜底，无论发生何种问题，都要保证网络服务可用。如果用户连我们的服务器都连接不上，那可能会带来非常严重的灾难；当然，我们也要考虑服务器负载，不能造成服务器压力过大，导致雪崩之类的问题。\n\n有相关疑问欢迎随时留言。\n\n----\n谢谢。\n\nwingjay\n\n---\n### 《亿级Android架构》小专栏介绍\n业务的快速增长离不开稳定可靠的架构。[《亿级Android架构》](https://xiaozhuanlan.com/AndroidArch)小专栏会基于作者实际工作经验，结合国内大厂如阿里、腾讯、美团等基础架构现状，尝试谈谈如何设计一套好的架构来支持业务从0到1，甚至到亿，希望与大家多多探讨。\n\n本专栏主要内容：\n1. 当前大厂有哪些Android架构；\n2. 这些架构能解决什么问题；\n3. 这些架构的原理是什么；\n4. 学习这些架构对我们自身的意义。\n\n**[《亿级Android架构》](https://xiaozhuanlan.com/AndroidArch)小专栏文章列表：**\n\n[《亿级 Android 架构》专栏随谈》](https://xiaozhuanlan.com/topic/1934527806)\n\n[《Android 架构之网络连接与加速》](https://xiaozhuanlan.com/topic/6982074351)\n\n[《Android 架构之长连接技术》](https://xiaozhuanlan.com/topic/3758142906)\n\n[《Android 架构之高可用移动网络连接》](https://xiaozhuanlan.com/topic/2130768549)\n\n[《Android 架构之网络安全演进》](https://xiaozhuanlan.com/topic/8159302674)\n\n[《Android 架构之高性能移动端日志系统》](https://xiaozhuanlan.com/topic/2694081375)\n\n---\n \n## 参考文章\n[《微信终端跨平台组件 Mars 系列（三）连接超时与IP&Port排序》](https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=2649286458&idx=1&sn=320f690faa4f97f7a49a291d4de174a9&chksm=8334c3b8b4434aae904b6d590027b100283ef175938610805dd33ca53f004bd3c56040b11fa6#rd)\n\n[《海量之道系列文章之弱联网优化》](http://www.52im.net/thread-1588-1-1.html)\n\n[《LDNetDiagnoService_Android》](https://github.com/Lede-Inc/LDNetDiagnoService_Android)\n\n[《美团点评移动网络优化实践》](https://tech.meituan.com/Shark_SDK.html)\n","source":"_posts/Android-架构之高可用移动网络连接.md","raw":"title: Android 架构之高可用移动网络连接\ndate: 2019-01-16 11:36:02\npermalink: mobile-network-connection\ncategories:\n  - Android\n  - 亿级Android架构\ntags:\n\t- Android\n\t- 架构\n\t- 高可用\n\t- 网络\ncommentIssueId: 33\n---\n\n读者好，前面我们在[《Android 架构之网络连接与加速》](https://xiaozhuanlan.com/topic/6982074351)和[《Android 架构之长连接技术》](https://xiaozhuanlan.com/topic/3758142906)两篇文章中，讲解了`Http短连接、TCP长连接、连接复用与速度优化、数据压缩`等方面的知识点。不过，真实的网络环境是很复杂的，存在各种各样的因素会导致网络服务不可用，比如DNS劫持、服务器宕机、弱网等。换言之，如果服务都不可用，那上面这些优化也就没有意义了。\n\n因此，本文主要谈一下在真实的网络环境下，存在哪些常见的网络不可用原因，以及大多数公司是如何解决并兜底，从而达到`高可用连接`这个目标的。\n\n文章会从下面几方面进行阐述：\n- DNS劫持与可靠IP获取\n    - HttpDNS\n    - 内置IP列表+自动测速\n- IP列表的缓存更新策略\n- IP列表可用性兜底策略\n- 针对弱网的多IP复合连接测速\n- 自主网络诊断\n\n<!-- more -->\n\n## DNS劫持与可靠IP获取\n我们知道，大多数的网络请求第一步就是DNS过程，经过1-RTT的时间将域名转化为IP地址，然后再去发起请求。但是，有相关经验的开发者应该了解，DNS过程不仅耗时不稳定（3G下200ms，4G下100ms），而且可能解析失败，甚至被劫持，将用户导入到了错误的IP地址。如果攻击者自己做一个仿冒的网站，劫持你的DNS并将IP转到这个假网站上，可能会造成很大的用户数据泄漏和公司品牌损失。\n\n为了解决这个问题，获得可靠的IP列表，现有大厂会采用下面一些方案：\n#### 1. HTTPDNS\n比如阿里云和腾讯云都推出了自己的HttpDNS服务，在全国多地部署相关的服务器提供安全解析DNS服务。\n\n基本的原理就是通过发起Http请求到HttpDNS服务器，获取某个域名对应的可用IP列表。这个IP列表可以根据用户当前的地点进行返回，而且默认会进行IP测速，按速度排序。同时，伴随这IP列表，服务器还会下发一个缓存有效时间 TTL，有了这个时间，客户端可以放心的将IP列表缓存在本地，并在即将过期前及时去更新IP列表，保证每次网络请求都可以使用**当前最优**的IP地址。\n\n#### 2. 内置IP列表+自动测速\n当然，自建HttpDNS服务需要一定规模的机房部署、大量的客户端测速数据上报、全球IP库收集等，需要不少的投入。因此，有些公司比如**携程**就采用了更加轻量一点的方案：`内置IP列表`。\n\n具体原理如下：\n\n在APK打包时会内置一份IP列表进去。当App启动时，这些IP的权重相同，此时会随机从里面获取IP来使用。但是这有个问题，对不同地区的用户而言，最优IP肯定是不同的。比如对于上海的用户而言，上海区服务器的IP肯定是最快的，而对于深圳的用户而言，华南区IP才是最快的。因此，在App运行过程中，我们会通过依次对IP列表逐个进行**Ping测速**，根据测速结果动态变更IP的权重，然后提供给网络连接使用。\n\n![](https://user-gold-cdn.xitu.io/2019/1/16/16854a8022fae7a7?w=500&h=500&f=gif&s=2452895)\n## IP列表的缓存更新策略\n通过`HttpDNS或内置IP列表`的方案，我们可以为网络层提供一份相对可靠的IP地址作为缓存，每次需要发起请求时，直接从缓存里读取这份IP列表即可建立IP直连。\n\n那新的问题来了，移动网络是在不断变化的。最常见的场景，比如我们从Wi-Fi切换到了4G，获取进入电梯后从4G降级成3G，或者我们从A Wi-Fi换到了B Wi-Fi，这都意味着我们的**网络链路变更**了。那么，`之前缓存的IP列表是否仍然可用，或者仍然最优呢？`\n\n显然并不一定，比如从Wi-Fi切到了移动4G，背后整条网络链路都不同了，之前的IP列表很有可能不是最优的了，极端情况下可能某些IP地址也不可用了。因此，我们需要最好IP列表的及时更新，保证无论网络如何切换，我们都能使用最优的IP地址列表。\n\n具体有下面几种方式：\n1. 定时器监听HttpDNS返回的`TTL过期时间`。当IP列表即将过期前，发起请求获取下一轮的IP列表并进行更新；\n2. 监控网络连接状态，网络链路切换，比如Wi-Fi/3G/4G转换，如果是Wi-Fi，还可以监控SSID信息变更（针对不同的Wi-Fi热点），及时触发IP列表刷新；在异步更新过程中，可以仍然使用旧缓存IP提供服务；\n3. 配置中心下发，这种有时会用在服务器分流，比如某台服务器压力过大，可以通过配置中心系统下发新的IP列表给客户端访问。\n\n另外，IP列表缓存应该对不同网络类型、网络标识有对应的一份缓存，可以使用`网络类型（3G、4G、Wi-Fi等）+网络标识（SSID、ispCode等）`作为`缓存Key`，当网络切换时，使用Key去查询缓存。\n\n这些缓存可以持久化到多个文件，以Key作为文件名，同时可以基于当前网络状态，缓存一份IP列表到内存供使用，当网络状态变化，则刷新内存缓存。\n\n![](https://user-gold-cdn.xitu.io/2019/1/16/16854a8022cf2833?w=1280&h=852&f=jpeg&s=142010)\n\n## IP列表可用性兜底策略\n通过更新机制，我们可以保证本地IP列表缓存动态更新的及时性。那么，`如果HttpDNS服务器出现故障呢，或者首次打开App，HttpDNS还没有完成，或者大面积DNS劫持等，怎么办呢？`\n\n所以说，除了及时获取最优IP列表，我们还要考虑，如果获取不到IP列表，如何进行兜底？保证用户的网络请求不受影响。\n\n在线上运行中，可以采取下面四组IP兜底策略，按优先级排列如下：\n- HttpDNS IP：即大厂自建的HttpDNS服务获取动态IP；\n- DNS IP：即常规Local DNS获取IP；\n- Auth IP：通过配置下发的动态保底IP列表；\n- Hardcode IP：本地写死的保底IP列表\n\n前面两种动态IP不用多说，大家都清楚，这两者可以动态获取IP，效果最好。但是，如果发生故障，导致这两个方案都不可用，比如大面积DNS劫持之类的，这时客户端必须能够自动降级到`静态兜底IP`，保证网络服务可用。\n\n但这也可能存在一个问题，就是`静态兜底IP`对应服务器访问量可能会突然暴增，如果峰值太高可能造成更大的危害如`雪崩`。因此，除了内置静态兜底IP，还需要为客户端提供一个可通过`配置动态下发`的`兜底IP列表`，可以做到负载均衡，将流量分散到不同机器上。而且这些静态IP贵精不贵多，并且要有高可用的后台服务保证，作为全局网络服务的兜底。\n\n## 针对弱网的多IP复合连接测速\n通过上面的几套方案，可以保证用户能够`高可用的获取最优IP列表`，提高用户访问速度，而且能应对各种复杂的网络状态。\n\n那么现在考虑这样一种情况，上面的IP列表我们能够正常的获取，但是，**用户处于弱网状态下，IP连接成功率很低，怎么办呢？**\n\n针对弱网一般有两种方式：\n- 串行连接：先连接第一个IP，直到发生了超时，再去对第二个IP建连；\n- 并行连接：同时对多个IP建立连接，哪个连成功了就用哪个；\n\n这两种方案的缺点是：串行连接可能需要很长时间的试错，才能找到可用的IP，而且这里还取决于如何选择超时时间，如果超时时间较长，则需要很长时间才能找到可用IP；如果很短，则可能会漏掉一些相对优质的IP，不断去尝试新IP，恶性循环；而并行连接则会对服务端造成极大的连接负载压力和一定程度的浪费，对于电量也有一定程度开销。\n\n因此，这里我们介绍下`Mars里的复合连接策略`作为学习参考：\n\n![](https://user-gold-cdn.xitu.io/2019/1/16/16854a80252a5bf8?w=640&h=296&f=png&s=114867)\n\n在弱网状态下，依次发起对5组IP+Port的连接，10s作为超时时间。当前一个连接发起了4s钟还未成功，则立即发起下一个连接，以此类推。当其中有一个连接建立成功，则立即停止其他连接。这样的方式可以兼备串行连接和并行连接的优势：较快找到可用IP，同时对于服务器不会造成过大的连接压力。至于这个超时时间10s，则可以通过上报数据来动态统计，找到一个合理的超时时间。\n\n![](https://user-gold-cdn.xitu.io/2019/1/16/16854a802525d5dc?w=1000&h=666&f=jpeg&s=247647)\n\n## 自主网络诊断\n在真实的线上环境我们发现，即使IP和后台服务均有效，仍有一部分用户的网络连接会出现失败。而此时单纯从IP地址已经分析不出原因，很有可能是该用户的网络链路上存在问题导致连接失败。\n\n这时就需要我们主动去探测这个用户的网络连接并诊断整条连接链路。\n\n因此，为了准确了解线上网络错误的用户的真实情况，我们会在客户端里内置网络诊断策略，通过`Ping`或者`TraceRoute`探测用户手机到服务器的整条网络链路上的情况，并将数据存储上报，用于分析用户的真实网络错误原因。\n\n[Ping](https://zh.wikipedia.org/wiki/Ping)大家比较熟悉，目的是为了测试另一台主机是否可达，向目标主机发送Echo包并等待回包；而[TraceRoute](https://zh.wikipedia.org/wiki/Traceroute)可以获取数据包在IP网络经过的路由器的IP地址，原理如下：\n- 程序是利用增加存活时间（TTL）值来实现其功能的。每当数据包经过一个路由器，其存活时间就会减1。当其存活时间是0时，主机便取消数据包，并发送一个ICMP TTL数据包给原数据包的发出者。\n- 程序发出的首3个数据包TTL值是1，之后3个是2，如此类推，它便得到一连串数据包路径。注意IP不保证每个数据包走的路径都一样。\n\n在Android上一般有两种方式来实现这个诊断：\n1. 通过后台线程执行ping命令的方式，模拟traceroute的过程；\n2. 通过编译开源网络检测库`iputils`C代码的方式对traceroute进行了套接字发送ICMP报文模拟。\n\n感兴趣的可以参考文末提供的开源项目`LDNetDiagnoService`，通过诊断可以把日志上报用于分析，并作出相关的调整和优化。\n\n\n## 小结\n本文针对如何提高网络连接的高可用性做了讲解和分析，线上方案最重要考虑的就是兜底，无论发生何种问题，都要保证网络服务可用。如果用户连我们的服务器都连接不上，那可能会带来非常严重的灾难；当然，我们也要考虑服务器负载，不能造成服务器压力过大，导致雪崩之类的问题。\n\n有相关疑问欢迎随时留言。\n\n----\n谢谢。\n\nwingjay\n\n---\n### 《亿级Android架构》小专栏介绍\n业务的快速增长离不开稳定可靠的架构。[《亿级Android架构》](https://xiaozhuanlan.com/AndroidArch)小专栏会基于作者实际工作经验，结合国内大厂如阿里、腾讯、美团等基础架构现状，尝试谈谈如何设计一套好的架构来支持业务从0到1，甚至到亿，希望与大家多多探讨。\n\n本专栏主要内容：\n1. 当前大厂有哪些Android架构；\n2. 这些架构能解决什么问题；\n3. 这些架构的原理是什么；\n4. 学习这些架构对我们自身的意义。\n\n**[《亿级Android架构》](https://xiaozhuanlan.com/AndroidArch)小专栏文章列表：**\n\n[《亿级 Android 架构》专栏随谈》](https://xiaozhuanlan.com/topic/1934527806)\n\n[《Android 架构之网络连接与加速》](https://xiaozhuanlan.com/topic/6982074351)\n\n[《Android 架构之长连接技术》](https://xiaozhuanlan.com/topic/3758142906)\n\n[《Android 架构之高可用移动网络连接》](https://xiaozhuanlan.com/topic/2130768549)\n\n[《Android 架构之网络安全演进》](https://xiaozhuanlan.com/topic/8159302674)\n\n[《Android 架构之高性能移动端日志系统》](https://xiaozhuanlan.com/topic/2694081375)\n\n---\n \n## 参考文章\n[《微信终端跨平台组件 Mars 系列（三）连接超时与IP&Port排序》](https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=2649286458&idx=1&sn=320f690faa4f97f7a49a291d4de174a9&chksm=8334c3b8b4434aae904b6d590027b100283ef175938610805dd33ca53f004bd3c56040b11fa6#rd)\n\n[《海量之道系列文章之弱联网优化》](http://www.52im.net/thread-1588-1-1.html)\n\n[《LDNetDiagnoService_Android》](https://github.com/Lede-Inc/LDNetDiagnoService_Android)\n\n[《美团点评移动网络优化实践》](https://tech.meituan.com/Shark_SDK.html)\n","slug":"mobile-network-connection","published":1,"updated":"2019-01-16T03:43:42.783Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplsht00223dn8sceth1g4","content":"<p>读者好，前面我们在 <a href=\"https://xiaozhuanlan.com/topic/6982074351\" target=\"_blank\" rel=\"external\">《Android 架构之网络连接与加速》</a> 和<a href=\"https://xiaozhuanlan.com/topic/3758142906\" target=\"_blank\" rel=\"external\">《Android 架构之长连接技术》</a>两篇文章中，讲解了 <code>Http 短连接、TCP 长连接、连接复用与速度优化、数据压缩</code> 等方面的知识点。不过，真实的网络环境是很复杂的，存在各种各样的因素会导致网络服务不可用，比如 DNS 劫持、服务器宕机、弱网等。换言之，如果服务都不可用，那上面这些优化也就没有意义了。</p>\n<p>因此，本文主要谈一下在真实的网络环境下，存在哪些常见的网络不可用原因，以及大多数公司是如何解决并兜底，从而达到 <code> 高可用连接 </code> 这个目标的。</p>\n<p>文章会从下面几方面进行阐述：</p>\n<ul>\n<li>DNS 劫持与可靠 IP 获取<ul>\n<li>HttpDNS</li>\n<li>内置 IP 列表 + 自动测速</li>\n</ul>\n</li>\n<li>IP 列表的缓存更新策略</li>\n<li>IP 列表可用性兜底策略</li>\n<li>针对弱网的多 IP 复合连接测速</li>\n<li>自主网络诊断</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"DNS 劫持与可靠 IP 获取\"><a href=\"#DNS 劫持与可靠 IP 获取\" class=\"headerlink\" title=\"DNS 劫持与可靠 IP 获取\"></a>DNS 劫持与可靠 IP 获取 </h2><p> 我们知道，大多数的网络请求第一步就是 DNS 过程，经过 1-RTT 的时间将域名转化为 IP 地址，然后再去发起请求。但是，有相关经验的开发者应该了解，DNS 过程不仅耗时不稳定（3G 下 200ms，4G 下 100ms），而且可能解析失败，甚至被劫持，将用户导入到了错误的 IP 地址。如果攻击者自己做一个仿冒的网站，劫持你的 DNS 并将 IP 转到这个假网站上，可能会造成很大的用户数据泄漏和公司品牌损失。</p>\n<p>为了解决这个问题，获得可靠的 IP 列表，现有大厂会采用下面一些方案：</p>\n<h4 id=\"1-HTTPDNS\"><a href=\"#1-HTTPDNS\" class=\"headerlink\" title=\"1. HTTPDNS\"></a>1. HTTPDNS</h4><p>比如阿里云和腾讯云都推出了自己的 HttpDNS 服务，在全国多地部署相关的服务器提供安全解析 DNS 服务。</p>\n<p>基本的原理就是通过发起 Http 请求到 HttpDNS 服务器，获取某个域名对应的可用 IP 列表。这个 IP 列表可以根据用户当前的地点进行返回，而且默认会进行 IP 测速，按速度排序。同时，伴随这 IP 列表，服务器还会下发一个缓存有效时间 TTL，有了这个时间，客户端可以放心的将 IP 列表缓存在本地，并在即将过期前及时去更新 IP 列表，保证每次网络请求都可以使用 <strong> 当前最优 </strong> 的 IP 地址。</p>\n<h4 id=\"2- 内置 IP 列表 - 自动测速\"><a href=\"#2- 内置 IP 列表 - 自动测速\" class=\"headerlink\" title=\"2. 内置 IP 列表 + 自动测速\"></a>2. 内置 IP 列表 + 自动测速 </h4><p> 当然，自建 HttpDNS 服务需要一定规模的机房部署、大量的客户端测速数据上报、全球 IP 库收集等，需要不少的投入。因此，有些公司比如 <strong> 携程 </strong> 就采用了更加轻量一点的方案：<code>内置 IP 列表</code>。</p>\n<p>具体原理如下：</p>\n<p>在 APK 打包时会内置一份 IP 列表进去。当 App 启动时，这些 IP 的权重相同，此时会随机从里面获取 IP 来使用。但是这有个问题，对不同地区的用户而言，最优 IP 肯定是不同的。比如对于上海的用户而言，上海区服务器的 IP 肯定是最快的，而对于深圳的用户而言，华南区 IP 才是最快的。因此，在 App 运行过程中，我们会通过依次对 IP 列表逐个进行<strong>Ping 测速</strong>，根据测速结果动态变更 IP 的权重，然后提供给网络连接使用。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/1/16/16854a8022fae7a7?w=500&amp;h=500&amp;f=gif&amp;s=2452895\" alt=\"\"></p>\n<h2 id=\"IP 列表的缓存更新策略\"><a href=\"#IP 列表的缓存更新策略\" class=\"headerlink\" title=\"IP 列表的缓存更新策略\"></a>IP 列表的缓存更新策略 </h2><p> 通过 <code>HttpDNS 或内置 IP 列表</code> 的方案，我们可以为网络层提供一份相对可靠的 IP 地址作为缓存，每次需要发起请求时，直接从缓存里读取这份 IP 列表即可建立 IP 直连。</p>\n<p>那新的问题来了，移动网络是在不断变化的。最常见的场景，比如我们从 Wi-Fi 切换到了 4G，获取进入电梯后从 4G 降级成 3G，或者我们从 A Wi-Fi 换到了 B Wi-Fi，这都意味着我们的 <strong> 网络链路变更 </strong> 了。那么，<code>之前缓存的 IP 列表是否仍然可用，或者仍然最优呢？</code></p>\n<p>显然并不一定，比如从 Wi-Fi 切到了移动 4G，背后整条网络链路都不同了，之前的 IP 列表很有可能不是最优的了，极端情况下可能某些 IP 地址也不可用了。因此，我们需要最好 IP 列表的及时更新，保证无论网络如何切换，我们都能使用最优的 IP 地址列表。</p>\n<p>具体有下面几种方式：</p>\n<ol>\n<li>定时器监听 HttpDNS 返回的<code>TTL 过期时间</code>。当 IP 列表即将过期前，发起请求获取下一轮的 IP 列表并进行更新；</li>\n<li>监控网络连接状态，网络链路切换，比如 Wi-Fi/3G/4G 转换，如果是 Wi-Fi，还可以监控 SSID 信息变更（针对不同的 Wi-Fi 热点），及时触发 IP 列表刷新；在异步更新过程中，可以仍然使用旧缓存 IP 提供服务；</li>\n<li>配置中心下发，这种有时会用在服务器分流，比如某台服务器压力过大，可以通过配置中心系统下发新的 IP 列表给客户端访问。</li>\n</ol>\n<p>另外，IP 列表缓存应该对不同网络类型、网络标识有对应的一份缓存，可以使用 <code> 网络类型（3G、4G、Wi-Fi 等）+ 网络标识（SSID、ispCode 等）</code>作为 <code> 缓存 Key</code>，当网络切换时，使用 Key 去查询缓存。</p>\n<p>这些缓存可以持久化到多个文件，以 Key 作为文件名，同时可以基于当前网络状态，缓存一份 IP 列表到内存供使用，当网络状态变化，则刷新内存缓存。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/1/16/16854a8022cf2833?w=1280&amp;h=852&amp;f=jpeg&amp;s=142010\" alt=\"\"></p>\n<h2 id=\"IP 列表可用性兜底策略\"><a href=\"#IP 列表可用性兜底策略\" class=\"headerlink\" title=\"IP 列表可用性兜底策略\"></a>IP 列表可用性兜底策略 </h2><p> 通过更新机制，我们可以保证本地 IP 列表缓存动态更新的及时性。那么，<code>如果 HttpDNS 服务器出现故障呢，或者首次打开 App，HttpDNS 还没有完成，或者大面积 DNS 劫持等，怎么办呢？</code></p>\n<p>所以说，除了及时获取最优 IP 列表，我们还要考虑，如果获取不到 IP 列表，如何进行兜底？保证用户的网络请求不受影响。</p>\n<p>在线上运行中，可以采取下面四组 IP 兜底策略，按优先级排列如下：</p>\n<ul>\n<li>HttpDNS IP：即大厂自建的 HttpDNS 服务获取动态 IP；</li>\n<li>DNS IP：即常规 Local DNS 获取 IP；</li>\n<li>Auth IP：通过配置下发的动态保底 IP 列表；</li>\n<li>Hardcode IP：本地写死的保底 IP 列表</li>\n</ul>\n<p>前面两种动态 IP 不用多说，大家都清楚，这两者可以动态获取 IP，效果最好。但是，如果发生故障，导致这两个方案都不可用，比如大面积 DNS 劫持之类的，这时客户端必须能够自动降级到 <code> 静态兜底 IP</code>，保证网络服务可用。</p>\n<p>但这也可能存在一个问题，就是 <code> 静态兜底 IP</code>对应服务器访问量可能会突然暴增，如果峰值太高可能造成更大的危害如 <code> 雪崩 </code>。因此，除了内置静态兜底 IP，还需要为客户端提供一个可通过<code> 配置动态下发 </code> 的<code>兜底 IP 列表</code>，可以做到负载均衡，将流量分散到不同机器上。而且这些静态 IP 贵精不贵多，并且要有高可用的后台服务保证，作为全局网络服务的兜底。</p>\n<h2 id=\"针对弱网的多 IP 复合连接测速\"><a href=\"# 针对弱网的多 IP 复合连接测速\" class=\"headerlink\" title=\"针对弱网的多 IP 复合连接测速\"></a>针对弱网的多 IP 复合连接测速 </h2><p> 通过上面的几套方案，可以保证用户能够 <code> 高可用的获取最优 IP 列表</code>，提高用户访问速度，而且能应对各种复杂的网络状态。</p>\n<p>那么现在考虑这样一种情况，上面的 IP 列表我们能够正常的获取，但是，<strong>用户处于弱网状态下，IP 连接成功率很低，怎么办呢？</strong></p>\n<p>针对弱网一般有两种方式：</p>\n<ul>\n<li>串行连接：先连接第一个 IP，直到发生了超时，再去对第二个 IP 建连；</li>\n<li>并行连接：同时对多个 IP 建立连接，哪个连成功了就用哪个；</li>\n</ul>\n<p>这两种方案的缺点是：串行连接可能需要很长时间的试错，才能找到可用的 IP，而且这里还取决于如何选择超时时间，如果超时时间较长，则需要很长时间才能找到可用 IP；如果很短，则可能会漏掉一些相对优质的 IP，不断去尝试新 IP，恶性循环；而并行连接则会对服务端造成极大的连接负载压力和一定程度的浪费，对于电量也有一定程度开销。</p>\n<p>因此，这里我们介绍下 <code>Mars 里的复合连接策略</code> 作为学习参考：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/1/16/16854a80252a5bf8?w=640&amp;h=296&amp;f=png&amp;s=114867\" alt=\"\"></p>\n<p>在弱网状态下，依次发起对 5 组 IP+Port 的连接，10s 作为超时时间。当前一个连接发起了 4s 钟还未成功，则立即发起下一个连接，以此类推。当其中有一个连接建立成功，则立即停止其他连接。这样的方式可以兼备串行连接和并行连接的优势：较快找到可用 IP，同时对于服务器不会造成过大的连接压力。至于这个超时时间 10s，则可以通过上报数据来动态统计，找到一个合理的超时时间。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/1/16/16854a802525d5dc?w=1000&amp;h=666&amp;f=jpeg&amp;s=247647\" alt=\"\"></p>\n<h2 id=\"自主网络诊断\"><a href=\"# 自主网络诊断\" class=\"headerlink\" title=\"自主网络诊断\"></a>自主网络诊断 </h2><p> 在真实的线上环境我们发现，即使 IP 和后台服务均有效，仍有一部分用户的网络连接会出现失败。而此时单纯从 IP 地址已经分析不出原因，很有可能是该用户的网络链路上存在问题导致连接失败。</p>\n<p>这时就需要我们主动去探测这个用户的网络连接并诊断整条连接链路。</p>\n<p>因此，为了准确了解线上网络错误的用户的真实情况，我们会在客户端里内置网络诊断策略，通过 <code>Ping</code> 或者 <code>TraceRoute</code> 探测用户手机到服务器的整条网络链路上的情况，并将数据存储上报，用于分析用户的真实网络错误原因。</p>\n<p><a href=\"https://zh.wikipedia.org/wiki/Ping\" target=\"_blank\" rel=\"external\">Ping</a>大家比较熟悉，目的是为了测试另一台主机是否可达，向目标主机发送 Echo 包并等待回包；而 <a href=\"https://zh.wikipedia.org/wiki/Traceroute\" target=\"_blank\" rel=\"external\">TraceRoute</a> 可以获取数据包在 IP 网络经过的路由器的 IP 地址，原理如下：</p>\n<ul>\n<li>程序是利用增加存活时间（TTL）值来实现其功能的。每当数据包经过一个路由器，其存活时间就会减 1。当其存活时间是 0 时，主机便取消数据包，并发送一个 ICMP TTL 数据包给原数据包的发出者。</li>\n<li>程序发出的首 3 个数据包 TTL 值是 1，之后 3 个是 2，如此类推，它便得到一连串数据包路径。注意 IP 不保证每个数据包走的路径都一样。</li>\n</ul>\n<p>在 Android 上一般有两种方式来实现这个诊断：</p>\n<ol>\n<li>通过后台线程执行 ping 命令的方式，模拟 traceroute 的过程；</li>\n<li>通过编译开源网络检测库<code>iputils</code>C 代码的方式对 traceroute 进行了套接字发送 ICMP 报文模拟。</li>\n</ol>\n<p>感兴趣的可以参考文末提供的开源项目<code>LDNetDiagnoService</code>，通过诊断可以把日志上报用于分析，并作出相关的调整和优化。</p>\n<h2 id=\"小结\"><a href=\"# 小结\" class=\"headerlink\" title=\"小结\"></a>小结 </h2><p> 本文针对如何提高网络连接的高可用性做了讲解和分析，线上方案最重要考虑的就是兜底，无论发生何种问题，都要保证网络服务可用。如果用户连我们的服务器都连接不上，那可能会带来非常严重的灾难；当然，我们也要考虑服务器负载，不能造成服务器压力过大，导致雪崩之类的问题。</p>\n<p>有相关疑问欢迎随时留言。</p>\n<hr>\n<p>谢谢。</p>\n<p>wingjay</p>\n<hr>\n<h3 id=\"《亿级 Android 架构》小专栏介绍\"><a href=\"#《亿级 Android 架构》小专栏介绍\" class=\"headerlink\" title=\"《亿级 Android 架构》小专栏介绍\"></a>《亿级 Android 架构》小专栏介绍 </h3><p> 业务的快速增长离不开稳定可靠的架构。<a href=\"https://xiaozhuanlan.com/AndroidArch\" target=\"_blank\" rel=\"external\">《亿级 Android 架构》</a>小专栏会基于作者实际工作经验，结合国内大厂如阿里、腾讯、美团等基础架构现状，尝试谈谈如何设计一套好的架构来支持业务从 0 到 1，甚至到亿，希望与大家多多探讨。</p>\n<p>本专栏主要内容：</p>\n<ol>\n<li>当前大厂有哪些 Android 架构；</li>\n<li>这些架构能解决什么问题；</li>\n<li>这些架构的原理是什么；</li>\n<li>学习这些架构对我们自身的意义。</li>\n</ol>\n<p><strong><a href=\"https://xiaozhuanlan.com/AndroidArch\" target=\"_blank\" rel=\"external\">《亿级 Android 架构》</a>小专栏文章列表：</strong></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/1934527806\" target=\"_blank\" rel=\"external\">《亿级 Android 架构》专栏随谈》</a></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/6982074351\" target=\"_blank\" rel=\"external\">《Android 架构之网络连接与加速》</a></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/3758142906\" target=\"_blank\" rel=\"external\">《Android 架构之长连接技术》</a></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/2130768549\" target=\"_blank\" rel=\"external\">《Android 架构之高可用移动网络连接》</a></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/8159302674\" target=\"_blank\" rel=\"external\">《Android 架构之网络安全演进》</a></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/2694081375\" target=\"_blank\" rel=\"external\">《Android 架构之高性能移动端日志系统》</a></p>\n<hr>\n<h2 id=\"参考文章\"><a href=\"# 参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=2649286458&amp;idx=1&amp;sn=320f690faa4f97f7a49a291d4de174a9&amp;chksm=8334c3b8b4434aae904b6d590027b100283ef175938610805dd33ca53f004bd3c56040b11fa6#rd\" target=\"_blank\" rel=\"external\">《微信终端跨平台组件 Mars 系列（三）连接超时与 IP&amp;Port 排序》</a></p>\n<p><a href=\"http://www.52im.net/thread-1588-1-1.html\" target=\"_blank\" rel=\"external\">《海量之道系列文章之弱联网优化》</a></p>\n<p><a href=\"https://github.com/Lede-Inc/LDNetDiagnoService_Android\" target=\"_blank\" rel=\"external\">《LDNetDiagnoService_Android》</a></p>\n<p><a href=\"https://tech.meituan.com/Shark_SDK.html\" target=\"_blank\" rel=\"external\">《美团点评移动网络优化实践》</a></p>\n","site":{"data":{}},"excerpt":"<p>读者好，前面我们在<a href=\"https://xiaozhuanlan.com/topic/6982074351\" target=\"_blank\" rel=\"external\">《Android 架构之网络连接与加速》</a>和<a href=\"https://xiaozhuanlan.com/topic/3758142906\" target=\"_blank\" rel=\"external\">《Android 架构之长连接技术》</a>两篇文章中，讲解了<code>Http短连接、TCP长连接、连接复用与速度优化、数据压缩</code>等方面的知识点。不过，真实的网络环境是很复杂的，存在各种各样的因素会导致网络服务不可用，比如DNS劫持、服务器宕机、弱网等。换言之，如果服务都不可用，那上面这些优化也就没有意义了。</p>\n<p>因此，本文主要谈一下在真实的网络环境下，存在哪些常见的网络不可用原因，以及大多数公司是如何解决并兜底，从而达到<code>高可用连接</code>这个目标的。</p>\n<p>文章会从下面几方面进行阐述：</p>\n<ul>\n<li>DNS劫持与可靠IP获取<ul>\n<li>HttpDNS</li>\n<li>内置IP列表+自动测速</li>\n</ul>\n</li>\n<li>IP列表的缓存更新策略</li>\n<li>IP列表可用性兜底策略</li>\n<li>针对弱网的多IP复合连接测速</li>\n<li>自主网络诊断</li>\n</ul>","more":"<h2 id=\"DNS劫持与可靠IP获取\"><a href=\"#DNS劫持与可靠IP获取\" class=\"headerlink\" title=\"DNS劫持与可靠IP获取\"></a>DNS劫持与可靠IP获取</h2><p>我们知道，大多数的网络请求第一步就是DNS过程，经过1-RTT的时间将域名转化为IP地址，然后再去发起请求。但是，有相关经验的开发者应该了解，DNS过程不仅耗时不稳定（3G下200ms，4G下100ms），而且可能解析失败，甚至被劫持，将用户导入到了错误的IP地址。如果攻击者自己做一个仿冒的网站，劫持你的DNS并将IP转到这个假网站上，可能会造成很大的用户数据泄漏和公司品牌损失。</p>\n<p>为了解决这个问题，获得可靠的IP列表，现有大厂会采用下面一些方案：</p>\n<h4 id=\"1-HTTPDNS\"><a href=\"#1-HTTPDNS\" class=\"headerlink\" title=\"1. HTTPDNS\"></a>1. HTTPDNS</h4><p>比如阿里云和腾讯云都推出了自己的HttpDNS服务，在全国多地部署相关的服务器提供安全解析DNS服务。</p>\n<p>基本的原理就是通过发起Http请求到HttpDNS服务器，获取某个域名对应的可用IP列表。这个IP列表可以根据用户当前的地点进行返回，而且默认会进行IP测速，按速度排序。同时，伴随这IP列表，服务器还会下发一个缓存有效时间 TTL，有了这个时间，客户端可以放心的将IP列表缓存在本地，并在即将过期前及时去更新IP列表，保证每次网络请求都可以使用<strong>当前最优</strong>的IP地址。</p>\n<h4 id=\"2-内置IP列表-自动测速\"><a href=\"#2-内置IP列表-自动测速\" class=\"headerlink\" title=\"2. 内置IP列表+自动测速\"></a>2. 内置IP列表+自动测速</h4><p>当然，自建HttpDNS服务需要一定规模的机房部署、大量的客户端测速数据上报、全球IP库收集等，需要不少的投入。因此，有些公司比如<strong>携程</strong>就采用了更加轻量一点的方案：<code>内置IP列表</code>。</p>\n<p>具体原理如下：</p>\n<p>在APK打包时会内置一份IP列表进去。当App启动时，这些IP的权重相同，此时会随机从里面获取IP来使用。但是这有个问题，对不同地区的用户而言，最优IP肯定是不同的。比如对于上海的用户而言，上海区服务器的IP肯定是最快的，而对于深圳的用户而言，华南区IP才是最快的。因此，在App运行过程中，我们会通过依次对IP列表逐个进行<strong>Ping测速</strong>，根据测速结果动态变更IP的权重，然后提供给网络连接使用。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/1/16/16854a8022fae7a7?w=500&amp;h=500&amp;f=gif&amp;s=2452895\" alt=\"\"></p>\n<h2 id=\"IP列表的缓存更新策略\"><a href=\"#IP列表的缓存更新策略\" class=\"headerlink\" title=\"IP列表的缓存更新策略\"></a>IP列表的缓存更新策略</h2><p>通过<code>HttpDNS或内置IP列表</code>的方案，我们可以为网络层提供一份相对可靠的IP地址作为缓存，每次需要发起请求时，直接从缓存里读取这份IP列表即可建立IP直连。</p>\n<p>那新的问题来了，移动网络是在不断变化的。最常见的场景，比如我们从Wi-Fi切换到了4G，获取进入电梯后从4G降级成3G，或者我们从A Wi-Fi换到了B Wi-Fi，这都意味着我们的<strong>网络链路变更</strong>了。那么，<code>之前缓存的IP列表是否仍然可用，或者仍然最优呢？</code></p>\n<p>显然并不一定，比如从Wi-Fi切到了移动4G，背后整条网络链路都不同了，之前的IP列表很有可能不是最优的了，极端情况下可能某些IP地址也不可用了。因此，我们需要最好IP列表的及时更新，保证无论网络如何切换，我们都能使用最优的IP地址列表。</p>\n<p>具体有下面几种方式：</p>\n<ol>\n<li>定时器监听HttpDNS返回的<code>TTL过期时间</code>。当IP列表即将过期前，发起请求获取下一轮的IP列表并进行更新；</li>\n<li>监控网络连接状态，网络链路切换，比如Wi-Fi/3G/4G转换，如果是Wi-Fi，还可以监控SSID信息变更（针对不同的Wi-Fi热点），及时触发IP列表刷新；在异步更新过程中，可以仍然使用旧缓存IP提供服务；</li>\n<li>配置中心下发，这种有时会用在服务器分流，比如某台服务器压力过大，可以通过配置中心系统下发新的IP列表给客户端访问。</li>\n</ol>\n<p>另外，IP列表缓存应该对不同网络类型、网络标识有对应的一份缓存，可以使用<code>网络类型（3G、4G、Wi-Fi等）+网络标识（SSID、ispCode等）</code>作为<code>缓存Key</code>，当网络切换时，使用Key去查询缓存。</p>\n<p>这些缓存可以持久化到多个文件，以Key作为文件名，同时可以基于当前网络状态，缓存一份IP列表到内存供使用，当网络状态变化，则刷新内存缓存。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/1/16/16854a8022cf2833?w=1280&amp;h=852&amp;f=jpeg&amp;s=142010\" alt=\"\"></p>\n<h2 id=\"IP列表可用性兜底策略\"><a href=\"#IP列表可用性兜底策略\" class=\"headerlink\" title=\"IP列表可用性兜底策略\"></a>IP列表可用性兜底策略</h2><p>通过更新机制，我们可以保证本地IP列表缓存动态更新的及时性。那么，<code>如果HttpDNS服务器出现故障呢，或者首次打开App，HttpDNS还没有完成，或者大面积DNS劫持等，怎么办呢？</code></p>\n<p>所以说，除了及时获取最优IP列表，我们还要考虑，如果获取不到IP列表，如何进行兜底？保证用户的网络请求不受影响。</p>\n<p>在线上运行中，可以采取下面四组IP兜底策略，按优先级排列如下：</p>\n<ul>\n<li>HttpDNS IP：即大厂自建的HttpDNS服务获取动态IP；</li>\n<li>DNS IP：即常规Local DNS获取IP；</li>\n<li>Auth IP：通过配置下发的动态保底IP列表；</li>\n<li>Hardcode IP：本地写死的保底IP列表</li>\n</ul>\n<p>前面两种动态IP不用多说，大家都清楚，这两者可以动态获取IP，效果最好。但是，如果发生故障，导致这两个方案都不可用，比如大面积DNS劫持之类的，这时客户端必须能够自动降级到<code>静态兜底IP</code>，保证网络服务可用。</p>\n<p>但这也可能存在一个问题，就是<code>静态兜底IP</code>对应服务器访问量可能会突然暴增，如果峰值太高可能造成更大的危害如<code>雪崩</code>。因此，除了内置静态兜底IP，还需要为客户端提供一个可通过<code>配置动态下发</code>的<code>兜底IP列表</code>，可以做到负载均衡，将流量分散到不同机器上。而且这些静态IP贵精不贵多，并且要有高可用的后台服务保证，作为全局网络服务的兜底。</p>\n<h2 id=\"针对弱网的多IP复合连接测速\"><a href=\"#针对弱网的多IP复合连接测速\" class=\"headerlink\" title=\"针对弱网的多IP复合连接测速\"></a>针对弱网的多IP复合连接测速</h2><p>通过上面的几套方案，可以保证用户能够<code>高可用的获取最优IP列表</code>，提高用户访问速度，而且能应对各种复杂的网络状态。</p>\n<p>那么现在考虑这样一种情况，上面的IP列表我们能够正常的获取，但是，<strong>用户处于弱网状态下，IP连接成功率很低，怎么办呢？</strong></p>\n<p>针对弱网一般有两种方式：</p>\n<ul>\n<li>串行连接：先连接第一个IP，直到发生了超时，再去对第二个IP建连；</li>\n<li>并行连接：同时对多个IP建立连接，哪个连成功了就用哪个；</li>\n</ul>\n<p>这两种方案的缺点是：串行连接可能需要很长时间的试错，才能找到可用的IP，而且这里还取决于如何选择超时时间，如果超时时间较长，则需要很长时间才能找到可用IP；如果很短，则可能会漏掉一些相对优质的IP，不断去尝试新IP，恶性循环；而并行连接则会对服务端造成极大的连接负载压力和一定程度的浪费，对于电量也有一定程度开销。</p>\n<p>因此，这里我们介绍下<code>Mars里的复合连接策略</code>作为学习参考：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/1/16/16854a80252a5bf8?w=640&amp;h=296&amp;f=png&amp;s=114867\" alt=\"\"></p>\n<p>在弱网状态下，依次发起对5组IP+Port的连接，10s作为超时时间。当前一个连接发起了4s钟还未成功，则立即发起下一个连接，以此类推。当其中有一个连接建立成功，则立即停止其他连接。这样的方式可以兼备串行连接和并行连接的优势：较快找到可用IP，同时对于服务器不会造成过大的连接压力。至于这个超时时间10s，则可以通过上报数据来动态统计，找到一个合理的超时时间。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/1/16/16854a802525d5dc?w=1000&amp;h=666&amp;f=jpeg&amp;s=247647\" alt=\"\"></p>\n<h2 id=\"自主网络诊断\"><a href=\"#自主网络诊断\" class=\"headerlink\" title=\"自主网络诊断\"></a>自主网络诊断</h2><p>在真实的线上环境我们发现，即使IP和后台服务均有效，仍有一部分用户的网络连接会出现失败。而此时单纯从IP地址已经分析不出原因，很有可能是该用户的网络链路上存在问题导致连接失败。</p>\n<p>这时就需要我们主动去探测这个用户的网络连接并诊断整条连接链路。</p>\n<p>因此，为了准确了解线上网络错误的用户的真实情况，我们会在客户端里内置网络诊断策略，通过<code>Ping</code>或者<code>TraceRoute</code>探测用户手机到服务器的整条网络链路上的情况，并将数据存储上报，用于分析用户的真实网络错误原因。</p>\n<p><a href=\"https://zh.wikipedia.org/wiki/Ping\" target=\"_blank\" rel=\"external\">Ping</a>大家比较熟悉，目的是为了测试另一台主机是否可达，向目标主机发送Echo包并等待回包；而<a href=\"https://zh.wikipedia.org/wiki/Traceroute\" target=\"_blank\" rel=\"external\">TraceRoute</a>可以获取数据包在IP网络经过的路由器的IP地址，原理如下：</p>\n<ul>\n<li>程序是利用增加存活时间（TTL）值来实现其功能的。每当数据包经过一个路由器，其存活时间就会减1。当其存活时间是0时，主机便取消数据包，并发送一个ICMP TTL数据包给原数据包的发出者。</li>\n<li>程序发出的首3个数据包TTL值是1，之后3个是2，如此类推，它便得到一连串数据包路径。注意IP不保证每个数据包走的路径都一样。</li>\n</ul>\n<p>在Android上一般有两种方式来实现这个诊断：</p>\n<ol>\n<li>通过后台线程执行ping命令的方式，模拟traceroute的过程；</li>\n<li>通过编译开源网络检测库<code>iputils</code>C代码的方式对traceroute进行了套接字发送ICMP报文模拟。</li>\n</ol>\n<p>感兴趣的可以参考文末提供的开源项目<code>LDNetDiagnoService</code>，通过诊断可以把日志上报用于分析，并作出相关的调整和优化。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>本文针对如何提高网络连接的高可用性做了讲解和分析，线上方案最重要考虑的就是兜底，无论发生何种问题，都要保证网络服务可用。如果用户连我们的服务器都连接不上，那可能会带来非常严重的灾难；当然，我们也要考虑服务器负载，不能造成服务器压力过大，导致雪崩之类的问题。</p>\n<p>有相关疑问欢迎随时留言。</p>\n<hr>\n<p>谢谢。</p>\n<p>wingjay</p>\n<hr>\n<h3 id=\"《亿级Android架构》小专栏介绍\"><a href=\"#《亿级Android架构》小专栏介绍\" class=\"headerlink\" title=\"《亿级Android架构》小专栏介绍\"></a>《亿级Android架构》小专栏介绍</h3><p>业务的快速增长离不开稳定可靠的架构。<a href=\"https://xiaozhuanlan.com/AndroidArch\" target=\"_blank\" rel=\"external\">《亿级Android架构》</a>小专栏会基于作者实际工作经验，结合国内大厂如阿里、腾讯、美团等基础架构现状，尝试谈谈如何设计一套好的架构来支持业务从0到1，甚至到亿，希望与大家多多探讨。</p>\n<p>本专栏主要内容：</p>\n<ol>\n<li>当前大厂有哪些Android架构；</li>\n<li>这些架构能解决什么问题；</li>\n<li>这些架构的原理是什么；</li>\n<li>学习这些架构对我们自身的意义。</li>\n</ol>\n<p><strong><a href=\"https://xiaozhuanlan.com/AndroidArch\" target=\"_blank\" rel=\"external\">《亿级Android架构》</a>小专栏文章列表：</strong></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/1934527806\" target=\"_blank\" rel=\"external\">《亿级 Android 架构》专栏随谈》</a></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/6982074351\" target=\"_blank\" rel=\"external\">《Android 架构之网络连接与加速》</a></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/3758142906\" target=\"_blank\" rel=\"external\">《Android 架构之长连接技术》</a></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/2130768549\" target=\"_blank\" rel=\"external\">《Android 架构之高可用移动网络连接》</a></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/8159302674\" target=\"_blank\" rel=\"external\">《Android 架构之网络安全演进》</a></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/2694081375\" target=\"_blank\" rel=\"external\">《Android 架构之高性能移动端日志系统》</a></p>\n<hr>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=2649286458&amp;idx=1&amp;sn=320f690faa4f97f7a49a291d4de174a9&amp;chksm=8334c3b8b4434aae904b6d590027b100283ef175938610805dd33ca53f004bd3c56040b11fa6#rd\" target=\"_blank\" rel=\"external\">《微信终端跨平台组件 Mars 系列（三）连接超时与IP&amp;Port排序》</a></p>\n<p><a href=\"http://www.52im.net/thread-1588-1-1.html\" target=\"_blank\" rel=\"external\">《海量之道系列文章之弱联网优化》</a></p>\n<p><a href=\"https://github.com/Lede-Inc/LDNetDiagnoService_Android\" target=\"_blank\" rel=\"external\">《LDNetDiagnoService_Android》</a></p>\n<p><a href=\"https://tech.meituan.com/Shark_SDK.html\" target=\"_blank\" rel=\"external\">《美团点评移动网络优化实践》</a></p>","sticky":0},{"title":"Java 技术之动态代理机制","date":"2018-02-11T06:46:30.000Z","commentIssueId":28,"_content":"> 之前的文章里讲解过了Java的反射机制、垃圾回收机制，这一次我们来讲解一个更有意思的机制：动态代理。学习下Java里为什么出现这样一个机制，什么场合下会使用这个机制。\n\n> [《Java 技术之反射》](/2017/04/26/Java-%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%8F%8D%E5%B0%84/)\n> [《Java 技术之类加载机制》](/2017/05/08/java_classloader/)\n\n<!-- more -->\n## 静态代理\n常规的代理模式有以下三个部分组成：\n**功能接口**\n```java\ninterface IFunction {\n\tvoid doAThing();\n}\n```\n**功能提供者**\n```java\nclass FunctionProvider implement IFunction {\n\tpublic void doAThing {\n\t\tSystem.out.print(\"do A\");\n\t}\n}\n```\n**功能代理者**\n```java\nclass Proxy implement IFunction {\n\tprivate FunctionProvider provider;\n\tProxy(FunctionProvider provider) {\n\t\tthis.provider = provider;\n\t}\n\n\tpublic void doAThing {\n\t\tprovider.doAThing();\n\t}\n}\n```\n\n前两者就是普通的接口和实现类，而第三个就是所谓的代理类。对于使用者而言，他会让代理类去完成某件任务，并不关心这件任务具体的跑腿者。\n\n这就是静态代理，好处是方便调整变换具体实现类，而使用者不会受到任何影响。\n\n不过这种方式也存在弊端：比如有多个接口需要进行代理，那么就要为每一个功能提供者创建对应的一个代理类，那就会越来越庞大。而且，所谓的“静态”代理，意味着必须提前知道被代理的委托类。\n\n通过下面一个例子来说明下：\n\n#### 统计函数耗时--静态代理实现\n现在希望通过一个代理类，对我感兴趣的方法进行耗时统计，利用静态代理有如下实现：\n\n```java\ninterface IAFunc {\n\tvoid doA();\n}\ninterface IBFunc {\n\tvoid doB();\n}\n```\n\n```java\nclass TimeConsumeProxy implement IAFunc, IBFunc {\n\tprivate AFunc a;\n\tprivate BFunc b;\n\tpublic(AFunc a, BFunc b) {\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t}\n\tvoid doA() {\n\t\tlong start = System.currentMillions();\n\n\t\ta.doA();\n\t\t\n\t\tSystem.out.println(\"耗时：\" + (System.currentMillions() - start));\n\t}\n\tvoid doB() {\n\t\tlong start = System.currentMillions();\n\n\t\tb.doB();\n\t\t\n\t\tSystem.out.println(\"耗时：\" + (System.currentMillions() - start));\n\t}\n}\n```\n\n弊端很明显，如果接口越多，每新增一个函数都要去修改这个`TimeConsumeProxy`代理类：把委托类对象传进去，实现接口，在函数执行前后统计耗时。\n\n这种方式显然不是可持续性的，下面来看下使用动态代理的实现方式，进行对比。\n\n## 动态代理\n动态代理的核心思想是通过Java Proxy类，为传入进来的任意对象动态生成一个代理对象，这个代理对象默认实现了原始对象的所有接口。\n\n还是通过统计函数耗时例子来说明更加直接。\n\n#### 统计函数耗时--动态代理实现\n```java\ninterface IAFunc {\n\tvoid doA();\n}\ninterface IBFunc {\n\tvoid doB();\n}\n```\n\n```java\nclass A implement IAFunc { ... }\nclass B implement IBFunc { ... }\n```\n\n```java\nclass TimeConsumeProxy implements InvocationHandler {\n\tprivate Object realObject;\n\n\tpublic Object bind(Object realObject) {\n\t\tthis.realObject = realObject;\n\t\tObject proxyObject = Proxy.newInstance(\n\t\t\trealObject.getClass().getClassLoader(),\n\t\t\trealObject.getClass().getInterfaces(),\n\t\t\tthis\n\t\t);\n\n\t\treturn proxyObject;\n\t}\n\n\t@Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        long start = System.currentMillions();\n\n        Object result = method.invoke(target, args);\n\n        System.out.println(\"耗时：\" + (System.currentMillions() - start));\n\n        return result;\n    }\n}\n```\n\n具体使用时：\n```java\npublic static void main(String[] args) {\n\tA a = new A();\n\tIAFunc aProxy = (IAFunc) new TimeConsumeProxy().bind(a);\n\taProxy.doA();\n\n\tB b = new B();\n\tIBFunc bProxy = (IBFunc) new TimeConsumeProxy().bind(b);\n\tbProxy.doB();\t\n}\n```\n\n这里最大的区别就是：代理类和委托类**互相透明独立**，逻辑没有任何耦合，在运行时才绑定在一起。这也就是静态代理与动态代理最大的不同，带来的好处就是：无论委托类有多少个，代理类不受到任何影响，而且在编译时无需知道具体委托类。\n\n回到动态代理本身，上面代码中最重要的就是:\n```java\nObject proxyObject = Proxy.newInstance(\n\t\t\trealObject.getClass().getClassLoader(),\n\t\t\trealObject.getClass().getInterfaces(),\n\t\t\tthis\n\t\t);\n```\n通过Proxy工具，把真实委托类转换成了一个代理类，最开始提到了一个代理模式的三要素：功能接口、功能提供者、功能代理者；在这里对应的就是：`realObject.getClass().getInterfaces()`，`realObject`，`TimeConsumeProxy`。\n\n其实动态代理并不复杂，通过一个Proxy工具，为委托类的接口自动生成一个代理对象，后续的函数调用都通过这个代理对象进行发起，最终会执行到`InvocationHandler#invoke`方法，在这个方法里除了调用真实委托类对应的方法，还可以做一些其他自定义的逻辑，比如上面的运行耗时统计等。\n\n## 探索动态代理实现机制\n好了，上面我们已经把动态代理的基本用法及为什么要用动态代理进行了讲解，很多文章到这里也差不多了，不过我们还准备进一步探索一下给感兴趣的读者。\n\n抛出几个问题：\n1. 上面生成的代理对象`Object proxyObject`究竟是个什么东西？为什么它可以转型成`IAFunc`，还能调用`doA()`方法？\n2. 这个`proxyObject`是怎么生成出来的？它是一个class吗？\n\n\n下面我先给出答案，再一步步探究这个答案是如何来的。\n\n### 问题一: proxyObject究竟是个什么 -> 动态生成的$Proxy0.class文件\n在调用`Proxy.newInstance`后，Java最终会为委托类`A`生成一个真实的class文件：`$Proxy0.class`，而`proxyObject`就是这个class的一个实例。\n\n猜一下，这个`$Proxy0.class`类长什么样呢，包含了什么方法呢？回看下刚刚的代码：\n```java\nIAFunc aProxy = (IAFunc) new TimeConsumeProxy().bind(a);\naProxy.doA();\n```\n\n推理下，显然这个`$Proxy0.class`实现了 `IAFunc` 接口，同时它内部也实现了`doA()`方法，而且重点是：这个`doA()`方法在运行时会执行到`TimeConsumeProxy#invoke()`方法里。\n\n重点来了！下面我们来看下这个`$Proxy0.class`文件，把它放进IDE反编译下，可以看到如下内容，来验证下刚刚的猜想：\n\n```java\nfinal class $Proxy0 extends Proxy implements IAFunc {\n    private static Method m1;\n    private static Method m3;\n    private static Method m2;\n    private static Method m0;\n\n    public $Proxy0(InvocationHandler var1) throws  {\n        super(var1);\n    }\n\n    public final boolean equals(Object var1) throws  {\n        // 省略\n    }\n\n    public final void doA() throws  {\n        try {\n        \t// 划重点\n            super.h.invoke(this, m3, (Object[])null);\n        } catch (RuntimeException | Error var2) {\n            throw var2;\n        } catch (Throwable var3) {\n            throw new UndeclaredThrowableException(var3);\n        }\n    }\n\n    public final String toString() throws  {\n        // 省略\n    }\n\n    public final int hashCode() throws  {\n        // 省略\n    }\n\n    static {\n        try {\n        \t// 划重点\n            m3 = Class.forName(\"proxy.IAFunc\").getMethod(\"doA\", new Class[0]);\n\n            m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", new Class[]{Class.forName(\"java.lang.Object\")});\n            m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\", new Class[0]);\n            m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\", new Class[0]);\n        } catch (NoSuchMethodException var2) {\n            throw new NoSuchMethodError(var2.getMessage());\n        } catch (ClassNotFoundException var3) {\n            throw new NoClassDefFoundError(var3.getMessage());\n        }\n    }\n}\n```\n\n没错，刚刚的猜想都中了！实现了`IAFunc`接口和`doA()`方法，不过，`doA()`里是什么鬼？\n\n```java\nsuper.h.invoke(this, m3, (Object[])null);\n```\n\n回看下，`TimeConsumeProxy`里面的`invoke`方法，它的函数签名是啥？\n```java\npublic Object invoke(Object proxy, Method method, Object[] args);\n```\n\n没错，`doA()`里做的就是调用`TimeConsumeProxy#invoke()`方法。\n\n那么也就是说，下面这段代码执行流程如下：\n```java\nIAFunc aProxy = (IAFunc) new TimeConsumeProxy().bind(a);\naProxy.doA();\n```\n\n1. 基于传入的委托类`A`，生成一个`$Proxy0.class`文件；\n2. 创建一个`$Proxy0.class`对象，转型为`IAFunc`接口；\n3. 调用`aProxy.doA()`时，自动调用TimeConsumeProxy内部的`invoke`方法。\n\n### 问题二：proxyObject 是怎么一步步生成出来的 -> $Proxy0.class文件生成流程\n刚刚从末尾看了结果，现在我们回到代码的起始端来看：\n```java\nObject proxyObject = Proxy.newInstance(\n\t\t\trealObject.getClass().getClassLoader(),\n\t\t\trealObject.getClass().getInterfaces(),\n\t\t\tthis\n\t\t);\n```\n\n准备好，开始发车读源码了。我会截取重要的代码并加上注释。\n\n先看`Proxy.newInstance()`:\n```java\npublic static Object newProxyInstance(ClassLoader loader,\n                                      Class<?>[] interfaces,\n                                      InvocationHandler h) {\n    //复制要代理的接口                                  \t\n\tfinal Class<?>[] intfs = interfaces.clone();\n\n\t//重点：生成 $Proxy0.class 文件并通过 ClassLoader 加载进来\n\tClass<?> cl = getProxyClass0(loader, intfs);\n\n\t//对$Proxy0.class生成一个实例，就是`proxyObject`\n\tfinal Constructor<?> cons = cl.getConstructor(constructorParams);\n\treturn cons.newInstance(new Object[]{h});\n}\n```\n\n再来看 `getProxyClass0` 的具体实现：`ProxyClassFactory`工厂类：\n```\n@Override\npublic Class<?> apply(ClassLoader loader, Class<?>[] interfaces) {\n\t// 参数为ClassLoader和要代理的接口\n\n\tMap<Class<?>, Boolean> interfaceSet = new IdentityHashMap<>(interfaces.length);\n\n\t// 1. 验证ClassLoader和接口有效性\n\tfor (Class<?> intf : interfaces) {\n\t\t// 验证classLoader正确性\n\t\tClass<?> interfaceClass = Class.forName(intf.getName(), false, loader);\n\t\tif (interfaceClass != intf) {\n            throw new IllegalArgumentException(\n                intf + \" is not visible from class loader\");\n        }\n\n\t\t// 验证传入的接口class有效\n\t\tif (!interfaceClass.isInterface()) { ... } \n\n\t\t// 验证接口是否重复\n\t\tif (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) { ... }\n\t}\n\n\t// 2. 创建包名及类名 $Proxy0.class\n\tproxyPkg = ReflectUtil.PROXY_PACKAGE + \".\";\n\tlong num = nextUniqueNumber.getAndIncrement();\n    String proxyName = proxyPkg + proxyClassNamePrefix + num;\n\n    // 3. 创建class字节码内容\n    byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);\n\n    // 4. 基于字节码和类名，生成Class<?>对象\n    return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length);\n}\n```\n\n再看下第三步生成class内容 `ProxyGenerator.generateProxyClass`：\n```java\n// 添加 hashCode equals toString方法\naddProxyMethod(hashCodeMethod, Object.class);\naddProxyMethod(equalsMethod, Object.class);\naddProxyMethod(toStringMethod, Object.class);\n\n// 添加委托类的接口实现\nfor (int i = 0; i < interfaces.length; i++) {\n    Method[] methods = interfaces[i].getMethods();\n    for (int j = 0; j < methods.length; j++) {\n         addProxyMethod(methods[j], interfaces[i]);\n    }\n}\n\n// 添加构造函数\nmethods.add(this.generateConstructor());\n```\n\n这里构造好了类的内容：添加必要的函数，实现接口，构造函数等，下面就是要写入上一步看到的 `$Proxy0.class` 了。\n\n```java\n ByteArrayOutputStream bout = new ByteArrayOutputStream();\n DataOutputStream dout = new DataOutputStream(bout);\n dout.writeInt(0xCAFEBABE);\n ...\n dout.writeShort(ACC_PUBLIC | ACC_FINAL | ACC_SUPER);\n ...\n return bout.toByteArray();\n```\n\n到这里就生成了第一步看到的`$Proxy0.class`文件了，完成闭环，讲解完成！\n\n## 动态代理小结\n通过上面的讲解可以看出，动态代理可以随时为任意的委托类进行代理，并可以在`InvocationHandler#invoke`拿到运行时的信息，并可以做一些切面处理。\n\n在动态代理背后，其实是为一个委托类动态生成了一个`$Proxy0.class`的代理类，该代理类会实现委托类的接口，并把接口调用转发到`InvocationHandler#invoke`上，最终调用到真实委托类的对应方法。\n\n动态代理机制把委托类和代理类进行了隔离，提高了扩展性。\n\n\n## Java动态代理与Python装饰器\n这是Java语言提供的一个有意思的语言特性，而其实Python里也提供了一种类似的特性：装饰器，可以达到类似的面相切面编程思想，下次有空再把两者做下对比，这次先到这。\n\n\n--\n谢谢。\n\nwingjay\n\n\n\n\n\n\n","source":"_posts/Java-技术之动态代理机制.md","raw":"title: Java 技术之动态代理机制\ndate: 2018-02-11 14:46:30\npermalink: java-dynamic-proxy\ncategories:\n\t- 深入理解Java技术\ntags:\n\t- Java\n\t- 动态代理\ncommentIssueId: 28\n---\n> 之前的文章里讲解过了Java的反射机制、垃圾回收机制，这一次我们来讲解一个更有意思的机制：动态代理。学习下Java里为什么出现这样一个机制，什么场合下会使用这个机制。\n\n> [《Java 技术之反射》](/2017/04/26/Java-%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%8F%8D%E5%B0%84/)\n> [《Java 技术之类加载机制》](/2017/05/08/java_classloader/)\n\n<!-- more -->\n## 静态代理\n常规的代理模式有以下三个部分组成：\n**功能接口**\n```java\ninterface IFunction {\n\tvoid doAThing();\n}\n```\n**功能提供者**\n```java\nclass FunctionProvider implement IFunction {\n\tpublic void doAThing {\n\t\tSystem.out.print(\"do A\");\n\t}\n}\n```\n**功能代理者**\n```java\nclass Proxy implement IFunction {\n\tprivate FunctionProvider provider;\n\tProxy(FunctionProvider provider) {\n\t\tthis.provider = provider;\n\t}\n\n\tpublic void doAThing {\n\t\tprovider.doAThing();\n\t}\n}\n```\n\n前两者就是普通的接口和实现类，而第三个就是所谓的代理类。对于使用者而言，他会让代理类去完成某件任务，并不关心这件任务具体的跑腿者。\n\n这就是静态代理，好处是方便调整变换具体实现类，而使用者不会受到任何影响。\n\n不过这种方式也存在弊端：比如有多个接口需要进行代理，那么就要为每一个功能提供者创建对应的一个代理类，那就会越来越庞大。而且，所谓的“静态”代理，意味着必须提前知道被代理的委托类。\n\n通过下面一个例子来说明下：\n\n#### 统计函数耗时--静态代理实现\n现在希望通过一个代理类，对我感兴趣的方法进行耗时统计，利用静态代理有如下实现：\n\n```java\ninterface IAFunc {\n\tvoid doA();\n}\ninterface IBFunc {\n\tvoid doB();\n}\n```\n\n```java\nclass TimeConsumeProxy implement IAFunc, IBFunc {\n\tprivate AFunc a;\n\tprivate BFunc b;\n\tpublic(AFunc a, BFunc b) {\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t}\n\tvoid doA() {\n\t\tlong start = System.currentMillions();\n\n\t\ta.doA();\n\t\t\n\t\tSystem.out.println(\"耗时：\" + (System.currentMillions() - start));\n\t}\n\tvoid doB() {\n\t\tlong start = System.currentMillions();\n\n\t\tb.doB();\n\t\t\n\t\tSystem.out.println(\"耗时：\" + (System.currentMillions() - start));\n\t}\n}\n```\n\n弊端很明显，如果接口越多，每新增一个函数都要去修改这个`TimeConsumeProxy`代理类：把委托类对象传进去，实现接口，在函数执行前后统计耗时。\n\n这种方式显然不是可持续性的，下面来看下使用动态代理的实现方式，进行对比。\n\n## 动态代理\n动态代理的核心思想是通过Java Proxy类，为传入进来的任意对象动态生成一个代理对象，这个代理对象默认实现了原始对象的所有接口。\n\n还是通过统计函数耗时例子来说明更加直接。\n\n#### 统计函数耗时--动态代理实现\n```java\ninterface IAFunc {\n\tvoid doA();\n}\ninterface IBFunc {\n\tvoid doB();\n}\n```\n\n```java\nclass A implement IAFunc { ... }\nclass B implement IBFunc { ... }\n```\n\n```java\nclass TimeConsumeProxy implements InvocationHandler {\n\tprivate Object realObject;\n\n\tpublic Object bind(Object realObject) {\n\t\tthis.realObject = realObject;\n\t\tObject proxyObject = Proxy.newInstance(\n\t\t\trealObject.getClass().getClassLoader(),\n\t\t\trealObject.getClass().getInterfaces(),\n\t\t\tthis\n\t\t);\n\n\t\treturn proxyObject;\n\t}\n\n\t@Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        long start = System.currentMillions();\n\n        Object result = method.invoke(target, args);\n\n        System.out.println(\"耗时：\" + (System.currentMillions() - start));\n\n        return result;\n    }\n}\n```\n\n具体使用时：\n```java\npublic static void main(String[] args) {\n\tA a = new A();\n\tIAFunc aProxy = (IAFunc) new TimeConsumeProxy().bind(a);\n\taProxy.doA();\n\n\tB b = new B();\n\tIBFunc bProxy = (IBFunc) new TimeConsumeProxy().bind(b);\n\tbProxy.doB();\t\n}\n```\n\n这里最大的区别就是：代理类和委托类**互相透明独立**，逻辑没有任何耦合，在运行时才绑定在一起。这也就是静态代理与动态代理最大的不同，带来的好处就是：无论委托类有多少个，代理类不受到任何影响，而且在编译时无需知道具体委托类。\n\n回到动态代理本身，上面代码中最重要的就是:\n```java\nObject proxyObject = Proxy.newInstance(\n\t\t\trealObject.getClass().getClassLoader(),\n\t\t\trealObject.getClass().getInterfaces(),\n\t\t\tthis\n\t\t);\n```\n通过Proxy工具，把真实委托类转换成了一个代理类，最开始提到了一个代理模式的三要素：功能接口、功能提供者、功能代理者；在这里对应的就是：`realObject.getClass().getInterfaces()`，`realObject`，`TimeConsumeProxy`。\n\n其实动态代理并不复杂，通过一个Proxy工具，为委托类的接口自动生成一个代理对象，后续的函数调用都通过这个代理对象进行发起，最终会执行到`InvocationHandler#invoke`方法，在这个方法里除了调用真实委托类对应的方法，还可以做一些其他自定义的逻辑，比如上面的运行耗时统计等。\n\n## 探索动态代理实现机制\n好了，上面我们已经把动态代理的基本用法及为什么要用动态代理进行了讲解，很多文章到这里也差不多了，不过我们还准备进一步探索一下给感兴趣的读者。\n\n抛出几个问题：\n1. 上面生成的代理对象`Object proxyObject`究竟是个什么东西？为什么它可以转型成`IAFunc`，还能调用`doA()`方法？\n2. 这个`proxyObject`是怎么生成出来的？它是一个class吗？\n\n\n下面我先给出答案，再一步步探究这个答案是如何来的。\n\n### 问题一: proxyObject究竟是个什么 -> 动态生成的$Proxy0.class文件\n在调用`Proxy.newInstance`后，Java最终会为委托类`A`生成一个真实的class文件：`$Proxy0.class`，而`proxyObject`就是这个class的一个实例。\n\n猜一下，这个`$Proxy0.class`类长什么样呢，包含了什么方法呢？回看下刚刚的代码：\n```java\nIAFunc aProxy = (IAFunc) new TimeConsumeProxy().bind(a);\naProxy.doA();\n```\n\n推理下，显然这个`$Proxy0.class`实现了 `IAFunc` 接口，同时它内部也实现了`doA()`方法，而且重点是：这个`doA()`方法在运行时会执行到`TimeConsumeProxy#invoke()`方法里。\n\n重点来了！下面我们来看下这个`$Proxy0.class`文件，把它放进IDE反编译下，可以看到如下内容，来验证下刚刚的猜想：\n\n```java\nfinal class $Proxy0 extends Proxy implements IAFunc {\n    private static Method m1;\n    private static Method m3;\n    private static Method m2;\n    private static Method m0;\n\n    public $Proxy0(InvocationHandler var1) throws  {\n        super(var1);\n    }\n\n    public final boolean equals(Object var1) throws  {\n        // 省略\n    }\n\n    public final void doA() throws  {\n        try {\n        \t// 划重点\n            super.h.invoke(this, m3, (Object[])null);\n        } catch (RuntimeException | Error var2) {\n            throw var2;\n        } catch (Throwable var3) {\n            throw new UndeclaredThrowableException(var3);\n        }\n    }\n\n    public final String toString() throws  {\n        // 省略\n    }\n\n    public final int hashCode() throws  {\n        // 省略\n    }\n\n    static {\n        try {\n        \t// 划重点\n            m3 = Class.forName(\"proxy.IAFunc\").getMethod(\"doA\", new Class[0]);\n\n            m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", new Class[]{Class.forName(\"java.lang.Object\")});\n            m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\", new Class[0]);\n            m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\", new Class[0]);\n        } catch (NoSuchMethodException var2) {\n            throw new NoSuchMethodError(var2.getMessage());\n        } catch (ClassNotFoundException var3) {\n            throw new NoClassDefFoundError(var3.getMessage());\n        }\n    }\n}\n```\n\n没错，刚刚的猜想都中了！实现了`IAFunc`接口和`doA()`方法，不过，`doA()`里是什么鬼？\n\n```java\nsuper.h.invoke(this, m3, (Object[])null);\n```\n\n回看下，`TimeConsumeProxy`里面的`invoke`方法，它的函数签名是啥？\n```java\npublic Object invoke(Object proxy, Method method, Object[] args);\n```\n\n没错，`doA()`里做的就是调用`TimeConsumeProxy#invoke()`方法。\n\n那么也就是说，下面这段代码执行流程如下：\n```java\nIAFunc aProxy = (IAFunc) new TimeConsumeProxy().bind(a);\naProxy.doA();\n```\n\n1. 基于传入的委托类`A`，生成一个`$Proxy0.class`文件；\n2. 创建一个`$Proxy0.class`对象，转型为`IAFunc`接口；\n3. 调用`aProxy.doA()`时，自动调用TimeConsumeProxy内部的`invoke`方法。\n\n### 问题二：proxyObject 是怎么一步步生成出来的 -> $Proxy0.class文件生成流程\n刚刚从末尾看了结果，现在我们回到代码的起始端来看：\n```java\nObject proxyObject = Proxy.newInstance(\n\t\t\trealObject.getClass().getClassLoader(),\n\t\t\trealObject.getClass().getInterfaces(),\n\t\t\tthis\n\t\t);\n```\n\n准备好，开始发车读源码了。我会截取重要的代码并加上注释。\n\n先看`Proxy.newInstance()`:\n```java\npublic static Object newProxyInstance(ClassLoader loader,\n                                      Class<?>[] interfaces,\n                                      InvocationHandler h) {\n    //复制要代理的接口                                  \t\n\tfinal Class<?>[] intfs = interfaces.clone();\n\n\t//重点：生成 $Proxy0.class 文件并通过 ClassLoader 加载进来\n\tClass<?> cl = getProxyClass0(loader, intfs);\n\n\t//对$Proxy0.class生成一个实例，就是`proxyObject`\n\tfinal Constructor<?> cons = cl.getConstructor(constructorParams);\n\treturn cons.newInstance(new Object[]{h});\n}\n```\n\n再来看 `getProxyClass0` 的具体实现：`ProxyClassFactory`工厂类：\n```\n@Override\npublic Class<?> apply(ClassLoader loader, Class<?>[] interfaces) {\n\t// 参数为ClassLoader和要代理的接口\n\n\tMap<Class<?>, Boolean> interfaceSet = new IdentityHashMap<>(interfaces.length);\n\n\t// 1. 验证ClassLoader和接口有效性\n\tfor (Class<?> intf : interfaces) {\n\t\t// 验证classLoader正确性\n\t\tClass<?> interfaceClass = Class.forName(intf.getName(), false, loader);\n\t\tif (interfaceClass != intf) {\n            throw new IllegalArgumentException(\n                intf + \" is not visible from class loader\");\n        }\n\n\t\t// 验证传入的接口class有效\n\t\tif (!interfaceClass.isInterface()) { ... } \n\n\t\t// 验证接口是否重复\n\t\tif (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) { ... }\n\t}\n\n\t// 2. 创建包名及类名 $Proxy0.class\n\tproxyPkg = ReflectUtil.PROXY_PACKAGE + \".\";\n\tlong num = nextUniqueNumber.getAndIncrement();\n    String proxyName = proxyPkg + proxyClassNamePrefix + num;\n\n    // 3. 创建class字节码内容\n    byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);\n\n    // 4. 基于字节码和类名，生成Class<?>对象\n    return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length);\n}\n```\n\n再看下第三步生成class内容 `ProxyGenerator.generateProxyClass`：\n```java\n// 添加 hashCode equals toString方法\naddProxyMethod(hashCodeMethod, Object.class);\naddProxyMethod(equalsMethod, Object.class);\naddProxyMethod(toStringMethod, Object.class);\n\n// 添加委托类的接口实现\nfor (int i = 0; i < interfaces.length; i++) {\n    Method[] methods = interfaces[i].getMethods();\n    for (int j = 0; j < methods.length; j++) {\n         addProxyMethod(methods[j], interfaces[i]);\n    }\n}\n\n// 添加构造函数\nmethods.add(this.generateConstructor());\n```\n\n这里构造好了类的内容：添加必要的函数，实现接口，构造函数等，下面就是要写入上一步看到的 `$Proxy0.class` 了。\n\n```java\n ByteArrayOutputStream bout = new ByteArrayOutputStream();\n DataOutputStream dout = new DataOutputStream(bout);\n dout.writeInt(0xCAFEBABE);\n ...\n dout.writeShort(ACC_PUBLIC | ACC_FINAL | ACC_SUPER);\n ...\n return bout.toByteArray();\n```\n\n到这里就生成了第一步看到的`$Proxy0.class`文件了，完成闭环，讲解完成！\n\n## 动态代理小结\n通过上面的讲解可以看出，动态代理可以随时为任意的委托类进行代理，并可以在`InvocationHandler#invoke`拿到运行时的信息，并可以做一些切面处理。\n\n在动态代理背后，其实是为一个委托类动态生成了一个`$Proxy0.class`的代理类，该代理类会实现委托类的接口，并把接口调用转发到`InvocationHandler#invoke`上，最终调用到真实委托类的对应方法。\n\n动态代理机制把委托类和代理类进行了隔离，提高了扩展性。\n\n\n## Java动态代理与Python装饰器\n这是Java语言提供的一个有意思的语言特性，而其实Python里也提供了一种类似的特性：装饰器，可以达到类似的面相切面编程思想，下次有空再把两者做下对比，这次先到这。\n\n\n--\n谢谢。\n\nwingjay\n\n\n\n\n\n\n","slug":"java-dynamic-proxy","published":1,"updated":"2018-11-26T06:56:27.480Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplshu00243dn8tcvza4ao","content":"<blockquote>\n<p>之前的文章里讲解过了 Java 的反射机制、垃圾回收机制，这一次我们来讲解一个更有意思的机制：动态代理。学习下 Java 里为什么出现这样一个机制，什么场合下会使用这个机制。</p>\n<p><a href=\"/2017/04/26/Java-%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%8F%8D%E5%B0%84/\">《Java 技术之反射》</a><br><a href=\"/2017/05/08/java_classloader/\">《Java 技术之类加载机制》</a></p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"静态代理\"><a href=\"# 静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理 </h2><p> 常规的代理模式有以下三个部分组成：<br><strong>功能接口</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IFunction</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doAThing</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>功能提供者</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FunctionProvider</span> <span class=\"title\">implement</span> <span class=\"title\">IFunction</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> doAThing &#123;</div><div class=\"line\">\t\tSystem.out.print(<span class=\"string\">\"do A\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>功能代理者</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Proxy</span> <span class=\"title\">implement</span> <span class=\"title\">IFunction</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> FunctionProvider provider;</div><div class=\"line\">\tProxy(FunctionProvider provider) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.provider = provider;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> doAThing &#123;</div><div class=\"line\">\t\tprovider.doAThing();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>前两者就是普通的接口和实现类，而第三个就是所谓的代理类。对于使用者而言，他会让代理类去完成某件任务，并不关心这件任务具体的跑腿者。</p>\n<p>这就是静态代理，好处是方便调整变换具体实现类，而使用者不会受到任何影响。</p>\n<p>不过这种方式也存在弊端：比如有多个接口需要进行代理，那么就要为每一个功能提供者创建对应的一个代理类，那就会越来越庞大。而且，所谓的“静态”代理，意味着必须提前知道被代理的委托类。</p>\n<p>通过下面一个例子来说明下：</p>\n<h4 id=\"统计函数耗时–静态代理实现\"><a href=\"# 统计函数耗时–静态代理实现\" class=\"headerlink\" title=\"统计函数耗时–静态代理实现\"></a>统计函数耗时–静态代理实现 </h4><p> 现在希望通过一个代理类，对我感兴趣的方法进行耗时统计，利用静态代理有如下实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IAFunc</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doA</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IBFunc</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doB</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TimeConsumeProxy</span> <span class=\"title\">implement</span> <span class=\"title\">IAFunc</span>, <span class=\"title\">IBFunc</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> AFunc a;</div><div class=\"line\">\t<span class=\"keyword\">private</span> BFunc b;</div><div class=\"line\">\t<span class=\"keyword\">public</span>(AFunc a, BFunc b) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.a = a;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.b = b;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doA</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">long</span> start = System.currentMillions();</div><div class=\"line\"></div><div class=\"line\">\t\ta.doA();</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"耗时：\"</span> + (System.currentMillions() - start));</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doB</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">long</span> start = System.currentMillions();</div><div class=\"line\"></div><div class=\"line\">\t\tb.doB();</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"耗时：\"</span> + (System.currentMillions() - start));</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>弊端很明显，如果接口越多，每新增一个函数都要去修改这个 <code>TimeConsumeProxy</code> 代理类：把委托类对象传进去，实现接口，在函数执行前后统计耗时。</p>\n<p>这种方式显然不是可持续性的，下面来看下使用动态代理的实现方式，进行对比。</p>\n<h2 id=\"动态代理\"><a href=\"# 动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理 </h2><p> 动态代理的核心思想是通过 Java Proxy 类，为传入进来的任意对象动态生成一个代理对象，这个代理对象默认实现了原始对象的所有接口。</p>\n<p>还是通过统计函数耗时例子来说明更加直接。</p>\n<h4 id=\"统计函数耗时–动态代理实现\"><a href=\"# 统计函数耗时–动态代理实现\" class=\"headerlink\" title=\"统计函数耗时–动态代理实现\"></a>统计函数耗时–动态代理实现</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IAFunc</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doA</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IBFunc</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doB</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> <span class=\"title\">implement</span> <span class=\"title\">IAFunc</span> </span>&#123; ... &#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"title\">implement</span> <span class=\"title\">IBFunc</span> </span>&#123; ... &#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TimeConsumeProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> Object realObject;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">bind</span><span class=\"params\">(Object realObject)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.realObject = realObject;</div><div class=\"line\">\t\tObject proxyObject = Proxy.newInstance(</div><div class=\"line\">\t\t\trealObject.getClass().getClassLoader(),</div><div class=\"line\">\t\t\trealObject.getClass().getInterfaces(),</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span></div><div class=\"line\">\t\t);</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> proxyObject;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">long</span> start = System.currentMillions();</div><div class=\"line\"></div><div class=\"line\">        Object result = method.invoke(target, args);</div><div class=\"line\"></div><div class=\"line\">        System.out.println(<span class=\"string\">\"耗时：\"</span> + (System.currentMillions() - start));</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> result;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>具体使用时：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\tA a = <span class=\"keyword\">new</span> A();</div><div class=\"line\">\tIAFunc aProxy = (IAFunc) <span class=\"keyword\">new</span> TimeConsumeProxy().bind(a);</div><div class=\"line\">\taProxy.doA();</div><div class=\"line\"></div><div class=\"line\">\tB b = <span class=\"keyword\">new</span> B();</div><div class=\"line\">\tIBFunc bProxy = (IBFunc) <span class=\"keyword\">new</span> TimeConsumeProxy().bind(b);</div><div class=\"line\">\tbProxy.doB();\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里最大的区别就是：代理类和委托类 <strong> 互相透明独立</strong>，逻辑没有任何耦合，在运行时才绑定在一起。这也就是静态代理与动态代理最大的不同，带来的好处就是：无论委托类有多少个，代理类不受到任何影响，而且在编译时无需知道具体委托类。</p>\n<p>回到动态代理本身，上面代码中最重要的就是:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object proxyObject = Proxy.newInstance(</div><div class=\"line\">\t\t\trealObject.getClass().getClassLoader(),</div><div class=\"line\">\t\t\trealObject.getClass().getInterfaces(),</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span></div><div class=\"line\">\t\t);</div></pre></td></tr></table></figure></p>\n<p>通过 Proxy 工具，把真实委托类转换成了一个代理类，最开始提到了一个代理模式的三要素：功能接口、功能提供者、功能代理者；在这里对应的就是：<code>realObject.getClass().getInterfaces()</code>，<code>realObject</code>，<code>TimeConsumeProxy</code>。</p>\n<p>其实动态代理并不复杂，通过一个 Proxy 工具，为委托类的接口自动生成一个代理对象，后续的函数调用都通过这个代理对象进行发起，最终会执行到 <code>InvocationHandler#invoke</code> 方法，在这个方法里除了调用真实委托类对应的方法，还可以做一些其他自定义的逻辑，比如上面的运行耗时统计等。</p>\n<h2 id=\"探索动态代理实现机制\"><a href=\"# 探索动态代理实现机制\" class=\"headerlink\" title=\"探索动态代理实现机制\"></a>探索动态代理实现机制 </h2><p> 好了，上面我们已经把动态代理的基本用法及为什么要用动态代理进行了讲解，很多文章到这里也差不多了，不过我们还准备进一步探索一下给感兴趣的读者。</p>\n<p>抛出几个问题：</p>\n<ol>\n<li>上面生成的代理对象 <code>Object proxyObject</code> 究竟是个什么东西？为什么它可以转型成 <code>IAFunc</code>，还能调用<code>doA()</code> 方法？</li>\n<li>这个 <code>proxyObject</code> 是怎么生成出来的？它是一个 class 吗？</li>\n</ol>\n<p>下面我先给出答案，再一步步探究这个答案是如何来的。</p>\n<h3 id=\"问题一 -proxyObject 究竟是个什么 -gt- 动态生成的 -Proxy0-class 文件\"><a href=\"# 问题一 -proxyObject 究竟是个什么 -gt- 动态生成的 -Proxy0-class 文件\" class=\"headerlink\" title=\"问题一: proxyObject 究竟是个什么 -&gt; 动态生成的 $Proxy0.class 文件\"></a>问题一: proxyObject 究竟是个什么 -&gt; 动态生成的 $Proxy0.class 文件 </h3><p> 在调用 <code>Proxy.newInstance</code> 后，Java 最终会为委托类 <code>A</code> 生成一个真实的 class 文件：<code>$Proxy0.class</code>，而 <code>proxyObject</code> 就是这个 class 的一个实例。</p>\n<p>猜一下，这个 <code>$Proxy0.class</code> 类长什么样呢，包含了什么方法呢？回看下刚刚的代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">IAFunc aProxy = (IAFunc) <span class=\"keyword\">new</span> TimeConsumeProxy().bind(a);</div><div class=\"line\">aProxy.doA();</div></pre></td></tr></table></figure></p>\n<p>推理下，显然这个 <code>$Proxy0.class</code> 实现了 <code>IAFunc</code> 接口，同时它内部也实现了 <code>doA()</code> 方法，而且重点是：这个 <code>doA()</code> 方法在运行时会执行到 <code>TimeConsumeProxy#invoke()</code> 方法里。</p>\n<p>重点来了！下面我们来看下这个 <code>$Proxy0.class</code> 文件，把它放进 IDE 反编译下，可以看到如下内容，来验证下刚刚的猜想：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> $<span class=\"title\">Proxy0</span> <span class=\"keyword\">extends</span> <span class=\"title\">Proxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">IAFunc</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m1;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m3;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m2;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m0;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> $Proxy0(InvocationHandler var1) <span class=\"keyword\">throws</span>  &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(var1);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object var1)</span> <span class=\"keyword\">throws</span>  </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 省略</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">doA</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span>  </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        \t<span class=\"comment\">// 划重点</span></div><div class=\"line\">            <span class=\"keyword\">super</span>.h.invoke(<span class=\"keyword\">this</span>, m3, (Object[])<span class=\"keyword\">null</span>);</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RuntimeException | Error var2) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> var2;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable var3) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UndeclaredThrowableException(var3);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span>  </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 省略</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span>  </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 省略</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">static</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        \t<span class=\"comment\">// 划重点</span></div><div class=\"line\">            m3 = Class.forName(<span class=\"string\">\"proxy.IAFunc\"</span>).getMethod(<span class=\"string\">\"doA\"</span>, <span class=\"keyword\">new</span> Class[<span class=\"number\">0</span>]);</div><div class=\"line\"></div><div class=\"line\">            m1 = Class.forName(<span class=\"string\">\"java.lang.Object\"</span>).getMethod(<span class=\"string\">\"equals\"</span>, <span class=\"keyword\">new</span> Class[]&#123;Class.forName(<span class=\"string\">\"java.lang.Object\"</span>)&#125;);</div><div class=\"line\">            m2 = Class.forName(<span class=\"string\">\"java.lang.Object\"</span>).getMethod(<span class=\"string\">\"toString\"</span>, <span class=\"keyword\">new</span> Class[<span class=\"number\">0</span>]);</div><div class=\"line\">            m0 = Class.forName(<span class=\"string\">\"java.lang.Object\"</span>).getMethod(<span class=\"string\">\"hashCode\"</span>, <span class=\"keyword\">new</span> Class[<span class=\"number\">0</span>]);</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NoSuchMethodException var2) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchMethodError(var2.getMessage());</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException var3) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoClassDefFoundError(var3.getMessage());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>没错，刚刚的猜想都中了！实现了 <code>IAFunc</code> 接口和 <code>doA()</code> 方法，不过，<code>doA()</code>里是什么鬼？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">super</span>.h.invoke(<span class=\"keyword\">this</span>, m3, (Object[])<span class=\"keyword\">null</span>);</div></pre></td></tr></table></figure>\n<p>回看下，<code>TimeConsumeProxy</code>里面的 <code>invoke</code> 方法，它的函数签名是啥？<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span></span>;</div></pre></td></tr></table></figure></p>\n<p>没错，<code>doA()</code>里做的就是调用 <code>TimeConsumeProxy#invoke()</code> 方法。</p>\n<p>那么也就是说，下面这段代码执行流程如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">IAFunc aProxy = (IAFunc) <span class=\"keyword\">new</span> TimeConsumeProxy().bind(a);</div><div class=\"line\">aProxy.doA();</div></pre></td></tr></table></figure></p>\n<ol>\n<li>基于传入的委托类 <code>A</code>，生成一个<code>$Proxy0.class</code> 文件；</li>\n<li>创建一个 <code>$Proxy0.class</code> 对象，转型为 <code>IAFunc</code> 接口；</li>\n<li>调用 <code>aProxy.doA()</code> 时，自动调用 TimeConsumeProxy 内部的 <code>invoke</code> 方法。</li>\n</ol>\n<h3 id=\"问题二：proxyObject- 是怎么一步步生成出来的 -gt-Proxy0-class 文件生成流程\"><a href=\"# 问题二：proxyObject- 是怎么一步步生成出来的 -gt-Proxy0-class 文件生成流程\" class=\"headerlink\" title=\"问题二：proxyObject 是怎么一步步生成出来的 -&gt; $Proxy0.class 文件生成流程\"></a>问题二：proxyObject 是怎么一步步生成出来的 -&gt; $Proxy0.class 文件生成流程 </h3><p> 刚刚从末尾看了结果，现在我们回到代码的起始端来看：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object proxyObject = Proxy.newInstance(</div><div class=\"line\">\t\t\trealObject.getClass().getClassLoader(),</div><div class=\"line\">\t\t\trealObject.getClass().getInterfaces(),</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span></div><div class=\"line\">\t\t);</div></pre></td></tr></table></figure></p>\n<p>准备好，开始发车读源码了。我会截取重要的代码并加上注释。</p>\n<p>先看<code>Proxy.newInstance()</code>:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title\">newProxyInstance</span><span class=\"params\">(ClassLoader loader,</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"params\">                                      Class&lt;?&gt;[] interfaces,</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"params\">                                      InvocationHandler h)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 复制要代理的接口                                  \t</span></div><div class=\"line\">\t<span class=\"keyword\">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// 重点：生成 $Proxy0.class 文件并通过 ClassLoader 加载进来</span></div><div class=\"line\">\tClass&lt;?&gt; cl = getProxyClass0(loader, intfs);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// 对 $Proxy0.class 生成一个实例，就是 `proxyObject`</span></div><div class=\"line\">\t<span class=\"keyword\">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</div><div class=\"line\">\t<span class=\"keyword\">return</span> cons.newInstance(<span class=\"keyword\">new</span> Object[]&#123;h&#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>再来看 <code>getProxyClass0</code> 的具体实现：<code>ProxyClassFactory</code>工厂类：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</div><div class=\"line\">\t// 参数为 ClassLoader 和要代理的接口</div><div class=\"line\"></div><div class=\"line\">\tMap&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length);</div><div class=\"line\"></div><div class=\"line\">\t// 1. 验证 ClassLoader 和接口有效性</div><div class=\"line\">\tfor (Class&lt;?&gt; intf : interfaces) &#123;</div><div class=\"line\">\t\t// 验证 classLoader 正确性</div><div class=\"line\">\t\tClass&lt;?&gt; interfaceClass = Class.forName(intf.getName(), false, loader);</div><div class=\"line\">\t\tif (interfaceClass != intf) &#123;</div><div class=\"line\">            throw new IllegalArgumentException(</div><div class=\"line\">                intf + &quot; is not visible from class loader&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">\t\t// 验证传入的接口 class 有效</div><div class=\"line\">\t\tif (!interfaceClass.isInterface()) &#123; ... &#125; </div><div class=\"line\"></div><div class=\"line\">\t\t// 验证接口是否重复</div><div class=\"line\">\t\tif (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123; ... &#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t// 2. 创建包名及类名 $Proxy0.class</div><div class=\"line\">\tproxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;;</div><div class=\"line\">\tlong num = nextUniqueNumber.getAndIncrement();</div><div class=\"line\">    String proxyName = proxyPkg + proxyClassNamePrefix + num;</div><div class=\"line\"></div><div class=\"line\">    // 3. 创建 class 字节码内容</div><div class=\"line\">    byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);</div><div class=\"line\"></div><div class=\"line\">    // 4. 基于字节码和类名，生成 Class&lt;?&gt; 对象</div><div class=\"line\">    return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>再看下第三步生成 class 内容 <code>ProxyGenerator.generateProxyClass</code>：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 添加 hashCode equals toString 方法</span></div><div class=\"line\">addProxyMethod(hashCodeMethod, Object.class);</div><div class=\"line\">addProxyMethod(equalsMethod, Object.class);</div><div class=\"line\">addProxyMethod(toStringMethod, Object.class);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 添加委托类的接口实现</span></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; interfaces.length; i++) &#123;</div><div class=\"line\">    Method[] methods = interfaces[i].getMethods();</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; methods.length; j++) &#123;</div><div class=\"line\">         addProxyMethod(methods[j], interfaces[i]);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 添加构造函数</span></div><div class=\"line\">methods.add(<span class=\"keyword\">this</span>.generateConstructor());</div></pre></td></tr></table></figure></p>\n<p>这里构造好了类的内容：添加必要的函数，实现接口，构造函数等，下面就是要写入上一步看到的 <code>$Proxy0.class</code> 了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">ByteArrayOutputStream bout = <span class=\"keyword\">new</span> ByteArrayOutputStream();</div><div class=\"line\">DataOutputStream dout = <span class=\"keyword\">new</span> DataOutputStream(bout);</div><div class=\"line\">dout.writeInt(<span class=\"number\">0xCAFEBABE</span>);</div><div class=\"line\">...</div><div class=\"line\">dout.writeShort(ACC_PUBLIC | ACC_FINAL | ACC_SUPER);</div><div class=\"line\">...</div><div class=\"line\"><span class=\"keyword\">return</span> bout.toByteArray();</div></pre></td></tr></table></figure>\n<p>到这里就生成了第一步看到的 <code>$Proxy0.class</code> 文件了，完成闭环，讲解完成！</p>\n<h2 id=\"动态代理小结\"><a href=\"# 动态代理小结\" class=\"headerlink\" title=\"动态代理小结\"></a>动态代理小结 </h2><p> 通过上面的讲解可以看出，动态代理可以随时为任意的委托类进行代理，并可以在 <code>InvocationHandler#invoke</code> 拿到运行时的信息，并可以做一些切面处理。</p>\n<p>在动态代理背后，其实是为一个委托类动态生成了一个 <code>$Proxy0.class</code> 的代理类，该代理类会实现委托类的接口，并把接口调用转发到 <code>InvocationHandler#invoke</code> 上，最终调用到真实委托类的对应方法。</p>\n<p>动态代理机制把委托类和代理类进行了隔离，提高了扩展性。</p>\n<h2 id=\"Java 动态代理与 Python 装饰器\"><a href=\"#Java 动态代理与 Python 装饰器\" class=\"headerlink\" title=\"Java 动态代理与 Python 装饰器\"></a>Java 动态代理与 Python 装饰器 </h2><p> 这是 Java 语言提供的一个有意思的语言特性，而其实 Python 里也提供了一种类似的特性：装饰器，可以达到类似的面相切面编程思想，下次有空再把两者做下对比，这次先到这。</p>\n<p>–<br>谢谢。</p>\n<p>wingjay</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>之前的文章里讲解过了Java的反射机制、垃圾回收机制，这一次我们来讲解一个更有意思的机制：动态代理。学习下Java里为什么出现这样一个机制，什么场合下会使用这个机制。</p>\n<p><a href=\"/2017/04/26/Java-%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%8F%8D%E5%B0%84/\">《Java 技术之反射》</a><br><a href=\"/2017/05/08/java_classloader/\">《Java 技术之类加载机制》</a></p>\n</blockquote>","more":"<h2 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h2><p>常规的代理模式有以下三个部分组成：<br><strong>功能接口</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IFunction</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doAThing</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>功能提供者</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FunctionProvider</span> <span class=\"title\">implement</span> <span class=\"title\">IFunction</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> doAThing &#123;</div><div class=\"line\">\t\tSystem.out.print(<span class=\"string\">\"do A\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>功能代理者</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Proxy</span> <span class=\"title\">implement</span> <span class=\"title\">IFunction</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> FunctionProvider provider;</div><div class=\"line\">\tProxy(FunctionProvider provider) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.provider = provider;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> doAThing &#123;</div><div class=\"line\">\t\tprovider.doAThing();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>前两者就是普通的接口和实现类，而第三个就是所谓的代理类。对于使用者而言，他会让代理类去完成某件任务，并不关心这件任务具体的跑腿者。</p>\n<p>这就是静态代理，好处是方便调整变换具体实现类，而使用者不会受到任何影响。</p>\n<p>不过这种方式也存在弊端：比如有多个接口需要进行代理，那么就要为每一个功能提供者创建对应的一个代理类，那就会越来越庞大。而且，所谓的“静态”代理，意味着必须提前知道被代理的委托类。</p>\n<p>通过下面一个例子来说明下：</p>\n<h4 id=\"统计函数耗时–静态代理实现\"><a href=\"#统计函数耗时–静态代理实现\" class=\"headerlink\" title=\"统计函数耗时–静态代理实现\"></a>统计函数耗时–静态代理实现</h4><p>现在希望通过一个代理类，对我感兴趣的方法进行耗时统计，利用静态代理有如下实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IAFunc</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doA</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IBFunc</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doB</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TimeConsumeProxy</span> <span class=\"title\">implement</span> <span class=\"title\">IAFunc</span>, <span class=\"title\">IBFunc</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> AFunc a;</div><div class=\"line\">\t<span class=\"keyword\">private</span> BFunc b;</div><div class=\"line\">\t<span class=\"keyword\">public</span>(AFunc a, BFunc b) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.a = a;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.b = b;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doA</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">long</span> start = System.currentMillions();</div><div class=\"line\"></div><div class=\"line\">\t\ta.doA();</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"耗时：\"</span> + (System.currentMillions() - start));</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doB</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">long</span> start = System.currentMillions();</div><div class=\"line\"></div><div class=\"line\">\t\tb.doB();</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"耗时：\"</span> + (System.currentMillions() - start));</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>弊端很明显，如果接口越多，每新增一个函数都要去修改这个<code>TimeConsumeProxy</code>代理类：把委托类对象传进去，实现接口，在函数执行前后统计耗时。</p>\n<p>这种方式显然不是可持续性的，下面来看下使用动态代理的实现方式，进行对比。</p>\n<h2 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h2><p>动态代理的核心思想是通过Java Proxy类，为传入进来的任意对象动态生成一个代理对象，这个代理对象默认实现了原始对象的所有接口。</p>\n<p>还是通过统计函数耗时例子来说明更加直接。</p>\n<h4 id=\"统计函数耗时–动态代理实现\"><a href=\"#统计函数耗时–动态代理实现\" class=\"headerlink\" title=\"统计函数耗时–动态代理实现\"></a>统计函数耗时–动态代理实现</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IAFunc</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doA</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IBFunc</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doB</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> <span class=\"title\">implement</span> <span class=\"title\">IAFunc</span> </span>&#123; ... &#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"title\">implement</span> <span class=\"title\">IBFunc</span> </span>&#123; ... &#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TimeConsumeProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> Object realObject;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">bind</span><span class=\"params\">(Object realObject)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.realObject = realObject;</div><div class=\"line\">\t\tObject proxyObject = Proxy.newInstance(</div><div class=\"line\">\t\t\trealObject.getClass().getClassLoader(),</div><div class=\"line\">\t\t\trealObject.getClass().getInterfaces(),</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span></div><div class=\"line\">\t\t);</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> proxyObject;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">long</span> start = System.currentMillions();</div><div class=\"line\"></div><div class=\"line\">        Object result = method.invoke(target, args);</div><div class=\"line\"></div><div class=\"line\">        System.out.println(<span class=\"string\">\"耗时：\"</span> + (System.currentMillions() - start));</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> result;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>具体使用时：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\tA a = <span class=\"keyword\">new</span> A();</div><div class=\"line\">\tIAFunc aProxy = (IAFunc) <span class=\"keyword\">new</span> TimeConsumeProxy().bind(a);</div><div class=\"line\">\taProxy.doA();</div><div class=\"line\"></div><div class=\"line\">\tB b = <span class=\"keyword\">new</span> B();</div><div class=\"line\">\tIBFunc bProxy = (IBFunc) <span class=\"keyword\">new</span> TimeConsumeProxy().bind(b);</div><div class=\"line\">\tbProxy.doB();\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里最大的区别就是：代理类和委托类<strong>互相透明独立</strong>，逻辑没有任何耦合，在运行时才绑定在一起。这也就是静态代理与动态代理最大的不同，带来的好处就是：无论委托类有多少个，代理类不受到任何影响，而且在编译时无需知道具体委托类。</p>\n<p>回到动态代理本身，上面代码中最重要的就是:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object proxyObject = Proxy.newInstance(</div><div class=\"line\">\t\t\trealObject.getClass().getClassLoader(),</div><div class=\"line\">\t\t\trealObject.getClass().getInterfaces(),</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span></div><div class=\"line\">\t\t);</div></pre></td></tr></table></figure></p>\n<p>通过Proxy工具，把真实委托类转换成了一个代理类，最开始提到了一个代理模式的三要素：功能接口、功能提供者、功能代理者；在这里对应的就是：<code>realObject.getClass().getInterfaces()</code>，<code>realObject</code>，<code>TimeConsumeProxy</code>。</p>\n<p>其实动态代理并不复杂，通过一个Proxy工具，为委托类的接口自动生成一个代理对象，后续的函数调用都通过这个代理对象进行发起，最终会执行到<code>InvocationHandler#invoke</code>方法，在这个方法里除了调用真实委托类对应的方法，还可以做一些其他自定义的逻辑，比如上面的运行耗时统计等。</p>\n<h2 id=\"探索动态代理实现机制\"><a href=\"#探索动态代理实现机制\" class=\"headerlink\" title=\"探索动态代理实现机制\"></a>探索动态代理实现机制</h2><p>好了，上面我们已经把动态代理的基本用法及为什么要用动态代理进行了讲解，很多文章到这里也差不多了，不过我们还准备进一步探索一下给感兴趣的读者。</p>\n<p>抛出几个问题：</p>\n<ol>\n<li>上面生成的代理对象<code>Object proxyObject</code>究竟是个什么东西？为什么它可以转型成<code>IAFunc</code>，还能调用<code>doA()</code>方法？</li>\n<li>这个<code>proxyObject</code>是怎么生成出来的？它是一个class吗？</li>\n</ol>\n<p>下面我先给出答案，再一步步探究这个答案是如何来的。</p>\n<h3 id=\"问题一-proxyObject究竟是个什么-gt-动态生成的-Proxy0-class文件\"><a href=\"#问题一-proxyObject究竟是个什么-gt-动态生成的-Proxy0-class文件\" class=\"headerlink\" title=\"问题一: proxyObject究竟是个什么 -&gt; 动态生成的$Proxy0.class文件\"></a>问题一: proxyObject究竟是个什么 -&gt; 动态生成的$Proxy0.class文件</h3><p>在调用<code>Proxy.newInstance</code>后，Java最终会为委托类<code>A</code>生成一个真实的class文件：<code>$Proxy0.class</code>，而<code>proxyObject</code>就是这个class的一个实例。</p>\n<p>猜一下，这个<code>$Proxy0.class</code>类长什么样呢，包含了什么方法呢？回看下刚刚的代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">IAFunc aProxy = (IAFunc) <span class=\"keyword\">new</span> TimeConsumeProxy().bind(a);</div><div class=\"line\">aProxy.doA();</div></pre></td></tr></table></figure></p>\n<p>推理下，显然这个<code>$Proxy0.class</code>实现了 <code>IAFunc</code> 接口，同时它内部也实现了<code>doA()</code>方法，而且重点是：这个<code>doA()</code>方法在运行时会执行到<code>TimeConsumeProxy#invoke()</code>方法里。</p>\n<p>重点来了！下面我们来看下这个<code>$Proxy0.class</code>文件，把它放进IDE反编译下，可以看到如下内容，来验证下刚刚的猜想：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> $<span class=\"title\">Proxy0</span> <span class=\"keyword\">extends</span> <span class=\"title\">Proxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">IAFunc</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m1;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m3;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m2;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m0;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> $Proxy0(InvocationHandler var1) <span class=\"keyword\">throws</span>  &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(var1);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object var1)</span> <span class=\"keyword\">throws</span>  </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 省略</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">doA</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span>  </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        \t<span class=\"comment\">// 划重点</span></div><div class=\"line\">            <span class=\"keyword\">super</span>.h.invoke(<span class=\"keyword\">this</span>, m3, (Object[])<span class=\"keyword\">null</span>);</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RuntimeException | Error var2) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> var2;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable var3) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UndeclaredThrowableException(var3);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span>  </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 省略</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span>  </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 省略</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">static</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        \t<span class=\"comment\">// 划重点</span></div><div class=\"line\">            m3 = Class.forName(<span class=\"string\">\"proxy.IAFunc\"</span>).getMethod(<span class=\"string\">\"doA\"</span>, <span class=\"keyword\">new</span> Class[<span class=\"number\">0</span>]);</div><div class=\"line\"></div><div class=\"line\">            m1 = Class.forName(<span class=\"string\">\"java.lang.Object\"</span>).getMethod(<span class=\"string\">\"equals\"</span>, <span class=\"keyword\">new</span> Class[]&#123;Class.forName(<span class=\"string\">\"java.lang.Object\"</span>)&#125;);</div><div class=\"line\">            m2 = Class.forName(<span class=\"string\">\"java.lang.Object\"</span>).getMethod(<span class=\"string\">\"toString\"</span>, <span class=\"keyword\">new</span> Class[<span class=\"number\">0</span>]);</div><div class=\"line\">            m0 = Class.forName(<span class=\"string\">\"java.lang.Object\"</span>).getMethod(<span class=\"string\">\"hashCode\"</span>, <span class=\"keyword\">new</span> Class[<span class=\"number\">0</span>]);</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NoSuchMethodException var2) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchMethodError(var2.getMessage());</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException var3) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoClassDefFoundError(var3.getMessage());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>没错，刚刚的猜想都中了！实现了<code>IAFunc</code>接口和<code>doA()</code>方法，不过，<code>doA()</code>里是什么鬼？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">super</span>.h.invoke(<span class=\"keyword\">this</span>, m3, (Object[])<span class=\"keyword\">null</span>);</div></pre></td></tr></table></figure>\n<p>回看下，<code>TimeConsumeProxy</code>里面的<code>invoke</code>方法，它的函数签名是啥？<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span></span>;</div></pre></td></tr></table></figure></p>\n<p>没错，<code>doA()</code>里做的就是调用<code>TimeConsumeProxy#invoke()</code>方法。</p>\n<p>那么也就是说，下面这段代码执行流程如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">IAFunc aProxy = (IAFunc) <span class=\"keyword\">new</span> TimeConsumeProxy().bind(a);</div><div class=\"line\">aProxy.doA();</div></pre></td></tr></table></figure></p>\n<ol>\n<li>基于传入的委托类<code>A</code>，生成一个<code>$Proxy0.class</code>文件；</li>\n<li>创建一个<code>$Proxy0.class</code>对象，转型为<code>IAFunc</code>接口；</li>\n<li>调用<code>aProxy.doA()</code>时，自动调用TimeConsumeProxy内部的<code>invoke</code>方法。</li>\n</ol>\n<h3 id=\"问题二：proxyObject-是怎么一步步生成出来的-gt-Proxy0-class文件生成流程\"><a href=\"#问题二：proxyObject-是怎么一步步生成出来的-gt-Proxy0-class文件生成流程\" class=\"headerlink\" title=\"问题二：proxyObject 是怎么一步步生成出来的 -&gt; $Proxy0.class文件生成流程\"></a>问题二：proxyObject 是怎么一步步生成出来的 -&gt; $Proxy0.class文件生成流程</h3><p>刚刚从末尾看了结果，现在我们回到代码的起始端来看：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object proxyObject = Proxy.newInstance(</div><div class=\"line\">\t\t\trealObject.getClass().getClassLoader(),</div><div class=\"line\">\t\t\trealObject.getClass().getInterfaces(),</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span></div><div class=\"line\">\t\t);</div></pre></td></tr></table></figure></p>\n<p>准备好，开始发车读源码了。我会截取重要的代码并加上注释。</p>\n<p>先看<code>Proxy.newInstance()</code>:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title\">newProxyInstance</span><span class=\"params\">(ClassLoader loader,</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"params\">                                      Class&lt;?&gt;[] interfaces,</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"params\">                                      InvocationHandler h)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//复制要代理的接口                                  \t</span></div><div class=\"line\">\t<span class=\"keyword\">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">//重点：生成 $Proxy0.class 文件并通过 ClassLoader 加载进来</span></div><div class=\"line\">\tClass&lt;?&gt; cl = getProxyClass0(loader, intfs);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">//对$Proxy0.class生成一个实例，就是`proxyObject`</span></div><div class=\"line\">\t<span class=\"keyword\">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</div><div class=\"line\">\t<span class=\"keyword\">return</span> cons.newInstance(<span class=\"keyword\">new</span> Object[]&#123;h&#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>再来看 <code>getProxyClass0</code> 的具体实现：<code>ProxyClassFactory</code>工厂类：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</div><div class=\"line\">\t// 参数为ClassLoader和要代理的接口</div><div class=\"line\"></div><div class=\"line\">\tMap&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length);</div><div class=\"line\"></div><div class=\"line\">\t// 1. 验证ClassLoader和接口有效性</div><div class=\"line\">\tfor (Class&lt;?&gt; intf : interfaces) &#123;</div><div class=\"line\">\t\t// 验证classLoader正确性</div><div class=\"line\">\t\tClass&lt;?&gt; interfaceClass = Class.forName(intf.getName(), false, loader);</div><div class=\"line\">\t\tif (interfaceClass != intf) &#123;</div><div class=\"line\">            throw new IllegalArgumentException(</div><div class=\"line\">                intf + &quot; is not visible from class loader&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">\t\t// 验证传入的接口class有效</div><div class=\"line\">\t\tif (!interfaceClass.isInterface()) &#123; ... &#125; </div><div class=\"line\"></div><div class=\"line\">\t\t// 验证接口是否重复</div><div class=\"line\">\t\tif (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123; ... &#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t// 2. 创建包名及类名 $Proxy0.class</div><div class=\"line\">\tproxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;;</div><div class=\"line\">\tlong num = nextUniqueNumber.getAndIncrement();</div><div class=\"line\">    String proxyName = proxyPkg + proxyClassNamePrefix + num;</div><div class=\"line\"></div><div class=\"line\">    // 3. 创建class字节码内容</div><div class=\"line\">    byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);</div><div class=\"line\"></div><div class=\"line\">    // 4. 基于字节码和类名，生成Class&lt;?&gt;对象</div><div class=\"line\">    return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>再看下第三步生成class内容 <code>ProxyGenerator.generateProxyClass</code>：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 添加 hashCode equals toString方法</span></div><div class=\"line\">addProxyMethod(hashCodeMethod, Object.class);</div><div class=\"line\">addProxyMethod(equalsMethod, Object.class);</div><div class=\"line\">addProxyMethod(toStringMethod, Object.class);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 添加委托类的接口实现</span></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; interfaces.length; i++) &#123;</div><div class=\"line\">    Method[] methods = interfaces[i].getMethods();</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; methods.length; j++) &#123;</div><div class=\"line\">         addProxyMethod(methods[j], interfaces[i]);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 添加构造函数</span></div><div class=\"line\">methods.add(<span class=\"keyword\">this</span>.generateConstructor());</div></pre></td></tr></table></figure></p>\n<p>这里构造好了类的内容：添加必要的函数，实现接口，构造函数等，下面就是要写入上一步看到的 <code>$Proxy0.class</code> 了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">ByteArrayOutputStream bout = <span class=\"keyword\">new</span> ByteArrayOutputStream();</div><div class=\"line\">DataOutputStream dout = <span class=\"keyword\">new</span> DataOutputStream(bout);</div><div class=\"line\">dout.writeInt(<span class=\"number\">0xCAFEBABE</span>);</div><div class=\"line\">...</div><div class=\"line\">dout.writeShort(ACC_PUBLIC | ACC_FINAL | ACC_SUPER);</div><div class=\"line\">...</div><div class=\"line\"><span class=\"keyword\">return</span> bout.toByteArray();</div></pre></td></tr></table></figure>\n<p>到这里就生成了第一步看到的<code>$Proxy0.class</code>文件了，完成闭环，讲解完成！</p>\n<h2 id=\"动态代理小结\"><a href=\"#动态代理小结\" class=\"headerlink\" title=\"动态代理小结\"></a>动态代理小结</h2><p>通过上面的讲解可以看出，动态代理可以随时为任意的委托类进行代理，并可以在<code>InvocationHandler#invoke</code>拿到运行时的信息，并可以做一些切面处理。</p>\n<p>在动态代理背后，其实是为一个委托类动态生成了一个<code>$Proxy0.class</code>的代理类，该代理类会实现委托类的接口，并把接口调用转发到<code>InvocationHandler#invoke</code>上，最终调用到真实委托类的对应方法。</p>\n<p>动态代理机制把委托类和代理类进行了隔离，提高了扩展性。</p>\n<h2 id=\"Java动态代理与Python装饰器\"><a href=\"#Java动态代理与Python装饰器\" class=\"headerlink\" title=\"Java动态代理与Python装饰器\"></a>Java动态代理与Python装饰器</h2><p>这是Java语言提供的一个有意思的语言特性，而其实Python里也提供了一种类似的特性：装饰器，可以达到类似的面相切面编程思想，下次有空再把两者做下对比，这次先到这。</p>\n<p>–<br>谢谢。</p>\n<p>wingjay</p>","sticky":0},{"title":"Java 技术之反射","date":"2017-04-26T14:37:55.000Z","commentIssueId":6,"_content":">关于Java反射机制的文章很多，这次换种方式来讲解反射的作用。\n\n>本文涉及到的知识点：`class.getDeclaredXXX()`、`XXX.getModifiers()`、`method.getReturnType()`、`method.getParameterTypes()`、`method.isAnnotationPresent(XXX.class)`、`Modifier.isStatic(method.getModifiers())` 和 `constructor.newInstance(XX)`\n\n>本文涉及代码：\nhttps://github.com/wingjay/HelloJava/blob/master/data-structure/src/reflection/ForArticle.java   \n\n<!-- more -->\n\n## 先来看一个熟悉的 Class\n首先，简单来说，反射就是在运行时可以获取任意 `Class` 或 `Object` 内部所有成员属性，如成员变量、成员方法、构造函数和 Annotation。\n\n这次先给出一个大家非常熟悉的 `Class`：`UserBean`。\n\n本文要完成的任务就是，在只有一个 `UserBean.getClass()` 的情况下，利用代码`打印出其内部所有成员变量、方法，并动态执行内部用 @Invoke 修饰的成员方法`。\n\n```\npackage com.wingjay.reflection;\n\npublic class UserBean {\n\n    public String userName;\n\n    private long userId;\n\n    public UserBean(String userName, long userId) {\n        this.userName = userName;\n        this.userId = userId;\n    }\n\n    public String getName() {\n        return userName;\n    }\n\n    public long getId() {\n        return userId;\n    }\n\n    @Invoke\n    public static void staticMethod(String devName) {\n        System.out.printf(\"Hi %s, I'm a static method\", devName);\n    }\n\n    @Invoke\n    public void publicMethod() {\n        System.out.println(\"I'm a public method\");\n    }\n\n    @Invoke\n    private void privateMethod() {\n        System.out.println(\"I'm a private method\");\n    }\n}\n```\n\n在只提供一个 UserBean 的 Class 情况下，\n\n1. 打印出这个 `Class` 内部的所有成员变量、成员方法、构造函数，包括 `private` 的；\n2. 调用这个 `Class` 内部的三个用 `@Invoke` 修饰的方法：`staticMethod()`, `publicMethod()`, `privateMethod()`；\n\n## 1. 打印 UserBean Class 里的所有成员变量、成员方法，包括 private 的\n首先我们拥有一个 `Class userBeanClass = UserBean.class`，我们要利用这个 `Class` 来打印它的成员变量 `userName` 和 `userId`。\n\n#### 打印成员变量\n那么如何获取成员变量呢，我们发现，Java 里提供了 `Field` 这个类来表示成员变量，提供了 `clazz.getDeclaredFields()` 来获取一个类内部声明的所有变量。因此，可以利用下面的代码获取 `userBeanClass` 内部所有的成员变量。\n```\nField[] fields = userBeanClass.getDeclaredFields();\n```\n那么，我们如何将一个 `field` 对象打印成 `private String userName;` 这种形式呢？或者说如何分别找到 `private`、`String`、`userName` 这三个值呢？\n\n其实，`Field` 里包含了三种元素来对应它们，分别是`Modifier`、`Type`、`Name`。\n```\nprivate <-- field.getModifiers();\nString <-- field.getType();\nuserName <-- field.getName();\n```\n\n```\n// fields\nField[] fields = userBeanClass.getDeclaredFields();\n\nfor(Field field : fields) {\n    String fieldString = \"\";\n    fieldString += Modifier.toString(field.getModifiers()) + \" \"; // `private`\n    fieldString += field.getType().getSimpleName() + \" \"; // `String`\n    fieldString += field.getName(); // `userName`\n    fieldString += \";\";\n    System.out.println(fieldString);\n}\n```\n\n打印结果：\n\n```\npublic String userName;\nprivate long userId;\n```\n\n#### 打印成员方法\n类似成员变量的 `Field`，成员方法也有对应的类 `Method`，首先可以通过 `Method[] methods = userBeanClass.getDeclaredMethods();` 获得所有的成员方法，然后，为了打印形如：`public static void staticMethod(String devName)`的数据，可以利用下列 `method` 提供的方法：\n\n```\nprivate static <-- method.getModifiers();\nvoid <-- method.getReturnType();\nstaticMethod <-- method.getName();\nString <-- method.getParameterTypes();\n```\n\n因此可以得到:\n```\nMethod[] methods = userBeanClass.getDeclaredMethods();\nfor (Method method : methods) {\n    String methodString = Modifier.toString(method.getModifiers()) + \" \" ; // private static\n    methodString += method.getReturnType().getSimpleName() + \" \"; // void\n    methodString += method.getName() + \"(\"; // staticMethod \n    Class[] parameters = method.getParameterTypes();\n    for (Class parameter : parameters) {\n        methodString += parameter.getSimpleName() + \" \"; // String\n    }\n    methodString += \")\";\n    System.out.println(methodString);\n}\n```\n\n打印结果如下：\n```\npublic String getName()\npublic long getId()\npublic static void staticMethod(String )\npublic void publicMethod()\nprivate void privateMethod()\n```\n可以完整的打印所有成员方法，无论是 `public` 还是 `private`，而且能打印 `static` 关键字。\n\n#### 打印构造函数\n其实构造函数和成员函数非常类似，Java 里提供了 `Constructor` 来表示构造函数，为了打印 `public UserBean(String userName, long userId)`，可以利用下面的函数实现：\n\n```\n// constructors\nConstructor[] constructors = userBeanClass.getDeclaredConstructors();\nfor (Constructor constructor : constructors) {\n    String s = Modifier.toString(constructor.getModifiers()) + \" \";\n    s += constructor.getName() + \"(\";\n    Class[] parameters = constructor.getParameterTypes();\n    for (Class parameter : parameters) {\n        s += parameter.getSimpleName() + \", \";\n    }\n    s += \")\";\n    System.out.println(s);\n}\n```\n\n打印结果如下：\n```\npublic com.wingjay.reflection.UserBean(String, long)\n```\n\n## 2. 调用 Class 内部的用 `@Invoke` 修饰的方法\n从上面知道，我们可以利用 `class.getDeclaredMethods()` 获取一个类内部所有成员方法，接下来我们还要做的事是：\n\n1. 判断这个方法是否被 `@Invoke` 修饰\n2. 如果修饰，判断这个方法是不是 `static` 的\n3. 如果是 `static`，则可以直接用 class 调用\n4. 如果不是 `static`，那就需要实例化一个对象来调用\n5. 如果这个方法是 `private` 的，要记得 `setAccessible(true)`。\n\n如果分别实现上面的一些功能呢？\n\n- 为了判断一个 Method 是否被某个 Annotation 修饰，可以用 `method.isAnnotationPresent(Invoke.class)` ；\n- 关于 `static` `private`，我们可以用 `Modifier` 类提供的 `Modifier.isStatic()` 和 `Modifier.isPrivate()`来判断；\n- 如果 Method 不是 static，那就要实例化对象，我们可以用 `class.newInstance()` 或者 `constructor.newInstance(params)` 来得到实例。\n- 关于执行一个 Method，可以使用 `method.invoke(object, ...params)` 方法，如果方法不是 `static` 就必须实例化一个 `object` 传给它，否则可以传 `null`\n\n\n实现如下：\n```\nMethod[] methods = userBeanClass.getDeclaredMethods(); // 获取所有成员方法\nfor (Method method : methods) {\n    if (method.isAnnotationPresent(Invoke.class)) { // 判断是否被 @Invoke 修饰\n        if (Modifier.isStatic(method.getModifiers())) { // 如果是 static 方法\n            method.invoke(null, \"wingjay\"); // 直接调用，并传入需要的参数 devName\n        } else {\n            Class[] params = {String.class, long.class};\n            Constructor constructor = userBeanClass.getDeclaredConstructor(params); // 获取参数格式为 String,long 的构造函数\n            Object userBean = constructor.newInstance(\"wingjay\", 11); // 利用构造函数进行实例化，得到 Object\n            if (Modifier.isPrivate(method.getModifiers())) {\n                method.setAccessible(true); // 如果是 private 的方法，需要获取其调用权限\n            }\n            method.invoke(userBean); // 调用 method，无须参数\n        }\n    }\n}\n```\n\n打印结果：\n```\nI'm a public method\nHi wingjay, I'm a static method\nI'm a private method\n```\n\n可见三个方法都正常调用了，而且 `public static void staticMethod(String devName)` 的参数 `devName` 也正常传进去了。\n\n## 小结\n基于上面两个实践，我们已经能够利用反射机制，在运行状态下把一个 Class 的内部成员方法、成员变量和构造函数全部获取到，并且能够进行实例化、直接调用内部的成员方法。\n\n因此，有了反射机制，我们即使只有动态得到的 Class，也能直接得到它内部的信息、甚至调用它内部的方法。\n\n了解了反射后，下文我将介绍 `Annotation` 一些有趣的自定义实现，合理地利用 `Annotation` 能让代码更简洁，自动生成代码，实现一些常规难以实现的功能。\n\n谢谢。\n\nwingjay\n\nhttp://wingjay.com\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n","source":"_posts/Java-技术之反射.md","raw":"title: Java 技术之反射\ndate: 2017-04-26 22:37:55\ncategories:\n  - 深入理解Java技术\ntags: Java\ncommentIssueId: 6\n---\n>关于Java反射机制的文章很多，这次换种方式来讲解反射的作用。\n\n>本文涉及到的知识点：`class.getDeclaredXXX()`、`XXX.getModifiers()`、`method.getReturnType()`、`method.getParameterTypes()`、`method.isAnnotationPresent(XXX.class)`、`Modifier.isStatic(method.getModifiers())` 和 `constructor.newInstance(XX)`\n\n>本文涉及代码：\nhttps://github.com/wingjay/HelloJava/blob/master/data-structure/src/reflection/ForArticle.java   \n\n<!-- more -->\n\n## 先来看一个熟悉的 Class\n首先，简单来说，反射就是在运行时可以获取任意 `Class` 或 `Object` 内部所有成员属性，如成员变量、成员方法、构造函数和 Annotation。\n\n这次先给出一个大家非常熟悉的 `Class`：`UserBean`。\n\n本文要完成的任务就是，在只有一个 `UserBean.getClass()` 的情况下，利用代码`打印出其内部所有成员变量、方法，并动态执行内部用 @Invoke 修饰的成员方法`。\n\n```\npackage com.wingjay.reflection;\n\npublic class UserBean {\n\n    public String userName;\n\n    private long userId;\n\n    public UserBean(String userName, long userId) {\n        this.userName = userName;\n        this.userId = userId;\n    }\n\n    public String getName() {\n        return userName;\n    }\n\n    public long getId() {\n        return userId;\n    }\n\n    @Invoke\n    public static void staticMethod(String devName) {\n        System.out.printf(\"Hi %s, I'm a static method\", devName);\n    }\n\n    @Invoke\n    public void publicMethod() {\n        System.out.println(\"I'm a public method\");\n    }\n\n    @Invoke\n    private void privateMethod() {\n        System.out.println(\"I'm a private method\");\n    }\n}\n```\n\n在只提供一个 UserBean 的 Class 情况下，\n\n1. 打印出这个 `Class` 内部的所有成员变量、成员方法、构造函数，包括 `private` 的；\n2. 调用这个 `Class` 内部的三个用 `@Invoke` 修饰的方法：`staticMethod()`, `publicMethod()`, `privateMethod()`；\n\n## 1. 打印 UserBean Class 里的所有成员变量、成员方法，包括 private 的\n首先我们拥有一个 `Class userBeanClass = UserBean.class`，我们要利用这个 `Class` 来打印它的成员变量 `userName` 和 `userId`。\n\n#### 打印成员变量\n那么如何获取成员变量呢，我们发现，Java 里提供了 `Field` 这个类来表示成员变量，提供了 `clazz.getDeclaredFields()` 来获取一个类内部声明的所有变量。因此，可以利用下面的代码获取 `userBeanClass` 内部所有的成员变量。\n```\nField[] fields = userBeanClass.getDeclaredFields();\n```\n那么，我们如何将一个 `field` 对象打印成 `private String userName;` 这种形式呢？或者说如何分别找到 `private`、`String`、`userName` 这三个值呢？\n\n其实，`Field` 里包含了三种元素来对应它们，分别是`Modifier`、`Type`、`Name`。\n```\nprivate <-- field.getModifiers();\nString <-- field.getType();\nuserName <-- field.getName();\n```\n\n```\n// fields\nField[] fields = userBeanClass.getDeclaredFields();\n\nfor(Field field : fields) {\n    String fieldString = \"\";\n    fieldString += Modifier.toString(field.getModifiers()) + \" \"; // `private`\n    fieldString += field.getType().getSimpleName() + \" \"; // `String`\n    fieldString += field.getName(); // `userName`\n    fieldString += \";\";\n    System.out.println(fieldString);\n}\n```\n\n打印结果：\n\n```\npublic String userName;\nprivate long userId;\n```\n\n#### 打印成员方法\n类似成员变量的 `Field`，成员方法也有对应的类 `Method`，首先可以通过 `Method[] methods = userBeanClass.getDeclaredMethods();` 获得所有的成员方法，然后，为了打印形如：`public static void staticMethod(String devName)`的数据，可以利用下列 `method` 提供的方法：\n\n```\nprivate static <-- method.getModifiers();\nvoid <-- method.getReturnType();\nstaticMethod <-- method.getName();\nString <-- method.getParameterTypes();\n```\n\n因此可以得到:\n```\nMethod[] methods = userBeanClass.getDeclaredMethods();\nfor (Method method : methods) {\n    String methodString = Modifier.toString(method.getModifiers()) + \" \" ; // private static\n    methodString += method.getReturnType().getSimpleName() + \" \"; // void\n    methodString += method.getName() + \"(\"; // staticMethod \n    Class[] parameters = method.getParameterTypes();\n    for (Class parameter : parameters) {\n        methodString += parameter.getSimpleName() + \" \"; // String\n    }\n    methodString += \")\";\n    System.out.println(methodString);\n}\n```\n\n打印结果如下：\n```\npublic String getName()\npublic long getId()\npublic static void staticMethod(String )\npublic void publicMethod()\nprivate void privateMethod()\n```\n可以完整的打印所有成员方法，无论是 `public` 还是 `private`，而且能打印 `static` 关键字。\n\n#### 打印构造函数\n其实构造函数和成员函数非常类似，Java 里提供了 `Constructor` 来表示构造函数，为了打印 `public UserBean(String userName, long userId)`，可以利用下面的函数实现：\n\n```\n// constructors\nConstructor[] constructors = userBeanClass.getDeclaredConstructors();\nfor (Constructor constructor : constructors) {\n    String s = Modifier.toString(constructor.getModifiers()) + \" \";\n    s += constructor.getName() + \"(\";\n    Class[] parameters = constructor.getParameterTypes();\n    for (Class parameter : parameters) {\n        s += parameter.getSimpleName() + \", \";\n    }\n    s += \")\";\n    System.out.println(s);\n}\n```\n\n打印结果如下：\n```\npublic com.wingjay.reflection.UserBean(String, long)\n```\n\n## 2. 调用 Class 内部的用 `@Invoke` 修饰的方法\n从上面知道，我们可以利用 `class.getDeclaredMethods()` 获取一个类内部所有成员方法，接下来我们还要做的事是：\n\n1. 判断这个方法是否被 `@Invoke` 修饰\n2. 如果修饰，判断这个方法是不是 `static` 的\n3. 如果是 `static`，则可以直接用 class 调用\n4. 如果不是 `static`，那就需要实例化一个对象来调用\n5. 如果这个方法是 `private` 的，要记得 `setAccessible(true)`。\n\n如果分别实现上面的一些功能呢？\n\n- 为了判断一个 Method 是否被某个 Annotation 修饰，可以用 `method.isAnnotationPresent(Invoke.class)` ；\n- 关于 `static` `private`，我们可以用 `Modifier` 类提供的 `Modifier.isStatic()` 和 `Modifier.isPrivate()`来判断；\n- 如果 Method 不是 static，那就要实例化对象，我们可以用 `class.newInstance()` 或者 `constructor.newInstance(params)` 来得到实例。\n- 关于执行一个 Method，可以使用 `method.invoke(object, ...params)` 方法，如果方法不是 `static` 就必须实例化一个 `object` 传给它，否则可以传 `null`\n\n\n实现如下：\n```\nMethod[] methods = userBeanClass.getDeclaredMethods(); // 获取所有成员方法\nfor (Method method : methods) {\n    if (method.isAnnotationPresent(Invoke.class)) { // 判断是否被 @Invoke 修饰\n        if (Modifier.isStatic(method.getModifiers())) { // 如果是 static 方法\n            method.invoke(null, \"wingjay\"); // 直接调用，并传入需要的参数 devName\n        } else {\n            Class[] params = {String.class, long.class};\n            Constructor constructor = userBeanClass.getDeclaredConstructor(params); // 获取参数格式为 String,long 的构造函数\n            Object userBean = constructor.newInstance(\"wingjay\", 11); // 利用构造函数进行实例化，得到 Object\n            if (Modifier.isPrivate(method.getModifiers())) {\n                method.setAccessible(true); // 如果是 private 的方法，需要获取其调用权限\n            }\n            method.invoke(userBean); // 调用 method，无须参数\n        }\n    }\n}\n```\n\n打印结果：\n```\nI'm a public method\nHi wingjay, I'm a static method\nI'm a private method\n```\n\n可见三个方法都正常调用了，而且 `public static void staticMethod(String devName)` 的参数 `devName` 也正常传进去了。\n\n## 小结\n基于上面两个实践，我们已经能够利用反射机制，在运行状态下把一个 Class 的内部成员方法、成员变量和构造函数全部获取到，并且能够进行实例化、直接调用内部的成员方法。\n\n因此，有了反射机制，我们即使只有动态得到的 Class，也能直接得到它内部的信息、甚至调用它内部的方法。\n\n了解了反射后，下文我将介绍 `Annotation` 一些有趣的自定义实现，合理地利用 `Annotation` 能让代码更简洁，自动生成代码，实现一些常规难以实现的功能。\n\n谢谢。\n\nwingjay\n\nhttp://wingjay.com\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n","slug":"Java-技术之反射","published":1,"updated":"2018-11-26T06:56:27.480Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplshv00273dn8stu4ln11","content":"<blockquote>\n<p>关于 Java 反射机制的文章很多，这次换种方式来讲解反射的作用。</p>\n<p>本文涉及到的知识点：<code>class.getDeclaredXXX()</code>、<code>XXX.getModifiers()</code>、<code>method.getReturnType()</code>、<code>method.getParameterTypes()</code>、<code>method.isAnnotationPresent(XXX.class)</code>、<code>Modifier.isStatic(method.getModifiers())</code> 和 <code>constructor.newInstance(XX)</code></p>\n<p>本文涉及代码：<br><a href=\"https://github.com/wingjay/HelloJava/blob/master/data-structure/src/reflection/ForArticle.java\" target=\"_blank\" rel=\"external\">https://github.com/wingjay/HelloJava/blob/master/data-structure/src/reflection/ForArticle.java</a>   </p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"先来看一个熟悉的 -Class\"><a href=\"# 先来看一个熟悉的 -Class\" class=\"headerlink\" title=\"先来看一个熟悉的 Class\"></a>先来看一个熟悉的 Class</h2><p>首先，简单来说，反射就是在运行时可以获取任意 <code>Class</code> 或 <code>Object</code> 内部所有成员属性，如成员变量、成员方法、构造函数和 Annotation。</p>\n<p>这次先给出一个大家非常熟悉的 <code>Class</code>：<code>UserBean</code>。</p>\n<p>本文要完成的任务就是，在只有一个 <code>UserBean.getClass()</code> 的情况下，利用代码 <code> 打印出其内部所有成员变量、方法，并动态执行内部用 @Invoke 修饰的成员方法</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.wingjay.reflection;</div><div class=\"line\"></div><div class=\"line\">public class UserBean &#123;</div><div class=\"line\"></div><div class=\"line\">    public String userName;</div><div class=\"line\"></div><div class=\"line\">    private long userId;</div><div class=\"line\"></div><div class=\"line\">    public UserBean(String userName, long userId) &#123;</div><div class=\"line\">        this.userName = userName;</div><div class=\"line\">        this.userId = userId;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public String getName() &#123;</div><div class=\"line\">        return userName;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public long getId() &#123;</div><div class=\"line\">        return userId;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Invoke</div><div class=\"line\">    public static void staticMethod(String devName) &#123;</div><div class=\"line\">        System.out.printf(&quot;Hi %s, I&apos;m a static method&quot;, devName);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Invoke</div><div class=\"line\">    public void publicMethod() &#123;</div><div class=\"line\">        System.out.println(&quot;I&apos;m a public method&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Invoke</div><div class=\"line\">    private void privateMethod() &#123;</div><div class=\"line\">        System.out.println(&quot;I&apos;m a private method&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在只提供一个 UserBean 的 Class 情况下，</p>\n<ol>\n<li>打印出这个 <code>Class</code> 内部的所有成员变量、成员方法、构造函数，包括 <code>private</code> 的；</li>\n<li>调用这个 <code>Class</code> 内部的三个用 <code>@Invoke</code> 修饰的方法：<code>staticMethod()</code>, <code>publicMethod()</code>, <code>privateMethod()</code>；</li>\n</ol>\n<h2 id=\"1- 打印 -UserBean-Class- 里的所有成员变量、成员方法，包括 -private- 的\"><a href=\"#1- 打印 -UserBean-Class- 里的所有成员变量、成员方法，包括 -private- 的\" class=\"headerlink\" title=\"1. 打印 UserBean Class 里的所有成员变量、成员方法，包括 private 的\"></a>1. 打印 UserBean Class 里的所有成员变量、成员方法，包括 private 的 </h2><p> 首先我们拥有一个 <code>Class userBeanClass = UserBean.class</code>，我们要利用这个 <code>Class</code> 来打印它的成员变量 <code>userName</code> 和 <code>userId</code>。</p>\n<h4 id=\"打印成员变量\"><a href=\"# 打印成员变量\" class=\"headerlink\" title=\"打印成员变量\"></a>打印成员变量 </h4><p> 那么如何获取成员变量呢，我们发现，Java 里提供了 <code>Field</code> 这个类来表示成员变量，提供了 <code>clazz.getDeclaredFields()</code> 来获取一个类内部声明的所有变量。因此，可以利用下面的代码获取 <code>userBeanClass</code> 内部所有的成员变量。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Field[] fields = userBeanClass.getDeclaredFields();</div></pre></td></tr></table></figure></p>\n<p>那么，我们如何将一个 <code>field</code> 对象打印成 <code>private String userName;</code> 这种形式呢？或者说如何分别找到 <code>private</code>、<code>String</code>、<code>userName</code> 这三个值呢？</p>\n<p>其实，<code>Field</code> 里包含了三种元素来对应它们，分别是<code>Modifier</code>、<code>Type</code>、<code>Name</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">private &lt;-- field.getModifiers();</div><div class=\"line\">String &lt;-- field.getType();</div><div class=\"line\">userName &lt;-- field.getName();</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">// fields</div><div class=\"line\">Field[] fields = userBeanClass.getDeclaredFields();</div><div class=\"line\"></div><div class=\"line\">for(Field field : fields) &#123;</div><div class=\"line\">    String fieldString = &quot;&quot;;</div><div class=\"line\">    fieldString += Modifier.toString(field.getModifiers()) + &quot; &quot;; // `private`</div><div class=\"line\">    fieldString += field.getType().getSimpleName() + &quot; &quot;; // `String`</div><div class=\"line\">    fieldString += field.getName(); // `userName`</div><div class=\"line\">    fieldString += &quot;;&quot;;</div><div class=\"line\">    System.out.println(fieldString);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>打印结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">public String userName;</div><div class=\"line\">private long userId;</div></pre></td></tr></table></figure>\n<h4 id=\"打印成员方法\"><a href=\"# 打印成员方法\" class=\"headerlink\" title=\"打印成员方法\"></a>打印成员方法 </h4><p> 类似成员变量的 <code>Field</code>，成员方法也有对应的类 <code>Method</code>，首先可以通过 <code>Method[] methods = userBeanClass.getDeclaredMethods();</code> 获得所有的成员方法，然后，为了打印形如：<code>public static void staticMethod(String devName)</code>的数据，可以利用下列 <code>method</code> 提供的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static &lt;-- method.getModifiers();</div><div class=\"line\">void &lt;-- method.getReturnType();</div><div class=\"line\">staticMethod &lt;-- method.getName();</div><div class=\"line\">String &lt;-- method.getParameterTypes();</div></pre></td></tr></table></figure>\n<p>因此可以得到:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">Method[] methods = userBeanClass.getDeclaredMethods();</div><div class=\"line\">for (Method method : methods) &#123;</div><div class=\"line\">    String methodString = Modifier.toString(method.getModifiers()) + &quot; &quot; ; // private static</div><div class=\"line\">    methodString += method.getReturnType().getSimpleName() + &quot; &quot;; // void</div><div class=\"line\">    methodString += method.getName() + &quot;(&quot;; // staticMethod </div><div class=\"line\">    Class[] parameters = method.getParameterTypes();</div><div class=\"line\">    for (Class parameter : parameters) &#123;</div><div class=\"line\">        methodString += parameter.getSimpleName() + &quot; &quot;; // String</div><div class=\"line\">    &#125;</div><div class=\"line\">    methodString += &quot;)&quot;;</div><div class=\"line\">    System.out.println(methodString);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>打印结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public String getName()</div><div class=\"line\">public long getId()</div><div class=\"line\">public static void staticMethod(String)</div><div class=\"line\">public void publicMethod()</div><div class=\"line\">private void privateMethod()</div></pre></td></tr></table></figure></p>\n<p>可以完整的打印所有成员方法，无论是 <code>public</code> 还是 <code>private</code>，而且能打印 <code>static</code> 关键字。</p>\n<h4 id=\"打印构造函数\"><a href=\"# 打印构造函数\" class=\"headerlink\" title=\"打印构造函数\"></a>打印构造函数 </h4><p> 其实构造函数和成员函数非常类似，Java 里提供了 <code>Constructor</code> 来表示构造函数，为了打印 <code>public UserBean(String userName, long userId)</code>，可以利用下面的函数实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">// constructors</div><div class=\"line\">Constructor[] constructors = userBeanClass.getDeclaredConstructors();</div><div class=\"line\">for (Constructor constructor : constructors) &#123;</div><div class=\"line\">    String s = Modifier.toString(constructor.getModifiers()) + &quot; &quot;;</div><div class=\"line\">    s += constructor.getName() + &quot;(&quot;;</div><div class=\"line\">    Class[] parameters = constructor.getParameterTypes();</div><div class=\"line\">    for (Class parameter : parameters) &#123;</div><div class=\"line\">        s += parameter.getSimpleName() + &quot;, &quot;;</div><div class=\"line\">    &#125;</div><div class=\"line\">    s += &quot;)&quot;;</div><div class=\"line\">    System.out.println(s);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>打印结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">public com.wingjay.reflection.UserBean(String, long)</div></pre></td></tr></table></figure></p>\n<h2 id=\"2- 调用 -Class- 内部的用 -Invoke- 修饰的方法\"><a href=\"#2- 调用 -Class- 内部的用 -Invoke- 修饰的方法\" class=\"headerlink\" title=\"2. 调用 Class 内部的用 @Invoke 修饰的方法\"></a>2. 调用 Class 内部的用 <code>@Invoke</code> 修饰的方法 </h2><p> 从上面知道，我们可以利用 <code>class.getDeclaredMethods()</code> 获取一个类内部所有成员方法，接下来我们还要做的事是：</p>\n<ol>\n<li>判断这个方法是否被 <code>@Invoke</code> 修饰</li>\n<li>如果修饰，判断这个方法是不是 <code>static</code> 的</li>\n<li>如果是 <code>static</code>，则可以直接用 class 调用</li>\n<li>如果不是 <code>static</code>，那就需要实例化一个对象来调用</li>\n<li>如果这个方法是 <code>private</code> 的，要记得 <code>setAccessible(true)</code>。</li>\n</ol>\n<p>如果分别实现上面的一些功能呢？</p>\n<ul>\n<li>为了判断一个 Method 是否被某个 Annotation 修饰，可以用 <code>method.isAnnotationPresent(Invoke.class)</code> ；</li>\n<li>关于 <code>static</code> <code>private</code>，我们可以用 <code>Modifier</code> 类提供的 <code>Modifier.isStatic()</code> 和 <code>Modifier.isPrivate()</code>来判断；</li>\n<li>如果 Method 不是 static，那就要实例化对象，我们可以用 <code>class.newInstance()</code> 或者 <code>constructor.newInstance(params)</code> 来得到实例。</li>\n<li>关于执行一个 Method，可以使用 <code>method.invoke(object, ...params)</code> 方法，如果方法不是 <code>static</code> 就必须实例化一个 <code>object</code> 传给它，否则可以传 <code>null</code></li>\n</ul>\n<p>实现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">Method[] methods = userBeanClass.getDeclaredMethods(); // 获取所有成员方法</div><div class=\"line\">for (Method method : methods) &#123;</div><div class=\"line\">    if (method.isAnnotationPresent(Invoke.class)) &#123; // 判断是否被 @Invoke 修饰</div><div class=\"line\">        if (Modifier.isStatic(method.getModifiers())) &#123; // 如果是 static 方法</div><div class=\"line\">            method.invoke(null, &quot;wingjay&quot;); // 直接调用，并传入需要的参数 devName</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            Class[] params = &#123;String.class, long.class&#125;;</div><div class=\"line\">            Constructor constructor = userBeanClass.getDeclaredConstructor(params); // 获取参数格式为 String,long 的构造函数</div><div class=\"line\">            Object userBean = constructor.newInstance(&quot;wingjay&quot;, 11); // 利用构造函数进行实例化，得到 Object</div><div class=\"line\">            if (Modifier.isPrivate(method.getModifiers())) &#123;</div><div class=\"line\">                method.setAccessible(true); // 如果是 private 的方法，需要获取其调用权限</div><div class=\"line\">            &#125;</div><div class=\"line\">            method.invoke(userBean); // 调用 method，无须参数</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>打印结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">I&apos;m a public method</div><div class=\"line\">Hi wingjay, I&apos;m a static method</div><div class=\"line\">I&apos;m a private method</div></pre></td></tr></table></figure></p>\n<p>可见三个方法都正常调用了，而且 <code>public static void staticMethod(String devName)</code> 的参数 <code>devName</code> 也正常传进去了。</p>\n<h2 id=\"小结\"><a href=\"# 小结\" class=\"headerlink\" title=\"小结\"></a>小结 </h2><p> 基于上面两个实践，我们已经能够利用反射机制，在运行状态下把一个 Class 的内部成员方法、成员变量和构造函数全部获取到，并且能够进行实例化、直接调用内部的成员方法。</p>\n<p>因此，有了反射机制，我们即使只有动态得到的 Class，也能直接得到它内部的信息、甚至调用它内部的方法。</p>\n<p>了解了反射后，下文我将介绍 <code>Annotation</code> 一些有趣的自定义实现，合理地利用 <code>Annotation</code> 能让代码更简洁，自动生成代码，实现一些常规难以实现的功能。</p>\n<p>谢谢。</p>\n<p>wingjay</p>\n<p><a href=\"http://wingjay.com\">http://wingjay.com</a></p>\n<p><img src=\"https://avatars0.githubusercontent.com/u/9619875?v=3&amp;s=460\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>关于Java反射机制的文章很多，这次换种方式来讲解反射的作用。</p>\n<p>本文涉及到的知识点：<code>class.getDeclaredXXX()</code>、<code>XXX.getModifiers()</code>、<code>method.getReturnType()</code>、<code>method.getParameterTypes()</code>、<code>method.isAnnotationPresent(XXX.class)</code>、<code>Modifier.isStatic(method.getModifiers())</code> 和 <code>constructor.newInstance(XX)</code></p>\n<p>本文涉及代码：<br><a href=\"https://github.com/wingjay/HelloJava/blob/master/data-structure/src/reflection/ForArticle.java\" target=\"_blank\" rel=\"external\">https://github.com/wingjay/HelloJava/blob/master/data-structure/src/reflection/ForArticle.java</a>   </p>\n</blockquote>","more":"<h2 id=\"先来看一个熟悉的-Class\"><a href=\"#先来看一个熟悉的-Class\" class=\"headerlink\" title=\"先来看一个熟悉的 Class\"></a>先来看一个熟悉的 Class</h2><p>首先，简单来说，反射就是在运行时可以获取任意 <code>Class</code> 或 <code>Object</code> 内部所有成员属性，如成员变量、成员方法、构造函数和 Annotation。</p>\n<p>这次先给出一个大家非常熟悉的 <code>Class</code>：<code>UserBean</code>。</p>\n<p>本文要完成的任务就是，在只有一个 <code>UserBean.getClass()</code> 的情况下，利用代码<code>打印出其内部所有成员变量、方法，并动态执行内部用 @Invoke 修饰的成员方法</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.wingjay.reflection;</div><div class=\"line\"></div><div class=\"line\">public class UserBean &#123;</div><div class=\"line\"></div><div class=\"line\">    public String userName;</div><div class=\"line\"></div><div class=\"line\">    private long userId;</div><div class=\"line\"></div><div class=\"line\">    public UserBean(String userName, long userId) &#123;</div><div class=\"line\">        this.userName = userName;</div><div class=\"line\">        this.userId = userId;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public String getName() &#123;</div><div class=\"line\">        return userName;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public long getId() &#123;</div><div class=\"line\">        return userId;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Invoke</div><div class=\"line\">    public static void staticMethod(String devName) &#123;</div><div class=\"line\">        System.out.printf(&quot;Hi %s, I&apos;m a static method&quot;, devName);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Invoke</div><div class=\"line\">    public void publicMethod() &#123;</div><div class=\"line\">        System.out.println(&quot;I&apos;m a public method&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Invoke</div><div class=\"line\">    private void privateMethod() &#123;</div><div class=\"line\">        System.out.println(&quot;I&apos;m a private method&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在只提供一个 UserBean 的 Class 情况下，</p>\n<ol>\n<li>打印出这个 <code>Class</code> 内部的所有成员变量、成员方法、构造函数，包括 <code>private</code> 的；</li>\n<li>调用这个 <code>Class</code> 内部的三个用 <code>@Invoke</code> 修饰的方法：<code>staticMethod()</code>, <code>publicMethod()</code>, <code>privateMethod()</code>；</li>\n</ol>\n<h2 id=\"1-打印-UserBean-Class-里的所有成员变量、成员方法，包括-private-的\"><a href=\"#1-打印-UserBean-Class-里的所有成员变量、成员方法，包括-private-的\" class=\"headerlink\" title=\"1. 打印 UserBean Class 里的所有成员变量、成员方法，包括 private 的\"></a>1. 打印 UserBean Class 里的所有成员变量、成员方法，包括 private 的</h2><p>首先我们拥有一个 <code>Class userBeanClass = UserBean.class</code>，我们要利用这个 <code>Class</code> 来打印它的成员变量 <code>userName</code> 和 <code>userId</code>。</p>\n<h4 id=\"打印成员变量\"><a href=\"#打印成员变量\" class=\"headerlink\" title=\"打印成员变量\"></a>打印成员变量</h4><p>那么如何获取成员变量呢，我们发现，Java 里提供了 <code>Field</code> 这个类来表示成员变量，提供了 <code>clazz.getDeclaredFields()</code> 来获取一个类内部声明的所有变量。因此，可以利用下面的代码获取 <code>userBeanClass</code> 内部所有的成员变量。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Field[] fields = userBeanClass.getDeclaredFields();</div></pre></td></tr></table></figure></p>\n<p>那么，我们如何将一个 <code>field</code> 对象打印成 <code>private String userName;</code> 这种形式呢？或者说如何分别找到 <code>private</code>、<code>String</code>、<code>userName</code> 这三个值呢？</p>\n<p>其实，<code>Field</code> 里包含了三种元素来对应它们，分别是<code>Modifier</code>、<code>Type</code>、<code>Name</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">private &lt;-- field.getModifiers();</div><div class=\"line\">String &lt;-- field.getType();</div><div class=\"line\">userName &lt;-- field.getName();</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">// fields</div><div class=\"line\">Field[] fields = userBeanClass.getDeclaredFields();</div><div class=\"line\"></div><div class=\"line\">for(Field field : fields) &#123;</div><div class=\"line\">    String fieldString = &quot;&quot;;</div><div class=\"line\">    fieldString += Modifier.toString(field.getModifiers()) + &quot; &quot;; // `private`</div><div class=\"line\">    fieldString += field.getType().getSimpleName() + &quot; &quot;; // `String`</div><div class=\"line\">    fieldString += field.getName(); // `userName`</div><div class=\"line\">    fieldString += &quot;;&quot;;</div><div class=\"line\">    System.out.println(fieldString);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>打印结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">public String userName;</div><div class=\"line\">private long userId;</div></pre></td></tr></table></figure>\n<h4 id=\"打印成员方法\"><a href=\"#打印成员方法\" class=\"headerlink\" title=\"打印成员方法\"></a>打印成员方法</h4><p>类似成员变量的 <code>Field</code>，成员方法也有对应的类 <code>Method</code>，首先可以通过 <code>Method[] methods = userBeanClass.getDeclaredMethods();</code> 获得所有的成员方法，然后，为了打印形如：<code>public static void staticMethod(String devName)</code>的数据，可以利用下列 <code>method</code> 提供的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static &lt;-- method.getModifiers();</div><div class=\"line\">void &lt;-- method.getReturnType();</div><div class=\"line\">staticMethod &lt;-- method.getName();</div><div class=\"line\">String &lt;-- method.getParameterTypes();</div></pre></td></tr></table></figure>\n<p>因此可以得到:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">Method[] methods = userBeanClass.getDeclaredMethods();</div><div class=\"line\">for (Method method : methods) &#123;</div><div class=\"line\">    String methodString = Modifier.toString(method.getModifiers()) + &quot; &quot; ; // private static</div><div class=\"line\">    methodString += method.getReturnType().getSimpleName() + &quot; &quot;; // void</div><div class=\"line\">    methodString += method.getName() + &quot;(&quot;; // staticMethod </div><div class=\"line\">    Class[] parameters = method.getParameterTypes();</div><div class=\"line\">    for (Class parameter : parameters) &#123;</div><div class=\"line\">        methodString += parameter.getSimpleName() + &quot; &quot;; // String</div><div class=\"line\">    &#125;</div><div class=\"line\">    methodString += &quot;)&quot;;</div><div class=\"line\">    System.out.println(methodString);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>打印结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public String getName()</div><div class=\"line\">public long getId()</div><div class=\"line\">public static void staticMethod(String )</div><div class=\"line\">public void publicMethod()</div><div class=\"line\">private void privateMethod()</div></pre></td></tr></table></figure></p>\n<p>可以完整的打印所有成员方法，无论是 <code>public</code> 还是 <code>private</code>，而且能打印 <code>static</code> 关键字。</p>\n<h4 id=\"打印构造函数\"><a href=\"#打印构造函数\" class=\"headerlink\" title=\"打印构造函数\"></a>打印构造函数</h4><p>其实构造函数和成员函数非常类似，Java 里提供了 <code>Constructor</code> 来表示构造函数，为了打印 <code>public UserBean(String userName, long userId)</code>，可以利用下面的函数实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">// constructors</div><div class=\"line\">Constructor[] constructors = userBeanClass.getDeclaredConstructors();</div><div class=\"line\">for (Constructor constructor : constructors) &#123;</div><div class=\"line\">    String s = Modifier.toString(constructor.getModifiers()) + &quot; &quot;;</div><div class=\"line\">    s += constructor.getName() + &quot;(&quot;;</div><div class=\"line\">    Class[] parameters = constructor.getParameterTypes();</div><div class=\"line\">    for (Class parameter : parameters) &#123;</div><div class=\"line\">        s += parameter.getSimpleName() + &quot;, &quot;;</div><div class=\"line\">    &#125;</div><div class=\"line\">    s += &quot;)&quot;;</div><div class=\"line\">    System.out.println(s);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>打印结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">public com.wingjay.reflection.UserBean(String, long)</div></pre></td></tr></table></figure></p>\n<h2 id=\"2-调用-Class-内部的用-Invoke-修饰的方法\"><a href=\"#2-调用-Class-内部的用-Invoke-修饰的方法\" class=\"headerlink\" title=\"2. 调用 Class 内部的用 @Invoke 修饰的方法\"></a>2. 调用 Class 内部的用 <code>@Invoke</code> 修饰的方法</h2><p>从上面知道，我们可以利用 <code>class.getDeclaredMethods()</code> 获取一个类内部所有成员方法，接下来我们还要做的事是：</p>\n<ol>\n<li>判断这个方法是否被 <code>@Invoke</code> 修饰</li>\n<li>如果修饰，判断这个方法是不是 <code>static</code> 的</li>\n<li>如果是 <code>static</code>，则可以直接用 class 调用</li>\n<li>如果不是 <code>static</code>，那就需要实例化一个对象来调用</li>\n<li>如果这个方法是 <code>private</code> 的，要记得 <code>setAccessible(true)</code>。</li>\n</ol>\n<p>如果分别实现上面的一些功能呢？</p>\n<ul>\n<li>为了判断一个 Method 是否被某个 Annotation 修饰，可以用 <code>method.isAnnotationPresent(Invoke.class)</code> ；</li>\n<li>关于 <code>static</code> <code>private</code>，我们可以用 <code>Modifier</code> 类提供的 <code>Modifier.isStatic()</code> 和 <code>Modifier.isPrivate()</code>来判断；</li>\n<li>如果 Method 不是 static，那就要实例化对象，我们可以用 <code>class.newInstance()</code> 或者 <code>constructor.newInstance(params)</code> 来得到实例。</li>\n<li>关于执行一个 Method，可以使用 <code>method.invoke(object, ...params)</code> 方法，如果方法不是 <code>static</code> 就必须实例化一个 <code>object</code> 传给它，否则可以传 <code>null</code></li>\n</ul>\n<p>实现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">Method[] methods = userBeanClass.getDeclaredMethods(); // 获取所有成员方法</div><div class=\"line\">for (Method method : methods) &#123;</div><div class=\"line\">    if (method.isAnnotationPresent(Invoke.class)) &#123; // 判断是否被 @Invoke 修饰</div><div class=\"line\">        if (Modifier.isStatic(method.getModifiers())) &#123; // 如果是 static 方法</div><div class=\"line\">            method.invoke(null, &quot;wingjay&quot;); // 直接调用，并传入需要的参数 devName</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            Class[] params = &#123;String.class, long.class&#125;;</div><div class=\"line\">            Constructor constructor = userBeanClass.getDeclaredConstructor(params); // 获取参数格式为 String,long 的构造函数</div><div class=\"line\">            Object userBean = constructor.newInstance(&quot;wingjay&quot;, 11); // 利用构造函数进行实例化，得到 Object</div><div class=\"line\">            if (Modifier.isPrivate(method.getModifiers())) &#123;</div><div class=\"line\">                method.setAccessible(true); // 如果是 private 的方法，需要获取其调用权限</div><div class=\"line\">            &#125;</div><div class=\"line\">            method.invoke(userBean); // 调用 method，无须参数</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>打印结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">I&apos;m a public method</div><div class=\"line\">Hi wingjay, I&apos;m a static method</div><div class=\"line\">I&apos;m a private method</div></pre></td></tr></table></figure></p>\n<p>可见三个方法都正常调用了，而且 <code>public static void staticMethod(String devName)</code> 的参数 <code>devName</code> 也正常传进去了。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>基于上面两个实践，我们已经能够利用反射机制，在运行状态下把一个 Class 的内部成员方法、成员变量和构造函数全部获取到，并且能够进行实例化、直接调用内部的成员方法。</p>\n<p>因此，有了反射机制，我们即使只有动态得到的 Class，也能直接得到它内部的信息、甚至调用它内部的方法。</p>\n<p>了解了反射后，下文我将介绍 <code>Annotation</code> 一些有趣的自定义实现，合理地利用 <code>Annotation</code> 能让代码更简洁，自动生成代码，实现一些常规难以实现的功能。</p>\n<p>谢谢。</p>\n<p>wingjay</p>\n<p><a href=\"http://wingjay.com\">http://wingjay.com</a></p>\n<p><img src=\"https://avatars0.githubusercontent.com/u/9619875?v=3&amp;s=460\" alt=\"\"></p>","sticky":0},{"title":"Java 技术之注解 Annotation","date":"2017-05-03T02:47:11.000Z","commentIssueId":5,"_content":"\n>`注解`这种语法本身很有意思，当前很多流行库如 `Dagger`、`ButterKnife`等都是基于注解这种语法。\n\n>熟练使用`注解`，既能让你的代码变得简洁易读，动态运行时执行你想要的操作，还能帮你生成代码，省去重复代码写作。\n\n> 本文涉及知识点：注解的生命周期，代码编辑时注解，编译时注解代码生成，运行时注解动态反射。\n\n<!-- more -->\n\n\n## 注解的生命周期与修饰对象\n对于 Java 代码从编写到运行有三个时期：代码编辑；编译成 `.class` 文件；读取到 JVM 运行。针对这三个时期有三种 `Annotation` 对应：\n```\nRetentionPolicy.SOURCE  // 只在代码编辑期生效\n\nRetentionPolicy.CLASS  // 在编译期生效，默认值\n\nRetentionPolicy.RUNTIME // 在代码运行时生效\n```\n\n除了生命周期，我们还可以指定 `Annotation` 用来指定的对象，比如修饰方法、类、变量、参数等，例如：\n```\n@Annotation \npublic void getName() {}\n\n@Annotation \nString name;\n\npublic void setName(@Annotation String name) {}\n```\n\nJava 提供了 `@Target` 这个`元注解`来指定某个 `Annotation` 修饰的目标对象。\n\n例如 `@Override` 是用来修饰方法的。\n```\n@Target(ElementType.METHOD)\npublic @interface Override {\n}\n```\n\n而 `@SuppressWarnings` 可以用来修饰很多，包括类、方法、变量等等。\n```\n@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})\npublic @interface SuppressWarnings {\n    String[] value();\n}\n```\n\n下面我们依次来看看不同生命周期的三类 Annotation。\n\n## 1. 代码编辑时注解\n这种 Annotation 只存在于代码编辑阶段（RetentionPolicy.SOURCE），主要功能是让 IDE 来为开发者提供 warning 检查。这一类注解只会在编辑代码时生效，当编译器把 .java 文件编译成 .class 文件时会自动丢弃。\n\n比较常用的有 `SuppressWarnings`，`Override`。\n\n`SuppressWarnings`是抑制编译器生成警告信息，比如我们调用了某个被标记为 `Deprecated` 的方法，这时编译器会发出警告，而我们又不得不使用这个方法时，就可以用`@SuppressWarnings`来抑制这个警告。\n```\n@Retention(RetentionPolicy.SOURCE)\npublic @interface SuppressWarnings {\n    String[] value();\n}\n```\n其作用如下图，`@SuppressWarnings(\"deprecation\")` 可以把 `deprecation` 相关的警告给抑制掉。\n\n\n![warning](/img/annotation/warning.png)\n![no-warning](/img/annotation/no-warning.png)\n\n`Override`用来标记重写父类某个方法，万一不小心写错方法名或者父类该方法发生改动，IDE 就会发出警告。\n```\n@Retention(RetentionPolicy.SOURCE)\npublic @interface Override {\n}\n```\n\n当然，对于开发者而言，这一类的 Annotation 我们很少自定义，更重要的是学会使用。其实 Java 和 Android 里提供了非常多有用的静态检查的 Annotation，有助于提高代码的正确率，省去人工的代码检查，方便代码给他人使用。\n\n之后的文章我会具体介绍 Android 内部[`support-annotations`]很多有趣有用的 Annotation。\n\n## 2. 运行时注解\n这一类注解是开发者广泛使用的。基本原理是利用`反射机制`在代码运行过程中动态地执行一些操作。关于 `反射机制` 我已经在之前的文章[Java 技术之反射](/2017/04/26/Java-技术之反射/)中细致阐述过了，不熟悉的读者可以去阅读。\n\n下面我们以两个例子来进行讲解。还是利用我们常用的 `UserBean` 对象为目标，对它内部的一些 `Annotation` 进行运行时处理。\n```\npublic class UserBean {\n\n    @Alias(\"user_name\")\n    public String userName;\n\n    @Alias(\"user_id\")\n    private long userId;\n\n    public UserBean(String userName, long userId) {\n        this.userName = userName;\n        this.userId = userId;\n    }\n\n    public String getName() {\n        return userName;\n    }\n\n    public long getId() {\n        return userId;\n    }\n\n    @Test(value = \"static_method\", id = 1)\n    public static void staticMethod() {\n        System.out.printf(\"I'm a static method\\n\");\n    }\n\n    @Test(value = \"public_method\", id = 2)\n    public void publicMethod() {\n        System.out.println(\"I'm a public method\\n\");\n    }\n\n    @Test(value = \"private_method\", id = 3)\n    private void privateMethod() {\n        System.out.println(\"I'm a private method\\n\");\n    }\n\n    @Test(id = 4)\n    public void testFailure() {\n        throw new RuntimeException(\"Test failure\");\n    }\n}\n```\n\n这次我在 `UserBean` 里面创建了两个自定义的 `Annotation`: `Alias` 和 `Test`，前者是用来设置变量的别名并在运行时打印，后者是调用所有被`Test`标记的方法，得出测试通过率。当然，这两个功能目前完全没有实现，只是标记了一下而已。下面我们依次来实现这两个Annotation的功能。\n\n#### Alias 功能实现：设置变量别名并在运行时打印别名\n首先，我们要创建 `Alias` 这个注解。那么要明确三个方面：\n\n- 生命周期是什么？\n- 针对的目标是什么类型？\n- 内部是否有参数？\n\n针对 `Alias` 的功能，我们可以作如下回答：\n- 生命周期是`运行时`，因为要动态打印出变量的别名 -> @Retention(RetentionPolicy.RUNTIME)\n- 针对的目标是 `变量` -> @Target(ElementType.FIELD)\n- 内部需要维护一个 String 型的变量来保存别名 -> String value();\n\n因此可以得到\n```\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Alias {\n    String value();\n}\n```\n\n`Alias` 定义得到了，接下来我们要实现它的功能了，即在运行时取出变量的别名并打印。\n\n代码如下：\n```\n/**\n * print alias during runtime\n */\nprivate static void printAlias(Object userBeanObject) {\n    for (Field field : userBeanObject.getClass().getDeclaredFields()) {\n        if (field.isAnnotationPresent(Alias.class)) {\n            Alias alias = field.getAnnotation(Alias.class);\n            System.out.println(alias.value());\n        }\n    }\n}\n```\n\n过程很简单，利用反射机制，把 `userBeanObject` 对应 Class 里所有的成员变量都找到，找出其中被 `Alias` 修饰的成员变量，然后把真实注解 `Alias` 对象取出来，把内部的 `value` 打印出来即可。 \n\n#### `Test`功能实现：调用所有被`Test`标记的方法，得出测试通过率\n同样我们要回答上面三个问题：生命周期，针对对象类型和内部参数，回答是：\n\n- 生命周期：由于是`动态运行时`去遍历这些 `Test` 的存在，因此是 `RUNTIME`;\n- 针对对象类型：因为是修饰`方法`的，因此是 `@Target(ElementType.METHOD)`;\n- 内部参数：由于需要记录方法的`名称`和对应的`id`，因此需要 `String value();` `int id;`\n\n得到如下：\n```\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Test {\n    String value() default \"\"; // 如果没有设置，那么直接取函数方法名\n    int id();\n}\n```\n\n接下来我们需要找到所有被 `@Test` 修饰的方法，并逐一调用。注意两点：\n1. 就算是 `private` 和 `static` 修饰的方法也需要调用；\n2. 在执行每个方法前后都要打印相关log，表示开始测试该方法。打印的内容要含有 `value` 和 `id`， 如果 `@Test` 里的 `value` 没有设置值，那么就取函数名为值。\n\n可以看出，在 `UserBean` 里已经定义好了三个被 `@Test` 修饰的方法了。\n```\n    @Test(value = \"static_method\", id = 1)\n    public static void staticMethod() {\n        System.out.printf(\"I'm a static method\\n\");\n    }\n\n    @Test(value = \"public_method\", id = 2)\n    public void publicMethod() {\n        System.out.println(\"I'm a public method\\n\");\n    }\n\n    @Test(value = \"private_method\", id = 3)\n    private void privateMethod() {\n        System.out.println(\"I'm a private method\\n\");\n    }\n\n    @Test(id = 4)\n    public void testFailure() {\n        throw new RuntimeException(\"Test failure\");\n    }\n```\n\n接下来我们实现 `@Test` 的具体功能：\n```\n/**\n * Test methods which are be annotated with @Test\n */\nprivate static void doTest(Object object) {\n    Method[] methods = object.getClass().getDeclaredMethods();\n    for (Method method : methods) {\n        if (method.isAnnotationPresent(Test.class)) {\n            Test test = method.getAnnotation(Test.class);\n            try {\n                String methodName = test.value().length() == 0 ? method.getName() : test.value(); // if test.value() is empty, use `method.getName()`\n                System.out.printf(\"Testing. methodName: %s, id: %s\\n\", methodName, test.id());\n\n                if (Modifier.isStatic(method.getModifiers())) {\n                    method.invoke(null); // static method\n                } else if (Modifier.isPrivate(method.getModifiers())) {\n                    method.setAccessible(true);  // private method\n                    method.invoke(object);\n                } else {\n                    method.invoke(object);  // public method\n                }\n\n                System.out.printf(\"PASS: Method id: %s\\n\", test.id());\n            } catch (Exception e) {\n                System.out.printf(\"FAIL: Method id: %s\\n\", test.id());\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n打印结果如下：\n\n```\nTesting. methodName: static_method, id: 1\nI'm a static method\nPASS: Method id: 1\n\nTesting. methodName: public_method, id: 2\nI'm a public method\nPASS: Method id: 2\n\nTesting. methodName: private_method, id: 3\nI'm a private method\nPASS: Method id: 3\n\nTesting. methodName: testFailure, id: 4\nFAIL: Method id: 4\n```\n\n全部正常打印。其中，由于 `testFailure()` 的 `@Test` 里未设置 `value()`，因此直接打印了它的函数名；针对`static`方法，直接调用`method.invoke(null)`；针对`private`，利用`method.setAccessible(true);`获取了权限。\n\n当然这里有一点要注意，我在 `invoke method` 时，直接使用 `method.invoke(object);`，没有传任何参数。这是由于我在 `UserBean` 里写的几个方法都不用传参数。如果需要传参数的话，那就还需要再单独判断是哪个函数，并传递对应的参数进去。\n\n\n## 3. 编译时注解\n当 .java 文件写好了准备进行编译时，我们有另一种 Annotation 可以在这时发挥效果。\n\n我们知道，Java 源代码编译的过程会对所有的文件进行扫描，而`编译时 Annotation` 的作用就是`在编译过程中生成代码`。在 Java 里提供了 apt 工具来处理注解，同时有一套 Mirror API 来描述编译时的程序语义结构，它可以在编译时获取到被注解 Java 元素的信息以方便我们处理。该处理过程的核心是编写注解处理器 `AnnotationProcessor` 接口。\n\n大概说明下整体的过程。\n\n假设我们希望用某个 `Annotation`：`@Inject` 来生成一些代码，那么我们要做下面几步：\n\n##### 定义 @Inject\n由于它是编译时注解，因此是 `RetentionPolicy.CLASS`，对象的话就是变量和构造函数，因此得到：\n```\n@Retention(RetentionPolicy.CLASS)\n@Target({ElementType.CONSTRUCTOR, ElementType.FIELD})\npublic @interface Inject {\n}\n```\n\n##### 定义 Processor 类\n```\n// Helper to define the Processor\n@AutoService(Processor.class)\n// Define the supported Java source code version\n@SupportedSourceVersion(SourceVersion.RELEASE_7)\n// Define which annotation you want to process\n@SupportedAnnotationTypes(\"com.wingjay.annotation.Inject\")\npublic class MyProcessor extends AbstractProcessor {  ...  }\n```\n##### 重写 `Processor` 内部的 `process` 方法\n这个 `process` 方法会在编译时被执行到，我们可以在这个方法里进行代码生成的工作。\n\n关于具体的代码生成部分，可以利用 `Square` 提供的 `JavaPoet` 工具：https://github.com/square/javapoet\n\n下面有一些代码片段供参考：\n```\n@Override\npublic boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n\t//扫描所有 Inject 标记过的元素\n    Set<? extends Element> elements = roundEnv.getElementsAnnotatedWith(Inject.class);\n    Set<? extends TypeElement> typeElements = ElementFilter.typesIn(elements);\n    for (TypeElement element : typeElements) {\n\n    \t// 拼接待生成代码\n    \tClassName currentType = ClassName.get(element);\n      \tMethodSpec.Builder builder = MethodSpec.methodBuilder(\"fromCursor\")\n\t       .returns(currentType)\n\t       .addModifiers(Modifier.STATIC)\n\t       .addModifiers(Modifier.PUBLIC)\n\t       .addParameter(ClassName.get(\"android.database\", \"Cursor\"), \"cursor\");\n\n\t    // 将这些拼接代码写入文件\n        String className = ... // 设置你要生成的代码class名字\n        JavaFileObject sourceFile =   processingEnv.getFiler().createSourceFile(className, element);\n        Writer writer = sourceFile.openWriter();\n        javaFile.writeTo(writer);\n        writer.close();  \n\t}\n\treturn false;\n}\n```\n\n\n## 小结\n本文在前文[Java 技术之反射](/2017/04/26/Java-技术之反射/)的基础上，对 Java 的注解 `Annotation` 做了一定的介绍。\n\n熟练使用 `Annotation` 能在很多时候帮助代码变得更简洁，也能帮我们生成很多代码，免除重复写作相同代码，是一种很高效的编程方式。\n\n下一篇我会为 Android 的小伙伴介绍不少你可能不太知道但非常好用的 `Android Annotation`。\n\n谢谢。\n\nwingjay\n\nhttp://wingjay.com\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n","source":"_posts/Java-技术之注解-Annotation.md","raw":"title: Java 技术之注解 Annotation\ndate: 2017-05-03 10:47:11\ncategories:\n  - 深入理解Java技术\ntags: \n  - Java\n  - Annotation\ncommentIssueId: 5  \n---\n\n>`注解`这种语法本身很有意思，当前很多流行库如 `Dagger`、`ButterKnife`等都是基于注解这种语法。\n\n>熟练使用`注解`，既能让你的代码变得简洁易读，动态运行时执行你想要的操作，还能帮你生成代码，省去重复代码写作。\n\n> 本文涉及知识点：注解的生命周期，代码编辑时注解，编译时注解代码生成，运行时注解动态反射。\n\n<!-- more -->\n\n\n## 注解的生命周期与修饰对象\n对于 Java 代码从编写到运行有三个时期：代码编辑；编译成 `.class` 文件；读取到 JVM 运行。针对这三个时期有三种 `Annotation` 对应：\n```\nRetentionPolicy.SOURCE  // 只在代码编辑期生效\n\nRetentionPolicy.CLASS  // 在编译期生效，默认值\n\nRetentionPolicy.RUNTIME // 在代码运行时生效\n```\n\n除了生命周期，我们还可以指定 `Annotation` 用来指定的对象，比如修饰方法、类、变量、参数等，例如：\n```\n@Annotation \npublic void getName() {}\n\n@Annotation \nString name;\n\npublic void setName(@Annotation String name) {}\n```\n\nJava 提供了 `@Target` 这个`元注解`来指定某个 `Annotation` 修饰的目标对象。\n\n例如 `@Override` 是用来修饰方法的。\n```\n@Target(ElementType.METHOD)\npublic @interface Override {\n}\n```\n\n而 `@SuppressWarnings` 可以用来修饰很多，包括类、方法、变量等等。\n```\n@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})\npublic @interface SuppressWarnings {\n    String[] value();\n}\n```\n\n下面我们依次来看看不同生命周期的三类 Annotation。\n\n## 1. 代码编辑时注解\n这种 Annotation 只存在于代码编辑阶段（RetentionPolicy.SOURCE），主要功能是让 IDE 来为开发者提供 warning 检查。这一类注解只会在编辑代码时生效，当编译器把 .java 文件编译成 .class 文件时会自动丢弃。\n\n比较常用的有 `SuppressWarnings`，`Override`。\n\n`SuppressWarnings`是抑制编译器生成警告信息，比如我们调用了某个被标记为 `Deprecated` 的方法，这时编译器会发出警告，而我们又不得不使用这个方法时，就可以用`@SuppressWarnings`来抑制这个警告。\n```\n@Retention(RetentionPolicy.SOURCE)\npublic @interface SuppressWarnings {\n    String[] value();\n}\n```\n其作用如下图，`@SuppressWarnings(\"deprecation\")` 可以把 `deprecation` 相关的警告给抑制掉。\n\n\n![warning](/img/annotation/warning.png)\n![no-warning](/img/annotation/no-warning.png)\n\n`Override`用来标记重写父类某个方法，万一不小心写错方法名或者父类该方法发生改动，IDE 就会发出警告。\n```\n@Retention(RetentionPolicy.SOURCE)\npublic @interface Override {\n}\n```\n\n当然，对于开发者而言，这一类的 Annotation 我们很少自定义，更重要的是学会使用。其实 Java 和 Android 里提供了非常多有用的静态检查的 Annotation，有助于提高代码的正确率，省去人工的代码检查，方便代码给他人使用。\n\n之后的文章我会具体介绍 Android 内部[`support-annotations`]很多有趣有用的 Annotation。\n\n## 2. 运行时注解\n这一类注解是开发者广泛使用的。基本原理是利用`反射机制`在代码运行过程中动态地执行一些操作。关于 `反射机制` 我已经在之前的文章[Java 技术之反射](/2017/04/26/Java-技术之反射/)中细致阐述过了，不熟悉的读者可以去阅读。\n\n下面我们以两个例子来进行讲解。还是利用我们常用的 `UserBean` 对象为目标，对它内部的一些 `Annotation` 进行运行时处理。\n```\npublic class UserBean {\n\n    @Alias(\"user_name\")\n    public String userName;\n\n    @Alias(\"user_id\")\n    private long userId;\n\n    public UserBean(String userName, long userId) {\n        this.userName = userName;\n        this.userId = userId;\n    }\n\n    public String getName() {\n        return userName;\n    }\n\n    public long getId() {\n        return userId;\n    }\n\n    @Test(value = \"static_method\", id = 1)\n    public static void staticMethod() {\n        System.out.printf(\"I'm a static method\\n\");\n    }\n\n    @Test(value = \"public_method\", id = 2)\n    public void publicMethod() {\n        System.out.println(\"I'm a public method\\n\");\n    }\n\n    @Test(value = \"private_method\", id = 3)\n    private void privateMethod() {\n        System.out.println(\"I'm a private method\\n\");\n    }\n\n    @Test(id = 4)\n    public void testFailure() {\n        throw new RuntimeException(\"Test failure\");\n    }\n}\n```\n\n这次我在 `UserBean` 里面创建了两个自定义的 `Annotation`: `Alias` 和 `Test`，前者是用来设置变量的别名并在运行时打印，后者是调用所有被`Test`标记的方法，得出测试通过率。当然，这两个功能目前完全没有实现，只是标记了一下而已。下面我们依次来实现这两个Annotation的功能。\n\n#### Alias 功能实现：设置变量别名并在运行时打印别名\n首先，我们要创建 `Alias` 这个注解。那么要明确三个方面：\n\n- 生命周期是什么？\n- 针对的目标是什么类型？\n- 内部是否有参数？\n\n针对 `Alias` 的功能，我们可以作如下回答：\n- 生命周期是`运行时`，因为要动态打印出变量的别名 -> @Retention(RetentionPolicy.RUNTIME)\n- 针对的目标是 `变量` -> @Target(ElementType.FIELD)\n- 内部需要维护一个 String 型的变量来保存别名 -> String value();\n\n因此可以得到\n```\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Alias {\n    String value();\n}\n```\n\n`Alias` 定义得到了，接下来我们要实现它的功能了，即在运行时取出变量的别名并打印。\n\n代码如下：\n```\n/**\n * print alias during runtime\n */\nprivate static void printAlias(Object userBeanObject) {\n    for (Field field : userBeanObject.getClass().getDeclaredFields()) {\n        if (field.isAnnotationPresent(Alias.class)) {\n            Alias alias = field.getAnnotation(Alias.class);\n            System.out.println(alias.value());\n        }\n    }\n}\n```\n\n过程很简单，利用反射机制，把 `userBeanObject` 对应 Class 里所有的成员变量都找到，找出其中被 `Alias` 修饰的成员变量，然后把真实注解 `Alias` 对象取出来，把内部的 `value` 打印出来即可。 \n\n#### `Test`功能实现：调用所有被`Test`标记的方法，得出测试通过率\n同样我们要回答上面三个问题：生命周期，针对对象类型和内部参数，回答是：\n\n- 生命周期：由于是`动态运行时`去遍历这些 `Test` 的存在，因此是 `RUNTIME`;\n- 针对对象类型：因为是修饰`方法`的，因此是 `@Target(ElementType.METHOD)`;\n- 内部参数：由于需要记录方法的`名称`和对应的`id`，因此需要 `String value();` `int id;`\n\n得到如下：\n```\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Test {\n    String value() default \"\"; // 如果没有设置，那么直接取函数方法名\n    int id();\n}\n```\n\n接下来我们需要找到所有被 `@Test` 修饰的方法，并逐一调用。注意两点：\n1. 就算是 `private` 和 `static` 修饰的方法也需要调用；\n2. 在执行每个方法前后都要打印相关log，表示开始测试该方法。打印的内容要含有 `value` 和 `id`， 如果 `@Test` 里的 `value` 没有设置值，那么就取函数名为值。\n\n可以看出，在 `UserBean` 里已经定义好了三个被 `@Test` 修饰的方法了。\n```\n    @Test(value = \"static_method\", id = 1)\n    public static void staticMethod() {\n        System.out.printf(\"I'm a static method\\n\");\n    }\n\n    @Test(value = \"public_method\", id = 2)\n    public void publicMethod() {\n        System.out.println(\"I'm a public method\\n\");\n    }\n\n    @Test(value = \"private_method\", id = 3)\n    private void privateMethod() {\n        System.out.println(\"I'm a private method\\n\");\n    }\n\n    @Test(id = 4)\n    public void testFailure() {\n        throw new RuntimeException(\"Test failure\");\n    }\n```\n\n接下来我们实现 `@Test` 的具体功能：\n```\n/**\n * Test methods which are be annotated with @Test\n */\nprivate static void doTest(Object object) {\n    Method[] methods = object.getClass().getDeclaredMethods();\n    for (Method method : methods) {\n        if (method.isAnnotationPresent(Test.class)) {\n            Test test = method.getAnnotation(Test.class);\n            try {\n                String methodName = test.value().length() == 0 ? method.getName() : test.value(); // if test.value() is empty, use `method.getName()`\n                System.out.printf(\"Testing. methodName: %s, id: %s\\n\", methodName, test.id());\n\n                if (Modifier.isStatic(method.getModifiers())) {\n                    method.invoke(null); // static method\n                } else if (Modifier.isPrivate(method.getModifiers())) {\n                    method.setAccessible(true);  // private method\n                    method.invoke(object);\n                } else {\n                    method.invoke(object);  // public method\n                }\n\n                System.out.printf(\"PASS: Method id: %s\\n\", test.id());\n            } catch (Exception e) {\n                System.out.printf(\"FAIL: Method id: %s\\n\", test.id());\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n打印结果如下：\n\n```\nTesting. methodName: static_method, id: 1\nI'm a static method\nPASS: Method id: 1\n\nTesting. methodName: public_method, id: 2\nI'm a public method\nPASS: Method id: 2\n\nTesting. methodName: private_method, id: 3\nI'm a private method\nPASS: Method id: 3\n\nTesting. methodName: testFailure, id: 4\nFAIL: Method id: 4\n```\n\n全部正常打印。其中，由于 `testFailure()` 的 `@Test` 里未设置 `value()`，因此直接打印了它的函数名；针对`static`方法，直接调用`method.invoke(null)`；针对`private`，利用`method.setAccessible(true);`获取了权限。\n\n当然这里有一点要注意，我在 `invoke method` 时，直接使用 `method.invoke(object);`，没有传任何参数。这是由于我在 `UserBean` 里写的几个方法都不用传参数。如果需要传参数的话，那就还需要再单独判断是哪个函数，并传递对应的参数进去。\n\n\n## 3. 编译时注解\n当 .java 文件写好了准备进行编译时，我们有另一种 Annotation 可以在这时发挥效果。\n\n我们知道，Java 源代码编译的过程会对所有的文件进行扫描，而`编译时 Annotation` 的作用就是`在编译过程中生成代码`。在 Java 里提供了 apt 工具来处理注解，同时有一套 Mirror API 来描述编译时的程序语义结构，它可以在编译时获取到被注解 Java 元素的信息以方便我们处理。该处理过程的核心是编写注解处理器 `AnnotationProcessor` 接口。\n\n大概说明下整体的过程。\n\n假设我们希望用某个 `Annotation`：`@Inject` 来生成一些代码，那么我们要做下面几步：\n\n##### 定义 @Inject\n由于它是编译时注解，因此是 `RetentionPolicy.CLASS`，对象的话就是变量和构造函数，因此得到：\n```\n@Retention(RetentionPolicy.CLASS)\n@Target({ElementType.CONSTRUCTOR, ElementType.FIELD})\npublic @interface Inject {\n}\n```\n\n##### 定义 Processor 类\n```\n// Helper to define the Processor\n@AutoService(Processor.class)\n// Define the supported Java source code version\n@SupportedSourceVersion(SourceVersion.RELEASE_7)\n// Define which annotation you want to process\n@SupportedAnnotationTypes(\"com.wingjay.annotation.Inject\")\npublic class MyProcessor extends AbstractProcessor {  ...  }\n```\n##### 重写 `Processor` 内部的 `process` 方法\n这个 `process` 方法会在编译时被执行到，我们可以在这个方法里进行代码生成的工作。\n\n关于具体的代码生成部分，可以利用 `Square` 提供的 `JavaPoet` 工具：https://github.com/square/javapoet\n\n下面有一些代码片段供参考：\n```\n@Override\npublic boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n\t//扫描所有 Inject 标记过的元素\n    Set<? extends Element> elements = roundEnv.getElementsAnnotatedWith(Inject.class);\n    Set<? extends TypeElement> typeElements = ElementFilter.typesIn(elements);\n    for (TypeElement element : typeElements) {\n\n    \t// 拼接待生成代码\n    \tClassName currentType = ClassName.get(element);\n      \tMethodSpec.Builder builder = MethodSpec.methodBuilder(\"fromCursor\")\n\t       .returns(currentType)\n\t       .addModifiers(Modifier.STATIC)\n\t       .addModifiers(Modifier.PUBLIC)\n\t       .addParameter(ClassName.get(\"android.database\", \"Cursor\"), \"cursor\");\n\n\t    // 将这些拼接代码写入文件\n        String className = ... // 设置你要生成的代码class名字\n        JavaFileObject sourceFile =   processingEnv.getFiler().createSourceFile(className, element);\n        Writer writer = sourceFile.openWriter();\n        javaFile.writeTo(writer);\n        writer.close();  \n\t}\n\treturn false;\n}\n```\n\n\n## 小结\n本文在前文[Java 技术之反射](/2017/04/26/Java-技术之反射/)的基础上，对 Java 的注解 `Annotation` 做了一定的介绍。\n\n熟练使用 `Annotation` 能在很多时候帮助代码变得更简洁，也能帮我们生成很多代码，免除重复写作相同代码，是一种很高效的编程方式。\n\n下一篇我会为 Android 的小伙伴介绍不少你可能不太知道但非常好用的 `Android Annotation`。\n\n谢谢。\n\nwingjay\n\nhttp://wingjay.com\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n","slug":"Java-技术之注解-Annotation","published":1,"updated":"2018-11-26T06:56:27.481Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplshw00293dn86hetq87e","content":"<blockquote>\n<p><code>注解 </code> 这种语法本身很有意思，当前很多流行库如 <code>Dagger</code>、<code>ButterKnife</code>等都是基于注解这种语法。</p>\n<p>熟练使用 <code> 注解</code>，既能让你的代码变得简洁易读，动态运行时执行你想要的操作，还能帮你生成代码，省去重复代码写作。</p>\n<p>本文涉及知识点：注解的生命周期，代码编辑时注解，编译时注解代码生成，运行时注解动态反射。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"注解的生命周期与修饰对象\"><a href=\"# 注解的生命周期与修饰对象\" class=\"headerlink\" title=\"注解的生命周期与修饰对象\"></a>注解的生命周期与修饰对象 </h2><p> 对于 Java 代码从编写到运行有三个时期：代码编辑；编译成 <code>.class</code> 文件；读取到 JVM 运行。针对这三个时期有三种 <code>Annotation</code> 对应：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">RetentionPolicy.SOURCE  // 只在代码编辑期生效</div><div class=\"line\"></div><div class=\"line\">RetentionPolicy.CLASS  // 在编译期生效，默认值</div><div class=\"line\"></div><div class=\"line\">RetentionPolicy.RUNTIME // 在代码运行时生效</div></pre></td></tr></table></figure></p>\n<p>除了生命周期，我们还可以指定 <code>Annotation</code> 用来指定的对象，比如修饰方法、类、变量、参数等，例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Annotation </div><div class=\"line\">public void getName() &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">@Annotation </div><div class=\"line\">String name;</div><div class=\"line\"></div><div class=\"line\">public void setName(@Annotation String name) &#123;&#125;</div></pre></td></tr></table></figure></p>\n<p>Java 提供了 <code>@Target</code> 这个 <code> 元注解 </code> 来指定某个 <code>Annotation</code> 修饰的目标对象。</p>\n<p>例如 <code>@Override</code> 是用来修饰方法的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Target(ElementType.METHOD)</div><div class=\"line\">public @interface Override &#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>而 <code>@SuppressWarnings</code> 可以用来修饰很多，包括类、方法、变量等等。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</div><div class=\"line\">public @interface SuppressWarnings &#123;</div><div class=\"line\">    String[] value();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>下面我们依次来看看不同生命周期的三类 Annotation。</p>\n<h2 id=\"1- 代码编辑时注解\"><a href=\"#1- 代码编辑时注解\" class=\"headerlink\" title=\"1. 代码编辑时注解\"></a>1. 代码编辑时注解 </h2><p> 这种 Annotation 只存在于代码编辑阶段（RetentionPolicy.SOURCE），主要功能是让 IDE 来为开发者提供 warning 检查。这一类注解只会在编辑代码时生效，当编译器把 .java 文件编译成 .class 文件时会自动丢弃。</p>\n<p>比较常用的有 <code>SuppressWarnings</code>，<code>Override</code>。</p>\n<p><code>SuppressWarnings</code>是抑制编译器生成警告信息，比如我们调用了某个被标记为 <code>Deprecated</code> 的方法，这时编译器会发出警告，而我们又不得不使用这个方法时，就可以用 <code>@SuppressWarnings</code> 来抑制这个警告。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Retention(RetentionPolicy.SOURCE)</div><div class=\"line\">public @interface SuppressWarnings &#123;</div><div class=\"line\">    String[] value();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其作用如下图，<code>@SuppressWarnings(&quot;deprecation&quot;)</code> 可以把 <code>deprecation</code> 相关的警告给抑制掉。</p>\n<p><img src=\"/img/annotation/warning.png\" alt=\"warning\"><br><img src=\"/img/annotation/no-warning.png\" alt=\"no-warning\"></p>\n<p><code>Override</code>用来标记重写父类某个方法，万一不小心写错方法名或者父类该方法发生改动，IDE 就会发出警告。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Retention(RetentionPolicy.SOURCE)</div><div class=\"line\">public @interface Override &#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>当然，对于开发者而言，这一类的 Annotation 我们很少自定义，更重要的是学会使用。其实 Java 和 Android 里提供了非常多有用的静态检查的 Annotation，有助于提高代码的正确率，省去人工的代码检查，方便代码给他人使用。</p>\n<p>之后的文章我会具体介绍 Android 内部 [<code>support-annotations</code>] 很多有趣有用的 Annotation。</p>\n<h2 id=\"2- 运行时注解\"><a href=\"#2- 运行时注解\" class=\"headerlink\" title=\"2. 运行时注解\"></a>2. 运行时注解 </h2><p> 这一类注解是开发者广泛使用的。基本原理是利用 <code> 反射机制 </code> 在代码运行过程中动态地执行一些操作。关于 <code>反射机制 </code> 我已经在之前的文章<a href=\"/2017/04/26/Java- 技术之反射 /\">Java 技术之反射</a> 中细致阐述过了，不熟悉的读者可以去阅读。</p>\n<p>下面我们以两个例子来进行讲解。还是利用我们常用的 <code>UserBean</code> 对象为目标，对它内部的一些 <code>Annotation</code> 进行运行时处理。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class UserBean &#123;</div><div class=\"line\"></div><div class=\"line\">    @Alias(&quot;user_name&quot;)</div><div class=\"line\">    public String userName;</div><div class=\"line\"></div><div class=\"line\">    @Alias(&quot;user_id&quot;)</div><div class=\"line\">    private long userId;</div><div class=\"line\"></div><div class=\"line\">    public UserBean(String userName, long userId) &#123;</div><div class=\"line\">        this.userName = userName;</div><div class=\"line\">        this.userId = userId;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public String getName() &#123;</div><div class=\"line\">        return userName;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public long getId() &#123;</div><div class=\"line\">        return userId;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Test(value = &quot;static_method&quot;, id = 1)</div><div class=\"line\">    public static void staticMethod() &#123;</div><div class=\"line\">        System.out.printf(&quot;I&apos;m a static method\\n&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Test(value = &quot;public_method&quot;, id = 2)</div><div class=\"line\">    public void publicMethod() &#123;</div><div class=\"line\">        System.out.println(&quot;I&apos;m a public method\\n&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Test(value = &quot;private_method&quot;, id = 3)</div><div class=\"line\">    private void privateMethod() &#123;</div><div class=\"line\">        System.out.println(&quot;I&apos;m a private method\\n&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Test(id = 4)</div><div class=\"line\">    public void testFailure() &#123;</div><div class=\"line\">        throw new RuntimeException(&quot;Test failure&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这次我在 <code>UserBean</code> 里面创建了两个自定义的 <code>Annotation</code>: <code>Alias</code> 和 <code>Test</code>，前者是用来设置变量的别名并在运行时打印，后者是调用所有被 <code>Test</code> 标记的方法，得出测试通过率。当然，这两个功能目前完全没有实现，只是标记了一下而已。下面我们依次来实现这两个 Annotation 的功能。</p>\n<h4 id=\"Alias- 功能实现：设置变量别名并在运行时打印别名\"><a href=\"#Alias- 功能实现：设置变量别名并在运行时打印别名\" class=\"headerlink\" title=\"Alias 功能实现：设置变量别名并在运行时打印别名\"></a>Alias 功能实现：设置变量别名并在运行时打印别名 </h4><p> 首先，我们要创建 <code>Alias</code> 这个注解。那么要明确三个方面：</p>\n<ul>\n<li>生命周期是什么？</li>\n<li>针对的目标是什么类型？</li>\n<li>内部是否有参数？</li>\n</ul>\n<p>针对 <code>Alias</code> 的功能，我们可以作如下回答：</p>\n<ul>\n<li>生命周期是 <code> 运行时</code>，因为要动态打印出变量的别名 -&gt; @Retention(RetentionPolicy.RUNTIME)</li>\n<li>针对的目标是 <code>变量</code> -&gt; @Target(ElementType.FIELD)</li>\n<li>内部需要维护一个 String 型的变量来保存别名 -&gt; String value();</li>\n</ul>\n<p>因此可以得到<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Target(ElementType.FIELD)</div><div class=\"line\">@Retention(RetentionPolicy.RUNTIME)</div><div class=\"line\">public @interface Alias &#123;</div><div class=\"line\">    String value();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>Alias</code> 定义得到了，接下来我们要实现它的功能了，即在运行时取出变量的别名并打印。</p>\n<p>代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * print alias during runtime</div><div class=\"line\"> */</div><div class=\"line\">private static void printAlias(Object userBeanObject) &#123;</div><div class=\"line\">    for (Field field : userBeanObject.getClass().getDeclaredFields()) &#123;</div><div class=\"line\">        if (field.isAnnotationPresent(Alias.class)) &#123;</div><div class=\"line\">            Alias alias = field.getAnnotation(Alias.class);</div><div class=\"line\">            System.out.println(alias.value());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>过程很简单，利用反射机制，把 <code>userBeanObject</code> 对应 Class 里所有的成员变量都找到，找出其中被 <code>Alias</code> 修饰的成员变量，然后把真实注解 <code>Alias</code> 对象取出来，把内部的 <code>value</code> 打印出来即可。 </p>\n<h4 id=\"Test 功能实现：调用所有被 Test 标记的方法，得出测试通过率\"><a href=\"#Test 功能实现：调用所有被 Test 标记的方法，得出测试通过率\" class=\"headerlink\" title=\"Test 功能实现：调用所有被 Test 标记的方法，得出测试通过率\"></a><code>Test</code>功能实现：调用所有被 <code>Test</code> 标记的方法，得出测试通过率 </h4><p> 同样我们要回答上面三个问题：生命周期，针对对象类型和内部参数，回答是：</p>\n<ul>\n<li>生命周期：由于是 <code> 动态运行时 </code> 去遍历这些 <code>Test</code> 的存在，因此是 <code>RUNTIME</code>;</li>\n<li>针对对象类型：因为是修饰 <code> 方法 </code> 的，因此是 <code>@Target(ElementType.METHOD)</code>;</li>\n<li>内部参数：由于需要记录方法的 <code> 名称 </code> 和对应的<code>id</code>，因此需要 <code>String value();</code> <code>int id;</code></li>\n</ul>\n<p>得到如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Target(ElementType.METHOD)</div><div class=\"line\">@Retention(RetentionPolicy.RUNTIME)</div><div class=\"line\">public @interface Test &#123;</div><div class=\"line\">    String value() default &quot;&quot;; // 如果没有设置，那么直接取函数方法名</div><div class=\"line\">    int id();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>接下来我们需要找到所有被 <code>@Test</code> 修饰的方法，并逐一调用。注意两点：</p>\n<ol>\n<li>就算是 <code>private</code> 和 <code>static</code> 修饰的方法也需要调用；</li>\n<li>在执行每个方法前后都要打印相关 log，表示开始测试该方法。打印的内容要含有 <code>value</code> 和 <code>id</code>， 如果 <code>@Test</code> 里的 <code>value</code> 没有设置值，那么就取函数名为值。</li>\n</ol>\n<p>可以看出，在 <code>UserBean</code> 里已经定义好了三个被 <code>@Test</code> 修饰的方法了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Test(value = &quot;static_method&quot;, id = 1)</div><div class=\"line\">public static void staticMethod() &#123;</div><div class=\"line\">    System.out.printf(&quot;I&apos;m a static method\\n&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@Test(value = &quot;public_method&quot;, id = 2)</div><div class=\"line\">public void publicMethod() &#123;</div><div class=\"line\">    System.out.println(&quot;I&apos;m a public method\\n&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@Test(value = &quot;private_method&quot;, id = 3)</div><div class=\"line\">private void privateMethod() &#123;</div><div class=\"line\">    System.out.println(&quot;I&apos;m a private method\\n&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@Test(id = 4)</div><div class=\"line\">public void testFailure() &#123;</div><div class=\"line\">    throw new RuntimeException(&quot;Test failure&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>接下来我们实现 <code>@Test</code> 的具体功能：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Test methods which are be annotated with @Test</div><div class=\"line\"> */</div><div class=\"line\">private static void doTest(Object object) &#123;</div><div class=\"line\">    Method[] methods = object.getClass().getDeclaredMethods();</div><div class=\"line\">    for (Method method : methods) &#123;</div><div class=\"line\">        if (method.isAnnotationPresent(Test.class)) &#123;</div><div class=\"line\">            Test test = method.getAnnotation(Test.class);</div><div class=\"line\">            try &#123;</div><div class=\"line\">                String methodName = test.value().length() == 0 ? method.getName() : test.value(); // if test.value() is empty, use `method.getName()`</div><div class=\"line\">                System.out.printf(&quot;Testing. methodName: %s, id: %s\\n&quot;, methodName, test.id());</div><div class=\"line\"></div><div class=\"line\">                if (Modifier.isStatic(method.getModifiers())) &#123;</div><div class=\"line\">                    method.invoke(null); // static method</div><div class=\"line\">                &#125; else if (Modifier.isPrivate(method.getModifiers())) &#123;</div><div class=\"line\">                    method.setAccessible(true);  // private method</div><div class=\"line\">                    method.invoke(object);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    method.invoke(object);  // public method</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                System.out.printf(&quot;PASS: Method id: %s\\n&quot;, test.id());</div><div class=\"line\">            &#125; catch (Exception e) &#123;</div><div class=\"line\">                System.out.printf(&quot;FAIL: Method id: %s\\n&quot;, test.id());</div><div class=\"line\">                e.printStackTrace();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>打印结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">Testing. methodName: static_method, id: 1</div><div class=\"line\">I&apos;m a static method</div><div class=\"line\">PASS: Method id: 1</div><div class=\"line\"></div><div class=\"line\">Testing. methodName: public_method, id: 2</div><div class=\"line\">I&apos;m a public method</div><div class=\"line\">PASS: Method id: 2</div><div class=\"line\"></div><div class=\"line\">Testing. methodName: private_method, id: 3</div><div class=\"line\">I&apos;m a private method</div><div class=\"line\">PASS: Method id: 3</div><div class=\"line\"></div><div class=\"line\">Testing. methodName: testFailure, id: 4</div><div class=\"line\">FAIL: Method id: 4</div></pre></td></tr></table></figure>\n<p>全部正常打印。其中，由于 <code>testFailure()</code> 的 <code>@Test</code> 里未设置 <code>value()</code>，因此直接打印了它的函数名；针对 <code>static</code> 方法，直接调用 <code>method.invoke(null)</code>；针对<code>private</code>，利用<code>method.setAccessible(true);</code> 获取了权限。</p>\n<p>当然这里有一点要注意，我在 <code>invoke method</code> 时，直接使用 <code>method.invoke(object);</code>，没有传任何参数。这是由于我在 <code>UserBean</code> 里写的几个方法都不用传参数。如果需要传参数的话，那就还需要再单独判断是哪个函数，并传递对应的参数进去。</p>\n<h2 id=\"3- 编译时注解\"><a href=\"#3- 编译时注解\" class=\"headerlink\" title=\"3. 编译时注解\"></a>3. 编译时注解 </h2><p> 当 .java 文件写好了准备进行编译时，我们有另一种 Annotation 可以在这时发挥效果。</p>\n<p>我们知道，Java 源代码编译的过程会对所有的文件进行扫描，而 <code> 编译时 Annotation</code> 的作用就是 <code> 在编译过程中生成代码</code>。在 Java 里提供了 apt 工具来处理注解，同时有一套 Mirror API 来描述编译时的程序语义结构，它可以在编译时获取到被注解 Java 元素的信息以方便我们处理。该处理过程的核心是编写注解处理器 <code>AnnotationProcessor</code> 接口。</p>\n<p>大概说明下整体的过程。</p>\n<p>假设我们希望用某个 <code>Annotation</code>：<code>@Inject</code> 来生成一些代码，那么我们要做下面几步：</p>\n<h5 id=\"定义 -Inject\"><a href=\"# 定义 -Inject\" class=\"headerlink\" title=\"定义 @Inject\"></a>定义 @Inject</h5><p>由于它是编译时注解，因此是 <code>RetentionPolicy.CLASS</code>，对象的话就是变量和构造函数，因此得到：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Retention(RetentionPolicy.CLASS)</div><div class=\"line\">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.FIELD&#125;)</div><div class=\"line\">public @interface Inject &#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h5 id=\"定义 -Processor- 类\"><a href=\"# 定义 -Processor- 类\" class=\"headerlink\" title=\"定义 Processor 类\"></a>定义 Processor 类</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Helper to define the Processor</div><div class=\"line\">@AutoService(Processor.class)</div><div class=\"line\">// Define the supported Java source code version</div><div class=\"line\">@SupportedSourceVersion(SourceVersion.RELEASE_7)</div><div class=\"line\">// Define which annotation you want to process</div><div class=\"line\">@SupportedAnnotationTypes(&quot;com.wingjay.annotation.Inject&quot;)</div><div class=\"line\">public class MyProcessor extends AbstractProcessor &#123;  ...  &#125;</div></pre></td></tr></table></figure>\n<h5 id=\"重写 -Processor- 内部的 -process- 方法\"><a href=\"# 重写 -Processor- 内部的 -process- 方法\" class=\"headerlink\" title=\"重写 Processor 内部的 process 方法\"></a>重写 <code>Processor</code> 内部的 <code>process</code> 方法 </h5><p> 这个 <code>process</code> 方法会在编译时被执行到，我们可以在这个方法里进行代码生成的工作。</p>\n<p>关于具体的代码生成部分，可以利用 <code>Square</code> 提供的 <code>JavaPoet</code> 工具：<a href=\"https://github.com/square/javapoet\" target=\"_blank\" rel=\"external\">https://github.com/square/javapoet</a></p>\n<p>下面有一些代码片段供参考：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123;</div><div class=\"line\">\t// 扫描所有 Inject 标记过的元素</div><div class=\"line\">    Set&lt;? extends Element&gt; elements = roundEnv.getElementsAnnotatedWith(Inject.class);</div><div class=\"line\">    Set&lt;? extends TypeElement&gt; typeElements = ElementFilter.typesIn(elements);</div><div class=\"line\">    for (TypeElement element : typeElements) &#123;</div><div class=\"line\"></div><div class=\"line\">    \t// 拼接待生成代码</div><div class=\"line\">    \tClassName currentType = ClassName.get(element);</div><div class=\"line\">      \tMethodSpec.Builder builder = MethodSpec.methodBuilder(&quot;fromCursor&quot;)</div><div class=\"line\">\t       .returns(currentType)</div><div class=\"line\">\t       .addModifiers(Modifier.STATIC)</div><div class=\"line\">\t       .addModifiers(Modifier.PUBLIC)</div><div class=\"line\">\t       .addParameter(ClassName.get(&quot;android.database&quot;, &quot;Cursor&quot;), &quot;cursor&quot;);</div><div class=\"line\"></div><div class=\"line\">\t    // 将这些拼接代码写入文件</div><div class=\"line\">        String className = ... // 设置你要生成的代码 class 名字</div><div class=\"line\">        JavaFileObject sourceFile =   processingEnv.getFiler().createSourceFile(className, element);</div><div class=\"line\">        Writer writer = sourceFile.openWriter();</div><div class=\"line\">        javaFile.writeTo(writer);</div><div class=\"line\">        writer.close();  </div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"小结\"><a href=\"# 小结\" class=\"headerlink\" title=\"小结\"></a>小结 </h2><p> 本文在前文 <a href=\"/2017/04/26/Java- 技术之反射 /\">Java 技术之反射</a> 的基础上，对 Java 的注解 <code>Annotation</code> 做了一定的介绍。</p>\n<p>熟练使用 <code>Annotation</code> 能在很多时候帮助代码变得更简洁，也能帮我们生成很多代码，免除重复写作相同代码，是一种很高效的编程方式。</p>\n<p>下一篇我会为 Android 的小伙伴介绍不少你可能不太知道但非常好用的 <code>Android Annotation</code>。</p>\n<p>谢谢。</p>\n<p>wingjay</p>\n<p><a href=\"http://wingjay.com\">http://wingjay.com</a></p>\n<p><img src=\"https://avatars0.githubusercontent.com/u/9619875?v=3&amp;s=460\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p><code>注解</code>这种语法本身很有意思，当前很多流行库如 <code>Dagger</code>、<code>ButterKnife</code>等都是基于注解这种语法。</p>\n<p>熟练使用<code>注解</code>，既能让你的代码变得简洁易读，动态运行时执行你想要的操作，还能帮你生成代码，省去重复代码写作。</p>\n<p>本文涉及知识点：注解的生命周期，代码编辑时注解，编译时注解代码生成，运行时注解动态反射。</p>\n</blockquote>","more":"<h2 id=\"注解的生命周期与修饰对象\"><a href=\"#注解的生命周期与修饰对象\" class=\"headerlink\" title=\"注解的生命周期与修饰对象\"></a>注解的生命周期与修饰对象</h2><p>对于 Java 代码从编写到运行有三个时期：代码编辑；编译成 <code>.class</code> 文件；读取到 JVM 运行。针对这三个时期有三种 <code>Annotation</code> 对应：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">RetentionPolicy.SOURCE  // 只在代码编辑期生效</div><div class=\"line\"></div><div class=\"line\">RetentionPolicy.CLASS  // 在编译期生效，默认值</div><div class=\"line\"></div><div class=\"line\">RetentionPolicy.RUNTIME // 在代码运行时生效</div></pre></td></tr></table></figure></p>\n<p>除了生命周期，我们还可以指定 <code>Annotation</code> 用来指定的对象，比如修饰方法、类、变量、参数等，例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Annotation </div><div class=\"line\">public void getName() &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">@Annotation </div><div class=\"line\">String name;</div><div class=\"line\"></div><div class=\"line\">public void setName(@Annotation String name) &#123;&#125;</div></pre></td></tr></table></figure></p>\n<p>Java 提供了 <code>@Target</code> 这个<code>元注解</code>来指定某个 <code>Annotation</code> 修饰的目标对象。</p>\n<p>例如 <code>@Override</code> 是用来修饰方法的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Target(ElementType.METHOD)</div><div class=\"line\">public @interface Override &#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>而 <code>@SuppressWarnings</code> 可以用来修饰很多，包括类、方法、变量等等。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</div><div class=\"line\">public @interface SuppressWarnings &#123;</div><div class=\"line\">    String[] value();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>下面我们依次来看看不同生命周期的三类 Annotation。</p>\n<h2 id=\"1-代码编辑时注解\"><a href=\"#1-代码编辑时注解\" class=\"headerlink\" title=\"1. 代码编辑时注解\"></a>1. 代码编辑时注解</h2><p>这种 Annotation 只存在于代码编辑阶段（RetentionPolicy.SOURCE），主要功能是让 IDE 来为开发者提供 warning 检查。这一类注解只会在编辑代码时生效，当编译器把 .java 文件编译成 .class 文件时会自动丢弃。</p>\n<p>比较常用的有 <code>SuppressWarnings</code>，<code>Override</code>。</p>\n<p><code>SuppressWarnings</code>是抑制编译器生成警告信息，比如我们调用了某个被标记为 <code>Deprecated</code> 的方法，这时编译器会发出警告，而我们又不得不使用这个方法时，就可以用<code>@SuppressWarnings</code>来抑制这个警告。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Retention(RetentionPolicy.SOURCE)</div><div class=\"line\">public @interface SuppressWarnings &#123;</div><div class=\"line\">    String[] value();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其作用如下图，<code>@SuppressWarnings(&quot;deprecation&quot;)</code> 可以把 <code>deprecation</code> 相关的警告给抑制掉。</p>\n<p><img src=\"/img/annotation/warning.png\" alt=\"warning\"><br><img src=\"/img/annotation/no-warning.png\" alt=\"no-warning\"></p>\n<p><code>Override</code>用来标记重写父类某个方法，万一不小心写错方法名或者父类该方法发生改动，IDE 就会发出警告。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Retention(RetentionPolicy.SOURCE)</div><div class=\"line\">public @interface Override &#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>当然，对于开发者而言，这一类的 Annotation 我们很少自定义，更重要的是学会使用。其实 Java 和 Android 里提供了非常多有用的静态检查的 Annotation，有助于提高代码的正确率，省去人工的代码检查，方便代码给他人使用。</p>\n<p>之后的文章我会具体介绍 Android 内部[<code>support-annotations</code>]很多有趣有用的 Annotation。</p>\n<h2 id=\"2-运行时注解\"><a href=\"#2-运行时注解\" class=\"headerlink\" title=\"2. 运行时注解\"></a>2. 运行时注解</h2><p>这一类注解是开发者广泛使用的。基本原理是利用<code>反射机制</code>在代码运行过程中动态地执行一些操作。关于 <code>反射机制</code> 我已经在之前的文章<a href=\"/2017/04/26/Java-技术之反射/\">Java 技术之反射</a>中细致阐述过了，不熟悉的读者可以去阅读。</p>\n<p>下面我们以两个例子来进行讲解。还是利用我们常用的 <code>UserBean</code> 对象为目标，对它内部的一些 <code>Annotation</code> 进行运行时处理。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class UserBean &#123;</div><div class=\"line\"></div><div class=\"line\">    @Alias(&quot;user_name&quot;)</div><div class=\"line\">    public String userName;</div><div class=\"line\"></div><div class=\"line\">    @Alias(&quot;user_id&quot;)</div><div class=\"line\">    private long userId;</div><div class=\"line\"></div><div class=\"line\">    public UserBean(String userName, long userId) &#123;</div><div class=\"line\">        this.userName = userName;</div><div class=\"line\">        this.userId = userId;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public String getName() &#123;</div><div class=\"line\">        return userName;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public long getId() &#123;</div><div class=\"line\">        return userId;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Test(value = &quot;static_method&quot;, id = 1)</div><div class=\"line\">    public static void staticMethod() &#123;</div><div class=\"line\">        System.out.printf(&quot;I&apos;m a static method\\n&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Test(value = &quot;public_method&quot;, id = 2)</div><div class=\"line\">    public void publicMethod() &#123;</div><div class=\"line\">        System.out.println(&quot;I&apos;m a public method\\n&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Test(value = &quot;private_method&quot;, id = 3)</div><div class=\"line\">    private void privateMethod() &#123;</div><div class=\"line\">        System.out.println(&quot;I&apos;m a private method\\n&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Test(id = 4)</div><div class=\"line\">    public void testFailure() &#123;</div><div class=\"line\">        throw new RuntimeException(&quot;Test failure&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这次我在 <code>UserBean</code> 里面创建了两个自定义的 <code>Annotation</code>: <code>Alias</code> 和 <code>Test</code>，前者是用来设置变量的别名并在运行时打印，后者是调用所有被<code>Test</code>标记的方法，得出测试通过率。当然，这两个功能目前完全没有实现，只是标记了一下而已。下面我们依次来实现这两个Annotation的功能。</p>\n<h4 id=\"Alias-功能实现：设置变量别名并在运行时打印别名\"><a href=\"#Alias-功能实现：设置变量别名并在运行时打印别名\" class=\"headerlink\" title=\"Alias 功能实现：设置变量别名并在运行时打印别名\"></a>Alias 功能实现：设置变量别名并在运行时打印别名</h4><p>首先，我们要创建 <code>Alias</code> 这个注解。那么要明确三个方面：</p>\n<ul>\n<li>生命周期是什么？</li>\n<li>针对的目标是什么类型？</li>\n<li>内部是否有参数？</li>\n</ul>\n<p>针对 <code>Alias</code> 的功能，我们可以作如下回答：</p>\n<ul>\n<li>生命周期是<code>运行时</code>，因为要动态打印出变量的别名 -&gt; @Retention(RetentionPolicy.RUNTIME)</li>\n<li>针对的目标是 <code>变量</code> -&gt; @Target(ElementType.FIELD)</li>\n<li>内部需要维护一个 String 型的变量来保存别名 -&gt; String value();</li>\n</ul>\n<p>因此可以得到<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Target(ElementType.FIELD)</div><div class=\"line\">@Retention(RetentionPolicy.RUNTIME)</div><div class=\"line\">public @interface Alias &#123;</div><div class=\"line\">    String value();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>Alias</code> 定义得到了，接下来我们要实现它的功能了，即在运行时取出变量的别名并打印。</p>\n<p>代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * print alias during runtime</div><div class=\"line\"> */</div><div class=\"line\">private static void printAlias(Object userBeanObject) &#123;</div><div class=\"line\">    for (Field field : userBeanObject.getClass().getDeclaredFields()) &#123;</div><div class=\"line\">        if (field.isAnnotationPresent(Alias.class)) &#123;</div><div class=\"line\">            Alias alias = field.getAnnotation(Alias.class);</div><div class=\"line\">            System.out.println(alias.value());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>过程很简单，利用反射机制，把 <code>userBeanObject</code> 对应 Class 里所有的成员变量都找到，找出其中被 <code>Alias</code> 修饰的成员变量，然后把真实注解 <code>Alias</code> 对象取出来，把内部的 <code>value</code> 打印出来即可。 </p>\n<h4 id=\"Test功能实现：调用所有被Test标记的方法，得出测试通过率\"><a href=\"#Test功能实现：调用所有被Test标记的方法，得出测试通过率\" class=\"headerlink\" title=\"Test功能实现：调用所有被Test标记的方法，得出测试通过率\"></a><code>Test</code>功能实现：调用所有被<code>Test</code>标记的方法，得出测试通过率</h4><p>同样我们要回答上面三个问题：生命周期，针对对象类型和内部参数，回答是：</p>\n<ul>\n<li>生命周期：由于是<code>动态运行时</code>去遍历这些 <code>Test</code> 的存在，因此是 <code>RUNTIME</code>;</li>\n<li>针对对象类型：因为是修饰<code>方法</code>的，因此是 <code>@Target(ElementType.METHOD)</code>;</li>\n<li>内部参数：由于需要记录方法的<code>名称</code>和对应的<code>id</code>，因此需要 <code>String value();</code> <code>int id;</code></li>\n</ul>\n<p>得到如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Target(ElementType.METHOD)</div><div class=\"line\">@Retention(RetentionPolicy.RUNTIME)</div><div class=\"line\">public @interface Test &#123;</div><div class=\"line\">    String value() default &quot;&quot;; // 如果没有设置，那么直接取函数方法名</div><div class=\"line\">    int id();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>接下来我们需要找到所有被 <code>@Test</code> 修饰的方法，并逐一调用。注意两点：</p>\n<ol>\n<li>就算是 <code>private</code> 和 <code>static</code> 修饰的方法也需要调用；</li>\n<li>在执行每个方法前后都要打印相关log，表示开始测试该方法。打印的内容要含有 <code>value</code> 和 <code>id</code>， 如果 <code>@Test</code> 里的 <code>value</code> 没有设置值，那么就取函数名为值。</li>\n</ol>\n<p>可以看出，在 <code>UserBean</code> 里已经定义好了三个被 <code>@Test</code> 修饰的方法了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Test(value = &quot;static_method&quot;, id = 1)</div><div class=\"line\">public static void staticMethod() &#123;</div><div class=\"line\">    System.out.printf(&quot;I&apos;m a static method\\n&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@Test(value = &quot;public_method&quot;, id = 2)</div><div class=\"line\">public void publicMethod() &#123;</div><div class=\"line\">    System.out.println(&quot;I&apos;m a public method\\n&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@Test(value = &quot;private_method&quot;, id = 3)</div><div class=\"line\">private void privateMethod() &#123;</div><div class=\"line\">    System.out.println(&quot;I&apos;m a private method\\n&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@Test(id = 4)</div><div class=\"line\">public void testFailure() &#123;</div><div class=\"line\">    throw new RuntimeException(&quot;Test failure&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>接下来我们实现 <code>@Test</code> 的具体功能：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Test methods which are be annotated with @Test</div><div class=\"line\"> */</div><div class=\"line\">private static void doTest(Object object) &#123;</div><div class=\"line\">    Method[] methods = object.getClass().getDeclaredMethods();</div><div class=\"line\">    for (Method method : methods) &#123;</div><div class=\"line\">        if (method.isAnnotationPresent(Test.class)) &#123;</div><div class=\"line\">            Test test = method.getAnnotation(Test.class);</div><div class=\"line\">            try &#123;</div><div class=\"line\">                String methodName = test.value().length() == 0 ? method.getName() : test.value(); // if test.value() is empty, use `method.getName()`</div><div class=\"line\">                System.out.printf(&quot;Testing. methodName: %s, id: %s\\n&quot;, methodName, test.id());</div><div class=\"line\"></div><div class=\"line\">                if (Modifier.isStatic(method.getModifiers())) &#123;</div><div class=\"line\">                    method.invoke(null); // static method</div><div class=\"line\">                &#125; else if (Modifier.isPrivate(method.getModifiers())) &#123;</div><div class=\"line\">                    method.setAccessible(true);  // private method</div><div class=\"line\">                    method.invoke(object);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    method.invoke(object);  // public method</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                System.out.printf(&quot;PASS: Method id: %s\\n&quot;, test.id());</div><div class=\"line\">            &#125; catch (Exception e) &#123;</div><div class=\"line\">                System.out.printf(&quot;FAIL: Method id: %s\\n&quot;, test.id());</div><div class=\"line\">                e.printStackTrace();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>打印结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">Testing. methodName: static_method, id: 1</div><div class=\"line\">I&apos;m a static method</div><div class=\"line\">PASS: Method id: 1</div><div class=\"line\"></div><div class=\"line\">Testing. methodName: public_method, id: 2</div><div class=\"line\">I&apos;m a public method</div><div class=\"line\">PASS: Method id: 2</div><div class=\"line\"></div><div class=\"line\">Testing. methodName: private_method, id: 3</div><div class=\"line\">I&apos;m a private method</div><div class=\"line\">PASS: Method id: 3</div><div class=\"line\"></div><div class=\"line\">Testing. methodName: testFailure, id: 4</div><div class=\"line\">FAIL: Method id: 4</div></pre></td></tr></table></figure>\n<p>全部正常打印。其中，由于 <code>testFailure()</code> 的 <code>@Test</code> 里未设置 <code>value()</code>，因此直接打印了它的函数名；针对<code>static</code>方法，直接调用<code>method.invoke(null)</code>；针对<code>private</code>，利用<code>method.setAccessible(true);</code>获取了权限。</p>\n<p>当然这里有一点要注意，我在 <code>invoke method</code> 时，直接使用 <code>method.invoke(object);</code>，没有传任何参数。这是由于我在 <code>UserBean</code> 里写的几个方法都不用传参数。如果需要传参数的话，那就还需要再单独判断是哪个函数，并传递对应的参数进去。</p>\n<h2 id=\"3-编译时注解\"><a href=\"#3-编译时注解\" class=\"headerlink\" title=\"3. 编译时注解\"></a>3. 编译时注解</h2><p>当 .java 文件写好了准备进行编译时，我们有另一种 Annotation 可以在这时发挥效果。</p>\n<p>我们知道，Java 源代码编译的过程会对所有的文件进行扫描，而<code>编译时 Annotation</code> 的作用就是<code>在编译过程中生成代码</code>。在 Java 里提供了 apt 工具来处理注解，同时有一套 Mirror API 来描述编译时的程序语义结构，它可以在编译时获取到被注解 Java 元素的信息以方便我们处理。该处理过程的核心是编写注解处理器 <code>AnnotationProcessor</code> 接口。</p>\n<p>大概说明下整体的过程。</p>\n<p>假设我们希望用某个 <code>Annotation</code>：<code>@Inject</code> 来生成一些代码，那么我们要做下面几步：</p>\n<h5 id=\"定义-Inject\"><a href=\"#定义-Inject\" class=\"headerlink\" title=\"定义 @Inject\"></a>定义 @Inject</h5><p>由于它是编译时注解，因此是 <code>RetentionPolicy.CLASS</code>，对象的话就是变量和构造函数，因此得到：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Retention(RetentionPolicy.CLASS)</div><div class=\"line\">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.FIELD&#125;)</div><div class=\"line\">public @interface Inject &#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h5 id=\"定义-Processor-类\"><a href=\"#定义-Processor-类\" class=\"headerlink\" title=\"定义 Processor 类\"></a>定义 Processor 类</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Helper to define the Processor</div><div class=\"line\">@AutoService(Processor.class)</div><div class=\"line\">// Define the supported Java source code version</div><div class=\"line\">@SupportedSourceVersion(SourceVersion.RELEASE_7)</div><div class=\"line\">// Define which annotation you want to process</div><div class=\"line\">@SupportedAnnotationTypes(&quot;com.wingjay.annotation.Inject&quot;)</div><div class=\"line\">public class MyProcessor extends AbstractProcessor &#123;  ...  &#125;</div></pre></td></tr></table></figure>\n<h5 id=\"重写-Processor-内部的-process-方法\"><a href=\"#重写-Processor-内部的-process-方法\" class=\"headerlink\" title=\"重写 Processor 内部的 process 方法\"></a>重写 <code>Processor</code> 内部的 <code>process</code> 方法</h5><p>这个 <code>process</code> 方法会在编译时被执行到，我们可以在这个方法里进行代码生成的工作。</p>\n<p>关于具体的代码生成部分，可以利用 <code>Square</code> 提供的 <code>JavaPoet</code> 工具：<a href=\"https://github.com/square/javapoet\" target=\"_blank\" rel=\"external\">https://github.com/square/javapoet</a></p>\n<p>下面有一些代码片段供参考：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123;</div><div class=\"line\">\t//扫描所有 Inject 标记过的元素</div><div class=\"line\">    Set&lt;? extends Element&gt; elements = roundEnv.getElementsAnnotatedWith(Inject.class);</div><div class=\"line\">    Set&lt;? extends TypeElement&gt; typeElements = ElementFilter.typesIn(elements);</div><div class=\"line\">    for (TypeElement element : typeElements) &#123;</div><div class=\"line\"></div><div class=\"line\">    \t// 拼接待生成代码</div><div class=\"line\">    \tClassName currentType = ClassName.get(element);</div><div class=\"line\">      \tMethodSpec.Builder builder = MethodSpec.methodBuilder(&quot;fromCursor&quot;)</div><div class=\"line\">\t       .returns(currentType)</div><div class=\"line\">\t       .addModifiers(Modifier.STATIC)</div><div class=\"line\">\t       .addModifiers(Modifier.PUBLIC)</div><div class=\"line\">\t       .addParameter(ClassName.get(&quot;android.database&quot;, &quot;Cursor&quot;), &quot;cursor&quot;);</div><div class=\"line\"></div><div class=\"line\">\t    // 将这些拼接代码写入文件</div><div class=\"line\">        String className = ... // 设置你要生成的代码class名字</div><div class=\"line\">        JavaFileObject sourceFile =   processingEnv.getFiler().createSourceFile(className, element);</div><div class=\"line\">        Writer writer = sourceFile.openWriter();</div><div class=\"line\">        javaFile.writeTo(writer);</div><div class=\"line\">        writer.close();  </div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>本文在前文<a href=\"/2017/04/26/Java-技术之反射/\">Java 技术之反射</a>的基础上，对 Java 的注解 <code>Annotation</code> 做了一定的介绍。</p>\n<p>熟练使用 <code>Annotation</code> 能在很多时候帮助代码变得更简洁，也能帮我们生成很多代码，免除重复写作相同代码，是一种很高效的编程方式。</p>\n<p>下一篇我会为 Android 的小伙伴介绍不少你可能不太知道但非常好用的 <code>Android Annotation</code>。</p>\n<p>谢谢。</p>\n<p>wingjay</p>\n<p><a href=\"http://wingjay.com\">http://wingjay.com</a></p>\n<p><img src=\"https://avatars0.githubusercontent.com/u/9619875?v=3&amp;s=460\" alt=\"\"></p>","sticky":0},{"title":"Java 技术之垃圾回收机制","date":"2017-05-24T13:19:26.000Z","commentIssueId":2,"_content":"\n>垃圾回收机制是 Java 非常重要的特性之一，也是面试题的常客。它让开发者无需关注空间的创建和释放，而是以守护进程的形式在后台自动回收垃圾。这样做不仅提高了开发效率，更改善了内存的使用状况。\n\n>今天本文来对垃圾回收机制进行讲解，主要涉及下面几个问题：\n- 什么是堆内存？\n- 什么是垃圾？\n- 有哪些方法回收这些垃圾？\n- 什么是分代回收机制？\n\n<!-- more -->\n\n## 什么是 Java 堆内存\n堆是在 JVM 启动时创建的，主要用来维护运行时数据，如运行过程中创建的对象和数组都是基于这块内存空间。Java 堆是非常重要的元素，如果我们动态创建的对象没有得到及时回收，持续堆积，最后会导致堆空间被占满，内存溢出。\n\n因此，Java 提供了一种垃圾回收机制，在后台创建一个守护进程。该进程会在内存紧张的时候自动跳出来，把堆空间的垃圾全部进行回收，从而保证程序的正常运行。\n\n## 那什么是垃圾呢？\n所谓“垃圾”，就是指所有不再存活的对象。常见的判断是否存活有两种方法：引用计数法和可达性分析。\n\n### 引用计数法\n为每一个创建的对象分配一个引用计数器，用来存储该对象被引用的个数。当该个数为零，意味着没有人再使用这个对象，可以认为“对象死亡”。但是，这种方案存在严重的问题，就是无法检测“循环引用”：当两个对象互相引用，即时它俩都不被外界任何东西引用，它俩的计数都不为零，因此永远不会被回收。而实际上对于开发者而言，这两个对象已经完全没有用处了。\n\n因此，Java 里没有采用这样的方案来判定对象的“存活性”。\n\n### 可达性分析\n这种方案是目前主流语言里采用的对象存活性判断方案。基本思路是把所有引用的对象想象成一棵树，从树的根结点 GC Roots 出发，持续遍历找出所有连接的树枝对象，这些对象则被称为“可达”对象，或称“存活”对象。其余的对象则被视为“死亡”的“不可达”对象，或称“垃圾”。\n\n参考下图，object5,object6和object7便是不可达对象，视为“死亡状态”，应该被垃圾回收器回收。\n\n![](/img/gc/reachable.JPG)\n\n#### GC Roots 究竟指谁呢？\n我们可以猜测，GC Roots 本身一定是可达的，这样从它们出发遍历到的对象才能保证一定可达。那么，Java 里有哪些对象是一定可达呢？主要有以下四种：\n- 虚拟机栈（帧栈中的本地变量表）中引用的对象。\n- 方法区中静态属性引用的对象。\n- 方法区中常量引用的对象。\n- 本地方法栈中JNI引用的对象。\n\n不少读者可能对这些 GC Roots 似懂非懂，这涉及到 JVM 本身的内存结构等等，未来的文章会再做深入讲解。这里只要知道有这么几种类型的 GC Roots，每次垃圾回收器会从这些根结点开始遍历寻找所有可达节点。\n\n## 有哪些方式来回收这些垃圾呢？\n上面已经知道，所有GC Roots不可达的对象都称为垃圾，参考下图，黑色的表示垃圾，灰色表示存活对象，绿色表示空白空间。\n\n![](/img/gc/garbage.png)\n\n那么，我们如何来回收这些垃圾呢？\n\n#### 标记－清理\n第一步，所谓“标记”就是利用可达性遍历堆内存，把“存活”对象和“垃圾”对象进行标记，得到的结果如上图；\n第二步，既然“垃圾”已经标记好了，那我们再遍历一遍，把所有“垃圾”对象所占的空间直接`清空`即可。\n\n结果如下：\n![](/img/gc/mark-sweep.png)\n\n这便是`标记－清理`方案，`简单方便`，但是容易产生`内存碎片`。\n\n#### 标记－整理\n既然上面的方法会产生内存碎片，那好，我在清理的时候，把所有`存活`对象扎堆到同一个地方，让它们待在一起，这样就没有内存碎片了。\n\n结果如下：\n![](/img/gc/mark-compact.png)\n\n这两种方案适合`存活对象多，垃圾少`的情况，它只需要清理掉少量的垃圾，然后挪动下存活对象就可以了。\n\n#### 复制\n这种方法比较粗暴，直接把堆内存分成两部分，一段时间内只允许在其中一块内存上进行分配，当这块内存被分配完后，则执行垃圾回收，把所有`存活`对象全部复制到另一块内存上，当前内存则直接全部清空。\n\n参考下图：\n![](/img/gc/copying.png)\n\n起初时只使用上面部分的内存，直到内存使用完毕，才进行垃圾回收，把所有存活对象搬到下半部分，并把上半部分进行清空。\n\n这种做法不容易产生碎片，也简单粗暴；但是，它意味着你在一段时间内只能使用一部分的内存，超过这部分内存的话就意味着堆内存里频繁的`复制清空`。\n\n这种方案适合`存活对象少，垃圾多`的情况，这样在复制时就不需要复制多少对象过去，多数垃圾直接被清空处理。\n\n## Java 的分代回收机制\n上面我们看到有至少三种方法来回收内存，那么 Java 里是如何选择利用这三种回收算法呢？是只用一种还是三种都用呢？\n\n### Java 的堆结构\n在选择回收算法前，我们先来看一下 Java 堆的结构。\n\n一块 Java 堆空间一般分成三部分，这三部分用来存储三类数据：\n- 刚刚创建的对象。在代码运行时会持续不断地创造新的对象，这些新创建的对象会被统一放在一起。因为有很多局部变量等在新创建后很快会变成`不可达`的对象，`快速死去`，因此这块区域的特点是`存活对象少，垃圾多`。形象点描述这块区域为：`新生代`；\n- 存活了一段时间的对象。这些对象早早就被创建了，而且一直活了下来。我们把这些`存活时间较长`的对象放在一起，它们的特点是`存活对象多，垃圾少`。形象点描述这块区域为：`老年代`；\n- 永久存在的对象。比如一些静态文件，这些对象的特点是不需要垃圾回收，永远存活。形象点描述这块区域为：`永久代`。（不过在 Java 8 里已经把`永久代`删除了，把这块内存空间给了`元空间`，后续文章再讲解。）\n\n也就是说，常规的 Java 堆至少包括了 `新生代` 和 `老年代` 两块内存区域，而且这两块区域有很明显的特征：\n- 新生代：存活对象少、垃圾多\n- 老年代：存活对象多、垃圾少\n\n\n结合新生代／老年代的存活对象特点和之前提过的几种垃圾回收算法，可以得到如下的回收方案：\n### 新生代－`复制`回收机制\n对于新生代区域，由于每次 GC 都会有大量新对象死去，只有少量存活。因此采用`复制`回收算法，GC 时把少量的存活对象复制过去即可。\n\n那么如何设计这个`复制`算法比较好呢？有以下几种方式：\n\n##### 思路1. 把内存均分成 `1:1` 两等份\n如下图拆分内存。\n![](/img/gc/young_1.png)\n\n每次只使用一半的内存，当这一半满了后，就进行垃圾回收，把存活的对象直接复制到另一半内存，并清空当前一半的内存。\n\n这种分法的缺陷是相当于只有一半的可用内存，对于新生代而言，新对象持续不断地被创建，如果只有一半可用内存，那显然要持续不断地进行垃圾回收工作，反而影响到了正常程序的运行，得不偿失。\n\n##### 思路2. 把内存按 `9:1` 分\n既然上面的分法导致可用内存只剩一半，那么我做些调整，把 `1:1`变成`9:1`，\n![](/img/gc/young_2.png)\n\n最开始在 `9` 的内存区使用，当 `9` 快要满时，执行复制回收，把 `9` 内仍然存活的对象复制到 `1` 区，并清空 `9` 区。\n\n这样看起来是比上面的方法好了，但是它存在比较严重的问题。\n\n当我们把 `9` 区存活对象复制到 `1` 区时，由于内存空间比例相差比较大，所以很有可能 `1` 区放不满，此时就不得不把对象移到 `老年区`。而这就意味着，可能会有一部分 `并不老` 的 `9` 区对象由于 `1` 区放不下了而被放到了 `老年区`，可想而知，这破坏了 `老年区` 的规则。或者说，一定程度上的 `老年区` 并不一定全是 `老年对象`。\n\n那应该如何才能把真正比较 `老` 的对象挪到 `老年区` 呢？ \n\n##### 思路3. 把内存按 `8:1:1` 分\n![](/img/gc/young_3.png)\n\n既然 `9:1` 有可能把年轻对象放到 `老年区`，那就换成 `8:1:1`，依次取名为 `Eden`、`Survivor A`、`Survivor B`区，其中`Eden`意为伊甸园，形容有很多新生对象在里面创建；`Survivor`区则为幸存者，即经历 GC 后仍然存活下来的对象。\n\n工作原理如下：\n1. 首先，`Eden`区最大，对外提供堆内存。当 `Eden` 区快要满了，则进行 `Minor GC`，把存活对象放入`Survivor A`区，清空 `Eden` 区；\n2. `Eden`区被清空后，继续对外提供堆内存；\n3. 当`Eden`区再次被填满，此时对`Eden`区和`Survivor A`区同时进行 `Minor GC`，把存活对象放入`Survivor B`区，同时清空`Eden` 区和`Survivor A`区；\n4. `Eden`区继续对外提供堆内存，并重复上述过程，即在`Eden`区填满后，把`Eden`区和某个`Survivor`区的存活对象放到另一个`Survivor`区；\n5. 当某个`Survivor`区被填满，且仍有对象未被复制完毕时，或者某些对象在反复`Survive` `15` 次左右时，则把这部分剩余对象放到`Old`区；\n6. 当 `Old` 区也被填满时，进行 `Major GC`，对 `Old` 区进行垃圾回收。\n\n[注意，在真实的 JVM 环境里，可以通过参数 `SurvivorRatio` 手动配置`Eden`区和单个`Survivor`区的比例，默认为8。]\n\n那么，所谓的 `Old` 区垃圾回收，或称`Major GC`，应该如何执行呢？\n\n### 老年代－`标记整理`回收机制\n根据上面我们知道，老年代一般存放的是存活时间较久的对象，所以每一次 GC 时，存活对象比较较大，也就是说每次只有少部分对象被回收。\n\n因此，根据不同回收机制的特点，这里选择`存活对象多，垃圾少`的`标记整理`回收机制，仅仅通过少量地移动对象就能清理垃圾，而且不存在内存碎片化。\n\n至此，我们已经了解了 Java 堆内存的分代原理，并了解了不同代根据各自特点采用了不同的回收机制，即`新生代`采用`回收`机制，`老年代`采用`标记整理`机制。\n\n\n## 小结\n垃圾回收是 Java 非常重要的特性，也是高级 Java 工程师的必经之路。\n\n如有问题欢迎与我联系。\n\n谢谢。\n\nwingjay\n\nhttp://wingjay.com\n\n\n\n参考文章：\n- 《[理解Java垃圾回收机制](http://jayfeng.com/2016/03/11/%E7%90%86%E8%A7%A3Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/)》\n- 《[JVM 的 工作原理，层次结构 以及 GC工作原理](https://segmentfault.com/a/1190000002579346#articleHeader6)》\n- 《[深入理解Java虚拟机笔记二（垃圾收集器与内存分配策略）](http://howiefh.github.io/2015/04/08/jvm-note-2/)》\n\n","source":"_posts/Java-技术之垃圾回收机制.md","raw":"title: Java 技术之垃圾回收机制\ndate: 2017-05-24 21:19:26\ncategories:\n  - 深入理解Java技术\ntags: Java\ncommentIssueId: 2\n---\n\n>垃圾回收机制是 Java 非常重要的特性之一，也是面试题的常客。它让开发者无需关注空间的创建和释放，而是以守护进程的形式在后台自动回收垃圾。这样做不仅提高了开发效率，更改善了内存的使用状况。\n\n>今天本文来对垃圾回收机制进行讲解，主要涉及下面几个问题：\n- 什么是堆内存？\n- 什么是垃圾？\n- 有哪些方法回收这些垃圾？\n- 什么是分代回收机制？\n\n<!-- more -->\n\n## 什么是 Java 堆内存\n堆是在 JVM 启动时创建的，主要用来维护运行时数据，如运行过程中创建的对象和数组都是基于这块内存空间。Java 堆是非常重要的元素，如果我们动态创建的对象没有得到及时回收，持续堆积，最后会导致堆空间被占满，内存溢出。\n\n因此，Java 提供了一种垃圾回收机制，在后台创建一个守护进程。该进程会在内存紧张的时候自动跳出来，把堆空间的垃圾全部进行回收，从而保证程序的正常运行。\n\n## 那什么是垃圾呢？\n所谓“垃圾”，就是指所有不再存活的对象。常见的判断是否存活有两种方法：引用计数法和可达性分析。\n\n### 引用计数法\n为每一个创建的对象分配一个引用计数器，用来存储该对象被引用的个数。当该个数为零，意味着没有人再使用这个对象，可以认为“对象死亡”。但是，这种方案存在严重的问题，就是无法检测“循环引用”：当两个对象互相引用，即时它俩都不被外界任何东西引用，它俩的计数都不为零，因此永远不会被回收。而实际上对于开发者而言，这两个对象已经完全没有用处了。\n\n因此，Java 里没有采用这样的方案来判定对象的“存活性”。\n\n### 可达性分析\n这种方案是目前主流语言里采用的对象存活性判断方案。基本思路是把所有引用的对象想象成一棵树，从树的根结点 GC Roots 出发，持续遍历找出所有连接的树枝对象，这些对象则被称为“可达”对象，或称“存活”对象。其余的对象则被视为“死亡”的“不可达”对象，或称“垃圾”。\n\n参考下图，object5,object6和object7便是不可达对象，视为“死亡状态”，应该被垃圾回收器回收。\n\n![](/img/gc/reachable.JPG)\n\n#### GC Roots 究竟指谁呢？\n我们可以猜测，GC Roots 本身一定是可达的，这样从它们出发遍历到的对象才能保证一定可达。那么，Java 里有哪些对象是一定可达呢？主要有以下四种：\n- 虚拟机栈（帧栈中的本地变量表）中引用的对象。\n- 方法区中静态属性引用的对象。\n- 方法区中常量引用的对象。\n- 本地方法栈中JNI引用的对象。\n\n不少读者可能对这些 GC Roots 似懂非懂，这涉及到 JVM 本身的内存结构等等，未来的文章会再做深入讲解。这里只要知道有这么几种类型的 GC Roots，每次垃圾回收器会从这些根结点开始遍历寻找所有可达节点。\n\n## 有哪些方式来回收这些垃圾呢？\n上面已经知道，所有GC Roots不可达的对象都称为垃圾，参考下图，黑色的表示垃圾，灰色表示存活对象，绿色表示空白空间。\n\n![](/img/gc/garbage.png)\n\n那么，我们如何来回收这些垃圾呢？\n\n#### 标记－清理\n第一步，所谓“标记”就是利用可达性遍历堆内存，把“存活”对象和“垃圾”对象进行标记，得到的结果如上图；\n第二步，既然“垃圾”已经标记好了，那我们再遍历一遍，把所有“垃圾”对象所占的空间直接`清空`即可。\n\n结果如下：\n![](/img/gc/mark-sweep.png)\n\n这便是`标记－清理`方案，`简单方便`，但是容易产生`内存碎片`。\n\n#### 标记－整理\n既然上面的方法会产生内存碎片，那好，我在清理的时候，把所有`存活`对象扎堆到同一个地方，让它们待在一起，这样就没有内存碎片了。\n\n结果如下：\n![](/img/gc/mark-compact.png)\n\n这两种方案适合`存活对象多，垃圾少`的情况，它只需要清理掉少量的垃圾，然后挪动下存活对象就可以了。\n\n#### 复制\n这种方法比较粗暴，直接把堆内存分成两部分，一段时间内只允许在其中一块内存上进行分配，当这块内存被分配完后，则执行垃圾回收，把所有`存活`对象全部复制到另一块内存上，当前内存则直接全部清空。\n\n参考下图：\n![](/img/gc/copying.png)\n\n起初时只使用上面部分的内存，直到内存使用完毕，才进行垃圾回收，把所有存活对象搬到下半部分，并把上半部分进行清空。\n\n这种做法不容易产生碎片，也简单粗暴；但是，它意味着你在一段时间内只能使用一部分的内存，超过这部分内存的话就意味着堆内存里频繁的`复制清空`。\n\n这种方案适合`存活对象少，垃圾多`的情况，这样在复制时就不需要复制多少对象过去，多数垃圾直接被清空处理。\n\n## Java 的分代回收机制\n上面我们看到有至少三种方法来回收内存，那么 Java 里是如何选择利用这三种回收算法呢？是只用一种还是三种都用呢？\n\n### Java 的堆结构\n在选择回收算法前，我们先来看一下 Java 堆的结构。\n\n一块 Java 堆空间一般分成三部分，这三部分用来存储三类数据：\n- 刚刚创建的对象。在代码运行时会持续不断地创造新的对象，这些新创建的对象会被统一放在一起。因为有很多局部变量等在新创建后很快会变成`不可达`的对象，`快速死去`，因此这块区域的特点是`存活对象少，垃圾多`。形象点描述这块区域为：`新生代`；\n- 存活了一段时间的对象。这些对象早早就被创建了，而且一直活了下来。我们把这些`存活时间较长`的对象放在一起，它们的特点是`存活对象多，垃圾少`。形象点描述这块区域为：`老年代`；\n- 永久存在的对象。比如一些静态文件，这些对象的特点是不需要垃圾回收，永远存活。形象点描述这块区域为：`永久代`。（不过在 Java 8 里已经把`永久代`删除了，把这块内存空间给了`元空间`，后续文章再讲解。）\n\n也就是说，常规的 Java 堆至少包括了 `新生代` 和 `老年代` 两块内存区域，而且这两块区域有很明显的特征：\n- 新生代：存活对象少、垃圾多\n- 老年代：存活对象多、垃圾少\n\n\n结合新生代／老年代的存活对象特点和之前提过的几种垃圾回收算法，可以得到如下的回收方案：\n### 新生代－`复制`回收机制\n对于新生代区域，由于每次 GC 都会有大量新对象死去，只有少量存活。因此采用`复制`回收算法，GC 时把少量的存活对象复制过去即可。\n\n那么如何设计这个`复制`算法比较好呢？有以下几种方式：\n\n##### 思路1. 把内存均分成 `1:1` 两等份\n如下图拆分内存。\n![](/img/gc/young_1.png)\n\n每次只使用一半的内存，当这一半满了后，就进行垃圾回收，把存活的对象直接复制到另一半内存，并清空当前一半的内存。\n\n这种分法的缺陷是相当于只有一半的可用内存，对于新生代而言，新对象持续不断地被创建，如果只有一半可用内存，那显然要持续不断地进行垃圾回收工作，反而影响到了正常程序的运行，得不偿失。\n\n##### 思路2. 把内存按 `9:1` 分\n既然上面的分法导致可用内存只剩一半，那么我做些调整，把 `1:1`变成`9:1`，\n![](/img/gc/young_2.png)\n\n最开始在 `9` 的内存区使用，当 `9` 快要满时，执行复制回收，把 `9` 内仍然存活的对象复制到 `1` 区，并清空 `9` 区。\n\n这样看起来是比上面的方法好了，但是它存在比较严重的问题。\n\n当我们把 `9` 区存活对象复制到 `1` 区时，由于内存空间比例相差比较大，所以很有可能 `1` 区放不满，此时就不得不把对象移到 `老年区`。而这就意味着，可能会有一部分 `并不老` 的 `9` 区对象由于 `1` 区放不下了而被放到了 `老年区`，可想而知，这破坏了 `老年区` 的规则。或者说，一定程度上的 `老年区` 并不一定全是 `老年对象`。\n\n那应该如何才能把真正比较 `老` 的对象挪到 `老年区` 呢？ \n\n##### 思路3. 把内存按 `8:1:1` 分\n![](/img/gc/young_3.png)\n\n既然 `9:1` 有可能把年轻对象放到 `老年区`，那就换成 `8:1:1`，依次取名为 `Eden`、`Survivor A`、`Survivor B`区，其中`Eden`意为伊甸园，形容有很多新生对象在里面创建；`Survivor`区则为幸存者，即经历 GC 后仍然存活下来的对象。\n\n工作原理如下：\n1. 首先，`Eden`区最大，对外提供堆内存。当 `Eden` 区快要满了，则进行 `Minor GC`，把存活对象放入`Survivor A`区，清空 `Eden` 区；\n2. `Eden`区被清空后，继续对外提供堆内存；\n3. 当`Eden`区再次被填满，此时对`Eden`区和`Survivor A`区同时进行 `Minor GC`，把存活对象放入`Survivor B`区，同时清空`Eden` 区和`Survivor A`区；\n4. `Eden`区继续对外提供堆内存，并重复上述过程，即在`Eden`区填满后，把`Eden`区和某个`Survivor`区的存活对象放到另一个`Survivor`区；\n5. 当某个`Survivor`区被填满，且仍有对象未被复制完毕时，或者某些对象在反复`Survive` `15` 次左右时，则把这部分剩余对象放到`Old`区；\n6. 当 `Old` 区也被填满时，进行 `Major GC`，对 `Old` 区进行垃圾回收。\n\n[注意，在真实的 JVM 环境里，可以通过参数 `SurvivorRatio` 手动配置`Eden`区和单个`Survivor`区的比例，默认为8。]\n\n那么，所谓的 `Old` 区垃圾回收，或称`Major GC`，应该如何执行呢？\n\n### 老年代－`标记整理`回收机制\n根据上面我们知道，老年代一般存放的是存活时间较久的对象，所以每一次 GC 时，存活对象比较较大，也就是说每次只有少部分对象被回收。\n\n因此，根据不同回收机制的特点，这里选择`存活对象多，垃圾少`的`标记整理`回收机制，仅仅通过少量地移动对象就能清理垃圾，而且不存在内存碎片化。\n\n至此，我们已经了解了 Java 堆内存的分代原理，并了解了不同代根据各自特点采用了不同的回收机制，即`新生代`采用`回收`机制，`老年代`采用`标记整理`机制。\n\n\n## 小结\n垃圾回收是 Java 非常重要的特性，也是高级 Java 工程师的必经之路。\n\n如有问题欢迎与我联系。\n\n谢谢。\n\nwingjay\n\nhttp://wingjay.com\n\n\n\n参考文章：\n- 《[理解Java垃圾回收机制](http://jayfeng.com/2016/03/11/%E7%90%86%E8%A7%A3Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/)》\n- 《[JVM 的 工作原理，层次结构 以及 GC工作原理](https://segmentfault.com/a/1190000002579346#articleHeader6)》\n- 《[深入理解Java虚拟机笔记二（垃圾收集器与内存分配策略）](http://howiefh.github.io/2015/04/08/jvm-note-2/)》\n\n","slug":"Java-技术之垃圾回收机制","published":1,"updated":"2018-11-26T06:56:27.480Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplshx002a3dn88yfg2mv7","content":"<blockquote>\n<p>垃圾回收机制是 Java 非常重要的特性之一，也是面试题的常客。它让开发者无需关注空间的创建和释放，而是以守护进程的形式在后台自动回收垃圾。这样做不仅提高了开发效率，更改善了内存的使用状况。</p>\n<p>今天本文来对垃圾回收机制进行讲解，主要涉及下面几个问题：</p>\n<ul>\n<li>什么是堆内存？</li>\n<li>什么是垃圾？</li>\n<li>有哪些方法回收这些垃圾？</li>\n<li>什么是分代回收机制？</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"什么是 -Java- 堆内存\"><a href=\"# 什么是 -Java- 堆内存\" class=\"headerlink\" title=\"什么是 Java 堆内存\"></a>什么是 Java 堆内存 </h2><p> 堆是在 JVM 启动时创建的，主要用来维护运行时数据，如运行过程中创建的对象和数组都是基于这块内存空间。Java 堆是非常重要的元素，如果我们动态创建的对象没有得到及时回收，持续堆积，最后会导致堆空间被占满，内存溢出。</p>\n<p>因此，Java 提供了一种垃圾回收机制，在后台创建一个守护进程。该进程会在内存紧张的时候自动跳出来，把堆空间的垃圾全部进行回收，从而保证程序的正常运行。</p>\n<h2 id=\"那什么是垃圾呢？\"><a href=\"# 那什么是垃圾呢？\" class=\"headerlink\" title=\"那什么是垃圾呢？\"></a>那什么是垃圾呢？</h2><p>所谓“垃圾”，就是指所有不再存活的对象。常见的判断是否存活有两种方法：引用计数法和可达性分析。</p>\n<h3 id=\"引用计数法\"><a href=\"# 引用计数法\" class=\"headerlink\" title=\"引用计数法\"></a>引用计数法 </h3><p> 为每一个创建的对象分配一个引用计数器，用来存储该对象被引用的个数。当该个数为零，意味着没有人再使用这个对象，可以认为“对象死亡”。但是，这种方案存在严重的问题，就是无法检测“循环引用”：当两个对象互相引用，即时它俩都不被外界任何东西引用，它俩的计数都不为零，因此永远不会被回收。而实际上对于开发者而言，这两个对象已经完全没有用处了。</p>\n<p>因此，Java 里没有采用这样的方案来判定对象的“存活性”。</p>\n<h3 id=\"可达性分析\"><a href=\"# 可达性分析\" class=\"headerlink\" title=\"可达性分析\"></a>可达性分析 </h3><p> 这种方案是目前主流语言里采用的对象存活性判断方案。基本思路是把所有引用的对象想象成一棵树，从树的根结点 GC Roots 出发，持续遍历找出所有连接的树枝对象，这些对象则被称为“可达”对象，或称“存活”对象。其余的对象则被视为“死亡”的“不可达”对象，或称“垃圾”。</p>\n<p>参考下图，object5,object6 和 object7 便是不可达对象，视为“死亡状态”，应该被垃圾回收器回收。</p>\n<p><img src=\"/img/gc/reachable.JPG\" alt=\"\"></p>\n<h4 id=\"GC-Roots- 究竟指谁呢？\"><a href=\"#GC-Roots- 究竟指谁呢？\" class=\"headerlink\" title=\"GC Roots 究竟指谁呢？\"></a>GC Roots 究竟指谁呢？</h4><p>我们可以猜测，GC Roots 本身一定是可达的，这样从它们出发遍历到的对象才能保证一定可达。那么，Java 里有哪些对象是一定可达呢？主要有以下四种：</p>\n<ul>\n<li>虚拟机栈（帧栈中的本地变量表）中引用的对象。</li>\n<li>方法区中静态属性引用的对象。</li>\n<li>方法区中常量引用的对象。</li>\n<li>本地方法栈中 JNI 引用的对象。</li>\n</ul>\n<p>不少读者可能对这些 GC Roots 似懂非懂，这涉及到 JVM 本身的内存结构等等，未来的文章会再做深入讲解。这里只要知道有这么几种类型的 GC Roots，每次垃圾回收器会从这些根结点开始遍历寻找所有可达节点。</p>\n<h2 id=\"有哪些方式来回收这些垃圾呢？\"><a href=\"# 有哪些方式来回收这些垃圾呢？\" class=\"headerlink\" title=\"有哪些方式来回收这些垃圾呢？\"></a>有哪些方式来回收这些垃圾呢？</h2><p>上面已经知道，所有 GC Roots 不可达的对象都称为垃圾，参考下图，黑色的表示垃圾，灰色表示存活对象，绿色表示空白空间。</p>\n<p><img src=\"/img/gc/garbage.png\" alt=\"\"></p>\n<p>那么，我们如何来回收这些垃圾呢？</p>\n<h4 id=\"标记－清理\"><a href=\"# 标记－清理\" class=\"headerlink\" title=\"标记－清理\"></a>标记－清理 </h4><p> 第一步，所谓“标记”就是利用可达性遍历堆内存，把“存活”对象和“垃圾”对象进行标记，得到的结果如上图；<br>第二步，既然“垃圾”已经标记好了，那我们再遍历一遍，把所有“垃圾”对象所占的空间直接 <code> 清空 </code> 即可。</p>\n<p>结果如下：<br><img src=\"/img/gc/mark-sweep.png\" alt=\"\"></p>\n<p>这便是 <code> 标记－清理 </code> 方案，<code>简单方便 </code>，但是容易产生<code> 内存碎片</code>。</p>\n<h4 id=\"标记－整理\"><a href=\"# 标记－整理\" class=\"headerlink\" title=\"标记－整理\"></a>标记－整理 </h4><p> 既然上面的方法会产生内存碎片，那好，我在清理的时候，把所有 <code> 存活 </code> 对象扎堆到同一个地方，让它们待在一起，这样就没有内存碎片了。</p>\n<p>结果如下：<br><img src=\"/img/gc/mark-compact.png\" alt=\"\"></p>\n<p>这两种方案适合 <code> 存活对象多，垃圾少 </code> 的情况，它只需要清理掉少量的垃圾，然后挪动下存活对象就可以了。</p>\n<h4 id=\"复制\"><a href=\"# 复制\" class=\"headerlink\" title=\"复制\"></a>复制 </h4><p> 这种方法比较粗暴，直接把堆内存分成两部分，一段时间内只允许在其中一块内存上进行分配，当这块内存被分配完后，则执行垃圾回收，把所有 <code> 存活 </code> 对象全部复制到另一块内存上，当前内存则直接全部清空。</p>\n<p>参考下图：<br><img src=\"/img/gc/copying.png\" alt=\"\"></p>\n<p>起初时只使用上面部分的内存，直到内存使用完毕，才进行垃圾回收，把所有存活对象搬到下半部分，并把上半部分进行清空。</p>\n<p>这种做法不容易产生碎片，也简单粗暴；但是，它意味着你在一段时间内只能使用一部分的内存，超过这部分内存的话就意味着堆内存里频繁的 <code> 复制清空</code>。</p>\n<p>这种方案适合 <code> 存活对象少，垃圾多 </code> 的情况，这样在复制时就不需要复制多少对象过去，多数垃圾直接被清空处理。</p>\n<h2 id=\"Java- 的分代回收机制\"><a href=\"#Java- 的分代回收机制\" class=\"headerlink\" title=\"Java 的分代回收机制\"></a>Java 的分代回收机制 </h2><p> 上面我们看到有至少三种方法来回收内存，那么 Java 里是如何选择利用这三种回收算法呢？是只用一种还是三种都用呢？</p>\n<h3 id=\"Java- 的堆结构\"><a href=\"#Java- 的堆结构\" class=\"headerlink\" title=\"Java 的堆结构\"></a>Java 的堆结构 </h3><p> 在选择回收算法前，我们先来看一下 Java 堆的结构。</p>\n<p>一块 Java 堆空间一般分成三部分，这三部分用来存储三类数据：</p>\n<ul>\n<li>刚刚创建的对象。在代码运行时会持续不断地创造新的对象，这些新创建的对象会被统一放在一起。因为有很多局部变量等在新创建后很快会变成 <code> 不可达 </code> 的对象，<code>快速死去 </code>，因此这块区域的特点是<code> 存活对象少，垃圾多 </code>。形象点描述这块区域为：<code> 新生代</code>；</li>\n<li>存活了一段时间的对象。这些对象早早就被创建了，而且一直活了下来。我们把这些 <code> 存活时间较长 </code> 的对象放在一起，它们的特点是 <code> 存活对象多，垃圾少 </code>。形象点描述这块区域为：<code> 老年代</code>；</li>\n<li>永久存在的对象。比如一些静态文件，这些对象的特点是不需要垃圾回收，永远存活。形象点描述这块区域为：<code>永久代 </code>。（不过在 Java 8 里已经把<code> 永久代 </code> 删除了，把这块内存空间给了 <code> 元空间</code>，后续文章再讲解。）</li>\n</ul>\n<p>也就是说，常规的 Java 堆至少包括了 <code>新生代 </code> 和 <code> 老年代</code> 两块内存区域，而且这两块区域有很明显的特征：</p>\n<ul>\n<li>新生代：存活对象少、垃圾多</li>\n<li>老年代：存活对象多、垃圾少</li>\n</ul>\n<p>结合新生代／老年代的存活对象特点和之前提过的几种垃圾回收算法，可以得到如下的回收方案：</p>\n<h3 id=\"新生代－复制回收机制\"><a href=\"# 新生代－复制回收机制\" class=\"headerlink\" title=\"新生代－复制回收机制\"></a>新生代－<code>复制 </code> 回收机制 </h3><p> 对于新生代区域，由于每次 GC 都会有大量新对象死去，只有少量存活。因此采用 <code> 复制 </code> 回收算法，GC 时把少量的存活对象复制过去即可。</p>\n<p>那么如何设计这个 <code> 复制 </code> 算法比较好呢？有以下几种方式：</p>\n<h5 id=\"思路 1- 把内存均分成 -1-1- 两等份\"><a href=\"# 思路 1- 把内存均分成 -1-1- 两等份\" class=\"headerlink\" title=\"思路 1. 把内存均分成 1:1 两等份\"></a>思路 1. 把内存均分成 <code>1:1</code> 两等份 </h5><p> 如下图拆分内存。<br><img src=\"/img/gc/young_1.png\" alt=\"\"></p>\n<p>每次只使用一半的内存，当这一半满了后，就进行垃圾回收，把存活的对象直接复制到另一半内存，并清空当前一半的内存。</p>\n<p>这种分法的缺陷是相当于只有一半的可用内存，对于新生代而言，新对象持续不断地被创建，如果只有一半可用内存，那显然要持续不断地进行垃圾回收工作，反而影响到了正常程序的运行，得不偿失。</p>\n<h5 id=\"思路 2- 把内存按 -9-1- 分\"><a href=\"# 思路 2- 把内存按 -9-1- 分\" class=\"headerlink\" title=\"思路 2. 把内存按 9:1 分\"></a>思路 2. 把内存按 <code>9:1</code> 分 </h5><p> 既然上面的分法导致可用内存只剩一半，那么我做些调整，把 <code>1:1</code>变成<code>9:1</code>，<br><img src=\"/img/gc/young_2.png\" alt=\"\"></p>\n<p>最开始在 <code>9</code> 的内存区使用，当 <code>9</code> 快要满时，执行复制回收，把 <code>9</code> 内仍然存活的对象复制到 <code>1</code> 区，并清空 <code>9</code> 区。</p>\n<p>这样看起来是比上面的方法好了，但是它存在比较严重的问题。</p>\n<p>当我们把 <code>9</code> 区存活对象复制到 <code>1</code> 区时，由于内存空间比例相差比较大，所以很有可能 <code>1</code> 区放不满，此时就不得不把对象移到 <code>老年区 </code>。而这就意味着，可能会有一部分 <code> 并不老 </code> 的 <code>9</code> 区对象由于 <code>1</code> 区放不下了而被放到了 <code> 老年区 </code>，可想而知，这破坏了 <code> 老年区 </code> 的规则。或者说，一定程度上的 <code> 老年区 </code> 并不一定全是 <code> 老年对象</code>。</p>\n<p>那应该如何才能把真正比较 <code>老 </code> 的对象挪到 <code> 老年区</code> 呢？ </p>\n<h5 id=\"思路 3- 把内存按 -8-1-1- 分\"><a href=\"# 思路 3- 把内存按 -8-1-1- 分\" class=\"headerlink\" title=\"思路 3. 把内存按 8:1:1 分\"></a>思路 3. 把内存按 <code>8:1:1</code> 分</h5><p><img src=\"/img/gc/young_3.png\" alt=\"\"></p>\n<p>既然 <code>9:1</code> 有可能把年轻对象放到 <code>老年区 </code>，那就换成 <code>8:1:1</code>，依次取名为 <code>Eden</code>、<code>Survivor A</code>、<code>Survivor B</code> 区，其中 <code>Eden</code> 意为伊甸园，形容有很多新生对象在里面创建；<code>Survivor</code>区则为幸存者，即经历 GC 后仍然存活下来的对象。</p>\n<p>工作原理如下：</p>\n<ol>\n<li>首先，<code>Eden</code>区最大，对外提供堆内存。当 <code>Eden</code> 区快要满了，则进行 <code>Minor GC</code>，把存活对象放入 <code>Survivor A</code> 区，清空 <code>Eden</code> 区；</li>\n<li><code>Eden</code>区被清空后，继续对外提供堆内存；</li>\n<li>当 <code>Eden</code> 区再次被填满，此时对 <code>Eden</code> 区和 <code>Survivor A</code> 区同时进行 <code>Minor GC</code>，把存活对象放入 <code>Survivor B</code> 区，同时清空 <code>Eden</code> 区和<code>Survivor A</code> 区；</li>\n<li><code>Eden</code>区继续对外提供堆内存，并重复上述过程，即在 <code>Eden</code> 区填满后，把 <code>Eden</code> 区和某个 <code>Survivor</code> 区的存活对象放到另一个 <code>Survivor</code> 区；</li>\n<li>当某个 <code>Survivor</code> 区被填满，且仍有对象未被复制完毕时，或者某些对象在反复 <code>Survive</code> <code>15</code> 次左右时，则把这部分剩余对象放到<code>Old</code> 区；</li>\n<li>当 <code>Old</code> 区也被填满时，进行 <code>Major GC</code>，对 <code>Old</code> 区进行垃圾回收。</li>\n</ol>\n<p>[注意，在真实的 JVM 环境里，可以通过参数 <code>SurvivorRatio</code> 手动配置 <code>Eden</code> 区和单个 <code>Survivor</code> 区的比例，默认为 8。]</p>\n<p>那么，所谓的 <code>Old</code> 区垃圾回收，或称<code>Major GC</code>，应该如何执行呢？</p>\n<h3 id=\"老年代－标记整理回收机制\"><a href=\"# 老年代－标记整理回收机制\" class=\"headerlink\" title=\"老年代－标记整理回收机制\"></a>老年代－<code>标记整理 </code> 回收机制 </h3><p> 根据上面我们知道，老年代一般存放的是存活时间较久的对象，所以每一次 GC 时，存活对象比较较大，也就是说每次只有少部分对象被回收。</p>\n<p>因此，根据不同回收机制的特点，这里选择 <code> 存活对象多，垃圾少 </code> 的<code>标记整理 </code> 回收机制，仅仅通过少量地移动对象就能清理垃圾，而且不存在内存碎片化。</p>\n<p>至此，我们已经了解了 Java 堆内存的分代原理，并了解了不同代根据各自特点采用了不同的回收机制，即 <code> 新生代 </code> 采用 <code> 回收 </code> 机制，<code>老年代 </code> 采用 <code> 标记整理 </code> 机制。</p>\n<h2 id=\"小结\"><a href=\"# 小结\" class=\"headerlink\" title=\"小结\"></a>小结 </h2><p> 垃圾回收是 Java 非常重要的特性，也是高级 Java 工程师的必经之路。</p>\n<p>如有问题欢迎与我联系。</p>\n<p>谢谢。</p>\n<p>wingjay</p>\n<p><a href=\"http://wingjay.com\">http://wingjay.com</a></p>\n<p>参考文章：</p>\n<ul>\n<li>《<a href=\"http://jayfeng.com/2016/03/11/%E7%90%86%E8%A7%A3Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/\" target=\"_blank\" rel=\"external\">理解 Java 垃圾回收机制</a>》</li>\n<li>《<a href=\"https://segmentfault.com/a/1190000002579346#articleHeader6\" target=\"_blank\" rel=\"external\">JVM 的 工作原理，层次结构 以及 GC 工作原理</a>》</li>\n<li>《<a href=\"http://howiefh.github.io/2015/04/08/jvm-note-2/\" target=\"_blank\" rel=\"external\">深入理解 Java 虚拟机笔记二（垃圾收集器与内存分配策略）</a>》</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>垃圾回收机制是 Java 非常重要的特性之一，也是面试题的常客。它让开发者无需关注空间的创建和释放，而是以守护进程的形式在后台自动回收垃圾。这样做不仅提高了开发效率，更改善了内存的使用状况。</p>\n<p>今天本文来对垃圾回收机制进行讲解，主要涉及下面几个问题：</p>\n<ul>\n<li>什么是堆内存？</li>\n<li>什么是垃圾？</li>\n<li>有哪些方法回收这些垃圾？</li>\n<li>什么是分代回收机制？</li>\n</ul>\n</blockquote>","more":"<h2 id=\"什么是-Java-堆内存\"><a href=\"#什么是-Java-堆内存\" class=\"headerlink\" title=\"什么是 Java 堆内存\"></a>什么是 Java 堆内存</h2><p>堆是在 JVM 启动时创建的，主要用来维护运行时数据，如运行过程中创建的对象和数组都是基于这块内存空间。Java 堆是非常重要的元素，如果我们动态创建的对象没有得到及时回收，持续堆积，最后会导致堆空间被占满，内存溢出。</p>\n<p>因此，Java 提供了一种垃圾回收机制，在后台创建一个守护进程。该进程会在内存紧张的时候自动跳出来，把堆空间的垃圾全部进行回收，从而保证程序的正常运行。</p>\n<h2 id=\"那什么是垃圾呢？\"><a href=\"#那什么是垃圾呢？\" class=\"headerlink\" title=\"那什么是垃圾呢？\"></a>那什么是垃圾呢？</h2><p>所谓“垃圾”，就是指所有不再存活的对象。常见的判断是否存活有两种方法：引用计数法和可达性分析。</p>\n<h3 id=\"引用计数法\"><a href=\"#引用计数法\" class=\"headerlink\" title=\"引用计数法\"></a>引用计数法</h3><p>为每一个创建的对象分配一个引用计数器，用来存储该对象被引用的个数。当该个数为零，意味着没有人再使用这个对象，可以认为“对象死亡”。但是，这种方案存在严重的问题，就是无法检测“循环引用”：当两个对象互相引用，即时它俩都不被外界任何东西引用，它俩的计数都不为零，因此永远不会被回收。而实际上对于开发者而言，这两个对象已经完全没有用处了。</p>\n<p>因此，Java 里没有采用这样的方案来判定对象的“存活性”。</p>\n<h3 id=\"可达性分析\"><a href=\"#可达性分析\" class=\"headerlink\" title=\"可达性分析\"></a>可达性分析</h3><p>这种方案是目前主流语言里采用的对象存活性判断方案。基本思路是把所有引用的对象想象成一棵树，从树的根结点 GC Roots 出发，持续遍历找出所有连接的树枝对象，这些对象则被称为“可达”对象，或称“存活”对象。其余的对象则被视为“死亡”的“不可达”对象，或称“垃圾”。</p>\n<p>参考下图，object5,object6和object7便是不可达对象，视为“死亡状态”，应该被垃圾回收器回收。</p>\n<p><img src=\"/img/gc/reachable.JPG\" alt=\"\"></p>\n<h4 id=\"GC-Roots-究竟指谁呢？\"><a href=\"#GC-Roots-究竟指谁呢？\" class=\"headerlink\" title=\"GC Roots 究竟指谁呢？\"></a>GC Roots 究竟指谁呢？</h4><p>我们可以猜测，GC Roots 本身一定是可达的，这样从它们出发遍历到的对象才能保证一定可达。那么，Java 里有哪些对象是一定可达呢？主要有以下四种：</p>\n<ul>\n<li>虚拟机栈（帧栈中的本地变量表）中引用的对象。</li>\n<li>方法区中静态属性引用的对象。</li>\n<li>方法区中常量引用的对象。</li>\n<li>本地方法栈中JNI引用的对象。</li>\n</ul>\n<p>不少读者可能对这些 GC Roots 似懂非懂，这涉及到 JVM 本身的内存结构等等，未来的文章会再做深入讲解。这里只要知道有这么几种类型的 GC Roots，每次垃圾回收器会从这些根结点开始遍历寻找所有可达节点。</p>\n<h2 id=\"有哪些方式来回收这些垃圾呢？\"><a href=\"#有哪些方式来回收这些垃圾呢？\" class=\"headerlink\" title=\"有哪些方式来回收这些垃圾呢？\"></a>有哪些方式来回收这些垃圾呢？</h2><p>上面已经知道，所有GC Roots不可达的对象都称为垃圾，参考下图，黑色的表示垃圾，灰色表示存活对象，绿色表示空白空间。</p>\n<p><img src=\"/img/gc/garbage.png\" alt=\"\"></p>\n<p>那么，我们如何来回收这些垃圾呢？</p>\n<h4 id=\"标记－清理\"><a href=\"#标记－清理\" class=\"headerlink\" title=\"标记－清理\"></a>标记－清理</h4><p>第一步，所谓“标记”就是利用可达性遍历堆内存，把“存活”对象和“垃圾”对象进行标记，得到的结果如上图；<br>第二步，既然“垃圾”已经标记好了，那我们再遍历一遍，把所有“垃圾”对象所占的空间直接<code>清空</code>即可。</p>\n<p>结果如下：<br><img src=\"/img/gc/mark-sweep.png\" alt=\"\"></p>\n<p>这便是<code>标记－清理</code>方案，<code>简单方便</code>，但是容易产生<code>内存碎片</code>。</p>\n<h4 id=\"标记－整理\"><a href=\"#标记－整理\" class=\"headerlink\" title=\"标记－整理\"></a>标记－整理</h4><p>既然上面的方法会产生内存碎片，那好，我在清理的时候，把所有<code>存活</code>对象扎堆到同一个地方，让它们待在一起，这样就没有内存碎片了。</p>\n<p>结果如下：<br><img src=\"/img/gc/mark-compact.png\" alt=\"\"></p>\n<p>这两种方案适合<code>存活对象多，垃圾少</code>的情况，它只需要清理掉少量的垃圾，然后挪动下存活对象就可以了。</p>\n<h4 id=\"复制\"><a href=\"#复制\" class=\"headerlink\" title=\"复制\"></a>复制</h4><p>这种方法比较粗暴，直接把堆内存分成两部分，一段时间内只允许在其中一块内存上进行分配，当这块内存被分配完后，则执行垃圾回收，把所有<code>存活</code>对象全部复制到另一块内存上，当前内存则直接全部清空。</p>\n<p>参考下图：<br><img src=\"/img/gc/copying.png\" alt=\"\"></p>\n<p>起初时只使用上面部分的内存，直到内存使用完毕，才进行垃圾回收，把所有存活对象搬到下半部分，并把上半部分进行清空。</p>\n<p>这种做法不容易产生碎片，也简单粗暴；但是，它意味着你在一段时间内只能使用一部分的内存，超过这部分内存的话就意味着堆内存里频繁的<code>复制清空</code>。</p>\n<p>这种方案适合<code>存活对象少，垃圾多</code>的情况，这样在复制时就不需要复制多少对象过去，多数垃圾直接被清空处理。</p>\n<h2 id=\"Java-的分代回收机制\"><a href=\"#Java-的分代回收机制\" class=\"headerlink\" title=\"Java 的分代回收机制\"></a>Java 的分代回收机制</h2><p>上面我们看到有至少三种方法来回收内存，那么 Java 里是如何选择利用这三种回收算法呢？是只用一种还是三种都用呢？</p>\n<h3 id=\"Java-的堆结构\"><a href=\"#Java-的堆结构\" class=\"headerlink\" title=\"Java 的堆结构\"></a>Java 的堆结构</h3><p>在选择回收算法前，我们先来看一下 Java 堆的结构。</p>\n<p>一块 Java 堆空间一般分成三部分，这三部分用来存储三类数据：</p>\n<ul>\n<li>刚刚创建的对象。在代码运行时会持续不断地创造新的对象，这些新创建的对象会被统一放在一起。因为有很多局部变量等在新创建后很快会变成<code>不可达</code>的对象，<code>快速死去</code>，因此这块区域的特点是<code>存活对象少，垃圾多</code>。形象点描述这块区域为：<code>新生代</code>；</li>\n<li>存活了一段时间的对象。这些对象早早就被创建了，而且一直活了下来。我们把这些<code>存活时间较长</code>的对象放在一起，它们的特点是<code>存活对象多，垃圾少</code>。形象点描述这块区域为：<code>老年代</code>；</li>\n<li>永久存在的对象。比如一些静态文件，这些对象的特点是不需要垃圾回收，永远存活。形象点描述这块区域为：<code>永久代</code>。（不过在 Java 8 里已经把<code>永久代</code>删除了，把这块内存空间给了<code>元空间</code>，后续文章再讲解。）</li>\n</ul>\n<p>也就是说，常规的 Java 堆至少包括了 <code>新生代</code> 和 <code>老年代</code> 两块内存区域，而且这两块区域有很明显的特征：</p>\n<ul>\n<li>新生代：存活对象少、垃圾多</li>\n<li>老年代：存活对象多、垃圾少</li>\n</ul>\n<p>结合新生代／老年代的存活对象特点和之前提过的几种垃圾回收算法，可以得到如下的回收方案：</p>\n<h3 id=\"新生代－复制回收机制\"><a href=\"#新生代－复制回收机制\" class=\"headerlink\" title=\"新生代－复制回收机制\"></a>新生代－<code>复制</code>回收机制</h3><p>对于新生代区域，由于每次 GC 都会有大量新对象死去，只有少量存活。因此采用<code>复制</code>回收算法，GC 时把少量的存活对象复制过去即可。</p>\n<p>那么如何设计这个<code>复制</code>算法比较好呢？有以下几种方式：</p>\n<h5 id=\"思路1-把内存均分成-1-1-两等份\"><a href=\"#思路1-把内存均分成-1-1-两等份\" class=\"headerlink\" title=\"思路1. 把内存均分成 1:1 两等份\"></a>思路1. 把内存均分成 <code>1:1</code> 两等份</h5><p>如下图拆分内存。<br><img src=\"/img/gc/young_1.png\" alt=\"\"></p>\n<p>每次只使用一半的内存，当这一半满了后，就进行垃圾回收，把存活的对象直接复制到另一半内存，并清空当前一半的内存。</p>\n<p>这种分法的缺陷是相当于只有一半的可用内存，对于新生代而言，新对象持续不断地被创建，如果只有一半可用内存，那显然要持续不断地进行垃圾回收工作，反而影响到了正常程序的运行，得不偿失。</p>\n<h5 id=\"思路2-把内存按-9-1-分\"><a href=\"#思路2-把内存按-9-1-分\" class=\"headerlink\" title=\"思路2. 把内存按 9:1 分\"></a>思路2. 把内存按 <code>9:1</code> 分</h5><p>既然上面的分法导致可用内存只剩一半，那么我做些调整，把 <code>1:1</code>变成<code>9:1</code>，<br><img src=\"/img/gc/young_2.png\" alt=\"\"></p>\n<p>最开始在 <code>9</code> 的内存区使用，当 <code>9</code> 快要满时，执行复制回收，把 <code>9</code> 内仍然存活的对象复制到 <code>1</code> 区，并清空 <code>9</code> 区。</p>\n<p>这样看起来是比上面的方法好了，但是它存在比较严重的问题。</p>\n<p>当我们把 <code>9</code> 区存活对象复制到 <code>1</code> 区时，由于内存空间比例相差比较大，所以很有可能 <code>1</code> 区放不满，此时就不得不把对象移到 <code>老年区</code>。而这就意味着，可能会有一部分 <code>并不老</code> 的 <code>9</code> 区对象由于 <code>1</code> 区放不下了而被放到了 <code>老年区</code>，可想而知，这破坏了 <code>老年区</code> 的规则。或者说，一定程度上的 <code>老年区</code> 并不一定全是 <code>老年对象</code>。</p>\n<p>那应该如何才能把真正比较 <code>老</code> 的对象挪到 <code>老年区</code> 呢？ </p>\n<h5 id=\"思路3-把内存按-8-1-1-分\"><a href=\"#思路3-把内存按-8-1-1-分\" class=\"headerlink\" title=\"思路3. 把内存按 8:1:1 分\"></a>思路3. 把内存按 <code>8:1:1</code> 分</h5><p><img src=\"/img/gc/young_3.png\" alt=\"\"></p>\n<p>既然 <code>9:1</code> 有可能把年轻对象放到 <code>老年区</code>，那就换成 <code>8:1:1</code>，依次取名为 <code>Eden</code>、<code>Survivor A</code>、<code>Survivor B</code>区，其中<code>Eden</code>意为伊甸园，形容有很多新生对象在里面创建；<code>Survivor</code>区则为幸存者，即经历 GC 后仍然存活下来的对象。</p>\n<p>工作原理如下：</p>\n<ol>\n<li>首先，<code>Eden</code>区最大，对外提供堆内存。当 <code>Eden</code> 区快要满了，则进行 <code>Minor GC</code>，把存活对象放入<code>Survivor A</code>区，清空 <code>Eden</code> 区；</li>\n<li><code>Eden</code>区被清空后，继续对外提供堆内存；</li>\n<li>当<code>Eden</code>区再次被填满，此时对<code>Eden</code>区和<code>Survivor A</code>区同时进行 <code>Minor GC</code>，把存活对象放入<code>Survivor B</code>区，同时清空<code>Eden</code> 区和<code>Survivor A</code>区；</li>\n<li><code>Eden</code>区继续对外提供堆内存，并重复上述过程，即在<code>Eden</code>区填满后，把<code>Eden</code>区和某个<code>Survivor</code>区的存活对象放到另一个<code>Survivor</code>区；</li>\n<li>当某个<code>Survivor</code>区被填满，且仍有对象未被复制完毕时，或者某些对象在反复<code>Survive</code> <code>15</code> 次左右时，则把这部分剩余对象放到<code>Old</code>区；</li>\n<li>当 <code>Old</code> 区也被填满时，进行 <code>Major GC</code>，对 <code>Old</code> 区进行垃圾回收。</li>\n</ol>\n<p>[注意，在真实的 JVM 环境里，可以通过参数 <code>SurvivorRatio</code> 手动配置<code>Eden</code>区和单个<code>Survivor</code>区的比例，默认为8。]</p>\n<p>那么，所谓的 <code>Old</code> 区垃圾回收，或称<code>Major GC</code>，应该如何执行呢？</p>\n<h3 id=\"老年代－标记整理回收机制\"><a href=\"#老年代－标记整理回收机制\" class=\"headerlink\" title=\"老年代－标记整理回收机制\"></a>老年代－<code>标记整理</code>回收机制</h3><p>根据上面我们知道，老年代一般存放的是存活时间较久的对象，所以每一次 GC 时，存活对象比较较大，也就是说每次只有少部分对象被回收。</p>\n<p>因此，根据不同回收机制的特点，这里选择<code>存活对象多，垃圾少</code>的<code>标记整理</code>回收机制，仅仅通过少量地移动对象就能清理垃圾，而且不存在内存碎片化。</p>\n<p>至此，我们已经了解了 Java 堆内存的分代原理，并了解了不同代根据各自特点采用了不同的回收机制，即<code>新生代</code>采用<code>回收</code>机制，<code>老年代</code>采用<code>标记整理</code>机制。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>垃圾回收是 Java 非常重要的特性，也是高级 Java 工程师的必经之路。</p>\n<p>如有问题欢迎与我联系。</p>\n<p>谢谢。</p>\n<p>wingjay</p>\n<p><a href=\"http://wingjay.com\">http://wingjay.com</a></p>\n<p>参考文章：</p>\n<ul>\n<li>《<a href=\"http://jayfeng.com/2016/03/11/%E7%90%86%E8%A7%A3Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/\" target=\"_blank\" rel=\"external\">理解Java垃圾回收机制</a>》</li>\n<li>《<a href=\"https://segmentfault.com/a/1190000002579346#articleHeader6\" target=\"_blank\" rel=\"external\">JVM 的 工作原理，层次结构 以及 GC工作原理</a>》</li>\n<li>《<a href=\"http://howiefh.github.io/2015/04/08/jvm-note-2/\" target=\"_blank\" rel=\"external\">深入理解Java虚拟机笔记二（垃圾收集器与内存分配策略）</a>》</li>\n</ul>","sticky":0},{"title":"Java 的 equals 与 hashcode 对比分析","date":"2017-03-29T13:23:53.000Z","commentIssueId":8,"_content":">在阅读《Effective Java》第3章里读到了关于 equals() 和 hashcode() 的一些介绍，这两个方法是很多Java程序员容易弄混的，因此本文针对这两个方法的用法和具体实现来做一些介绍。\n\n<!-- more -->\n\n## equals() 与 hashcode() 的用处？\n我们一般用`equals()`来比较两个对象的`逻辑意义`上的值是否相同。举个例子：\n```java\nclass Person {\n    String name;\n    int age;\n    long id;\n}\n```\n我们现在有两个Person的对象，person1 和person2，那么什么时候这两个是相等的呢？对于两个人而言，我们认为如果他们俩名字、年龄和ID都完全一样，那么就是同一个人。也就是说，如果\n```\nperson1.name = person2.name\nperson1.age = person2.age\nperson1.id = person2.id\n```\n那么我们就认为 `person1.equals(person2)=true`。这就是表示equals是指二者逻辑意义上相等即可。\n\n而 hashcode() 则是对一个对象进行hash计算得到的一个散列值，它有以下特点：\n1. 对象x和y的hashcode相同，不代表两个对象就相同(x.equals(y)=true)，可能存在hash碰撞；不过hashcode如果不相同，那么一定是两个不同的对象\n2. 如果两个对象的equals()相等，那么hashcode一定相等。\n所以我们一般可以用hashcode来快速比较两个对象`互异`，因为如果`x.hashcode() != y.hashcode()`，那么`x.equals(y)=false`。\n\n## equals() 的特性\n很多时候我们想要重写某个自定义object的equals()方法，那么一定要记住，你的equals()方法必须满足下面四个条件：\n1. 自反性：对于非null的对象x，必须有 `x.equals(x)=true`；\n2. 对称性：如果 `x.equals(y)=true`，那么`y.equals(x)`必须也为`true`；\n3. 传递性：如果`x.equals(y)=true`而且`y.equals(z)=true`，那么`x.equals(z)`必须为`true`；\n4. 对于非null的对象x，一定有`x.equals(null)=false`\n\n## 如何重载 equals() 方法呢？\n一般而言，如果你要重载 equals() 方法，有下面一套模版代码可以参考：\n1. 首先使用 `==` 来判断`两个对象是否引用相同`；\n2. 使用 `instanceof` 来判断`两个对象是否类型相同`；\n3. 如果类型相同，则把待比较参数转型；\n4. 比较两个对象内部每个逻辑值是否相等，只有全部相等才返回true，或者返回false；\n5. 测试这个方法是否能满足上面几个特性。\n\n## Java 源码 String 里 equals() 和 hashcode() 实现\n看完上面的特性和重载方法你可能有点头大，下面我们来看一下Java里的 String 是如何实现的吧，是否满足上面几个特性呢。\n```\npublic boolean equals(Object anObject) {\n    if (this == anObject) {\n        return true;\n    }\n    if (anObject instanceof String) {\n        String anotherString = (String)anObject;\n        int n = value.length;\n        if (n == anotherString.value.length) {\n            char v1[] = value;\n            char v2[] = anotherString.value;\n            int i = 0;\n            while (n-- != 0) {\n                if (v1[i] != v2[i])\n                    return false;\n                i++;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n```\n可以看到，上面的方法依次执行了下面的步骤：\n1. 比较引用`this == anObject`；\n2. 判断类型 `anObject instanceof String`；\n3. 转型 `String anotherString = (String)anObject`；\n4. 比较逻辑值 对 String 而言，首先要 `length` 相等 `n == anotherString.value.length`；然后要每一个字符相等，见代码，最后返回结果。\n\n下面我写了一段测试代码来验证是否符合上面几点特性：\n```\nprivate static void testStringEquals() {\n    String x = \"First\";\n    String y = \"First\";\n    String z = new String(\"First\");\n    System.out.println(x.equals(x));\n    System.out.println((x.equals(y) && y.equals(x)));\n    if (x.equals(y) && y.equals(x)) {\n        System.out.println(x.equals(z));\n    }\n    System.out.println(x.equals(null));\n}\n```\n打印结果如下：\n```\ntrue\ntrue\ntrue\nfalse\n```\n说明是符合的。\n\n然后我们再看下 hashcode() 的源代码实现，我们知道，hashcode的含义是计算hash散列值，其实就是对一个对象快速计算一个散列值，用来`判异`使用：只要 hashcode() 不同，那么两个对象一定不同。下面我们看下 String 是如何计算自己的hash值的。\n```java\nprivate final char value[]; /** The value is used for character storage. */\nprivate int hash; /** Cache the hash code for the string Default to 0 */\n\npublic int hashCode() {\n    int h = hash; \n    if (h == 0 && value.length > 0) { \n        char val[] = value;\n        for (int i = 0; i < value.length; i++) {\n            h = 31 * h + val[i];\n        }\n        hash = h;\n    }\n    return h;\n}\n```\n其中用来计算 hashcode 主要是这段代码\n```\nfor (int i = 0; i < value.length; i++) {\n    h = 31 * h + val[i];\n}\n```\n其中，value是内部存储string值的字符数组。计算hashcode的方法就是依次遍历每一个字符，乘以31后再加上下一个字符。例如\"a\"的hashcode就是 97；\"aa\"的hashcode是 `31*97+97`=3104。因此可以看出，`hashcode不同的两个 String 对象一定不是同一个对象`。\n\n## 谨记：重载 equals() 时要保证：两个equal的对象一定有相同的hashcode\n很多人在重载 equals() 时忽视了这一点，没有保证两个equal的对象具备相同的hashcode，从而导致了奇怪的错误。\n\n下面举一个例子，我先只重载 `PhoneNumberWithoutHashcode` 的 equals() 方法：\n```\nclass PhoneNumberWithoutHashcode {\n    final short countryCode;\n    final short number;\n    public PhoneNumberWithoutHashcode(int countryCode, int number) {\n        this.countryCode = (short) countryCode;\n        this.number = (short) number;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        // 1. check == reference\n        if(obj == this) {\n            return true;\n        }\n        // 2. check obj instance\n        if (!(obj instanceof PhoneNumberWithoutHashcode))\n            return false;\n\n        // 3. compare logic value\n        PhoneNumberWithoutHashcode anObj = (PhoneNumberWithoutHashcode) obj;\n        return anObj.countryCode == this.countryCode \n                && anObj.number == this.number;\n    }        \n}\n```\n下面我们来创建两个相同的对象，看看它们的 equals() hashcode() 返回值如何。\n```\nprivate static void test() {\n    PhoneNumberWithoutHashcode p1 = new PhoneNumberWithoutHashcode(86, 123123);\n    PhoneNumberWithoutHashcode p2 = new PhoneNumberWithoutHashcode(86, 123123);\n    System.out.println(\"p1.equals(p2)=\" + p1.equals(p2));\n    System.out.println(\"p1.hashcode()=\" + p1.hashCode());\n    System.out.println(\"p2.hashcode()=\" + p2.hashCode());    \n}\n```\n可以得到结果如下:\n```\np1.equals(p2)=true\np1.hashcode()=1846274136\np2.hashcode()=1639705018\n```\n可以看出，二者是 equals 的，但是hashcode不一样。这违背了 Java准则，会导致什么结果呢？\n\n```java\nprivate static void test() {\n    PhoneNumberWithoutHashcode p1 = new PhoneNumberWithoutHashcode(86, 123123);\n    PhoneNumberWithoutHashcode p2 = new PhoneNumberWithoutHashcode(86, 123123);\n    System.out.println(\"p1.equals(p2)=\" + p1.equals(p2));\n    \n    HashMap<PhoneNumberWithoutHashcode, String> map = new HashMap<>();\n    map.put(p1, \"TheValue\");\n    System.out.println(\"Result: \" + map.get(p2));\n}\n```\n\n读者觉得会打印什么呢？`Result: TheValue` 吗？我们来看下运行结果：\n```\np1.equals(p2)=true\nResult:  null\n```\n问题来了，p1和p2是equal的，但是确不是同样的key，至少对于HashMap而言，它们俩不是同一个key，为什么呢？\n\n我们看一下 HashMap 是怎么put和get的吧。\n```\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\npublic V get(Object key) {\n    Node<K,V> e;\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\n```\n从这段代码可以看到，p1 和 p2 被存储时就计算了一次 `hash(key)`，如下:\n```\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n其实就是调用了 `key.hashCode()` 方法，而我们知道虽然 `p1.equals(p2)=true`，但是`p1.hashCode() != p2.hashCode()`，因此 p1 和 p2 对 HashMap 而言压根就是两个 key，当然互相取不到对方的 value了。\n\n那么要如何改进这个类呢？我们再来实现它的 hashcode 方法吧。\n```\nclass PhoneNumber {\n    protected final short countryCode;\n    protected final short number;\n\n    public PhoneNumber(int countryCode, int number) {\n        this.countryCode = (short) countryCode;\n        this.number = (short) number;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        // 1. check == reference\n        if (this == obj)\n            return true;\n\n        // 2. check obj instance\n        if (!(obj instanceof PhoneNumber))\n            return false;\n\n        // 3. compare logic value\n        PhoneNumber target = (PhoneNumber) obj;\n        return target.number == this.number\n                && target.countryCode == this.countryCode;\n    }\n\n    @Override\n    public int hashCode() {\n        return (31 * this.countryCode) + this.number;\n    }\n}\n```\n这时我们的测试代码：\n```\nprivate static void test() {\n    PhoneNumber p1 = new PhoneNumber(86, 12);\n    PhoneNumber p2 = new PhoneNumber(86, 12);\n    System.out.println(\"p1.equals(p2)=\" + p1.equals(p2));\n    System.out.println(\"p1.hashcode()=\" + p1.hashCode());\n    System.out.println(\"p2.hashcode()=\" + p2.hashCode());\n\n    HashMap<PhoneNumber, String> map = new HashMap<>(2);\n    map.put(p1, \"TheValue\");\n    System.out.println(\"Result: \" + map.get(p2));\n}\n```\n打印结果如下：\n```\np1.equals(p2)=true\np1.hashcode()=88076\np2.hashcode()=88076\nResult: TheValue\n```\n说明重载hashcode后就能保证 `PhoneNumber` 在 `HashMap` 里正常运行了，毕竟像这种 HashMap HashSet 之类的都要基于对象的hash值。\n\n## 小结\n如果存在遗漏错误欢迎读者提出。\n\n谢谢。\n\nwingjay\n\nhttp://wingjay.com\n\n如果有问题，可以给我留言或发邮件<mailto:yinjiesh@126.com>","source":"_posts/Java的equals与hashcode对比分析.md","raw":"title: Java的equals与hashcode对比分析\ndate: 2017-03-29 21:23:53\ncategories:\n  - 深入理解Java技术\ntags: Java\ncommentIssueId: 8\n---\n>在阅读《Effective Java》第3章里读到了关于 equals() 和 hashcode() 的一些介绍，这两个方法是很多Java程序员容易弄混的，因此本文针对这两个方法的用法和具体实现来做一些介绍。\n\n<!-- more -->\n\n## equals() 与 hashcode() 的用处？\n我们一般用`equals()`来比较两个对象的`逻辑意义`上的值是否相同。举个例子：\n```java\nclass Person {\n    String name;\n    int age;\n    long id;\n}\n```\n我们现在有两个Person的对象，person1 和person2，那么什么时候这两个是相等的呢？对于两个人而言，我们认为如果他们俩名字、年龄和ID都完全一样，那么就是同一个人。也就是说，如果\n```\nperson1.name = person2.name\nperson1.age = person2.age\nperson1.id = person2.id\n```\n那么我们就认为 `person1.equals(person2)=true`。这就是表示equals是指二者逻辑意义上相等即可。\n\n而 hashcode() 则是对一个对象进行hash计算得到的一个散列值，它有以下特点：\n1. 对象x和y的hashcode相同，不代表两个对象就相同(x.equals(y)=true)，可能存在hash碰撞；不过hashcode如果不相同，那么一定是两个不同的对象\n2. 如果两个对象的equals()相等，那么hashcode一定相等。\n所以我们一般可以用hashcode来快速比较两个对象`互异`，因为如果`x.hashcode() != y.hashcode()`，那么`x.equals(y)=false`。\n\n## equals() 的特性\n很多时候我们想要重写某个自定义object的equals()方法，那么一定要记住，你的equals()方法必须满足下面四个条件：\n1. 自反性：对于非null的对象x，必须有 `x.equals(x)=true`；\n2. 对称性：如果 `x.equals(y)=true`，那么`y.equals(x)`必须也为`true`；\n3. 传递性：如果`x.equals(y)=true`而且`y.equals(z)=true`，那么`x.equals(z)`必须为`true`；\n4. 对于非null的对象x，一定有`x.equals(null)=false`\n\n## 如何重载 equals() 方法呢？\n一般而言，如果你要重载 equals() 方法，有下面一套模版代码可以参考：\n1. 首先使用 `==` 来判断`两个对象是否引用相同`；\n2. 使用 `instanceof` 来判断`两个对象是否类型相同`；\n3. 如果类型相同，则把待比较参数转型；\n4. 比较两个对象内部每个逻辑值是否相等，只有全部相等才返回true，或者返回false；\n5. 测试这个方法是否能满足上面几个特性。\n\n## Java 源码 String 里 equals() 和 hashcode() 实现\n看完上面的特性和重载方法你可能有点头大，下面我们来看一下Java里的 String 是如何实现的吧，是否满足上面几个特性呢。\n```\npublic boolean equals(Object anObject) {\n    if (this == anObject) {\n        return true;\n    }\n    if (anObject instanceof String) {\n        String anotherString = (String)anObject;\n        int n = value.length;\n        if (n == anotherString.value.length) {\n            char v1[] = value;\n            char v2[] = anotherString.value;\n            int i = 0;\n            while (n-- != 0) {\n                if (v1[i] != v2[i])\n                    return false;\n                i++;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n```\n可以看到，上面的方法依次执行了下面的步骤：\n1. 比较引用`this == anObject`；\n2. 判断类型 `anObject instanceof String`；\n3. 转型 `String anotherString = (String)anObject`；\n4. 比较逻辑值 对 String 而言，首先要 `length` 相等 `n == anotherString.value.length`；然后要每一个字符相等，见代码，最后返回结果。\n\n下面我写了一段测试代码来验证是否符合上面几点特性：\n```\nprivate static void testStringEquals() {\n    String x = \"First\";\n    String y = \"First\";\n    String z = new String(\"First\");\n    System.out.println(x.equals(x));\n    System.out.println((x.equals(y) && y.equals(x)));\n    if (x.equals(y) && y.equals(x)) {\n        System.out.println(x.equals(z));\n    }\n    System.out.println(x.equals(null));\n}\n```\n打印结果如下：\n```\ntrue\ntrue\ntrue\nfalse\n```\n说明是符合的。\n\n然后我们再看下 hashcode() 的源代码实现，我们知道，hashcode的含义是计算hash散列值，其实就是对一个对象快速计算一个散列值，用来`判异`使用：只要 hashcode() 不同，那么两个对象一定不同。下面我们看下 String 是如何计算自己的hash值的。\n```java\nprivate final char value[]; /** The value is used for character storage. */\nprivate int hash; /** Cache the hash code for the string Default to 0 */\n\npublic int hashCode() {\n    int h = hash; \n    if (h == 0 && value.length > 0) { \n        char val[] = value;\n        for (int i = 0; i < value.length; i++) {\n            h = 31 * h + val[i];\n        }\n        hash = h;\n    }\n    return h;\n}\n```\n其中用来计算 hashcode 主要是这段代码\n```\nfor (int i = 0; i < value.length; i++) {\n    h = 31 * h + val[i];\n}\n```\n其中，value是内部存储string值的字符数组。计算hashcode的方法就是依次遍历每一个字符，乘以31后再加上下一个字符。例如\"a\"的hashcode就是 97；\"aa\"的hashcode是 `31*97+97`=3104。因此可以看出，`hashcode不同的两个 String 对象一定不是同一个对象`。\n\n## 谨记：重载 equals() 时要保证：两个equal的对象一定有相同的hashcode\n很多人在重载 equals() 时忽视了这一点，没有保证两个equal的对象具备相同的hashcode，从而导致了奇怪的错误。\n\n下面举一个例子，我先只重载 `PhoneNumberWithoutHashcode` 的 equals() 方法：\n```\nclass PhoneNumberWithoutHashcode {\n    final short countryCode;\n    final short number;\n    public PhoneNumberWithoutHashcode(int countryCode, int number) {\n        this.countryCode = (short) countryCode;\n        this.number = (short) number;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        // 1. check == reference\n        if(obj == this) {\n            return true;\n        }\n        // 2. check obj instance\n        if (!(obj instanceof PhoneNumberWithoutHashcode))\n            return false;\n\n        // 3. compare logic value\n        PhoneNumberWithoutHashcode anObj = (PhoneNumberWithoutHashcode) obj;\n        return anObj.countryCode == this.countryCode \n                && anObj.number == this.number;\n    }        \n}\n```\n下面我们来创建两个相同的对象，看看它们的 equals() hashcode() 返回值如何。\n```\nprivate static void test() {\n    PhoneNumberWithoutHashcode p1 = new PhoneNumberWithoutHashcode(86, 123123);\n    PhoneNumberWithoutHashcode p2 = new PhoneNumberWithoutHashcode(86, 123123);\n    System.out.println(\"p1.equals(p2)=\" + p1.equals(p2));\n    System.out.println(\"p1.hashcode()=\" + p1.hashCode());\n    System.out.println(\"p2.hashcode()=\" + p2.hashCode());    \n}\n```\n可以得到结果如下:\n```\np1.equals(p2)=true\np1.hashcode()=1846274136\np2.hashcode()=1639705018\n```\n可以看出，二者是 equals 的，但是hashcode不一样。这违背了 Java准则，会导致什么结果呢？\n\n```java\nprivate static void test() {\n    PhoneNumberWithoutHashcode p1 = new PhoneNumberWithoutHashcode(86, 123123);\n    PhoneNumberWithoutHashcode p2 = new PhoneNumberWithoutHashcode(86, 123123);\n    System.out.println(\"p1.equals(p2)=\" + p1.equals(p2));\n    \n    HashMap<PhoneNumberWithoutHashcode, String> map = new HashMap<>();\n    map.put(p1, \"TheValue\");\n    System.out.println(\"Result: \" + map.get(p2));\n}\n```\n\n读者觉得会打印什么呢？`Result: TheValue` 吗？我们来看下运行结果：\n```\np1.equals(p2)=true\nResult:  null\n```\n问题来了，p1和p2是equal的，但是确不是同样的key，至少对于HashMap而言，它们俩不是同一个key，为什么呢？\n\n我们看一下 HashMap 是怎么put和get的吧。\n```\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\npublic V get(Object key) {\n    Node<K,V> e;\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\n```\n从这段代码可以看到，p1 和 p2 被存储时就计算了一次 `hash(key)`，如下:\n```\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n其实就是调用了 `key.hashCode()` 方法，而我们知道虽然 `p1.equals(p2)=true`，但是`p1.hashCode() != p2.hashCode()`，因此 p1 和 p2 对 HashMap 而言压根就是两个 key，当然互相取不到对方的 value了。\n\n那么要如何改进这个类呢？我们再来实现它的 hashcode 方法吧。\n```\nclass PhoneNumber {\n    protected final short countryCode;\n    protected final short number;\n\n    public PhoneNumber(int countryCode, int number) {\n        this.countryCode = (short) countryCode;\n        this.number = (short) number;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        // 1. check == reference\n        if (this == obj)\n            return true;\n\n        // 2. check obj instance\n        if (!(obj instanceof PhoneNumber))\n            return false;\n\n        // 3. compare logic value\n        PhoneNumber target = (PhoneNumber) obj;\n        return target.number == this.number\n                && target.countryCode == this.countryCode;\n    }\n\n    @Override\n    public int hashCode() {\n        return (31 * this.countryCode) + this.number;\n    }\n}\n```\n这时我们的测试代码：\n```\nprivate static void test() {\n    PhoneNumber p1 = new PhoneNumber(86, 12);\n    PhoneNumber p2 = new PhoneNumber(86, 12);\n    System.out.println(\"p1.equals(p2)=\" + p1.equals(p2));\n    System.out.println(\"p1.hashcode()=\" + p1.hashCode());\n    System.out.println(\"p2.hashcode()=\" + p2.hashCode());\n\n    HashMap<PhoneNumber, String> map = new HashMap<>(2);\n    map.put(p1, \"TheValue\");\n    System.out.println(\"Result: \" + map.get(p2));\n}\n```\n打印结果如下：\n```\np1.equals(p2)=true\np1.hashcode()=88076\np2.hashcode()=88076\nResult: TheValue\n```\n说明重载hashcode后就能保证 `PhoneNumber` 在 `HashMap` 里正常运行了，毕竟像这种 HashMap HashSet 之类的都要基于对象的hash值。\n\n## 小结\n如果存在遗漏错误欢迎读者提出。\n\n谢谢。\n\nwingjay\n\nhttp://wingjay.com\n\n如果有问题，可以给我留言或发邮件<mailto:yinjiesh@126.com>","slug":"Java的equals与hashcode对比分析","published":1,"updated":"2018-11-26T06:56:27.481Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplshy002d3dn8pu401bk9","content":"<blockquote>\n<p>在阅读《Effective Java》第 3 章里读到了关于 equals() 和 hashcode() 的一些介绍，这两个方法是很多 Java 程序员容易弄混的，因此本文针对这两个方法的用法和具体实现来做一些介绍。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"equals- 与 -hashcode- 的用处？\"><a href=\"#equals- 与 -hashcode- 的用处？\" class=\"headerlink\" title=\"equals() 与 hashcode() 的用处？\"></a>equals() 与 hashcode() 的用处？</h2><p>我们一般用 <code>equals()</code> 来比较两个对象的 <code> 逻辑意义 </code> 上的值是否相同。举个例子：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</div><div class=\"line\">    String name;</div><div class=\"line\">    <span class=\"keyword\">int</span> age;</div><div class=\"line\">    <span class=\"keyword\">long</span> id;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>我们现在有两个 Person 的对象，person1 和 person2，那么什么时候这两个是相等的呢？对于两个人而言，我们认为如果他们俩名字、年龄和 ID 都完全一样，那么就是同一个人。也就是说，如果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">person1.name = person2.name</div><div class=\"line\">person1.age = person2.age</div><div class=\"line\">person1.id = person2.id</div></pre></td></tr></table></figure></p>\n<p>那么我们就认为 <code>person1.equals(person2)=true</code>。这就是表示 equals 是指二者逻辑意义上相等即可。</p>\n<p>而 hashcode() 则是对一个对象进行 hash 计算得到的一个散列值，它有以下特点：</p>\n<ol>\n<li>对象 x 和 y 的 hashcode 相同，不代表两个对象就相同(x.equals(y)=true)，可能存在 hash 碰撞；不过 hashcode 如果不相同，那么一定是两个不同的对象</li>\n<li>如果两个对象的 equals()相等，那么 hashcode 一定相等。<br>所以我们一般可以用 hashcode 来快速比较两个对象 <code> 互异</code>，因为如果<code>x.hashcode() != y.hashcode()</code>，那么<code>x.equals(y)=false</code>。</li>\n</ol>\n<h2 id=\"equals- 的特性\"><a href=\"#equals- 的特性\" class=\"headerlink\" title=\"equals() 的特性\"></a>equals() 的特性 </h2><p> 很多时候我们想要重写某个自定义 object 的 equals()方法，那么一定要记住，你的 equals()方法必须满足下面四个条件：</p>\n<ol>\n<li>自反性：对于非 null 的对象 x，必须有 <code>x.equals(x)=true</code>；</li>\n<li>对称性：如果 <code>x.equals(y)=true</code>，那么 <code>y.equals(x)</code> 必须也为<code>true</code>；</li>\n<li>传递性：如果 <code>x.equals(y)=true</code> 而且 <code>y.equals(z)=true</code>，那么<code>x.equals(z)</code> 必须为<code>true</code>；</li>\n<li>对于非 null 的对象 x，一定有<code>x.equals(null)=false</code></li>\n</ol>\n<h2 id=\"如何重载 -equals- 方法呢？\"><a href=\"# 如何重载 -equals- 方法呢？\" class=\"headerlink\" title=\"如何重载 equals() 方法呢？\"></a>如何重载 equals() 方法呢？</h2><p>一般而言，如果你要重载 equals() 方法，有下面一套模版代码可以参考：</p>\n<ol>\n<li>首先使用 <code>==</code> 来判断 <code> 两个对象是否引用相同</code>；</li>\n<li>使用 <code>instanceof</code> 来判断 <code> 两个对象是否类型相同</code>；</li>\n<li>如果类型相同，则把待比较参数转型；</li>\n<li>比较两个对象内部每个逻辑值是否相等，只有全部相等才返回 true，或者返回 false；</li>\n<li>测试这个方法是否能满足上面几个特性。</li>\n</ol>\n<h2 id=\"Java- 源码 -String- 里 -equals- 和 -hashcode- 实现\"><a href=\"#Java- 源码 -String- 里 -equals- 和 -hashcode- 实现\" class=\"headerlink\" title=\"Java 源码 String 里 equals() 和 hashcode() 实现\"></a>Java 源码 String 里 equals() 和 hashcode() 实现 </h2><p> 看完上面的特性和重载方法你可能有点头大，下面我们来看一下 Java 里的 String 是如何实现的吧，是否满足上面几个特性呢。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">public boolean equals(Object anObject) &#123;</div><div class=\"line\">    if (this == anObject) &#123;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (anObject instanceof String) &#123;</div><div class=\"line\">        String anotherString = (String)anObject;</div><div class=\"line\">        int n = value.length;</div><div class=\"line\">        if (n == anotherString.value.length) &#123;</div><div class=\"line\">            char v1[] = value;</div><div class=\"line\">            char v2[] = anotherString.value;</div><div class=\"line\">            int i = 0;</div><div class=\"line\">            while (n-- != 0) &#123;</div><div class=\"line\">                if (v1[i] != v2[i])</div><div class=\"line\">                    return false;</div><div class=\"line\">                i++;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到，上面的方法依次执行了下面的步骤：</p>\n<ol>\n<li>比较引用<code>this == anObject</code>；</li>\n<li>判断类型 <code>anObject instanceof String</code>；</li>\n<li>转型 <code>String anotherString = (String)anObject</code>；</li>\n<li>比较逻辑值 对 String 而言，首先要 <code>length</code> 相等 <code>n == anotherString.value.length</code>；然后要每一个字符相等，见代码，最后返回结果。</li>\n</ol>\n<p>下面我写了一段测试代码来验证是否符合上面几点特性：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void testStringEquals() &#123;</div><div class=\"line\">    String x = &quot;First&quot;;</div><div class=\"line\">    String y = &quot;First&quot;;</div><div class=\"line\">    String z = new String(&quot;First&quot;);</div><div class=\"line\">    System.out.println(x.equals(x));</div><div class=\"line\">    System.out.println((x.equals(y) &amp;&amp; y.equals(x)));</div><div class=\"line\">    if (x.equals(y) &amp;&amp; y.equals(x)) &#123;</div><div class=\"line\">        System.out.println(x.equals(z));</div><div class=\"line\">    &#125;</div><div class=\"line\">    System.out.println(x.equals(null));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>打印结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">true</div><div class=\"line\">true</div><div class=\"line\">true</div><div class=\"line\">false</div></pre></td></tr></table></figure></p>\n<p>说明是符合的。</p>\n<p>然后我们再看下 hashcode() 的源代码实现，我们知道，hashcode 的含义是计算 hash 散列值，其实就是对一个对象快速计算一个散列值，用来 <code> 判异 </code> 使用：只要 hashcode() 不同，那么两个对象一定不同。下面我们看下 String 是如何计算自己的 hash 值的。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">char</span> value[]; <span class=\"comment\">/** The value is used for character storage. */</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> hash; <span class=\"comment\">/** Cache the hash code for the string Default to 0 */</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> h = hash; </div><div class=\"line\">    <span class=\"keyword\">if</span> (h == <span class=\"number\">0</span> &amp;&amp; value.length &gt; <span class=\"number\">0</span>) &#123; </div><div class=\"line\">        <span class=\"keyword\">char</span> val[] = value;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; value.length; i++) &#123;</div><div class=\"line\">            h = <span class=\"number\">31</span> * h + val[i];</div><div class=\"line\">        &#125;</div><div class=\"line\">        hash = h;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> h;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中用来计算 hashcode 主要是这段代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (int i = 0; i &lt; value.length; i++) &#123;</div><div class=\"line\">    h = 31 * h + val[i];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中，value 是内部存储 string 值的字符数组。计算 hashcode 的方法就是依次遍历每一个字符，乘以 31 后再加上下一个字符。例如”a”的 hashcode 就是 97；”aa”的 hashcode 是 <code>31*97+97</code>=3104。因此可以看出，<code>hashcode 不同的两个 String 对象一定不是同一个对象</code>。</p>\n<h2 id=\"谨记：重载 -equals- 时要保证：两个 equal 的对象一定有相同的 hashcode\"><a href=\"# 谨记：重载 -equals- 时要保证：两个 equal 的对象一定有相同的 hashcode\" class=\"headerlink\" title=\"谨记：重载 equals() 时要保证：两个 equal 的对象一定有相同的 hashcode\"></a>谨记：重载 equals() 时要保证：两个 equal 的对象一定有相同的 hashcode</h2><p>很多人在重载 equals() 时忽视了这一点，没有保证两个 equal 的对象具备相同的 hashcode，从而导致了奇怪的错误。</p>\n<p>下面举一个例子，我先只重载 <code>PhoneNumberWithoutHashcode</code> 的 equals() 方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">class PhoneNumberWithoutHashcode &#123;</div><div class=\"line\">    final short countryCode;</div><div class=\"line\">    final short number;</div><div class=\"line\">    public PhoneNumberWithoutHashcode(int countryCode, int number) &#123;</div><div class=\"line\">        this.countryCode = (short) countryCode;</div><div class=\"line\">        this.number = (short) number;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public boolean equals(Object obj) &#123;</div><div class=\"line\">        // 1. check == reference</div><div class=\"line\">        if(obj == this) &#123;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\">        // 2. check obj instance</div><div class=\"line\">        if (!(obj instanceof PhoneNumberWithoutHashcode))</div><div class=\"line\">            return false;</div><div class=\"line\"></div><div class=\"line\">        // 3. compare logic value</div><div class=\"line\">        PhoneNumberWithoutHashcode anObj = (PhoneNumberWithoutHashcode) obj;</div><div class=\"line\">        return anObj.countryCode == this.countryCode </div><div class=\"line\">                &amp;&amp; anObj.number == this.number;</div><div class=\"line\">    &#125;        </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>下面我们来创建两个相同的对象，看看它们的 equals() hashcode() 返回值如何。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void test() &#123;</div><div class=\"line\">    PhoneNumberWithoutHashcode p1 = new PhoneNumberWithoutHashcode(86, 123123);</div><div class=\"line\">    PhoneNumberWithoutHashcode p2 = new PhoneNumberWithoutHashcode(86, 123123);</div><div class=\"line\">    System.out.println(&quot;p1.equals(p2)=&quot; + p1.equals(p2));</div><div class=\"line\">    System.out.println(&quot;p1.hashcode()=&quot; + p1.hashCode());</div><div class=\"line\">    System.out.println(&quot;p2.hashcode()=&quot; + p2.hashCode());    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以得到结果如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">p1.equals(p2)=true</div><div class=\"line\">p1.hashcode()=1846274136</div><div class=\"line\">p2.hashcode()=1639705018</div></pre></td></tr></table></figure></p>\n<p>可以看出，二者是 equals 的，但是 hashcode 不一样。这违背了 Java 准则，会导致什么结果呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    PhoneNumberWithoutHashcode p1 = <span class=\"keyword\">new</span> PhoneNumberWithoutHashcode(<span class=\"number\">86</span>, <span class=\"number\">123123</span>);</div><div class=\"line\">    PhoneNumberWithoutHashcode p2 = <span class=\"keyword\">new</span> PhoneNumberWithoutHashcode(<span class=\"number\">86</span>, <span class=\"number\">123123</span>);</div><div class=\"line\">    System.out.println(<span class=\"string\">\"p1.equals(p2)=\"</span> + p1.equals(p2));</div><div class=\"line\">    </div><div class=\"line\">    HashMap&lt;PhoneNumberWithoutHashcode, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</div><div class=\"line\">    map.put(p1, <span class=\"string\">\"TheValue\"</span>);</div><div class=\"line\">    System.out.println(<span class=\"string\">\"Result:\"</span> + map.get(p2));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>读者觉得会打印什么呢？<code>Result: TheValue</code> 吗？我们来看下运行结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">p1.equals(p2)=true</div><div class=\"line\">Result:  null</div></pre></td></tr></table></figure></p>\n<p>问题来了，p1 和 p2 是 equal 的，但是确不是同样的 key，至少对于 HashMap 而言，它们俩不是同一个 key，为什么呢？</p>\n<p>我们看一下 HashMap 是怎么 put 和 get 的吧。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public V put(K key, V value) &#123;</div><div class=\"line\">    return putVal(hash(key), key, value, false, true);</div><div class=\"line\">&#125;</div><div class=\"line\">public V get(Object key) &#123;</div><div class=\"line\">    Node&lt;K,V&gt; e;</div><div class=\"line\">    return (e = getNode(hash(key), key)) == null ? null : e.value;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>从这段代码可以看到，p1 和 p2 被存储时就计算了一次 <code>hash(key)</code>，如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">static final int hash(Object key) &#123;</div><div class=\"line\">    int h;</div><div class=\"line\">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其实就是调用了 <code>key.hashCode()</code> 方法，而我们知道虽然 <code>p1.equals(p2)=true</code>，但是<code>p1.hashCode() != p2.hashCode()</code>，因此 p1 和 p2 对 HashMap 而言压根就是两个 key，当然互相取不到对方的 value 了。</p>\n<p>那么要如何改进这个类呢？我们再来实现它的 hashcode 方法吧。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">class PhoneNumber &#123;</div><div class=\"line\">    protected final short countryCode;</div><div class=\"line\">    protected final short number;</div><div class=\"line\"></div><div class=\"line\">    public PhoneNumber(int countryCode, int number) &#123;</div><div class=\"line\">        this.countryCode = (short) countryCode;</div><div class=\"line\">        this.number = (short) number;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public boolean equals(Object obj) &#123;</div><div class=\"line\">        // 1. check == reference</div><div class=\"line\">        if (this == obj)</div><div class=\"line\">            return true;</div><div class=\"line\"></div><div class=\"line\">        // 2. check obj instance</div><div class=\"line\">        if (!(obj instanceof PhoneNumber))</div><div class=\"line\">            return false;</div><div class=\"line\"></div><div class=\"line\">        // 3. compare logic value</div><div class=\"line\">        PhoneNumber target = (PhoneNumber) obj;</div><div class=\"line\">        return target.number == this.number</div><div class=\"line\">                &amp;&amp; target.countryCode == this.countryCode;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public int hashCode() &#123;</div><div class=\"line\">        return (31 * this.countryCode) + this.number;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这时我们的测试代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void test() &#123;</div><div class=\"line\">    PhoneNumber p1 = new PhoneNumber(86, 12);</div><div class=\"line\">    PhoneNumber p2 = new PhoneNumber(86, 12);</div><div class=\"line\">    System.out.println(&quot;p1.equals(p2)=&quot; + p1.equals(p2));</div><div class=\"line\">    System.out.println(&quot;p1.hashcode()=&quot; + p1.hashCode());</div><div class=\"line\">    System.out.println(&quot;p2.hashcode()=&quot; + p2.hashCode());</div><div class=\"line\"></div><div class=\"line\">    HashMap&lt;PhoneNumber, String&gt; map = new HashMap&lt;&gt;(2);</div><div class=\"line\">    map.put(p1, &quot;TheValue&quot;);</div><div class=\"line\">    System.out.println(&quot;Result: &quot; + map.get(p2));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>打印结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">p1.equals(p2)=true</div><div class=\"line\">p1.hashcode()=88076</div><div class=\"line\">p2.hashcode()=88076</div><div class=\"line\">Result: TheValue</div></pre></td></tr></table></figure></p>\n<p>说明重载 hashcode 后就能保证 <code>PhoneNumber</code> 在 <code>HashMap</code> 里正常运行了，毕竟像这种 HashMap HashSet 之类的都要基于对象的 hash 值。</p>\n<h2 id=\"小结\"><a href=\"# 小结\" class=\"headerlink\" title=\"小结\"></a>小结 </h2><p> 如果存在遗漏错误欢迎读者提出。</p>\n<p>谢谢。</p>\n<p>wingjay</p>\n<p><a href=\"http://wingjay.com\">http://wingjay.com</a></p>\n<p>如果有问题，可以给我留言或发邮件<a href=\"&#109;&#97;&#105;&#108;&#116;&#x6f;&#58;&#121;&#x69;&#x6e;&#x6a;&#105;&#101;&#115;&#104;&#x40;&#x31;&#x32;&#x36;&#x2e;&#99;&#111;&#x6d;\">&#121;&#x69;&#x6e;&#x6a;&#105;&#101;&#115;&#104;&#x40;&#x31;&#x32;&#x36;&#x2e;&#99;&#111;&#x6d;</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>在阅读《Effective Java》第3章里读到了关于 equals() 和 hashcode() 的一些介绍，这两个方法是很多Java程序员容易弄混的，因此本文针对这两个方法的用法和具体实现来做一些介绍。</p>\n</blockquote>","more":"<h2 id=\"equals-与-hashcode-的用处？\"><a href=\"#equals-与-hashcode-的用处？\" class=\"headerlink\" title=\"equals() 与 hashcode() 的用处？\"></a>equals() 与 hashcode() 的用处？</h2><p>我们一般用<code>equals()</code>来比较两个对象的<code>逻辑意义</code>上的值是否相同。举个例子：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</div><div class=\"line\">    String name;</div><div class=\"line\">    <span class=\"keyword\">int</span> age;</div><div class=\"line\">    <span class=\"keyword\">long</span> id;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>我们现在有两个Person的对象，person1 和person2，那么什么时候这两个是相等的呢？对于两个人而言，我们认为如果他们俩名字、年龄和ID都完全一样，那么就是同一个人。也就是说，如果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">person1.name = person2.name</div><div class=\"line\">person1.age = person2.age</div><div class=\"line\">person1.id = person2.id</div></pre></td></tr></table></figure></p>\n<p>那么我们就认为 <code>person1.equals(person2)=true</code>。这就是表示equals是指二者逻辑意义上相等即可。</p>\n<p>而 hashcode() 则是对一个对象进行hash计算得到的一个散列值，它有以下特点：</p>\n<ol>\n<li>对象x和y的hashcode相同，不代表两个对象就相同(x.equals(y)=true)，可能存在hash碰撞；不过hashcode如果不相同，那么一定是两个不同的对象</li>\n<li>如果两个对象的equals()相等，那么hashcode一定相等。<br>所以我们一般可以用hashcode来快速比较两个对象<code>互异</code>，因为如果<code>x.hashcode() != y.hashcode()</code>，那么<code>x.equals(y)=false</code>。</li>\n</ol>\n<h2 id=\"equals-的特性\"><a href=\"#equals-的特性\" class=\"headerlink\" title=\"equals() 的特性\"></a>equals() 的特性</h2><p>很多时候我们想要重写某个自定义object的equals()方法，那么一定要记住，你的equals()方法必须满足下面四个条件：</p>\n<ol>\n<li>自反性：对于非null的对象x，必须有 <code>x.equals(x)=true</code>；</li>\n<li>对称性：如果 <code>x.equals(y)=true</code>，那么<code>y.equals(x)</code>必须也为<code>true</code>；</li>\n<li>传递性：如果<code>x.equals(y)=true</code>而且<code>y.equals(z)=true</code>，那么<code>x.equals(z)</code>必须为<code>true</code>；</li>\n<li>对于非null的对象x，一定有<code>x.equals(null)=false</code></li>\n</ol>\n<h2 id=\"如何重载-equals-方法呢？\"><a href=\"#如何重载-equals-方法呢？\" class=\"headerlink\" title=\"如何重载 equals() 方法呢？\"></a>如何重载 equals() 方法呢？</h2><p>一般而言，如果你要重载 equals() 方法，有下面一套模版代码可以参考：</p>\n<ol>\n<li>首先使用 <code>==</code> 来判断<code>两个对象是否引用相同</code>；</li>\n<li>使用 <code>instanceof</code> 来判断<code>两个对象是否类型相同</code>；</li>\n<li>如果类型相同，则把待比较参数转型；</li>\n<li>比较两个对象内部每个逻辑值是否相等，只有全部相等才返回true，或者返回false；</li>\n<li>测试这个方法是否能满足上面几个特性。</li>\n</ol>\n<h2 id=\"Java-源码-String-里-equals-和-hashcode-实现\"><a href=\"#Java-源码-String-里-equals-和-hashcode-实现\" class=\"headerlink\" title=\"Java 源码 String 里 equals() 和 hashcode() 实现\"></a>Java 源码 String 里 equals() 和 hashcode() 实现</h2><p>看完上面的特性和重载方法你可能有点头大，下面我们来看一下Java里的 String 是如何实现的吧，是否满足上面几个特性呢。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">public boolean equals(Object anObject) &#123;</div><div class=\"line\">    if (this == anObject) &#123;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (anObject instanceof String) &#123;</div><div class=\"line\">        String anotherString = (String)anObject;</div><div class=\"line\">        int n = value.length;</div><div class=\"line\">        if (n == anotherString.value.length) &#123;</div><div class=\"line\">            char v1[] = value;</div><div class=\"line\">            char v2[] = anotherString.value;</div><div class=\"line\">            int i = 0;</div><div class=\"line\">            while (n-- != 0) &#123;</div><div class=\"line\">                if (v1[i] != v2[i])</div><div class=\"line\">                    return false;</div><div class=\"line\">                i++;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到，上面的方法依次执行了下面的步骤：</p>\n<ol>\n<li>比较引用<code>this == anObject</code>；</li>\n<li>判断类型 <code>anObject instanceof String</code>；</li>\n<li>转型 <code>String anotherString = (String)anObject</code>；</li>\n<li>比较逻辑值 对 String 而言，首先要 <code>length</code> 相等 <code>n == anotherString.value.length</code>；然后要每一个字符相等，见代码，最后返回结果。</li>\n</ol>\n<p>下面我写了一段测试代码来验证是否符合上面几点特性：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void testStringEquals() &#123;</div><div class=\"line\">    String x = &quot;First&quot;;</div><div class=\"line\">    String y = &quot;First&quot;;</div><div class=\"line\">    String z = new String(&quot;First&quot;);</div><div class=\"line\">    System.out.println(x.equals(x));</div><div class=\"line\">    System.out.println((x.equals(y) &amp;&amp; y.equals(x)));</div><div class=\"line\">    if (x.equals(y) &amp;&amp; y.equals(x)) &#123;</div><div class=\"line\">        System.out.println(x.equals(z));</div><div class=\"line\">    &#125;</div><div class=\"line\">    System.out.println(x.equals(null));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>打印结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">true</div><div class=\"line\">true</div><div class=\"line\">true</div><div class=\"line\">false</div></pre></td></tr></table></figure></p>\n<p>说明是符合的。</p>\n<p>然后我们再看下 hashcode() 的源代码实现，我们知道，hashcode的含义是计算hash散列值，其实就是对一个对象快速计算一个散列值，用来<code>判异</code>使用：只要 hashcode() 不同，那么两个对象一定不同。下面我们看下 String 是如何计算自己的hash值的。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">char</span> value[]; <span class=\"comment\">/** The value is used for character storage. */</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> hash; <span class=\"comment\">/** Cache the hash code for the string Default to 0 */</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> h = hash; </div><div class=\"line\">    <span class=\"keyword\">if</span> (h == <span class=\"number\">0</span> &amp;&amp; value.length &gt; <span class=\"number\">0</span>) &#123; </div><div class=\"line\">        <span class=\"keyword\">char</span> val[] = value;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; value.length; i++) &#123;</div><div class=\"line\">            h = <span class=\"number\">31</span> * h + val[i];</div><div class=\"line\">        &#125;</div><div class=\"line\">        hash = h;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> h;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中用来计算 hashcode 主要是这段代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (int i = 0; i &lt; value.length; i++) &#123;</div><div class=\"line\">    h = 31 * h + val[i];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中，value是内部存储string值的字符数组。计算hashcode的方法就是依次遍历每一个字符，乘以31后再加上下一个字符。例如”a”的hashcode就是 97；”aa”的hashcode是 <code>31*97+97</code>=3104。因此可以看出，<code>hashcode不同的两个 String 对象一定不是同一个对象</code>。</p>\n<h2 id=\"谨记：重载-equals-时要保证：两个equal的对象一定有相同的hashcode\"><a href=\"#谨记：重载-equals-时要保证：两个equal的对象一定有相同的hashcode\" class=\"headerlink\" title=\"谨记：重载 equals() 时要保证：两个equal的对象一定有相同的hashcode\"></a>谨记：重载 equals() 时要保证：两个equal的对象一定有相同的hashcode</h2><p>很多人在重载 equals() 时忽视了这一点，没有保证两个equal的对象具备相同的hashcode，从而导致了奇怪的错误。</p>\n<p>下面举一个例子，我先只重载 <code>PhoneNumberWithoutHashcode</code> 的 equals() 方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">class PhoneNumberWithoutHashcode &#123;</div><div class=\"line\">    final short countryCode;</div><div class=\"line\">    final short number;</div><div class=\"line\">    public PhoneNumberWithoutHashcode(int countryCode, int number) &#123;</div><div class=\"line\">        this.countryCode = (short) countryCode;</div><div class=\"line\">        this.number = (short) number;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public boolean equals(Object obj) &#123;</div><div class=\"line\">        // 1. check == reference</div><div class=\"line\">        if(obj == this) &#123;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\">        // 2. check obj instance</div><div class=\"line\">        if (!(obj instanceof PhoneNumberWithoutHashcode))</div><div class=\"line\">            return false;</div><div class=\"line\"></div><div class=\"line\">        // 3. compare logic value</div><div class=\"line\">        PhoneNumberWithoutHashcode anObj = (PhoneNumberWithoutHashcode) obj;</div><div class=\"line\">        return anObj.countryCode == this.countryCode </div><div class=\"line\">                &amp;&amp; anObj.number == this.number;</div><div class=\"line\">    &#125;        </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>下面我们来创建两个相同的对象，看看它们的 equals() hashcode() 返回值如何。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void test() &#123;</div><div class=\"line\">    PhoneNumberWithoutHashcode p1 = new PhoneNumberWithoutHashcode(86, 123123);</div><div class=\"line\">    PhoneNumberWithoutHashcode p2 = new PhoneNumberWithoutHashcode(86, 123123);</div><div class=\"line\">    System.out.println(&quot;p1.equals(p2)=&quot; + p1.equals(p2));</div><div class=\"line\">    System.out.println(&quot;p1.hashcode()=&quot; + p1.hashCode());</div><div class=\"line\">    System.out.println(&quot;p2.hashcode()=&quot; + p2.hashCode());    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以得到结果如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">p1.equals(p2)=true</div><div class=\"line\">p1.hashcode()=1846274136</div><div class=\"line\">p2.hashcode()=1639705018</div></pre></td></tr></table></figure></p>\n<p>可以看出，二者是 equals 的，但是hashcode不一样。这违背了 Java准则，会导致什么结果呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    PhoneNumberWithoutHashcode p1 = <span class=\"keyword\">new</span> PhoneNumberWithoutHashcode(<span class=\"number\">86</span>, <span class=\"number\">123123</span>);</div><div class=\"line\">    PhoneNumberWithoutHashcode p2 = <span class=\"keyword\">new</span> PhoneNumberWithoutHashcode(<span class=\"number\">86</span>, <span class=\"number\">123123</span>);</div><div class=\"line\">    System.out.println(<span class=\"string\">\"p1.equals(p2)=\"</span> + p1.equals(p2));</div><div class=\"line\">    </div><div class=\"line\">    HashMap&lt;PhoneNumberWithoutHashcode, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</div><div class=\"line\">    map.put(p1, <span class=\"string\">\"TheValue\"</span>);</div><div class=\"line\">    System.out.println(<span class=\"string\">\"Result: \"</span> + map.get(p2));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>读者觉得会打印什么呢？<code>Result: TheValue</code> 吗？我们来看下运行结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">p1.equals(p2)=true</div><div class=\"line\">Result:  null</div></pre></td></tr></table></figure></p>\n<p>问题来了，p1和p2是equal的，但是确不是同样的key，至少对于HashMap而言，它们俩不是同一个key，为什么呢？</p>\n<p>我们看一下 HashMap 是怎么put和get的吧。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public V put(K key, V value) &#123;</div><div class=\"line\">    return putVal(hash(key), key, value, false, true);</div><div class=\"line\">&#125;</div><div class=\"line\">public V get(Object key) &#123;</div><div class=\"line\">    Node&lt;K,V&gt; e;</div><div class=\"line\">    return (e = getNode(hash(key), key)) == null ? null : e.value;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>从这段代码可以看到，p1 和 p2 被存储时就计算了一次 <code>hash(key)</code>，如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">static final int hash(Object key) &#123;</div><div class=\"line\">    int h;</div><div class=\"line\">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其实就是调用了 <code>key.hashCode()</code> 方法，而我们知道虽然 <code>p1.equals(p2)=true</code>，但是<code>p1.hashCode() != p2.hashCode()</code>，因此 p1 和 p2 对 HashMap 而言压根就是两个 key，当然互相取不到对方的 value了。</p>\n<p>那么要如何改进这个类呢？我们再来实现它的 hashcode 方法吧。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">class PhoneNumber &#123;</div><div class=\"line\">    protected final short countryCode;</div><div class=\"line\">    protected final short number;</div><div class=\"line\"></div><div class=\"line\">    public PhoneNumber(int countryCode, int number) &#123;</div><div class=\"line\">        this.countryCode = (short) countryCode;</div><div class=\"line\">        this.number = (short) number;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public boolean equals(Object obj) &#123;</div><div class=\"line\">        // 1. check == reference</div><div class=\"line\">        if (this == obj)</div><div class=\"line\">            return true;</div><div class=\"line\"></div><div class=\"line\">        // 2. check obj instance</div><div class=\"line\">        if (!(obj instanceof PhoneNumber))</div><div class=\"line\">            return false;</div><div class=\"line\"></div><div class=\"line\">        // 3. compare logic value</div><div class=\"line\">        PhoneNumber target = (PhoneNumber) obj;</div><div class=\"line\">        return target.number == this.number</div><div class=\"line\">                &amp;&amp; target.countryCode == this.countryCode;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public int hashCode() &#123;</div><div class=\"line\">        return (31 * this.countryCode) + this.number;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这时我们的测试代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void test() &#123;</div><div class=\"line\">    PhoneNumber p1 = new PhoneNumber(86, 12);</div><div class=\"line\">    PhoneNumber p2 = new PhoneNumber(86, 12);</div><div class=\"line\">    System.out.println(&quot;p1.equals(p2)=&quot; + p1.equals(p2));</div><div class=\"line\">    System.out.println(&quot;p1.hashcode()=&quot; + p1.hashCode());</div><div class=\"line\">    System.out.println(&quot;p2.hashcode()=&quot; + p2.hashCode());</div><div class=\"line\"></div><div class=\"line\">    HashMap&lt;PhoneNumber, String&gt; map = new HashMap&lt;&gt;(2);</div><div class=\"line\">    map.put(p1, &quot;TheValue&quot;);</div><div class=\"line\">    System.out.println(&quot;Result: &quot; + map.get(p2));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>打印结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">p1.equals(p2)=true</div><div class=\"line\">p1.hashcode()=88076</div><div class=\"line\">p2.hashcode()=88076</div><div class=\"line\">Result: TheValue</div></pre></td></tr></table></figure></p>\n<p>说明重载hashcode后就能保证 <code>PhoneNumber</code> 在 <code>HashMap</code> 里正常运行了，毕竟像这种 HashMap HashSet 之类的都要基于对象的hash值。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>如果存在遗漏错误欢迎读者提出。</p>\n<p>谢谢。</p>\n<p>wingjay</p>\n<p><a href=\"http://wingjay.com\">http://wingjay.com</a></p>\n<p>如果有问题，可以给我留言或发邮件<a href=\"&#109;&#97;&#105;&#108;&#116;&#x6f;&#58;&#121;&#x69;&#x6e;&#x6a;&#105;&#101;&#115;&#104;&#x40;&#x31;&#x32;&#x36;&#x2e;&#99;&#111;&#x6d;\">&#121;&#x69;&#x6e;&#x6a;&#105;&#101;&#115;&#104;&#x40;&#x31;&#x32;&#x36;&#x2e;&#99;&#111;&#x6d;</a></p>","sticky":0},{"title":"RxLifecycle 源码解析－当 Activity 被 destory 时自动停掉网络请求","date":"2016-07-14T12:50:37.000Z","commentIssueId":15,"_content":"\n> 私以为，阅读开源项目是与世界级技术大牛直接对话的最好方式。\n此次来分享下 RxLifecycle 源码的分析。\n\n<!-- more -->\n**此文需要读者对RxJava有一定了解**\n\n## 一、 介绍\n本文分析思路不是从源码里抽代码出来一步步跟踪，而是提出问题，一步步思考解决方法，从而学习到开源项目的思维精华，而不仅仅是了解该项目的具体实现。笔者认为这种方式更有利于读者提高自身思维方式和技术能力。\n\n## 二、 开源项目\n[RxLifecycle](https://github.com/trello/RxLifecycle) 地址：https://github.com/trello/RxLifecycle 。该项目是为了防止`RxJava`中`subscription`导致内存泄漏而诞生的，核心思想是通过监听`Activity`、`Fragment`的生命周期，来自动断开`subscription`以防止内存泄漏。\n\n基本用法如下：\n```java\nmyObservable\n    .compose(RxLifecycle.bindUntilEvent(lifecycle, ActivityEvent.DESTROY))\n    .subscribe();\n```\n此处`myObservable`可以看成一个耗时的网络请求，通过绑定到`ActivityEvent.DESTROY`，一旦Activity发生了`DESTORY`生命周期，数据就不会再流向`subscriber`，即不会对这些数据进行任何处理和UI绘制，从而提高安全性。\n\n\n\n## 三、 问题\nAndroid开发中常会有这样一个场景：\n1. 发送网络请求 -> 2. 服务器处理请求并返回数据 -> 3. client端接收数据，绘制UI。\n\n在前两步一般都是不会出现问题的，但是在第三步，当数据返回给client端时，如果页面已经不在了，那么就无法去绘制UI，很有可能会导致意向不到的问题。因此，为了解决这个问题，一个好的思路就是`当页面离开时，自动断开网络请求数据的处理过程，即数据返回后不再进行任何处理`。\n\n\n## 四、 思考\n要达到上面这样一个功能，我们可以思考，至少需要两部分：\n1. 随时监听`Activity`(`Fragment`)的生命周期并对外发射出去；\n2. 在我们的网络请求中，接收生命周期并进行判断，如果该生命周期是自己绑定的，如`Destory`，那么就断开数据向下传递的过程。\n\n## 五、 分析\n可以看到，首先有一个核心功能要实现：就是既能够监听`Activity`生命周期事件并对外发射，又能够接收每一个生命周期事件并作出判断。为了实现这个功能，可以联想到`RxJava`中的`Subject`，既能够发射数据，又能够接收数据。\n\n## 六、 Subject解析\n了解`Subject`的读者可以跳过这部分。\n\n如何理解`Subject`呢？\n\n很容易，在RxJava里面，`Observable`是数据的发射者，它会对外发射数据，然后经过`map`、`flatmap`等等数据处理后，最终传递给`Observer`，这个数据接收者。因此，抛开中间数据处理不管，可以看出，`Observable`对外发射数据，是数据流的开端；`Observer`接收数据，是数据流的末端。\n\n那么`Subject`呢？看一眼源码：\n```\n/**\n * Represents an object that is both an Observable and an Observer.\n */\npublic abstract class Subject<T, R> extends Observable<R> implements Observer<T> {}\n```\n首先，它`extends Observable<R>`，说明`Subject`具备了对外发射数据的能力，即拥有了`from()`、`just()`等等；另外，它又`implements Observer<T>`，说明又能够处理数据，具备`onNext()`、`onCompleted`等等。\n\n然后，`Subject`毕竟只是一个抽象类，那么我们要如何使用它呢？\n\n这里介绍一种最简单的：`PublishSubject`:\n```\n  PublishSubject<Object> subject = PublishSubject.create();\n  // myObserver will receive \"one\" & \"two\" and onCompleted events\n  subject.subscribe(myObserver);\n  subject.onNext(\"one\");\n  subject.onNext(\"two\");\n  subject.onCompleted();\n```\n这里做的事情很简单，先创建一个`PublishSubject` -> 绑定一个`myObserver`，此时`subject`扮演了`Observable`的角色，把数据发射给`myObserver` -> 然后`subject`处理接收了两个数据`one`、`two` -> 最终这些数据都传递给了`myObserver`。所以，`subject`扮演的角色是:\n\n**数据`one`、`two`   =>   (Observer) `subject` (Observable)   =>   `myObserver`**\n\n简单来说，我们把数据`one`、`two`塞给`subject`，然后`subject`又发射给了`myObserver`。\n\n## 七、 BaseActivity监听生命周期\n那么我们先来实现生命周期监听功能，基本思路是：在`BaseActivity`里创建一个`PublishSubject`对象，在每个生命周期发生时，把该生命周期事件传递给`PublishSubject`。具体实现如下(只写部分生命周期，其他类似)：\n```java\nclass BaseActivity {\n\t\n\tprotected final PublishSubject<ActivityLifeCycleEvent> lifecycleSubject = PublishSubject.create();\n\n\t@Override\n  \tprotected void onCreate(Bundle savedInstanceState) {\n  \t\tlifecycleSubject.onNext(ActivityLifeCycleEvent.CREATE);\n  \t\t...\n  \t}\n\n  \t@Override\n  \tprotected void onPause() {\n  \t\tlifecycleSubject.onNext(ActivityLifeCycleEvent.PAUSE);\n  \t\t...\n  \t}\n\n  \t@Override\n  \tprotected void onStop() {\n  \t\tlifecycleSubject.onNext(ActivityLifeCycleEvent.STOP);\n  \t\t...\n  \t}\n  \t...\n}\n```\n这样的话，我们把所有生命周期事件都传给了`lifecycleSubject`了，或者说，`lifecycleSubject`已经接收到了并能够`对外发射各种生命周期事件`的能力了。\n\n## 八、 改良每一个Observable，接收生命周期并自动断开自身\n通常我们的一次网络请求长这样：\n```java\nnetworkObservable\n\t.subscribe(new Observer(  handleUI()  ));\n```\n其中，`networkObservable`表示一个通用的网络请求，会接收网络数据并传递给`Observer`去绘制UI。\n\n现在，我们希望这个`networkObservable`监听`Activity`的`DESTORY`事件，一旦发生了`DESTORY`就自动断开`Observer`，即使网络数据回来了也不再传递给`Observer`去绘制UI。即：\n```java\nnetworkObservable\n\t.compose(bindUntilEvent(ActivityLifeCycleEvent.DESTORY))\n\t.subscribe(new Observer(  handleUI()  ));\n```\n因此，我们需要实现\n```java\nbindUntilEvent(ActivityLifeCycleEvent.DESTORY)\n```\n这个方法，那如何实现呢？\n\n我们知道`lifecycleSubject`能够发射生命周期事件了，那么我们可以让`networkObservable`去检查`lifecycleSubject`发出的生命周期，如果和自己绑定的生命周期事件一样，那就自动停掉即可。\n\n## 九、 改装networkObservable\n对于`networkObservable自动停掉`，我们可以利用操作符\n```\nnetworkObservable.takeUntil(otherObservable)\n```\n它的作用是监听`otherObservable`，一旦`otherObservable`对外发射了数据，就自动把`networkObservable`停掉；\n\n那`otherObservable`何时对外发射数据呢？当然是`lifecycleSubject`发射出的生命周期事件`等于`绑定的生命周期事件时，开始发射。\n```java\n\totherObservable = lifecycleSubject.takeFirst(new Func1<ActivityLifeCycleEvent, Boolean>() {\n              @Override\n              public Boolean call(ActivityLifeCycleEvent activityLifeCycleEvent) {\n                return activityLifeCycleEvent.equals(bindEvent);\n              }\n            });\n```\n其中的关键是判断`activityLifeCycleEvent.equals(bindEvent);`，一旦条件满足，`otherObservable`就对外发射数据，然后`networkObservable`就立即自动停掉。\n\n## 十、 合并 生命周期监听 与 networkObservable改良\n1. 在BaseActivity里添加`lifecycleSubject`，并把每一个生命周期事件按时传递给`lifecycleSubject`\n2. 在BaseActivity里添加一个`bindUntilEvent`方法:\n```java\n  @NonNull\n  @Override\n  public <T> Observable.Transformer<T, T> bindUntilEvent(@NonNull final ActivityLifeCycleEvent event) {\n    return new Observable.Transformer<T, T>() {\n      @Override\n      public Observable<T> call(Observable<T> sourceObservable) {\n        Observable<ActivityLifeCycleEvent> compareLifecycleObservable =\n            lifecycleSubject.takeFirst(new Func1<ActivityLifeCycleEvent, Boolean>() {\n              @Override\n              public Boolean call(ActivityLifeCycleEvent activityLifeCycleEvent) {\n                return activityLifeCycleEvent.equals(event);\n              }\n            });\n        return sourceObservable.takeUntil(compareLifecycleObservable);\n      }\n    };\n  }\n```\n\n3. 在任意一个网络请求 networkObservable 处改良\n```\nnetworkObservable\n\t.compose(bindUntilEvent(ActivityLifeCycleEvent.DESTORY))\n\t.subscribe(new Observer(  handleUI()  ));\n```\n\n## 注意：\n1. 文中提到的`networkObservable`是网络请求，但实际上这不限于网络请求，任何耗时操作如文件io操作等都可以利用这个方法，来监听生命周期并自动暂停。\n2. 对于Fragment中的处理方法也是类似。\n\n\n谢谢！\n\nwingjay\n---\n\n欢迎各位关注\n[我的Github](https://github.com/wingjay): <https://github.com/wingjay> \n和 \n[我的个人博客](http://wingjay.com): <http://wingjay.com>\n和\n[我的简书](http://www.jianshu.com/users/da333fd63fe5/latest_articles): <http://www.jianshu.com/users/da333fd63fe5/latest_articles>\n和\n[微博 iam_wingjay](http://weibo.com/u/1625892654): <http://weibo.com/u/1625892654>\n如果有问题，可以给我留言或发邮件<mailto:yinjiesh@126.com>\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n\n\n\n\n","source":"_posts/RxLifecycle源码解析－当Activity被destory时自动暂停网络请求.md","raw":"title: RxLifecycle源码解析－当Activity被destory时自动停掉网络请求\ndate: 2016-07-14 20:50:37\ncategories:\n  - Android\n  - 带你学开源项目\ntags: \n\t- Android\n\t- RxJava \n  - 带你学开源项目\ncommentIssueId: 15  \n---\n\n> 私以为，阅读开源项目是与世界级技术大牛直接对话的最好方式。\n此次来分享下 RxLifecycle 源码的分析。\n\n<!-- more -->\n**此文需要读者对RxJava有一定了解**\n\n## 一、 介绍\n本文分析思路不是从源码里抽代码出来一步步跟踪，而是提出问题，一步步思考解决方法，从而学习到开源项目的思维精华，而不仅仅是了解该项目的具体实现。笔者认为这种方式更有利于读者提高自身思维方式和技术能力。\n\n## 二、 开源项目\n[RxLifecycle](https://github.com/trello/RxLifecycle) 地址：https://github.com/trello/RxLifecycle 。该项目是为了防止`RxJava`中`subscription`导致内存泄漏而诞生的，核心思想是通过监听`Activity`、`Fragment`的生命周期，来自动断开`subscription`以防止内存泄漏。\n\n基本用法如下：\n```java\nmyObservable\n    .compose(RxLifecycle.bindUntilEvent(lifecycle, ActivityEvent.DESTROY))\n    .subscribe();\n```\n此处`myObservable`可以看成一个耗时的网络请求，通过绑定到`ActivityEvent.DESTROY`，一旦Activity发生了`DESTORY`生命周期，数据就不会再流向`subscriber`，即不会对这些数据进行任何处理和UI绘制，从而提高安全性。\n\n\n\n## 三、 问题\nAndroid开发中常会有这样一个场景：\n1. 发送网络请求 -> 2. 服务器处理请求并返回数据 -> 3. client端接收数据，绘制UI。\n\n在前两步一般都是不会出现问题的，但是在第三步，当数据返回给client端时，如果页面已经不在了，那么就无法去绘制UI，很有可能会导致意向不到的问题。因此，为了解决这个问题，一个好的思路就是`当页面离开时，自动断开网络请求数据的处理过程，即数据返回后不再进行任何处理`。\n\n\n## 四、 思考\n要达到上面这样一个功能，我们可以思考，至少需要两部分：\n1. 随时监听`Activity`(`Fragment`)的生命周期并对外发射出去；\n2. 在我们的网络请求中，接收生命周期并进行判断，如果该生命周期是自己绑定的，如`Destory`，那么就断开数据向下传递的过程。\n\n## 五、 分析\n可以看到，首先有一个核心功能要实现：就是既能够监听`Activity`生命周期事件并对外发射，又能够接收每一个生命周期事件并作出判断。为了实现这个功能，可以联想到`RxJava`中的`Subject`，既能够发射数据，又能够接收数据。\n\n## 六、 Subject解析\n了解`Subject`的读者可以跳过这部分。\n\n如何理解`Subject`呢？\n\n很容易，在RxJava里面，`Observable`是数据的发射者，它会对外发射数据，然后经过`map`、`flatmap`等等数据处理后，最终传递给`Observer`，这个数据接收者。因此，抛开中间数据处理不管，可以看出，`Observable`对外发射数据，是数据流的开端；`Observer`接收数据，是数据流的末端。\n\n那么`Subject`呢？看一眼源码：\n```\n/**\n * Represents an object that is both an Observable and an Observer.\n */\npublic abstract class Subject<T, R> extends Observable<R> implements Observer<T> {}\n```\n首先，它`extends Observable<R>`，说明`Subject`具备了对外发射数据的能力，即拥有了`from()`、`just()`等等；另外，它又`implements Observer<T>`，说明又能够处理数据，具备`onNext()`、`onCompleted`等等。\n\n然后，`Subject`毕竟只是一个抽象类，那么我们要如何使用它呢？\n\n这里介绍一种最简单的：`PublishSubject`:\n```\n  PublishSubject<Object> subject = PublishSubject.create();\n  // myObserver will receive \"one\" & \"two\" and onCompleted events\n  subject.subscribe(myObserver);\n  subject.onNext(\"one\");\n  subject.onNext(\"two\");\n  subject.onCompleted();\n```\n这里做的事情很简单，先创建一个`PublishSubject` -> 绑定一个`myObserver`，此时`subject`扮演了`Observable`的角色，把数据发射给`myObserver` -> 然后`subject`处理接收了两个数据`one`、`two` -> 最终这些数据都传递给了`myObserver`。所以，`subject`扮演的角色是:\n\n**数据`one`、`two`   =>   (Observer) `subject` (Observable)   =>   `myObserver`**\n\n简单来说，我们把数据`one`、`two`塞给`subject`，然后`subject`又发射给了`myObserver`。\n\n## 七、 BaseActivity监听生命周期\n那么我们先来实现生命周期监听功能，基本思路是：在`BaseActivity`里创建一个`PublishSubject`对象，在每个生命周期发生时，把该生命周期事件传递给`PublishSubject`。具体实现如下(只写部分生命周期，其他类似)：\n```java\nclass BaseActivity {\n\t\n\tprotected final PublishSubject<ActivityLifeCycleEvent> lifecycleSubject = PublishSubject.create();\n\n\t@Override\n  \tprotected void onCreate(Bundle savedInstanceState) {\n  \t\tlifecycleSubject.onNext(ActivityLifeCycleEvent.CREATE);\n  \t\t...\n  \t}\n\n  \t@Override\n  \tprotected void onPause() {\n  \t\tlifecycleSubject.onNext(ActivityLifeCycleEvent.PAUSE);\n  \t\t...\n  \t}\n\n  \t@Override\n  \tprotected void onStop() {\n  \t\tlifecycleSubject.onNext(ActivityLifeCycleEvent.STOP);\n  \t\t...\n  \t}\n  \t...\n}\n```\n这样的话，我们把所有生命周期事件都传给了`lifecycleSubject`了，或者说，`lifecycleSubject`已经接收到了并能够`对外发射各种生命周期事件`的能力了。\n\n## 八、 改良每一个Observable，接收生命周期并自动断开自身\n通常我们的一次网络请求长这样：\n```java\nnetworkObservable\n\t.subscribe(new Observer(  handleUI()  ));\n```\n其中，`networkObservable`表示一个通用的网络请求，会接收网络数据并传递给`Observer`去绘制UI。\n\n现在，我们希望这个`networkObservable`监听`Activity`的`DESTORY`事件，一旦发生了`DESTORY`就自动断开`Observer`，即使网络数据回来了也不再传递给`Observer`去绘制UI。即：\n```java\nnetworkObservable\n\t.compose(bindUntilEvent(ActivityLifeCycleEvent.DESTORY))\n\t.subscribe(new Observer(  handleUI()  ));\n```\n因此，我们需要实现\n```java\nbindUntilEvent(ActivityLifeCycleEvent.DESTORY)\n```\n这个方法，那如何实现呢？\n\n我们知道`lifecycleSubject`能够发射生命周期事件了，那么我们可以让`networkObservable`去检查`lifecycleSubject`发出的生命周期，如果和自己绑定的生命周期事件一样，那就自动停掉即可。\n\n## 九、 改装networkObservable\n对于`networkObservable自动停掉`，我们可以利用操作符\n```\nnetworkObservable.takeUntil(otherObservable)\n```\n它的作用是监听`otherObservable`，一旦`otherObservable`对外发射了数据，就自动把`networkObservable`停掉；\n\n那`otherObservable`何时对外发射数据呢？当然是`lifecycleSubject`发射出的生命周期事件`等于`绑定的生命周期事件时，开始发射。\n```java\n\totherObservable = lifecycleSubject.takeFirst(new Func1<ActivityLifeCycleEvent, Boolean>() {\n              @Override\n              public Boolean call(ActivityLifeCycleEvent activityLifeCycleEvent) {\n                return activityLifeCycleEvent.equals(bindEvent);\n              }\n            });\n```\n其中的关键是判断`activityLifeCycleEvent.equals(bindEvent);`，一旦条件满足，`otherObservable`就对外发射数据，然后`networkObservable`就立即自动停掉。\n\n## 十、 合并 生命周期监听 与 networkObservable改良\n1. 在BaseActivity里添加`lifecycleSubject`，并把每一个生命周期事件按时传递给`lifecycleSubject`\n2. 在BaseActivity里添加一个`bindUntilEvent`方法:\n```java\n  @NonNull\n  @Override\n  public <T> Observable.Transformer<T, T> bindUntilEvent(@NonNull final ActivityLifeCycleEvent event) {\n    return new Observable.Transformer<T, T>() {\n      @Override\n      public Observable<T> call(Observable<T> sourceObservable) {\n        Observable<ActivityLifeCycleEvent> compareLifecycleObservable =\n            lifecycleSubject.takeFirst(new Func1<ActivityLifeCycleEvent, Boolean>() {\n              @Override\n              public Boolean call(ActivityLifeCycleEvent activityLifeCycleEvent) {\n                return activityLifeCycleEvent.equals(event);\n              }\n            });\n        return sourceObservable.takeUntil(compareLifecycleObservable);\n      }\n    };\n  }\n```\n\n3. 在任意一个网络请求 networkObservable 处改良\n```\nnetworkObservable\n\t.compose(bindUntilEvent(ActivityLifeCycleEvent.DESTORY))\n\t.subscribe(new Observer(  handleUI()  ));\n```\n\n## 注意：\n1. 文中提到的`networkObservable`是网络请求，但实际上这不限于网络请求，任何耗时操作如文件io操作等都可以利用这个方法，来监听生命周期并自动暂停。\n2. 对于Fragment中的处理方法也是类似。\n\n\n谢谢！\n\nwingjay\n---\n\n欢迎各位关注\n[我的Github](https://github.com/wingjay): <https://github.com/wingjay> \n和 \n[我的个人博客](http://wingjay.com): <http://wingjay.com>\n和\n[我的简书](http://www.jianshu.com/users/da333fd63fe5/latest_articles): <http://www.jianshu.com/users/da333fd63fe5/latest_articles>\n和\n[微博 iam_wingjay](http://weibo.com/u/1625892654): <http://weibo.com/u/1625892654>\n如果有问题，可以给我留言或发邮件<mailto:yinjiesh@126.com>\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n\n\n\n\n","slug":"RxLifecycle源码解析－当Activity被destory时自动暂停网络请求","published":1,"updated":"2018-11-26T06:56:27.481Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplshz002e3dn80qy9srhw","content":"<blockquote>\n<p>私以为，阅读开源项目是与世界级技术大牛直接对话的最好方式。<br>此次来分享下 RxLifecycle 源码的分析。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p><strong>此文需要读者对 RxJava 有一定了解</strong></p>\n<h2 id=\"一、- 介绍\"><a href=\"# 一、- 介绍\" class=\"headerlink\" title=\"一、 介绍\"></a>一、 介绍 </h2><p> 本文分析思路不是从源码里抽代码出来一步步跟踪，而是提出问题，一步步思考解决方法，从而学习到开源项目的思维精华，而不仅仅是了解该项目的具体实现。笔者认为这种方式更有利于读者提高自身思维方式和技术能力。</p>\n<h2 id=\"二、- 开源项目\"><a href=\"# 二、- 开源项目\" class=\"headerlink\" title=\"二、 开源项目\"></a>二、 开源项目 </h2><p><a href=\"https://github.com/trello/RxLifecycle\" target=\"_blank\" rel=\"external\">RxLifecycle</a> 地址：<a href=\"https://github.com/trello/RxLifecycle\" target=\"_blank\" rel=\"external\">https://github.com/trello/RxLifecycle</a> 。该项目是为了防止<code>RxJava</code> 中<code>subscription</code>导致内存泄漏而诞生的，核心思想是通过监听 <code>Activity</code>、<code>Fragment</code> 的生命周期，来自动断开 <code>subscription</code> 以防止内存泄漏。</p>\n<p>基本用法如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">myObservable</div><div class=\"line\">    .compose(RxLifecycle.bindUntilEvent(lifecycle, ActivityEvent.DESTROY))</div><div class=\"line\">    .subscribe();</div></pre></td></tr></table></figure></p>\n<p>此处 <code>myObservable</code> 可以看成一个耗时的网络请求，通过绑定到 <code>ActivityEvent.DESTROY</code>，一旦 Activity 发生了<code>DESTORY</code> 生命周期，数据就不会再流向<code>subscriber</code>，即不会对这些数据进行任何处理和 UI 绘制，从而提高安全性。</p>\n<h2 id=\"三、- 问题\"><a href=\"# 三、- 问题\" class=\"headerlink\" title=\"三、 问题\"></a>三、 问题</h2><p>Android 开发中常会有这样一个场景：</p>\n<ol>\n<li>发送网络请求 -&gt; 2. 服务器处理请求并返回数据 -&gt; 3. client 端接收数据，绘制 UI。</li>\n</ol>\n<p>在前两步一般都是不会出现问题的，但是在第三步，当数据返回给 client 端时，如果页面已经不在了，那么就无法去绘制 UI，很有可能会导致意向不到的问题。因此，为了解决这个问题，一个好的思路就是 <code> 当页面离开时，自动断开网络请求数据的处理过程，即数据返回后不再进行任何处理</code>。</p>\n<h2 id=\"四、- 思考\"><a href=\"# 四、- 思考\" class=\"headerlink\" title=\"四、 思考\"></a>四、 思考 </h2><p> 要达到上面这样一个功能，我们可以思考，至少需要两部分：</p>\n<ol>\n<li>随时监听 <code>Activity</code>(<code>Fragment</code>) 的生命周期并对外发射出去；</li>\n<li>在我们的网络请求中，接收生命周期并进行判断，如果该生命周期是自己绑定的，如<code>Destory</code>，那么就断开数据向下传递的过程。</li>\n</ol>\n<h2 id=\"五、- 分析\"><a href=\"# 五、- 分析\" class=\"headerlink\" title=\"五、 分析\"></a>五、 分析 </h2><p> 可以看到，首先有一个核心功能要实现：就是既能够监听 <code>Activity</code> 生命周期事件并对外发射，又能够接收每一个生命周期事件并作出判断。为了实现这个功能，可以联想到 <code>RxJava</code> 中的<code>Subject</code>，既能够发射数据，又能够接收数据。</p>\n<h2 id=\"六、-Subject 解析\"><a href=\"# 六、-Subject 解析\" class=\"headerlink\" title=\"六、 Subject 解析\"></a>六、 Subject 解析 </h2><p> 了解 <code>Subject</code> 的读者可以跳过这部分。</p>\n<p>如何理解 <code>Subject</code> 呢？</p>\n<p>很容易，在 RxJava 里面，<code>Observable</code>是数据的发射者，它会对外发射数据，然后经过 <code>map</code>、<code>flatmap</code> 等等数据处理后，最终传递给 <code>Observer</code>，这个数据接收者。因此，抛开中间数据处理不管，可以看出，<code>Observable</code> 对外发射数据，是数据流的开端；<code>Observer</code>接收数据，是数据流的末端。</p>\n<p>那么 <code>Subject</code> 呢？看一眼源码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Represents an object that is both an Observable and an Observer.</div><div class=\"line\"> */</div><div class=\"line\">public abstract class Subject&lt;T, R&gt; extends Observable&lt;R&gt; implements Observer&lt;T&gt; &#123;&#125;</div></pre></td></tr></table></figure></p>\n<p>首先，它 <code>extends Observable&lt;R&gt;</code>，说明<code>Subject</code> 具备了对外发射数据的能力，即拥有了 <code>from()</code>、<code>just()</code> 等等；另外，它又 <code>implements Observer&lt;T&gt;</code>，说明又能够处理数据，具备<code>onNext()</code>、<code>onCompleted</code> 等等。</p>\n<p>然后，<code>Subject</code>毕竟只是一个抽象类，那么我们要如何使用它呢？</p>\n<p>这里介绍一种最简单的：<code>PublishSubject</code>:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">PublishSubject&lt;Object&gt; subject = PublishSubject.create();</div><div class=\"line\">// myObserver will receive &quot;one&quot; &amp; &quot;two&quot; and onCompleted events</div><div class=\"line\">subject.subscribe(myObserver);</div><div class=\"line\">subject.onNext(&quot;one&quot;);</div><div class=\"line\">subject.onNext(&quot;two&quot;);</div><div class=\"line\">subject.onCompleted();</div></pre></td></tr></table></figure></p>\n<p>这里做的事情很简单，先创建一个 <code>PublishSubject</code> -&gt; 绑定一个<code>myObserver</code>，此时<code>subject</code> 扮演了 <code>Observable</code> 的角色，把数据发射给 <code>myObserver</code> -&gt; 然后<code>subject</code> 处理接收了两个数据 <code>one</code>、<code>two</code> -&gt; 最终这些数据都传递给了<code>myObserver</code>。所以，<code>subject</code> 扮演的角色是:</p>\n<p><strong>数据<code>one</code>、<code>two</code>   =&gt;   (Observer) <code>subject</code> (Observable)   =&gt;   <code>myObserver</code></strong></p>\n<p>简单来说，我们把数据 <code>one</code>、<code>two</code> 塞给 <code>subject</code>，然后<code>subject</code> 又发射给了<code>myObserver</code>。</p>\n<h2 id=\"七、-BaseActivity 监听生命周期\"><a href=\"# 七、-BaseActivity 监听生命周期\" class=\"headerlink\" title=\"七、 BaseActivity 监听生命周期\"></a>七、 BaseActivity 监听生命周期 </h2><p> 那么我们先来实现生命周期监听功能，基本思路是：在 <code>BaseActivity</code> 里创建一个 <code>PublishSubject</code> 对象，在每个生命周期发生时，把该生命周期事件传递给<code>PublishSubject</code>。具体实现如下(只写部分生命周期，其他类似)：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseActivity</span> </span>&#123;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> PublishSubject&lt;ActivityLifeCycleEvent&gt; lifecycleSubject = PublishSubject.create();</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">  \t<span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">  \t\tlifecycleSubject.onNext(ActivityLifeCycleEvent.CREATE);</div><div class=\"line\">  \t\t...</div><div class=\"line\">  \t&#125;</div><div class=\"line\"></div><div class=\"line\">  \t<span class=\"meta\">@Override</span></div><div class=\"line\">  \t<span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onPause</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  \t\tlifecycleSubject.onNext(ActivityLifeCycleEvent.PAUSE);</div><div class=\"line\">  \t\t...</div><div class=\"line\">  \t&#125;</div><div class=\"line\"></div><div class=\"line\">  \t<span class=\"meta\">@Override</span></div><div class=\"line\">  \t<span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStop</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  \t\tlifecycleSubject.onNext(ActivityLifeCycleEvent.STOP);</div><div class=\"line\">  \t\t...</div><div class=\"line\">  \t&#125;</div><div class=\"line\">  \t...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样的话，我们把所有生命周期事件都传给了 <code>lifecycleSubject</code> 了，或者说，<code>lifecycleSubject</code>已经接收到了并能够 <code> 对外发射各种生命周期事件 </code> 的能力了。</p>\n<h2 id=\"八、- 改良每一个 Observable，接收生命周期并自动断开自身\"><a href=\"# 八、- 改良每一个 Observable，接收生命周期并自动断开自身\" class=\"headerlink\" title=\"八、 改良每一个 Observable，接收生命周期并自动断开自身\"></a>八、 改良每一个 Observable，接收生命周期并自动断开自身 </h2><p> 通常我们的一次网络请求长这样：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">networkObservable</div><div class=\"line\">\t.subscribe(<span class=\"keyword\">new</span> Observer(handleUI()  ));</div></pre></td></tr></table></figure></p>\n<p>其中，<code>networkObservable</code>表示一个通用的网络请求，会接收网络数据并传递给 <code>Observer</code> 去绘制 UI。</p>\n<p>现在，我们希望这个 <code>networkObservable</code> 监听 <code>Activity</code> 的<code>DESTORY</code>事件，一旦发生了 <code>DESTORY</code> 就自动断开 <code>Observer</code>，即使网络数据回来了也不再传递给<code>Observer</code> 去绘制 UI。即：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">networkObservable</div><div class=\"line\">\t.compose(bindUntilEvent(ActivityLifeCycleEvent.DESTORY))</div><div class=\"line\">\t.subscribe(<span class=\"keyword\">new</span> Observer(handleUI()  ));</div></pre></td></tr></table></figure></p>\n<p>因此，我们需要实现<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">bindUntilEvent(ActivityLifeCycleEvent.DESTORY)</div></pre></td></tr></table></figure></p>\n<p>这个方法，那如何实现呢？</p>\n<p>我们知道 <code>lifecycleSubject</code> 能够发射生命周期事件了，那么我们可以让 <code>networkObservable</code> 去检查 <code>lifecycleSubject</code> 发出的生命周期，如果和自己绑定的生命周期事件一样，那就自动停掉即可。</p>\n<h2 id=\"九、- 改装 networkObservable\"><a href=\"# 九、- 改装 networkObservable\" class=\"headerlink\" title=\"九、 改装 networkObservable\"></a>九、 改装 networkObservable</h2><p>对于<code>networkObservable 自动停掉</code>，我们可以利用操作符<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">networkObservable.takeUntil(otherObservable)</div></pre></td></tr></table></figure></p>\n<p>它的作用是监听 <code>otherObservable</code>，一旦<code>otherObservable</code> 对外发射了数据，就自动把 <code>networkObservable</code> 停掉；</p>\n<p>那 <code>otherObservable</code> 何时对外发射数据呢？当然是 <code>lifecycleSubject</code> 发射出的生命周期事件 <code> 等于 </code> 绑定的生命周期事件时，开始发射。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">otherObservable = lifecycleSubject.takeFirst(<span class=\"keyword\">new</span> Func1&lt;ActivityLifeCycleEvent, Boolean&gt;() &#123;</div><div class=\"line\">             <span class=\"meta\">@Override</span></div><div class=\"line\">             <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">call</span><span class=\"params\">(ActivityLifeCycleEvent activityLifeCycleEvent)</span> </span>&#123;</div><div class=\"line\">               <span class=\"keyword\">return</span> activityLifeCycleEvent.equals(bindEvent);</div><div class=\"line\">             &#125;</div><div class=\"line\">           &#125;);</div></pre></td></tr></table></figure></p>\n<p>其中的关键是判断 <code>activityLifeCycleEvent.equals(bindEvent);</code>，一旦条件满足，<code>otherObservable</code> 就对外发射数据，然后 <code>networkObservable</code> 就立即自动停掉。</p>\n<h2 id=\"十、- 合并 - 生命周期监听 - 与 -networkObservable 改良\"><a href=\"# 十、- 合并 - 生命周期监听 - 与 -networkObservable 改良\" class=\"headerlink\" title=\"十、 合并 生命周期监听 与 networkObservable 改良\"></a>十、 合并 生命周期监听 与 networkObservable 改良</h2><ol>\n<li>在 BaseActivity 里添加<code>lifecycleSubject</code>，并把每一个生命周期事件按时传递给<code>lifecycleSubject</code></li>\n<li><p>在 BaseActivity 里添加一个 <code>bindUntilEvent</code> 方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@NonNull</span></div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; Observable.<span class=\"function\">Transformer&lt;T, T&gt; <span class=\"title\">bindUntilEvent</span><span class=\"params\">(@NonNull <span class=\"keyword\">final</span> ActivityLifeCycleEvent event)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Observable.Transformer&lt;T, T&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Observable&lt;T&gt; <span class=\"title\">call</span><span class=\"params\">(Observable&lt;T&gt; sourceObservable)</span> </span>&#123;</div><div class=\"line\">      Observable&lt;ActivityLifeCycleEvent&gt; compareLifecycleObservable =</div><div class=\"line\">          lifecycleSubject.takeFirst(<span class=\"keyword\">new</span> Func1&lt;ActivityLifeCycleEvent, Boolean&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">call</span><span class=\"params\">(ActivityLifeCycleEvent activityLifeCycleEvent)</span> </span>&#123;</div><div class=\"line\">              <span class=\"keyword\">return</span> activityLifeCycleEvent.equals(event);</div><div class=\"line\">            &#125;</div><div class=\"line\">          &#125;);</div><div class=\"line\">      <span class=\"keyword\">return</span> sourceObservable.takeUntil(compareLifecycleObservable);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>在任意一个网络请求 networkObservable 处改良</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">networkObservable</div><div class=\"line\">\t.compose(bindUntilEvent(ActivityLifeCycleEvent.DESTORY))</div><div class=\"line\">\t.subscribe(new Observer(  handleUI()  ));</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"注意：\"><a href=\"# 注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h2><ol>\n<li>文中提到的 <code>networkObservable</code> 是网络请求，但实际上这不限于网络请求，任何耗时操作如文件 io 操作等都可以利用这个方法，来监听生命周期并自动暂停。</li>\n<li>对于 Fragment 中的处理方法也是类似。</li>\n</ol>\n<p>谢谢！</p>\n<h2 id=\"wingjay\"><a href=\"#wingjay\" class=\"headerlink\" title=\"wingjay\"></a>wingjay</h2><p>欢迎各位关注 <br><a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\"> 我的 Github</a>: <a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\">https://github.com/wingjay</a><br>和 <br><a href=\"http://wingjay.com\"> 我的个人博客 </a>: <a href=\"http://wingjay.com\">http://wingjay.com</a><br> 和<br><a href=\"http://www.jianshu.com/users/da333fd63fe5/latest_articles\" target=\"_blank\" rel=\"external\">我的简书 </a>: <a href=\"http://www.jianshu.com/users/da333fd63fe5/latest_articles\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/users/da333fd63fe5/latest_articles</a><br> 和<br><a href=\"http://weibo.com/u/1625892654\" target=\"_blank\" rel=\"external\">微博 iam_wingjay</a>: <a href=\"http://weibo.com/u/1625892654\" target=\"_blank\" rel=\"external\">http://weibo.com/u/1625892654</a><br>如果有问题，可以给我留言或发邮件<a href=\"&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x79;&#x69;&#110;&#106;&#x69;&#x65;&#x73;&#104;&#x40;&#x31;&#x32;&#x36;&#x2e;&#99;&#x6f;&#x6d;\">&#x79;&#x69;&#110;&#106;&#x69;&#x65;&#x73;&#104;&#x40;&#x31;&#x32;&#x36;&#x2e;&#99;&#x6f;&#x6d;</a></p>\n<p><img src=\"https://avatars0.githubusercontent.com/u/9619875?v=3&amp;s=460\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>私以为，阅读开源项目是与世界级技术大牛直接对话的最好方式。<br>此次来分享下 RxLifecycle 源码的分析。</p>\n</blockquote>","more":"<p><strong>此文需要读者对RxJava有一定了解</strong></p>\n<h2 id=\"一、-介绍\"><a href=\"#一、-介绍\" class=\"headerlink\" title=\"一、 介绍\"></a>一、 介绍</h2><p>本文分析思路不是从源码里抽代码出来一步步跟踪，而是提出问题，一步步思考解决方法，从而学习到开源项目的思维精华，而不仅仅是了解该项目的具体实现。笔者认为这种方式更有利于读者提高自身思维方式和技术能力。</p>\n<h2 id=\"二、-开源项目\"><a href=\"#二、-开源项目\" class=\"headerlink\" title=\"二、 开源项目\"></a>二、 开源项目</h2><p><a href=\"https://github.com/trello/RxLifecycle\" target=\"_blank\" rel=\"external\">RxLifecycle</a> 地址：<a href=\"https://github.com/trello/RxLifecycle\" target=\"_blank\" rel=\"external\">https://github.com/trello/RxLifecycle</a> 。该项目是为了防止<code>RxJava</code>中<code>subscription</code>导致内存泄漏而诞生的，核心思想是通过监听<code>Activity</code>、<code>Fragment</code>的生命周期，来自动断开<code>subscription</code>以防止内存泄漏。</p>\n<p>基本用法如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">myObservable</div><div class=\"line\">    .compose(RxLifecycle.bindUntilEvent(lifecycle, ActivityEvent.DESTROY))</div><div class=\"line\">    .subscribe();</div></pre></td></tr></table></figure></p>\n<p>此处<code>myObservable</code>可以看成一个耗时的网络请求，通过绑定到<code>ActivityEvent.DESTROY</code>，一旦Activity发生了<code>DESTORY</code>生命周期，数据就不会再流向<code>subscriber</code>，即不会对这些数据进行任何处理和UI绘制，从而提高安全性。</p>\n<h2 id=\"三、-问题\"><a href=\"#三、-问题\" class=\"headerlink\" title=\"三、 问题\"></a>三、 问题</h2><p>Android开发中常会有这样一个场景：</p>\n<ol>\n<li>发送网络请求 -&gt; 2. 服务器处理请求并返回数据 -&gt; 3. client端接收数据，绘制UI。</li>\n</ol>\n<p>在前两步一般都是不会出现问题的，但是在第三步，当数据返回给client端时，如果页面已经不在了，那么就无法去绘制UI，很有可能会导致意向不到的问题。因此，为了解决这个问题，一个好的思路就是<code>当页面离开时，自动断开网络请求数据的处理过程，即数据返回后不再进行任何处理</code>。</p>\n<h2 id=\"四、-思考\"><a href=\"#四、-思考\" class=\"headerlink\" title=\"四、 思考\"></a>四、 思考</h2><p>要达到上面这样一个功能，我们可以思考，至少需要两部分：</p>\n<ol>\n<li>随时监听<code>Activity</code>(<code>Fragment</code>)的生命周期并对外发射出去；</li>\n<li>在我们的网络请求中，接收生命周期并进行判断，如果该生命周期是自己绑定的，如<code>Destory</code>，那么就断开数据向下传递的过程。</li>\n</ol>\n<h2 id=\"五、-分析\"><a href=\"#五、-分析\" class=\"headerlink\" title=\"五、 分析\"></a>五、 分析</h2><p>可以看到，首先有一个核心功能要实现：就是既能够监听<code>Activity</code>生命周期事件并对外发射，又能够接收每一个生命周期事件并作出判断。为了实现这个功能，可以联想到<code>RxJava</code>中的<code>Subject</code>，既能够发射数据，又能够接收数据。</p>\n<h2 id=\"六、-Subject解析\"><a href=\"#六、-Subject解析\" class=\"headerlink\" title=\"六、 Subject解析\"></a>六、 Subject解析</h2><p>了解<code>Subject</code>的读者可以跳过这部分。</p>\n<p>如何理解<code>Subject</code>呢？</p>\n<p>很容易，在RxJava里面，<code>Observable</code>是数据的发射者，它会对外发射数据，然后经过<code>map</code>、<code>flatmap</code>等等数据处理后，最终传递给<code>Observer</code>，这个数据接收者。因此，抛开中间数据处理不管，可以看出，<code>Observable</code>对外发射数据，是数据流的开端；<code>Observer</code>接收数据，是数据流的末端。</p>\n<p>那么<code>Subject</code>呢？看一眼源码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Represents an object that is both an Observable and an Observer.</div><div class=\"line\"> */</div><div class=\"line\">public abstract class Subject&lt;T, R&gt; extends Observable&lt;R&gt; implements Observer&lt;T&gt; &#123;&#125;</div></pre></td></tr></table></figure></p>\n<p>首先，它<code>extends Observable&lt;R&gt;</code>，说明<code>Subject</code>具备了对外发射数据的能力，即拥有了<code>from()</code>、<code>just()</code>等等；另外，它又<code>implements Observer&lt;T&gt;</code>，说明又能够处理数据，具备<code>onNext()</code>、<code>onCompleted</code>等等。</p>\n<p>然后，<code>Subject</code>毕竟只是一个抽象类，那么我们要如何使用它呢？</p>\n<p>这里介绍一种最简单的：<code>PublishSubject</code>:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">PublishSubject&lt;Object&gt; subject = PublishSubject.create();</div><div class=\"line\">// myObserver will receive &quot;one&quot; &amp; &quot;two&quot; and onCompleted events</div><div class=\"line\">subject.subscribe(myObserver);</div><div class=\"line\">subject.onNext(&quot;one&quot;);</div><div class=\"line\">subject.onNext(&quot;two&quot;);</div><div class=\"line\">subject.onCompleted();</div></pre></td></tr></table></figure></p>\n<p>这里做的事情很简单，先创建一个<code>PublishSubject</code> -&gt; 绑定一个<code>myObserver</code>，此时<code>subject</code>扮演了<code>Observable</code>的角色，把数据发射给<code>myObserver</code> -&gt; 然后<code>subject</code>处理接收了两个数据<code>one</code>、<code>two</code> -&gt; 最终这些数据都传递给了<code>myObserver</code>。所以，<code>subject</code>扮演的角色是:</p>\n<p><strong>数据<code>one</code>、<code>two</code>   =&gt;   (Observer) <code>subject</code> (Observable)   =&gt;   <code>myObserver</code></strong></p>\n<p>简单来说，我们把数据<code>one</code>、<code>two</code>塞给<code>subject</code>，然后<code>subject</code>又发射给了<code>myObserver</code>。</p>\n<h2 id=\"七、-BaseActivity监听生命周期\"><a href=\"#七、-BaseActivity监听生命周期\" class=\"headerlink\" title=\"七、 BaseActivity监听生命周期\"></a>七、 BaseActivity监听生命周期</h2><p>那么我们先来实现生命周期监听功能，基本思路是：在<code>BaseActivity</code>里创建一个<code>PublishSubject</code>对象，在每个生命周期发生时，把该生命周期事件传递给<code>PublishSubject</code>。具体实现如下(只写部分生命周期，其他类似)：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseActivity</span> </span>&#123;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> PublishSubject&lt;ActivityLifeCycleEvent&gt; lifecycleSubject = PublishSubject.create();</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">  \t<span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">  \t\tlifecycleSubject.onNext(ActivityLifeCycleEvent.CREATE);</div><div class=\"line\">  \t\t...</div><div class=\"line\">  \t&#125;</div><div class=\"line\"></div><div class=\"line\">  \t<span class=\"meta\">@Override</span></div><div class=\"line\">  \t<span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onPause</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  \t\tlifecycleSubject.onNext(ActivityLifeCycleEvent.PAUSE);</div><div class=\"line\">  \t\t...</div><div class=\"line\">  \t&#125;</div><div class=\"line\"></div><div class=\"line\">  \t<span class=\"meta\">@Override</span></div><div class=\"line\">  \t<span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStop</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  \t\tlifecycleSubject.onNext(ActivityLifeCycleEvent.STOP);</div><div class=\"line\">  \t\t...</div><div class=\"line\">  \t&#125;</div><div class=\"line\">  \t...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样的话，我们把所有生命周期事件都传给了<code>lifecycleSubject</code>了，或者说，<code>lifecycleSubject</code>已经接收到了并能够<code>对外发射各种生命周期事件</code>的能力了。</p>\n<h2 id=\"八、-改良每一个Observable，接收生命周期并自动断开自身\"><a href=\"#八、-改良每一个Observable，接收生命周期并自动断开自身\" class=\"headerlink\" title=\"八、 改良每一个Observable，接收生命周期并自动断开自身\"></a>八、 改良每一个Observable，接收生命周期并自动断开自身</h2><p>通常我们的一次网络请求长这样：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">networkObservable</div><div class=\"line\">\t.subscribe(<span class=\"keyword\">new</span> Observer(  handleUI()  ));</div></pre></td></tr></table></figure></p>\n<p>其中，<code>networkObservable</code>表示一个通用的网络请求，会接收网络数据并传递给<code>Observer</code>去绘制UI。</p>\n<p>现在，我们希望这个<code>networkObservable</code>监听<code>Activity</code>的<code>DESTORY</code>事件，一旦发生了<code>DESTORY</code>就自动断开<code>Observer</code>，即使网络数据回来了也不再传递给<code>Observer</code>去绘制UI。即：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">networkObservable</div><div class=\"line\">\t.compose(bindUntilEvent(ActivityLifeCycleEvent.DESTORY))</div><div class=\"line\">\t.subscribe(<span class=\"keyword\">new</span> Observer(  handleUI()  ));</div></pre></td></tr></table></figure></p>\n<p>因此，我们需要实现<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">bindUntilEvent(ActivityLifeCycleEvent.DESTORY)</div></pre></td></tr></table></figure></p>\n<p>这个方法，那如何实现呢？</p>\n<p>我们知道<code>lifecycleSubject</code>能够发射生命周期事件了，那么我们可以让<code>networkObservable</code>去检查<code>lifecycleSubject</code>发出的生命周期，如果和自己绑定的生命周期事件一样，那就自动停掉即可。</p>\n<h2 id=\"九、-改装networkObservable\"><a href=\"#九、-改装networkObservable\" class=\"headerlink\" title=\"九、 改装networkObservable\"></a>九、 改装networkObservable</h2><p>对于<code>networkObservable自动停掉</code>，我们可以利用操作符<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">networkObservable.takeUntil(otherObservable)</div></pre></td></tr></table></figure></p>\n<p>它的作用是监听<code>otherObservable</code>，一旦<code>otherObservable</code>对外发射了数据，就自动把<code>networkObservable</code>停掉；</p>\n<p>那<code>otherObservable</code>何时对外发射数据呢？当然是<code>lifecycleSubject</code>发射出的生命周期事件<code>等于</code>绑定的生命周期事件时，开始发射。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">otherObservable = lifecycleSubject.takeFirst(<span class=\"keyword\">new</span> Func1&lt;ActivityLifeCycleEvent, Boolean&gt;() &#123;</div><div class=\"line\">             <span class=\"meta\">@Override</span></div><div class=\"line\">             <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">call</span><span class=\"params\">(ActivityLifeCycleEvent activityLifeCycleEvent)</span> </span>&#123;</div><div class=\"line\">               <span class=\"keyword\">return</span> activityLifeCycleEvent.equals(bindEvent);</div><div class=\"line\">             &#125;</div><div class=\"line\">           &#125;);</div></pre></td></tr></table></figure></p>\n<p>其中的关键是判断<code>activityLifeCycleEvent.equals(bindEvent);</code>，一旦条件满足，<code>otherObservable</code>就对外发射数据，然后<code>networkObservable</code>就立即自动停掉。</p>\n<h2 id=\"十、-合并-生命周期监听-与-networkObservable改良\"><a href=\"#十、-合并-生命周期监听-与-networkObservable改良\" class=\"headerlink\" title=\"十、 合并 生命周期监听 与 networkObservable改良\"></a>十、 合并 生命周期监听 与 networkObservable改良</h2><ol>\n<li>在BaseActivity里添加<code>lifecycleSubject</code>，并把每一个生命周期事件按时传递给<code>lifecycleSubject</code></li>\n<li><p>在BaseActivity里添加一个<code>bindUntilEvent</code>方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@NonNull</span></div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; Observable.<span class=\"function\">Transformer&lt;T, T&gt; <span class=\"title\">bindUntilEvent</span><span class=\"params\">(@NonNull <span class=\"keyword\">final</span> ActivityLifeCycleEvent event)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Observable.Transformer&lt;T, T&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Observable&lt;T&gt; <span class=\"title\">call</span><span class=\"params\">(Observable&lt;T&gt; sourceObservable)</span> </span>&#123;</div><div class=\"line\">      Observable&lt;ActivityLifeCycleEvent&gt; compareLifecycleObservable =</div><div class=\"line\">          lifecycleSubject.takeFirst(<span class=\"keyword\">new</span> Func1&lt;ActivityLifeCycleEvent, Boolean&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">call</span><span class=\"params\">(ActivityLifeCycleEvent activityLifeCycleEvent)</span> </span>&#123;</div><div class=\"line\">              <span class=\"keyword\">return</span> activityLifeCycleEvent.equals(event);</div><div class=\"line\">            &#125;</div><div class=\"line\">          &#125;);</div><div class=\"line\">      <span class=\"keyword\">return</span> sourceObservable.takeUntil(compareLifecycleObservable);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>在任意一个网络请求 networkObservable 处改良</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">networkObservable</div><div class=\"line\">\t.compose(bindUntilEvent(ActivityLifeCycleEvent.DESTORY))</div><div class=\"line\">\t.subscribe(new Observer(  handleUI()  ));</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h2><ol>\n<li>文中提到的<code>networkObservable</code>是网络请求，但实际上这不限于网络请求，任何耗时操作如文件io操作等都可以利用这个方法，来监听生命周期并自动暂停。</li>\n<li>对于Fragment中的处理方法也是类似。</li>\n</ol>\n<p>谢谢！</p>\n<h2 id=\"wingjay\"><a href=\"#wingjay\" class=\"headerlink\" title=\"wingjay\"></a>wingjay</h2><p>欢迎各位关注<br><a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\">我的Github</a>: <a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\">https://github.com/wingjay</a><br>和<br><a href=\"http://wingjay.com\">我的个人博客</a>: <a href=\"http://wingjay.com\">http://wingjay.com</a><br>和<br><a href=\"http://www.jianshu.com/users/da333fd63fe5/latest_articles\" target=\"_blank\" rel=\"external\">我的简书</a>: <a href=\"http://www.jianshu.com/users/da333fd63fe5/latest_articles\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/users/da333fd63fe5/latest_articles</a><br>和<br><a href=\"http://weibo.com/u/1625892654\" target=\"_blank\" rel=\"external\">微博 iam_wingjay</a>: <a href=\"http://weibo.com/u/1625892654\" target=\"_blank\" rel=\"external\">http://weibo.com/u/1625892654</a><br>如果有问题，可以给我留言或发邮件<a href=\"&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x79;&#x69;&#110;&#106;&#x69;&#x65;&#x73;&#104;&#x40;&#x31;&#x32;&#x36;&#x2e;&#99;&#x6f;&#x6d;\">&#x79;&#x69;&#110;&#106;&#x69;&#x65;&#x73;&#104;&#x40;&#x31;&#x32;&#x36;&#x2e;&#99;&#x6f;&#x6d;</a></p>\n<p><img src=\"https://avatars0.githubusercontent.com/u/9619875?v=3&amp;s=460\" alt=\"\"></p>","sticky":0},{"title":"Java 技术之类加载机制","date":"2017-05-08T12:46:38.000Z","commentIssueId":4,"_content":"> 类加载机制是 Java 语言的一大亮点，使得 Java 类可以被动态加载到 Java 虚拟机中。\n\n> 这次我们抛开术语和概念，从例子入手，由浅入深地讲解 Java 的类加载机制。\n\n> 本文涉及知识点：双亲委托机制、BootstrapClassLoader、ExtClassLoader、AppClassLoader、自定义网络类加载器等\n\n> 文章涉及代码：\nhttps://github.com/wingjay/HelloJava/blob/master/common/src/classloader/HelloClassLoader.java\n\n<!-- more -->\n\n## 什么是 Java 类加载机制?\nJava 虚拟机一般使用 Java 类的流程为：首先将开发者编写的 Java 源代码（.java文件）编译成 Java 字节码（.class文件），然后类加载器会读取这个 .class 文件，并转换成 java.lang.Class 的实例。有了该 Class 实例后，Java 虚拟机可以利用 newInstance 之类的方法创建其真正对象了。\n\nClassLoader 是 Java 提供的类加载器，绝大多数的类加载器都继承自 ClassLoader，它们被用来加载不同来源的 Class 文件。\n\n## Class 文件有哪些来源呢?\n上文提到了 ClassLoader 可以去加载多种来源的 Class，那么具体有哪些来源呢？\n\n首先，最常见的是开发者在应用程序中编写的类，这些类位于项目目录下；\n\n然后，有 Java 内部自带的`核心类`如 `java.lang`、`java.math`、`java.io` 等 package 内部的类，位于 `$JAVA_HOME/jre/lib/` 目录下，如 `java.lang.String` 类就是定义在 `$JAVA_HOME/jre/lib/rt.jar` 文件里；\n\n另外，还有 Java `核心扩展类`，位于 `$JAVA_HOME/jre/lib/ext` 目录下。开发者也可以把自己编写的类打包成 jar 文件放入该目录下；\n\n最后还有一种，是动态加载远程的 .class 文件。\n\n既然有这么多种类的来源，那么在 Java 里，是由某一个具体的 ClassLoader 来统一加载呢？还是由多个 ClassLoader 来协作加载呢？\n\n## 哪些 ClassLoader 负责加载上面几类 Class？\n实际上，针对上面四种来源的类，分别有不同的加载器负责加载。\n\n首先，我们来看级别最高的 `Java 核心类`，即`$JAVA_HOME/jre/lib` 里的核心 jar 文件。这些类是 Java 运行的基础类，由一个名为 `BootstrapClassLoader` 加载器负责加载，它也被称作 `根加载器／引导加载器`。注意，`BootstrapClassLoader` 比较特殊，它不继承 `ClassLoader`，而是由 JVM 内部实现；\n\n然后，需要加载 `Java 核心扩展类`，即 `$JAVA_HOME/jre/lib/ext` 目录下的 jar 文件。这些文件由 `ExtensionClassLoader` 负责加载，它也被称作 `扩展类加载器`。当然，用户如果把自己开发的 jar 文件放在这个目录，也会被 `ExtClassLoader` 加载；\n\n接下来是开发者在项目中编写的类，这些文件将由 `AppClassLoader` 加载器进行加载，它也被称作 `系统类加载器 System ClassLoader`；\n\n最后，如果想远程加载如（本地文件／网络下载）的方式，则必须要自己自定义一个 ClassLoader，复写其中的 `findClass()` 方法才能得以实现。\n\n因此能看出，Java 里提供了至少四类 `ClassLoader` 来分别加载不同来源的 Class。\n\n那么，这几种 ClassLoader 是如何协作来加载一个类呢？\n\n## 这些 ClassLoader 以何种方式来协作加载 String 类呢？\nString 类是 Java 自带的最常用的一个类，现在的问题是，JVM 将以何种方式把 String class 加载进来呢？\n\n我们来猜想下。\n\n首先，String 类属于 Java 核心类，位于 `$JAVA_HOME/jre/lib` 目录下。有的朋友会马上反应过来，上文中提过了，该目录下的类会由 `BootstrapClassLoader` 进行加载。没错，它确实是由 `BootstrapClassLoader` 进行加载。但，这种回答的前提是你已经知道了 String 在 `$JAVA_HOME/jre/lib` 目录下。\n\n那么，如果你并不知道 String 类究竟位于哪呢？或者我希望你去加载一个 `unknown` 的类呢？\n\n有的朋友这时会说，那很简单，只要去遍历一遍所有的类，看看这个 `unknown` 的类位于哪里，然后再用对应的加载器去加载。\n\n是的，思路很正确。那应该如何去遍历呢？\n\n比如，可以先遍历用户自己写的类，如果找到了就用 `AppClassLoader` 去加载；否则去遍历 Java 核心类目录，找到了就用 `BootstrapClassLoader` 去加载，否则就去遍历 Java 扩展类库，依次类推。\n\n这种思路方向是正确的，不过存在一个漏洞。\n\n假如开发者自己伪造了一个 `java.lang.String` 类，即在项目中创建一个包`java.lang`，包内创建一个名为 `String` 的类，这完全可以做到。那如果利用上面的遍历方法，是不是这个项目中用到的 String 不是都变成了这个伪造的 `java.lang.String` 类吗？如何解决这个问题呢？\n\n解决方法很简单，当查找一个类时，优先遍历最高级别的 Java 核心类，然后再去遍历 Java 核心扩展类，最后再遍历用户自定义类，而且这个遍历过程是一旦找到就立即停止遍历。\n\n在 Java 中，这种实现方式也称作 `双亲委托`。其实很简单，把 `BootstrapClassLoader` 想象为核心高层领导人， `ExtClassLoader` 想象为中层干部， `AppClassLoader` 想象为普通公务员。每次需要加载一个类，先获取一个系统加载器 `AppClassLoader` 的实例（ClassLoader.getSystemClassLoader()），然后向上级层层请求，由最上级优先去加载，如果上级觉得这些类不属于核心类，就可以下放到各子级负责人去自行加载。\n\n如下图所示：\n![双亲委托](/img/classloader/order.png)\n\n## 真的是按照`双亲委托`方式进行类加载吗？\n下面通过几个例子来验证上面的加载方式。\n\n#### 开发者自定义的类会被 `AppClassLoader` 加载吗？\n在项目中创建一个名为 `MusicPlayer` 的类文件，内容如下：\n```\npackage classloader;\n\npublic class MusicPlayer {\n\tpublic void print() {\n\t\tSystem.out.printf(\"Hi I'm MusicPlayer\");\n\t}\n}\n```\n\n然后来加载 `MusicPlayer`。\n\n```\nprivate static void loadClass() throws ClassNotFoundException {\n    Class<?> clazz = Class.forName(\"classloader.MusicPlayer\");\n    ClassLoader classLoader = clazz.getClassLoader();\n    System.out.printf(\"ClassLoader is %s\", classLoader.getClass().getSimpleName());\n}\n```\n打印结果为：\n```\nClassLoader is AppClassLoader\n```\n可以验证，`MusicPlayer` 是由 `AppClassLoader` 进行的加载。\n\n#### 验证 `AppClassLoader` 的双亲真的是 ExtClassLoader 和 BootstrapClassLoader 吗？\n这时发现 `AppClassLoader` 提供了一个 `getParent()` 的方法，来打印看看都是什么。\n```\nprivate static void printParent() throws ClassNotFoundException {\n        Class<?> clazz = Class.forName(\"classloader.MusicPlayer\");\n        ClassLoader classLoader = clazz.getClassLoader();\n        System.out.printf(\"currentClassLoader is %s\\n\", classLoader.getClass().getSimpleName());\n\n        while (classLoader.getParent() != null) {\n            classLoader = classLoader.getParent();\n            System.out.printf(\"Parent is %s\\n\", classLoader.getClass().getSimpleName());\n        }\n}\n```\n打印结果为：\n```\ncurrentClassLoader is AppClassLoader\nParent is ExtClassLoader\n```\n首先能看到 `ExtClassLoader` 确实是 `AppClassLoader` 的双亲，不过却没有看到 `BootstrapClassLoader`。事实上，上文就提过， `BootstrapClassLoader`比较特殊，它是由 JVM 内部实现的，所以 `ExtClassLoader.getParent() = null`。\n\n#### 如果把 MusicPlayer 类挪到 `$JAVA_HOME/jre/lib/ext` 目录下会发生什么？\n上文中说了，`ExtClassLoader` 会加载`$JAVA_HOME/jre/lib/ext` 目录下所有的 jar 文件。那来尝试下直接把 `MusicPlayer` 这个类放到 `$JAVA_HOME/jre/lib/ext` 目录下吧。\n\n利用下面命令可以把 MusicPlayer.java 编译打包成 jar 文件，并放置到对应目录。\n```\njavac classloader/MusicPlayer.java\njar cvf MusicPlayer.jar classloader/MusicPlayer.class\nmv MusicPlayer.jar $JAVA_HOME/jre/lib/ext/\n```\n\n这时 MusicPlayer.jar 已经被放置与 `$JAVA_HOME/jre/lib/ext` 目录下，同时把之前的 `MusicPlayer` `删除`，而且这一次`刻意`使用 `AppClassLoader` 来加载：\n```\nprivate static void loadClass() throws ClassNotFoundException {\n    ClassLoader appClassLoader = ClassLoader.getSystemClassLoader(); // AppClassLoader\n    Class<?> clazz = appClassLoader.loadClass(\"classloader.MusicPlayer\");\n    ClassLoader classLoader = clazz.getClassLoader();\n    System.out.printf(\"ClassLoader is %s\", classLoader.getClass().getSimpleName());\n}\n```\n打印结果为：\n```\nClassLoader is ExtClassLoader\n```\n说明即使直接用 `AppClassLoader` 去加载，它仍然会被 `ExtClassLoader` 加载到。\n\n## 从源码角度真正理解`双亲委托`加载机制\n上面已经通过一些例子了解了`双亲委托`的一些特性了，下面来看一下它的实现代码，加深理解。\n\n打开 `ClassLoader` 里的 `loadClass()` 方法，便是需要分析的源码了。这个方法里做了下面几件事：\n\n1. 检查目标class是否曾经加载过，如果加载过则直接返回；\n2. 如果没加载过，把加载请求传递给 parent 加载器去加载；\n3. 如果 parent 加载器加载成功，则直接返回；\n4. 如果 parent 未加载到，则自身调用 findClass() 方法进行寻找，并把寻找结果返回。\n\n代码如下：\n```\nprotected Class<?> loadClass(String name, boolean resolve)\n    throws ClassNotFoundException\n{\n    synchronized (getClassLoadingLock(name)) {\n        // 1. 检查是否曾加载过\n        Class<?> c = findLoadedClass(name);\n        if (c == null) {\n            long t0 = System.nanoTime();\n            try {\n                if (parent != null) {\n                \t// 优先让 parent 加载器去加载\n                    c = parent.loadClass(name, false);\n                } else {\n                \t// 如无 parent，表示当前是 BootstrapClassLoader，调用 native 方法去 JVM 加载\n                    c = findBootstrapClassOrNull(name);\n                }\n            } catch (ClassNotFoundException e) {\n                // ClassNotFoundException thrown if class not found\n                // from the non-null parent class loader\n            }\n\n            if (c == null) {\n            \t// 如果 parent 均没有加载到目标class，调用自身的 findClass() 方法去搜索\n                long t1 = System.nanoTime();\n                c = findClass(name);\n\n                // this is the defining class loader; record the stats\n                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n                sun.misc.PerfCounter.getFindClasses().increment();\n            }\n        }\n        if (resolve) {\n            resolveClass(c);\n        }\n        return c;\n    }\n}\n\n// BootstrapClassLoader 会调用 native 方法去 JVM 加载\nprivate native Class<?> findBootstrapClass(String name);\n```\n\n看完实现源码相信能够有更完整的理解。\n\n## 类加载器最酷的一面：自定义类加载器\n前面提到了 Java 自带的加载器 `BootstrapClassLoader`、`AppClassLoader`和`ExtClassLoader`，这些都是 Java 已经提供好的。\n\n而真正有意思的，是 `自定义类加载器`，它允许我们在`运行时`可以从`本地磁盘或网络`上动态加载自定义类。这使得开发者可以动态修复某些有问题的类，热更新代码。\n\n下面来实现一个`网络类加载器`，这个加载器可以从网络上动态下载 .class 文件并加载到虚拟机中使用。\n\n后面我还会写作与 `热修复／动态更新` 相关的文章，这里先学习 Java 层 `NetworkClassLoader` 相关的原理。\n\n1. 作为一个 `NetworkClassLoader`，它首先要继承 `ClassLoader`；\n2. 然后它要实现`ClassLoader`内的 `findClass()` 方法。注意，不是`loadClass()`方法，因为`ClassLoader`提供了`loadClass()`（如上面的源码），它会基于`双亲委托`机制去搜索某个 class，直到搜索不到才会调用自身的`findClass()`，如果直接复写`loadClass()`，那还要实现`双亲委托`机制；\n3. 在 `findClass()` 方法里，要从网络上下载一个 .class 文件，然后转化成 Class 对象供虚拟机使用。\n\n具体实现代码如下：\n```\n/**\n * Load class from network\n */\npublic class NetworkClassLoader extends ClassLoader {\n\n    @Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        byte[] classData = downloadClassData(name); // 从远程下载\n        if (classData == null) {\n            super.findClass(name); // 未找到，抛异常\n        } else {\n            return defineClass(name, classData, 0, classData.length); // convert class byte data to Class<?> object\n        }\n        return null;\n    }\n\n    private byte[] downloadClassData(String name) {\n        // 从 localhost 下载 .class 文件\n        String path = \"http://localhost\" + File.separatorChar + \"java\" + File.separatorChar + name.replace('.', File.separatorChar) + \".class\"; \n\n        try {\n            URL url = new URL(path);\n            InputStream ins = url.openStream();\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            int bufferSize = 4096;\n            byte[] buffer = new byte[bufferSize];\n            int bytesNumRead = 0;\n            while ((bytesNumRead = ins.read(buffer)) != -1) {\n                baos.write(buffer, 0, bytesNumRead); // 把下载的二进制数据存入 ByteArrayOutputStream\n            }\n            return baos.toByteArray();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public String getName() {\n        System.out.printf(\"Real NetworkClassLoader\\n\");\n        return \"networkClassLoader\";\n    }\n}\n```\n\n这个类的作用是从网络上（这里是本人的 local apache 服务器 http://localhost/java 上）目录里去下载对应的 .class 文件，并转换成 Class<?> 返回回去使用。\n\n下面我们来利用这个 `NetworkClassLoader` 去加载 localhost 上的 `MusicPlayer` 类：\n\n1. 首先把 `MusicPlayer.class` 放置于 `/Library/WebServer/Documents/java` （MacOS）目录下，由于 MacOS 自带 apache 服务器，这里是服务器的默认目录；\n2. 执行下面一段代码：\n```\nString className = \"classloader.NetworkClass\";\nNetworkClassLoader networkClassLoader = new NetworkClassLoader();\nClass<?> clazz  = networkClassLoader.loadClass(className);\n```\n3. 正常运行，加载 `http://localhost/java/classloader/MusicPlayer.class`成功。\n\n可以看出 `NetworkClassLoader` 可以正常工作，如果读者要用的话，只要稍微修改 url 的拼接方式即可自行使用。\n\n## 小结\n类加载方式是 Java 上非常创新的一项技术，给未来的热修复技术提供了可能。本文力求通过简单的语言和合适的例子来讲解其中`双亲委托机制`、`自定义加载器`等，并开发了自定义的`NetworkClassLoader`。\n\n当然，类加载是很有意思的技术，很难覆盖所有知识点，比如不同类加载器加载同一个类，得到的实例却不是同一个等等。\n\n之后我还会写作关于热修复／动态更新相关的技术，欢迎关注。\n\n谢谢。\n\nwingjay\n\nhttp://wingjay.com\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n\n","source":"_posts/Java-技术之类加载机制.md","raw":"title: Java 技术之类加载机制\ndate: 2017-05-08 20:46:38\npermalink: java_classloader\ncategories:\n  - 深入理解Java技术\ntags:\n  - Java\n  - Annotation\ncommentIssueId: 4  \n---\n> 类加载机制是 Java 语言的一大亮点，使得 Java 类可以被动态加载到 Java 虚拟机中。\n\n> 这次我们抛开术语和概念，从例子入手，由浅入深地讲解 Java 的类加载机制。\n\n> 本文涉及知识点：双亲委托机制、BootstrapClassLoader、ExtClassLoader、AppClassLoader、自定义网络类加载器等\n\n> 文章涉及代码：\nhttps://github.com/wingjay/HelloJava/blob/master/common/src/classloader/HelloClassLoader.java\n\n<!-- more -->\n\n## 什么是 Java 类加载机制?\nJava 虚拟机一般使用 Java 类的流程为：首先将开发者编写的 Java 源代码（.java文件）编译成 Java 字节码（.class文件），然后类加载器会读取这个 .class 文件，并转换成 java.lang.Class 的实例。有了该 Class 实例后，Java 虚拟机可以利用 newInstance 之类的方法创建其真正对象了。\n\nClassLoader 是 Java 提供的类加载器，绝大多数的类加载器都继承自 ClassLoader，它们被用来加载不同来源的 Class 文件。\n\n## Class 文件有哪些来源呢?\n上文提到了 ClassLoader 可以去加载多种来源的 Class，那么具体有哪些来源呢？\n\n首先，最常见的是开发者在应用程序中编写的类，这些类位于项目目录下；\n\n然后，有 Java 内部自带的`核心类`如 `java.lang`、`java.math`、`java.io` 等 package 内部的类，位于 `$JAVA_HOME/jre/lib/` 目录下，如 `java.lang.String` 类就是定义在 `$JAVA_HOME/jre/lib/rt.jar` 文件里；\n\n另外，还有 Java `核心扩展类`，位于 `$JAVA_HOME/jre/lib/ext` 目录下。开发者也可以把自己编写的类打包成 jar 文件放入该目录下；\n\n最后还有一种，是动态加载远程的 .class 文件。\n\n既然有这么多种类的来源，那么在 Java 里，是由某一个具体的 ClassLoader 来统一加载呢？还是由多个 ClassLoader 来协作加载呢？\n\n## 哪些 ClassLoader 负责加载上面几类 Class？\n实际上，针对上面四种来源的类，分别有不同的加载器负责加载。\n\n首先，我们来看级别最高的 `Java 核心类`，即`$JAVA_HOME/jre/lib` 里的核心 jar 文件。这些类是 Java 运行的基础类，由一个名为 `BootstrapClassLoader` 加载器负责加载，它也被称作 `根加载器／引导加载器`。注意，`BootstrapClassLoader` 比较特殊，它不继承 `ClassLoader`，而是由 JVM 内部实现；\n\n然后，需要加载 `Java 核心扩展类`，即 `$JAVA_HOME/jre/lib/ext` 目录下的 jar 文件。这些文件由 `ExtensionClassLoader` 负责加载，它也被称作 `扩展类加载器`。当然，用户如果把自己开发的 jar 文件放在这个目录，也会被 `ExtClassLoader` 加载；\n\n接下来是开发者在项目中编写的类，这些文件将由 `AppClassLoader` 加载器进行加载，它也被称作 `系统类加载器 System ClassLoader`；\n\n最后，如果想远程加载如（本地文件／网络下载）的方式，则必须要自己自定义一个 ClassLoader，复写其中的 `findClass()` 方法才能得以实现。\n\n因此能看出，Java 里提供了至少四类 `ClassLoader` 来分别加载不同来源的 Class。\n\n那么，这几种 ClassLoader 是如何协作来加载一个类呢？\n\n## 这些 ClassLoader 以何种方式来协作加载 String 类呢？\nString 类是 Java 自带的最常用的一个类，现在的问题是，JVM 将以何种方式把 String class 加载进来呢？\n\n我们来猜想下。\n\n首先，String 类属于 Java 核心类，位于 `$JAVA_HOME/jre/lib` 目录下。有的朋友会马上反应过来，上文中提过了，该目录下的类会由 `BootstrapClassLoader` 进行加载。没错，它确实是由 `BootstrapClassLoader` 进行加载。但，这种回答的前提是你已经知道了 String 在 `$JAVA_HOME/jre/lib` 目录下。\n\n那么，如果你并不知道 String 类究竟位于哪呢？或者我希望你去加载一个 `unknown` 的类呢？\n\n有的朋友这时会说，那很简单，只要去遍历一遍所有的类，看看这个 `unknown` 的类位于哪里，然后再用对应的加载器去加载。\n\n是的，思路很正确。那应该如何去遍历呢？\n\n比如，可以先遍历用户自己写的类，如果找到了就用 `AppClassLoader` 去加载；否则去遍历 Java 核心类目录，找到了就用 `BootstrapClassLoader` 去加载，否则就去遍历 Java 扩展类库，依次类推。\n\n这种思路方向是正确的，不过存在一个漏洞。\n\n假如开发者自己伪造了一个 `java.lang.String` 类，即在项目中创建一个包`java.lang`，包内创建一个名为 `String` 的类，这完全可以做到。那如果利用上面的遍历方法，是不是这个项目中用到的 String 不是都变成了这个伪造的 `java.lang.String` 类吗？如何解决这个问题呢？\n\n解决方法很简单，当查找一个类时，优先遍历最高级别的 Java 核心类，然后再去遍历 Java 核心扩展类，最后再遍历用户自定义类，而且这个遍历过程是一旦找到就立即停止遍历。\n\n在 Java 中，这种实现方式也称作 `双亲委托`。其实很简单，把 `BootstrapClassLoader` 想象为核心高层领导人， `ExtClassLoader` 想象为中层干部， `AppClassLoader` 想象为普通公务员。每次需要加载一个类，先获取一个系统加载器 `AppClassLoader` 的实例（ClassLoader.getSystemClassLoader()），然后向上级层层请求，由最上级优先去加载，如果上级觉得这些类不属于核心类，就可以下放到各子级负责人去自行加载。\n\n如下图所示：\n![双亲委托](/img/classloader/order.png)\n\n## 真的是按照`双亲委托`方式进行类加载吗？\n下面通过几个例子来验证上面的加载方式。\n\n#### 开发者自定义的类会被 `AppClassLoader` 加载吗？\n在项目中创建一个名为 `MusicPlayer` 的类文件，内容如下：\n```\npackage classloader;\n\npublic class MusicPlayer {\n\tpublic void print() {\n\t\tSystem.out.printf(\"Hi I'm MusicPlayer\");\n\t}\n}\n```\n\n然后来加载 `MusicPlayer`。\n\n```\nprivate static void loadClass() throws ClassNotFoundException {\n    Class<?> clazz = Class.forName(\"classloader.MusicPlayer\");\n    ClassLoader classLoader = clazz.getClassLoader();\n    System.out.printf(\"ClassLoader is %s\", classLoader.getClass().getSimpleName());\n}\n```\n打印结果为：\n```\nClassLoader is AppClassLoader\n```\n可以验证，`MusicPlayer` 是由 `AppClassLoader` 进行的加载。\n\n#### 验证 `AppClassLoader` 的双亲真的是 ExtClassLoader 和 BootstrapClassLoader 吗？\n这时发现 `AppClassLoader` 提供了一个 `getParent()` 的方法，来打印看看都是什么。\n```\nprivate static void printParent() throws ClassNotFoundException {\n        Class<?> clazz = Class.forName(\"classloader.MusicPlayer\");\n        ClassLoader classLoader = clazz.getClassLoader();\n        System.out.printf(\"currentClassLoader is %s\\n\", classLoader.getClass().getSimpleName());\n\n        while (classLoader.getParent() != null) {\n            classLoader = classLoader.getParent();\n            System.out.printf(\"Parent is %s\\n\", classLoader.getClass().getSimpleName());\n        }\n}\n```\n打印结果为：\n```\ncurrentClassLoader is AppClassLoader\nParent is ExtClassLoader\n```\n首先能看到 `ExtClassLoader` 确实是 `AppClassLoader` 的双亲，不过却没有看到 `BootstrapClassLoader`。事实上，上文就提过， `BootstrapClassLoader`比较特殊，它是由 JVM 内部实现的，所以 `ExtClassLoader.getParent() = null`。\n\n#### 如果把 MusicPlayer 类挪到 `$JAVA_HOME/jre/lib/ext` 目录下会发生什么？\n上文中说了，`ExtClassLoader` 会加载`$JAVA_HOME/jre/lib/ext` 目录下所有的 jar 文件。那来尝试下直接把 `MusicPlayer` 这个类放到 `$JAVA_HOME/jre/lib/ext` 目录下吧。\n\n利用下面命令可以把 MusicPlayer.java 编译打包成 jar 文件，并放置到对应目录。\n```\njavac classloader/MusicPlayer.java\njar cvf MusicPlayer.jar classloader/MusicPlayer.class\nmv MusicPlayer.jar $JAVA_HOME/jre/lib/ext/\n```\n\n这时 MusicPlayer.jar 已经被放置与 `$JAVA_HOME/jre/lib/ext` 目录下，同时把之前的 `MusicPlayer` `删除`，而且这一次`刻意`使用 `AppClassLoader` 来加载：\n```\nprivate static void loadClass() throws ClassNotFoundException {\n    ClassLoader appClassLoader = ClassLoader.getSystemClassLoader(); // AppClassLoader\n    Class<?> clazz = appClassLoader.loadClass(\"classloader.MusicPlayer\");\n    ClassLoader classLoader = clazz.getClassLoader();\n    System.out.printf(\"ClassLoader is %s\", classLoader.getClass().getSimpleName());\n}\n```\n打印结果为：\n```\nClassLoader is ExtClassLoader\n```\n说明即使直接用 `AppClassLoader` 去加载，它仍然会被 `ExtClassLoader` 加载到。\n\n## 从源码角度真正理解`双亲委托`加载机制\n上面已经通过一些例子了解了`双亲委托`的一些特性了，下面来看一下它的实现代码，加深理解。\n\n打开 `ClassLoader` 里的 `loadClass()` 方法，便是需要分析的源码了。这个方法里做了下面几件事：\n\n1. 检查目标class是否曾经加载过，如果加载过则直接返回；\n2. 如果没加载过，把加载请求传递给 parent 加载器去加载；\n3. 如果 parent 加载器加载成功，则直接返回；\n4. 如果 parent 未加载到，则自身调用 findClass() 方法进行寻找，并把寻找结果返回。\n\n代码如下：\n```\nprotected Class<?> loadClass(String name, boolean resolve)\n    throws ClassNotFoundException\n{\n    synchronized (getClassLoadingLock(name)) {\n        // 1. 检查是否曾加载过\n        Class<?> c = findLoadedClass(name);\n        if (c == null) {\n            long t0 = System.nanoTime();\n            try {\n                if (parent != null) {\n                \t// 优先让 parent 加载器去加载\n                    c = parent.loadClass(name, false);\n                } else {\n                \t// 如无 parent，表示当前是 BootstrapClassLoader，调用 native 方法去 JVM 加载\n                    c = findBootstrapClassOrNull(name);\n                }\n            } catch (ClassNotFoundException e) {\n                // ClassNotFoundException thrown if class not found\n                // from the non-null parent class loader\n            }\n\n            if (c == null) {\n            \t// 如果 parent 均没有加载到目标class，调用自身的 findClass() 方法去搜索\n                long t1 = System.nanoTime();\n                c = findClass(name);\n\n                // this is the defining class loader; record the stats\n                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n                sun.misc.PerfCounter.getFindClasses().increment();\n            }\n        }\n        if (resolve) {\n            resolveClass(c);\n        }\n        return c;\n    }\n}\n\n// BootstrapClassLoader 会调用 native 方法去 JVM 加载\nprivate native Class<?> findBootstrapClass(String name);\n```\n\n看完实现源码相信能够有更完整的理解。\n\n## 类加载器最酷的一面：自定义类加载器\n前面提到了 Java 自带的加载器 `BootstrapClassLoader`、`AppClassLoader`和`ExtClassLoader`，这些都是 Java 已经提供好的。\n\n而真正有意思的，是 `自定义类加载器`，它允许我们在`运行时`可以从`本地磁盘或网络`上动态加载自定义类。这使得开发者可以动态修复某些有问题的类，热更新代码。\n\n下面来实现一个`网络类加载器`，这个加载器可以从网络上动态下载 .class 文件并加载到虚拟机中使用。\n\n后面我还会写作与 `热修复／动态更新` 相关的文章，这里先学习 Java 层 `NetworkClassLoader` 相关的原理。\n\n1. 作为一个 `NetworkClassLoader`，它首先要继承 `ClassLoader`；\n2. 然后它要实现`ClassLoader`内的 `findClass()` 方法。注意，不是`loadClass()`方法，因为`ClassLoader`提供了`loadClass()`（如上面的源码），它会基于`双亲委托`机制去搜索某个 class，直到搜索不到才会调用自身的`findClass()`，如果直接复写`loadClass()`，那还要实现`双亲委托`机制；\n3. 在 `findClass()` 方法里，要从网络上下载一个 .class 文件，然后转化成 Class 对象供虚拟机使用。\n\n具体实现代码如下：\n```\n/**\n * Load class from network\n */\npublic class NetworkClassLoader extends ClassLoader {\n\n    @Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        byte[] classData = downloadClassData(name); // 从远程下载\n        if (classData == null) {\n            super.findClass(name); // 未找到，抛异常\n        } else {\n            return defineClass(name, classData, 0, classData.length); // convert class byte data to Class<?> object\n        }\n        return null;\n    }\n\n    private byte[] downloadClassData(String name) {\n        // 从 localhost 下载 .class 文件\n        String path = \"http://localhost\" + File.separatorChar + \"java\" + File.separatorChar + name.replace('.', File.separatorChar) + \".class\"; \n\n        try {\n            URL url = new URL(path);\n            InputStream ins = url.openStream();\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            int bufferSize = 4096;\n            byte[] buffer = new byte[bufferSize];\n            int bytesNumRead = 0;\n            while ((bytesNumRead = ins.read(buffer)) != -1) {\n                baos.write(buffer, 0, bytesNumRead); // 把下载的二进制数据存入 ByteArrayOutputStream\n            }\n            return baos.toByteArray();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public String getName() {\n        System.out.printf(\"Real NetworkClassLoader\\n\");\n        return \"networkClassLoader\";\n    }\n}\n```\n\n这个类的作用是从网络上（这里是本人的 local apache 服务器 http://localhost/java 上）目录里去下载对应的 .class 文件，并转换成 Class<?> 返回回去使用。\n\n下面我们来利用这个 `NetworkClassLoader` 去加载 localhost 上的 `MusicPlayer` 类：\n\n1. 首先把 `MusicPlayer.class` 放置于 `/Library/WebServer/Documents/java` （MacOS）目录下，由于 MacOS 自带 apache 服务器，这里是服务器的默认目录；\n2. 执行下面一段代码：\n```\nString className = \"classloader.NetworkClass\";\nNetworkClassLoader networkClassLoader = new NetworkClassLoader();\nClass<?> clazz  = networkClassLoader.loadClass(className);\n```\n3. 正常运行，加载 `http://localhost/java/classloader/MusicPlayer.class`成功。\n\n可以看出 `NetworkClassLoader` 可以正常工作，如果读者要用的话，只要稍微修改 url 的拼接方式即可自行使用。\n\n## 小结\n类加载方式是 Java 上非常创新的一项技术，给未来的热修复技术提供了可能。本文力求通过简单的语言和合适的例子来讲解其中`双亲委托机制`、`自定义加载器`等，并开发了自定义的`NetworkClassLoader`。\n\n当然，类加载是很有意思的技术，很难覆盖所有知识点，比如不同类加载器加载同一个类，得到的实例却不是同一个等等。\n\n之后我还会写作关于热修复／动态更新相关的技术，欢迎关注。\n\n谢谢。\n\nwingjay\n\nhttp://wingjay.com\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n\n","slug":"java_classloader","published":1,"updated":"2018-11-26T06:56:27.481Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplsi1002i3dn8fw6hjh1w","content":"<blockquote>\n<p>类加载机制是 Java 语言的一大亮点，使得 Java 类可以被动态加载到 Java 虚拟机中。</p>\n<p>这次我们抛开术语和概念，从例子入手，由浅入深地讲解 Java 的类加载机制。</p>\n<p>本文涉及知识点：双亲委托机制、BootstrapClassLoader、ExtClassLoader、AppClassLoader、自定义网络类加载器等</p>\n<p>文章涉及代码：<br><a href=\"https://github.com/wingjay/HelloJava/blob/master/common/src/classloader/HelloClassLoader.java\" target=\"_blank\" rel=\"external\">https://github.com/wingjay/HelloJava/blob/master/common/src/classloader/HelloClassLoader.java</a></p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"什么是 -Java- 类加载机制\"><a href=\"# 什么是 -Java- 类加载机制\" class=\"headerlink\" title=\"什么是 Java 类加载机制?\"></a>什么是 Java 类加载机制?</h2><p>Java 虚拟机一般使用 Java 类的流程为：首先将开发者编写的 Java 源代码（.java 文件）编译成 Java 字节码（.class 文件），然后类加载器会读取这个 .class 文件，并转换成 java.lang.Class 的实例。有了该 Class 实例后，Java 虚拟机可以利用 newInstance 之类的方法创建其真正对象了。</p>\n<p>ClassLoader 是 Java 提供的类加载器，绝大多数的类加载器都继承自 ClassLoader，它们被用来加载不同来源的 Class 文件。</p>\n<h2 id=\"Class- 文件有哪些来源呢\"><a href=\"#Class- 文件有哪些来源呢\" class=\"headerlink\" title=\"Class 文件有哪些来源呢?\"></a>Class 文件有哪些来源呢?</h2><p>上文提到了 ClassLoader 可以去加载多种来源的 Class，那么具体有哪些来源呢？</p>\n<p>首先，最常见的是开发者在应用程序中编写的类，这些类位于项目目录下；</p>\n<p>然后，有 Java 内部自带的 <code> 核心类 </code> 如 <code>java.lang</code>、<code>java.math</code>、<code>java.io</code> 等 package 内部的类，位于 <code>$JAVA_HOME/jre/lib/</code> 目录下，如 <code>java.lang.String</code> 类就是定义在 <code>$JAVA_HOME/jre/lib/rt.jar</code> 文件里；</p>\n<p>另外，还有 Java <code>核心扩展类</code>，位于 <code>$JAVA_HOME/jre/lib/ext</code> 目录下。开发者也可以把自己编写的类打包成 jar 文件放入该目录下；</p>\n<p>最后还有一种，是动态加载远程的 .class 文件。</p>\n<p>既然有这么多种类的来源，那么在 Java 里，是由某一个具体的 ClassLoader 来统一加载呢？还是由多个 ClassLoader 来协作加载呢？</p>\n<h2 id=\"哪些 -ClassLoader- 负责加载上面几类 -Class？\"><a href=\"# 哪些 -ClassLoader- 负责加载上面几类 -Class？\" class=\"headerlink\" title=\"哪些 ClassLoader 负责加载上面几类 Class？\"></a>哪些 ClassLoader 负责加载上面几类 Class？</h2><p>实际上，针对上面四种来源的类，分别有不同的加载器负责加载。</p>\n<p>首先，我们来看级别最高的 <code>Java 核心类 </code>，即<code>$JAVA_HOME/jre/lib</code> 里的核心 jar 文件。这些类是 Java 运行的基础类，由一个名为 <code>BootstrapClassLoader</code> 加载器负责加载，它也被称作 <code> 根加载器／引导加载器</code>。注意，<code>BootstrapClassLoader</code> 比较特殊，它不继承 <code>ClassLoader</code>，而是由 JVM 内部实现；</p>\n<p>然后，需要加载 <code>Java 核心扩展类 </code>，即 <code>$JAVA_HOME/jre/lib/ext</code> 目录下的 jar 文件。这些文件由 <code>ExtensionClassLoader</code> 负责加载，它也被称作 <code> 扩展类加载器</code>。当然，用户如果把自己开发的 jar 文件放在这个目录，也会被 <code>ExtClassLoader</code> 加载；</p>\n<p>接下来是开发者在项目中编写的类，这些文件将由 <code>AppClassLoader</code> 加载器进行加载，它也被称作 <code>系统类加载器 System ClassLoader</code>；</p>\n<p>最后，如果想远程加载如（本地文件／网络下载）的方式，则必须要自己自定义一个 ClassLoader，复写其中的 <code>findClass()</code> 方法才能得以实现。</p>\n<p>因此能看出，Java 里提供了至少四类 <code>ClassLoader</code> 来分别加载不同来源的 Class。</p>\n<p>那么，这几种 ClassLoader 是如何协作来加载一个类呢？</p>\n<h2 id=\"这些 -ClassLoader- 以何种方式来协作加载 -String- 类呢？\"><a href=\"# 这些 -ClassLoader- 以何种方式来协作加载 -String- 类呢？\" class=\"headerlink\" title=\"这些 ClassLoader 以何种方式来协作加载 String 类呢？\"></a>这些 ClassLoader 以何种方式来协作加载 String 类呢？</h2><p>String 类是 Java 自带的最常用的一个类，现在的问题是，JVM 将以何种方式把 String class 加载进来呢？</p>\n<p>我们来猜想下。</p>\n<p>首先，String 类属于 Java 核心类，位于 <code>$JAVA_HOME/jre/lib</code> 目录下。有的朋友会马上反应过来，上文中提过了，该目录下的类会由 <code>BootstrapClassLoader</code> 进行加载。没错，它确实是由 <code>BootstrapClassLoader</code> 进行加载。但，这种回答的前提是你已经知道了 String 在 <code>$JAVA_HOME/jre/lib</code> 目录下。</p>\n<p>那么，如果你并不知道 String 类究竟位于哪呢？或者我希望你去加载一个 <code>unknown</code> 的类呢？</p>\n<p>有的朋友这时会说，那很简单，只要去遍历一遍所有的类，看看这个 <code>unknown</code> 的类位于哪里，然后再用对应的加载器去加载。</p>\n<p>是的，思路很正确。那应该如何去遍历呢？</p>\n<p>比如，可以先遍历用户自己写的类，如果找到了就用 <code>AppClassLoader</code> 去加载；否则去遍历 Java 核心类目录，找到了就用 <code>BootstrapClassLoader</code> 去加载，否则就去遍历 Java 扩展类库，依次类推。</p>\n<p>这种思路方向是正确的，不过存在一个漏洞。</p>\n<p>假如开发者自己伪造了一个 <code>java.lang.String</code> 类，即在项目中创建一个包<code>java.lang</code>，包内创建一个名为 <code>String</code> 的类，这完全可以做到。那如果利用上面的遍历方法，是不是这个项目中用到的 String 不是都变成了这个伪造的 <code>java.lang.String</code> 类吗？如何解决这个问题呢？</p>\n<p>解决方法很简单，当查找一个类时，优先遍历最高级别的 Java 核心类，然后再去遍历 Java 核心扩展类，最后再遍历用户自定义类，而且这个遍历过程是一旦找到就立即停止遍历。</p>\n<p>在 Java 中，这种实现方式也称作 <code>双亲委托</code>。其实很简单，把 <code>BootstrapClassLoader</code> 想象为核心高层领导人， <code>ExtClassLoader</code> 想象为中层干部， <code>AppClassLoader</code> 想象为普通公务员。每次需要加载一个类，先获取一个系统加载器 <code>AppClassLoader</code> 的实例（ClassLoader.getSystemClassLoader()），然后向上级层层请求，由最上级优先去加载，如果上级觉得这些类不属于核心类，就可以下放到各子级负责人去自行加载。</p>\n<p>如下图所示：<br><img src=\"/img/classloader/order.png\" alt=\"双亲委托\"></p>\n<h2 id=\"真的是按照双亲委托方式进行类加载吗？\"><a href=\"# 真的是按照双亲委托方式进行类加载吗？\" class=\"headerlink\" title=\"真的是按照双亲委托方式进行类加载吗？\"></a>真的是按照 <code> 双亲委托 </code> 方式进行类加载吗？</h2><p>下面通过几个例子来验证上面的加载方式。</p>\n<h4 id=\"开发者自定义的类会被 -AppClassLoader- 加载吗？\"><a href=\"# 开发者自定义的类会被 -AppClassLoader- 加载吗？\" class=\"headerlink\" title=\"开发者自定义的类会被 AppClassLoader 加载吗？\"></a>开发者自定义的类会被 <code>AppClassLoader</code> 加载吗？</h4><p>在项目中创建一个名为 <code>MusicPlayer</code> 的类文件，内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">package classloader;</div><div class=\"line\"></div><div class=\"line\">public class MusicPlayer &#123;</div><div class=\"line\">\tpublic void print() &#123;</div><div class=\"line\">\t\tSystem.out.printf(&quot;Hi I&apos;m MusicPlayer&quot;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>然后来加载 <code>MusicPlayer</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void loadClass() throws ClassNotFoundException &#123;</div><div class=\"line\">    Class&lt;?&gt; clazz = Class.forName(&quot;classloader.MusicPlayer&quot;);</div><div class=\"line\">    ClassLoader classLoader = clazz.getClassLoader();</div><div class=\"line\">    System.out.printf(&quot;ClassLoader is %s&quot;, classLoader.getClass().getSimpleName());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>打印结果为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ClassLoader is AppClassLoader</div></pre></td></tr></table></figure></p>\n<p>可以验证，<code>MusicPlayer</code> 是由 <code>AppClassLoader</code> 进行的加载。</p>\n<h4 id=\"验证 -AppClassLoader- 的双亲真的是 -ExtClassLoader- 和 -BootstrapClassLoader- 吗？\"><a href=\"# 验证 -AppClassLoader- 的双亲真的是 -ExtClassLoader- 和 -BootstrapClassLoader- 吗？\" class=\"headerlink\" title=\"验证 AppClassLoader 的双亲真的是 ExtClassLoader 和 BootstrapClassLoader 吗？\"></a>验证 <code>AppClassLoader</code> 的双亲真的是 ExtClassLoader 和 BootstrapClassLoader 吗？</h4><p>这时发现 <code>AppClassLoader</code> 提供了一个 <code>getParent()</code> 的方法，来打印看看都是什么。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void printParent() throws ClassNotFoundException &#123;</div><div class=\"line\">        Class&lt;?&gt; clazz = Class.forName(&quot;classloader.MusicPlayer&quot;);</div><div class=\"line\">        ClassLoader classLoader = clazz.getClassLoader();</div><div class=\"line\">        System.out.printf(&quot;currentClassLoader is %s\\n&quot;, classLoader.getClass().getSimpleName());</div><div class=\"line\"></div><div class=\"line\">        while (classLoader.getParent() != null) &#123;</div><div class=\"line\">            classLoader = classLoader.getParent();</div><div class=\"line\">            System.out.printf(&quot;Parent is %s\\n&quot;, classLoader.getClass().getSimpleName());</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>打印结果为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">currentClassLoader is AppClassLoader</div><div class=\"line\">Parent is ExtClassLoader</div></pre></td></tr></table></figure></p>\n<p>首先能看到 <code>ExtClassLoader</code> 确实是 <code>AppClassLoader</code> 的双亲，不过却没有看到 <code>BootstrapClassLoader</code>。事实上，上文就提过， <code>BootstrapClassLoader</code>比较特殊，它是由 JVM 内部实现的，所以 <code>ExtClassLoader.getParent() = null</code>。</p>\n<h4 id=\"如果把 -MusicPlayer- 类挪到 -JAVA-HOME-jre-lib-ext- 目录下会发生什么？\"><a href=\"# 如果把 -MusicPlayer- 类挪到 -JAVA-HOME-jre-lib-ext- 目录下会发生什么？\" class=\"headerlink\" title=\"如果把 MusicPlayer 类挪到 $JAVA_HOME/jre/lib/ext 目录下会发生什么？\"></a>如果把 MusicPlayer 类挪到 <code>$JAVA_HOME/jre/lib/ext</code> 目录下会发生什么？</h4><p>上文中说了，<code>ExtClassLoader</code> 会加载<code>$JAVA_HOME/jre/lib/ext</code> 目录下所有的 jar 文件。那来尝试下直接把 <code>MusicPlayer</code> 这个类放到 <code>$JAVA_HOME/jre/lib/ext</code> 目录下吧。</p>\n<p>利用下面命令可以把 MusicPlayer.java 编译打包成 jar 文件，并放置到对应目录。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">javac classloader/MusicPlayer.java</div><div class=\"line\">jar cvf MusicPlayer.jar classloader/MusicPlayer.class</div><div class=\"line\">mv MusicPlayer.jar $JAVA_HOME/jre/lib/ext/</div></pre></td></tr></table></figure></p>\n<p>这时 MusicPlayer.jar 已经被放置与 <code>$JAVA_HOME/jre/lib/ext</code> 目录下，同时把之前的 <code>MusicPlayer</code> <code>删除 </code>，而且这一次<code> 刻意 </code> 使用 <code>AppClassLoader</code> 来加载：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void loadClass() throws ClassNotFoundException &#123;</div><div class=\"line\">    ClassLoader appClassLoader = ClassLoader.getSystemClassLoader(); // AppClassLoader</div><div class=\"line\">    Class&lt;?&gt; clazz = appClassLoader.loadClass(&quot;classloader.MusicPlayer&quot;);</div><div class=\"line\">    ClassLoader classLoader = clazz.getClassLoader();</div><div class=\"line\">    System.out.printf(&quot;ClassLoader is %s&quot;, classLoader.getClass().getSimpleName());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>打印结果为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ClassLoader is ExtClassLoader</div></pre></td></tr></table></figure></p>\n<p>说明即使直接用 <code>AppClassLoader</code> 去加载，它仍然会被 <code>ExtClassLoader</code> 加载到。</p>\n<h2 id=\"从源码角度真正理解双亲委托加载机制\"><a href=\"# 从源码角度真正理解双亲委托加载机制\" class=\"headerlink\" title=\"从源码角度真正理解双亲委托加载机制\"></a>从源码角度真正理解 <code> 双亲委托 </code> 加载机制 </h2><p> 上面已经通过一些例子了解了 <code> 双亲委托 </code> 的一些特性了，下面来看一下它的实现代码，加深理解。</p>\n<p>打开 <code>ClassLoader</code> 里的 <code>loadClass()</code> 方法，便是需要分析的源码了。这个方法里做了下面几件事：</p>\n<ol>\n<li>检查目标 class 是否曾经加载过，如果加载过则直接返回；</li>\n<li>如果没加载过，把加载请求传递给 parent 加载器去加载；</li>\n<li>如果 parent 加载器加载成功，则直接返回；</li>\n<li>如果 parent 未加载到，则自身调用 findClass() 方法进行寻找，并把寻找结果返回。</li>\n</ol>\n<p>代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</div><div class=\"line\">    throws ClassNotFoundException</div><div class=\"line\">&#123;</div><div class=\"line\">    synchronized (getClassLoadingLock(name)) &#123;</div><div class=\"line\">        // 1. 检查是否曾加载过</div><div class=\"line\">        Class&lt;?&gt; c = findLoadedClass(name);</div><div class=\"line\">        if (c == null) &#123;</div><div class=\"line\">            long t0 = System.nanoTime();</div><div class=\"line\">            try &#123;</div><div class=\"line\">                if (parent != null) &#123;</div><div class=\"line\">                \t// 优先让 parent 加载器去加载</div><div class=\"line\">                    c = parent.loadClass(name, false);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                \t// 如无 parent，表示当前是 BootstrapClassLoader，调用 native 方法去 JVM 加载</div><div class=\"line\">                    c = findBootstrapClassOrNull(name);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; catch (ClassNotFoundException e) &#123;</div><div class=\"line\">                // ClassNotFoundException thrown if class not found</div><div class=\"line\">                // from the non-null parent class loader</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (c == null) &#123;</div><div class=\"line\">            \t// 如果 parent 均没有加载到目标 class，调用自身的 findClass() 方法去搜索</div><div class=\"line\">                long t1 = System.nanoTime();</div><div class=\"line\">                c = findClass(name);</div><div class=\"line\"></div><div class=\"line\">                // this is the defining class loader; record the stats</div><div class=\"line\">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</div><div class=\"line\">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</div><div class=\"line\">                sun.misc.PerfCounter.getFindClasses().increment();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (resolve) &#123;</div><div class=\"line\">            resolveClass(c);</div><div class=\"line\">        &#125;</div><div class=\"line\">        return c;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// BootstrapClassLoader 会调用 native 方法去 JVM 加载</div><div class=\"line\">private native Class&lt;?&gt; findBootstrapClass(String name);</div></pre></td></tr></table></figure></p>\n<p>看完实现源码相信能够有更完整的理解。</p>\n<h2 id=\"类加载器最酷的一面：自定义类加载器\"><a href=\"# 类加载器最酷的一面：自定义类加载器\" class=\"headerlink\" title=\"类加载器最酷的一面：自定义类加载器\"></a>类加载器最酷的一面：自定义类加载器 </h2><p> 前面提到了 Java 自带的加载器 <code>BootstrapClassLoader</code>、<code>AppClassLoader</code>和<code>ExtClassLoader</code>，这些都是 Java 已经提供好的。</p>\n<p>而真正有意思的，是 <code>自定义类加载器 </code>，它允许我们在<code> 运行时 </code> 可以从 <code> 本地磁盘或网络 </code> 上动态加载自定义类。这使得开发者可以动态修复某些有问题的类，热更新代码。</p>\n<p>下面来实现一个 <code> 网络类加载器</code>，这个加载器可以从网络上动态下载 .class 文件并加载到虚拟机中使用。</p>\n<p>后面我还会写作与 <code>热修复／动态更新</code> 相关的文章，这里先学习 Java 层 <code>NetworkClassLoader</code> 相关的原理。</p>\n<ol>\n<li>作为一个 <code>NetworkClassLoader</code>，它首先要继承 <code>ClassLoader</code>；</li>\n<li>然后它要实现 <code>ClassLoader</code> 内的 <code>findClass()</code> 方法。注意，不是 <code>loadClass()</code> 方法，因为 <code>ClassLoader</code> 提供了 <code>loadClass()</code>（如上面的源码），它会基于<code> 双亲委托 </code> 机制去搜索某个 class，直到搜索不到才会调用自身的 <code>findClass()</code>，如果直接复写<code>loadClass()</code>，那还要实现<code> 双亲委托 </code> 机制；</li>\n<li>在 <code>findClass()</code> 方法里，要从网络上下载一个 .class 文件，然后转化成 Class 对象供虚拟机使用。</li>\n</ol>\n<p>具体实现代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Load class from network</div><div class=\"line\"> */</div><div class=\"line\">public class NetworkClassLoader extends ClassLoader &#123;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</div><div class=\"line\">        byte[] classData = downloadClassData(name); // 从远程下载</div><div class=\"line\">        if (classData == null) &#123;</div><div class=\"line\">            super.findClass(name); // 未找到，抛异常</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            return defineClass(name, classData, 0, classData.length); // convert class byte data to Class&lt;?&gt; object</div><div class=\"line\">        &#125;</div><div class=\"line\">        return null;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    private byte[] downloadClassData(String name) &#123;</div><div class=\"line\">        // 从 localhost 下载 .class 文件</div><div class=\"line\">        String path = &quot;http://localhost&quot; + File.separatorChar + &quot;java&quot; + File.separatorChar + name.replace(&apos;.&apos;, File.separatorChar) + &quot;.class&quot;; </div><div class=\"line\"></div><div class=\"line\">        try &#123;</div><div class=\"line\">            URL url = new URL(path);</div><div class=\"line\">            InputStream ins = url.openStream();</div><div class=\"line\">            ByteArrayOutputStream baos = new ByteArrayOutputStream();</div><div class=\"line\">            int bufferSize = 4096;</div><div class=\"line\">            byte[] buffer = new byte[bufferSize];</div><div class=\"line\">            int bytesNumRead = 0;</div><div class=\"line\">            while ((bytesNumRead = ins.read(buffer)) != -1) &#123;</div><div class=\"line\">                baos.write(buffer, 0, bytesNumRead); // 把下载的二进制数据存入 ByteArrayOutputStream</div><div class=\"line\">            &#125;</div><div class=\"line\">            return baos.toByteArray();</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">        &#125;</div><div class=\"line\">        return null;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public String getName() &#123;</div><div class=\"line\">        System.out.printf(&quot;Real NetworkClassLoader\\n&quot;);</div><div class=\"line\">        return &quot;networkClassLoader&quot;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这个类的作用是从网络上（这里是本人的 local apache 服务器 <a href=\"http://localhost/java\" target=\"_blank\" rel=\"external\">http://localhost/java</a> 上）目录里去下载对应的 .class 文件，并转换成 Class&lt;?&gt; 返回回去使用。</p>\n<p>下面我们来利用这个 <code>NetworkClassLoader</code> 去加载 localhost 上的 <code>MusicPlayer</code> 类：</p>\n<ol>\n<li>首先把 <code>MusicPlayer.class</code> 放置于 <code>/Library/WebServer/Documents/java</code> （MacOS）目录下，由于 MacOS 自带 apache 服务器，这里是服务器的默认目录；</li>\n<li><p>执行下面一段代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">String className = &quot;classloader.NetworkClass&quot;;</div><div class=\"line\">NetworkClassLoader networkClassLoader = new NetworkClassLoader();</div><div class=\"line\">Class&lt;?&gt; clazz  = networkClassLoader.loadClass(className);</div></pre></td></tr></table></figure>\n</li>\n<li><p>正常运行，加载 <code>http://localhost/java/classloader/MusicPlayer.class</code>成功。</p>\n</li>\n</ol>\n<p>可以看出 <code>NetworkClassLoader</code> 可以正常工作，如果读者要用的话，只要稍微修改 url 的拼接方式即可自行使用。</p>\n<h2 id=\"小结\"><a href=\"# 小结\" class=\"headerlink\" title=\"小结\"></a>小结 </h2><p> 类加载方式是 Java 上非常创新的一项技术，给未来的热修复技术提供了可能。本文力求通过简单的语言和合适的例子来讲解其中 <code> 双亲委托机制 </code>、<code> 自定义加载器 </code> 等，并开发了自定义的<code>NetworkClassLoader</code>。</p>\n<p>当然，类加载是很有意思的技术，很难覆盖所有知识点，比如不同类加载器加载同一个类，得到的实例却不是同一个等等。</p>\n<p>之后我还会写作关于热修复／动态更新相关的技术，欢迎关注。</p>\n<p>谢谢。</p>\n<p>wingjay</p>\n<p><a href=\"http://wingjay.com\">http://wingjay.com</a></p>\n<p><img src=\"https://avatars0.githubusercontent.com/u/9619875?v=3&amp;s=460\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>类加载机制是 Java 语言的一大亮点，使得 Java 类可以被动态加载到 Java 虚拟机中。</p>\n<p>这次我们抛开术语和概念，从例子入手，由浅入深地讲解 Java 的类加载机制。</p>\n<p>本文涉及知识点：双亲委托机制、BootstrapClassLoader、ExtClassLoader、AppClassLoader、自定义网络类加载器等</p>\n<p>文章涉及代码：<br><a href=\"https://github.com/wingjay/HelloJava/blob/master/common/src/classloader/HelloClassLoader.java\" target=\"_blank\" rel=\"external\">https://github.com/wingjay/HelloJava/blob/master/common/src/classloader/HelloClassLoader.java</a></p>\n</blockquote>","more":"<h2 id=\"什么是-Java-类加载机制\"><a href=\"#什么是-Java-类加载机制\" class=\"headerlink\" title=\"什么是 Java 类加载机制?\"></a>什么是 Java 类加载机制?</h2><p>Java 虚拟机一般使用 Java 类的流程为：首先将开发者编写的 Java 源代码（.java文件）编译成 Java 字节码（.class文件），然后类加载器会读取这个 .class 文件，并转换成 java.lang.Class 的实例。有了该 Class 实例后，Java 虚拟机可以利用 newInstance 之类的方法创建其真正对象了。</p>\n<p>ClassLoader 是 Java 提供的类加载器，绝大多数的类加载器都继承自 ClassLoader，它们被用来加载不同来源的 Class 文件。</p>\n<h2 id=\"Class-文件有哪些来源呢\"><a href=\"#Class-文件有哪些来源呢\" class=\"headerlink\" title=\"Class 文件有哪些来源呢?\"></a>Class 文件有哪些来源呢?</h2><p>上文提到了 ClassLoader 可以去加载多种来源的 Class，那么具体有哪些来源呢？</p>\n<p>首先，最常见的是开发者在应用程序中编写的类，这些类位于项目目录下；</p>\n<p>然后，有 Java 内部自带的<code>核心类</code>如 <code>java.lang</code>、<code>java.math</code>、<code>java.io</code> 等 package 内部的类，位于 <code>$JAVA_HOME/jre/lib/</code> 目录下，如 <code>java.lang.String</code> 类就是定义在 <code>$JAVA_HOME/jre/lib/rt.jar</code> 文件里；</p>\n<p>另外，还有 Java <code>核心扩展类</code>，位于 <code>$JAVA_HOME/jre/lib/ext</code> 目录下。开发者也可以把自己编写的类打包成 jar 文件放入该目录下；</p>\n<p>最后还有一种，是动态加载远程的 .class 文件。</p>\n<p>既然有这么多种类的来源，那么在 Java 里，是由某一个具体的 ClassLoader 来统一加载呢？还是由多个 ClassLoader 来协作加载呢？</p>\n<h2 id=\"哪些-ClassLoader-负责加载上面几类-Class？\"><a href=\"#哪些-ClassLoader-负责加载上面几类-Class？\" class=\"headerlink\" title=\"哪些 ClassLoader 负责加载上面几类 Class？\"></a>哪些 ClassLoader 负责加载上面几类 Class？</h2><p>实际上，针对上面四种来源的类，分别有不同的加载器负责加载。</p>\n<p>首先，我们来看级别最高的 <code>Java 核心类</code>，即<code>$JAVA_HOME/jre/lib</code> 里的核心 jar 文件。这些类是 Java 运行的基础类，由一个名为 <code>BootstrapClassLoader</code> 加载器负责加载，它也被称作 <code>根加载器／引导加载器</code>。注意，<code>BootstrapClassLoader</code> 比较特殊，它不继承 <code>ClassLoader</code>，而是由 JVM 内部实现；</p>\n<p>然后，需要加载 <code>Java 核心扩展类</code>，即 <code>$JAVA_HOME/jre/lib/ext</code> 目录下的 jar 文件。这些文件由 <code>ExtensionClassLoader</code> 负责加载，它也被称作 <code>扩展类加载器</code>。当然，用户如果把自己开发的 jar 文件放在这个目录，也会被 <code>ExtClassLoader</code> 加载；</p>\n<p>接下来是开发者在项目中编写的类，这些文件将由 <code>AppClassLoader</code> 加载器进行加载，它也被称作 <code>系统类加载器 System ClassLoader</code>；</p>\n<p>最后，如果想远程加载如（本地文件／网络下载）的方式，则必须要自己自定义一个 ClassLoader，复写其中的 <code>findClass()</code> 方法才能得以实现。</p>\n<p>因此能看出，Java 里提供了至少四类 <code>ClassLoader</code> 来分别加载不同来源的 Class。</p>\n<p>那么，这几种 ClassLoader 是如何协作来加载一个类呢？</p>\n<h2 id=\"这些-ClassLoader-以何种方式来协作加载-String-类呢？\"><a href=\"#这些-ClassLoader-以何种方式来协作加载-String-类呢？\" class=\"headerlink\" title=\"这些 ClassLoader 以何种方式来协作加载 String 类呢？\"></a>这些 ClassLoader 以何种方式来协作加载 String 类呢？</h2><p>String 类是 Java 自带的最常用的一个类，现在的问题是，JVM 将以何种方式把 String class 加载进来呢？</p>\n<p>我们来猜想下。</p>\n<p>首先，String 类属于 Java 核心类，位于 <code>$JAVA_HOME/jre/lib</code> 目录下。有的朋友会马上反应过来，上文中提过了，该目录下的类会由 <code>BootstrapClassLoader</code> 进行加载。没错，它确实是由 <code>BootstrapClassLoader</code> 进行加载。但，这种回答的前提是你已经知道了 String 在 <code>$JAVA_HOME/jre/lib</code> 目录下。</p>\n<p>那么，如果你并不知道 String 类究竟位于哪呢？或者我希望你去加载一个 <code>unknown</code> 的类呢？</p>\n<p>有的朋友这时会说，那很简单，只要去遍历一遍所有的类，看看这个 <code>unknown</code> 的类位于哪里，然后再用对应的加载器去加载。</p>\n<p>是的，思路很正确。那应该如何去遍历呢？</p>\n<p>比如，可以先遍历用户自己写的类，如果找到了就用 <code>AppClassLoader</code> 去加载；否则去遍历 Java 核心类目录，找到了就用 <code>BootstrapClassLoader</code> 去加载，否则就去遍历 Java 扩展类库，依次类推。</p>\n<p>这种思路方向是正确的，不过存在一个漏洞。</p>\n<p>假如开发者自己伪造了一个 <code>java.lang.String</code> 类，即在项目中创建一个包<code>java.lang</code>，包内创建一个名为 <code>String</code> 的类，这完全可以做到。那如果利用上面的遍历方法，是不是这个项目中用到的 String 不是都变成了这个伪造的 <code>java.lang.String</code> 类吗？如何解决这个问题呢？</p>\n<p>解决方法很简单，当查找一个类时，优先遍历最高级别的 Java 核心类，然后再去遍历 Java 核心扩展类，最后再遍历用户自定义类，而且这个遍历过程是一旦找到就立即停止遍历。</p>\n<p>在 Java 中，这种实现方式也称作 <code>双亲委托</code>。其实很简单，把 <code>BootstrapClassLoader</code> 想象为核心高层领导人， <code>ExtClassLoader</code> 想象为中层干部， <code>AppClassLoader</code> 想象为普通公务员。每次需要加载一个类，先获取一个系统加载器 <code>AppClassLoader</code> 的实例（ClassLoader.getSystemClassLoader()），然后向上级层层请求，由最上级优先去加载，如果上级觉得这些类不属于核心类，就可以下放到各子级负责人去自行加载。</p>\n<p>如下图所示：<br><img src=\"/img/classloader/order.png\" alt=\"双亲委托\"></p>\n<h2 id=\"真的是按照双亲委托方式进行类加载吗？\"><a href=\"#真的是按照双亲委托方式进行类加载吗？\" class=\"headerlink\" title=\"真的是按照双亲委托方式进行类加载吗？\"></a>真的是按照<code>双亲委托</code>方式进行类加载吗？</h2><p>下面通过几个例子来验证上面的加载方式。</p>\n<h4 id=\"开发者自定义的类会被-AppClassLoader-加载吗？\"><a href=\"#开发者自定义的类会被-AppClassLoader-加载吗？\" class=\"headerlink\" title=\"开发者自定义的类会被 AppClassLoader 加载吗？\"></a>开发者自定义的类会被 <code>AppClassLoader</code> 加载吗？</h4><p>在项目中创建一个名为 <code>MusicPlayer</code> 的类文件，内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">package classloader;</div><div class=\"line\"></div><div class=\"line\">public class MusicPlayer &#123;</div><div class=\"line\">\tpublic void print() &#123;</div><div class=\"line\">\t\tSystem.out.printf(&quot;Hi I&apos;m MusicPlayer&quot;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>然后来加载 <code>MusicPlayer</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void loadClass() throws ClassNotFoundException &#123;</div><div class=\"line\">    Class&lt;?&gt; clazz = Class.forName(&quot;classloader.MusicPlayer&quot;);</div><div class=\"line\">    ClassLoader classLoader = clazz.getClassLoader();</div><div class=\"line\">    System.out.printf(&quot;ClassLoader is %s&quot;, classLoader.getClass().getSimpleName());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>打印结果为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ClassLoader is AppClassLoader</div></pre></td></tr></table></figure></p>\n<p>可以验证，<code>MusicPlayer</code> 是由 <code>AppClassLoader</code> 进行的加载。</p>\n<h4 id=\"验证-AppClassLoader-的双亲真的是-ExtClassLoader-和-BootstrapClassLoader-吗？\"><a href=\"#验证-AppClassLoader-的双亲真的是-ExtClassLoader-和-BootstrapClassLoader-吗？\" class=\"headerlink\" title=\"验证 AppClassLoader 的双亲真的是 ExtClassLoader 和 BootstrapClassLoader 吗？\"></a>验证 <code>AppClassLoader</code> 的双亲真的是 ExtClassLoader 和 BootstrapClassLoader 吗？</h4><p>这时发现 <code>AppClassLoader</code> 提供了一个 <code>getParent()</code> 的方法，来打印看看都是什么。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void printParent() throws ClassNotFoundException &#123;</div><div class=\"line\">        Class&lt;?&gt; clazz = Class.forName(&quot;classloader.MusicPlayer&quot;);</div><div class=\"line\">        ClassLoader classLoader = clazz.getClassLoader();</div><div class=\"line\">        System.out.printf(&quot;currentClassLoader is %s\\n&quot;, classLoader.getClass().getSimpleName());</div><div class=\"line\"></div><div class=\"line\">        while (classLoader.getParent() != null) &#123;</div><div class=\"line\">            classLoader = classLoader.getParent();</div><div class=\"line\">            System.out.printf(&quot;Parent is %s\\n&quot;, classLoader.getClass().getSimpleName());</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>打印结果为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">currentClassLoader is AppClassLoader</div><div class=\"line\">Parent is ExtClassLoader</div></pre></td></tr></table></figure></p>\n<p>首先能看到 <code>ExtClassLoader</code> 确实是 <code>AppClassLoader</code> 的双亲，不过却没有看到 <code>BootstrapClassLoader</code>。事实上，上文就提过， <code>BootstrapClassLoader</code>比较特殊，它是由 JVM 内部实现的，所以 <code>ExtClassLoader.getParent() = null</code>。</p>\n<h4 id=\"如果把-MusicPlayer-类挪到-JAVA-HOME-jre-lib-ext-目录下会发生什么？\"><a href=\"#如果把-MusicPlayer-类挪到-JAVA-HOME-jre-lib-ext-目录下会发生什么？\" class=\"headerlink\" title=\"如果把 MusicPlayer 类挪到 $JAVA_HOME/jre/lib/ext 目录下会发生什么？\"></a>如果把 MusicPlayer 类挪到 <code>$JAVA_HOME/jre/lib/ext</code> 目录下会发生什么？</h4><p>上文中说了，<code>ExtClassLoader</code> 会加载<code>$JAVA_HOME/jre/lib/ext</code> 目录下所有的 jar 文件。那来尝试下直接把 <code>MusicPlayer</code> 这个类放到 <code>$JAVA_HOME/jre/lib/ext</code> 目录下吧。</p>\n<p>利用下面命令可以把 MusicPlayer.java 编译打包成 jar 文件，并放置到对应目录。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">javac classloader/MusicPlayer.java</div><div class=\"line\">jar cvf MusicPlayer.jar classloader/MusicPlayer.class</div><div class=\"line\">mv MusicPlayer.jar $JAVA_HOME/jre/lib/ext/</div></pre></td></tr></table></figure></p>\n<p>这时 MusicPlayer.jar 已经被放置与 <code>$JAVA_HOME/jre/lib/ext</code> 目录下，同时把之前的 <code>MusicPlayer</code> <code>删除</code>，而且这一次<code>刻意</code>使用 <code>AppClassLoader</code> 来加载：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void loadClass() throws ClassNotFoundException &#123;</div><div class=\"line\">    ClassLoader appClassLoader = ClassLoader.getSystemClassLoader(); // AppClassLoader</div><div class=\"line\">    Class&lt;?&gt; clazz = appClassLoader.loadClass(&quot;classloader.MusicPlayer&quot;);</div><div class=\"line\">    ClassLoader classLoader = clazz.getClassLoader();</div><div class=\"line\">    System.out.printf(&quot;ClassLoader is %s&quot;, classLoader.getClass().getSimpleName());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>打印结果为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ClassLoader is ExtClassLoader</div></pre></td></tr></table></figure></p>\n<p>说明即使直接用 <code>AppClassLoader</code> 去加载，它仍然会被 <code>ExtClassLoader</code> 加载到。</p>\n<h2 id=\"从源码角度真正理解双亲委托加载机制\"><a href=\"#从源码角度真正理解双亲委托加载机制\" class=\"headerlink\" title=\"从源码角度真正理解双亲委托加载机制\"></a>从源码角度真正理解<code>双亲委托</code>加载机制</h2><p>上面已经通过一些例子了解了<code>双亲委托</code>的一些特性了，下面来看一下它的实现代码，加深理解。</p>\n<p>打开 <code>ClassLoader</code> 里的 <code>loadClass()</code> 方法，便是需要分析的源码了。这个方法里做了下面几件事：</p>\n<ol>\n<li>检查目标class是否曾经加载过，如果加载过则直接返回；</li>\n<li>如果没加载过，把加载请求传递给 parent 加载器去加载；</li>\n<li>如果 parent 加载器加载成功，则直接返回；</li>\n<li>如果 parent 未加载到，则自身调用 findClass() 方法进行寻找，并把寻找结果返回。</li>\n</ol>\n<p>代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</div><div class=\"line\">    throws ClassNotFoundException</div><div class=\"line\">&#123;</div><div class=\"line\">    synchronized (getClassLoadingLock(name)) &#123;</div><div class=\"line\">        // 1. 检查是否曾加载过</div><div class=\"line\">        Class&lt;?&gt; c = findLoadedClass(name);</div><div class=\"line\">        if (c == null) &#123;</div><div class=\"line\">            long t0 = System.nanoTime();</div><div class=\"line\">            try &#123;</div><div class=\"line\">                if (parent != null) &#123;</div><div class=\"line\">                \t// 优先让 parent 加载器去加载</div><div class=\"line\">                    c = parent.loadClass(name, false);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                \t// 如无 parent，表示当前是 BootstrapClassLoader，调用 native 方法去 JVM 加载</div><div class=\"line\">                    c = findBootstrapClassOrNull(name);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; catch (ClassNotFoundException e) &#123;</div><div class=\"line\">                // ClassNotFoundException thrown if class not found</div><div class=\"line\">                // from the non-null parent class loader</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (c == null) &#123;</div><div class=\"line\">            \t// 如果 parent 均没有加载到目标class，调用自身的 findClass() 方法去搜索</div><div class=\"line\">                long t1 = System.nanoTime();</div><div class=\"line\">                c = findClass(name);</div><div class=\"line\"></div><div class=\"line\">                // this is the defining class loader; record the stats</div><div class=\"line\">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</div><div class=\"line\">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</div><div class=\"line\">                sun.misc.PerfCounter.getFindClasses().increment();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (resolve) &#123;</div><div class=\"line\">            resolveClass(c);</div><div class=\"line\">        &#125;</div><div class=\"line\">        return c;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// BootstrapClassLoader 会调用 native 方法去 JVM 加载</div><div class=\"line\">private native Class&lt;?&gt; findBootstrapClass(String name);</div></pre></td></tr></table></figure></p>\n<p>看完实现源码相信能够有更完整的理解。</p>\n<h2 id=\"类加载器最酷的一面：自定义类加载器\"><a href=\"#类加载器最酷的一面：自定义类加载器\" class=\"headerlink\" title=\"类加载器最酷的一面：自定义类加载器\"></a>类加载器最酷的一面：自定义类加载器</h2><p>前面提到了 Java 自带的加载器 <code>BootstrapClassLoader</code>、<code>AppClassLoader</code>和<code>ExtClassLoader</code>，这些都是 Java 已经提供好的。</p>\n<p>而真正有意思的，是 <code>自定义类加载器</code>，它允许我们在<code>运行时</code>可以从<code>本地磁盘或网络</code>上动态加载自定义类。这使得开发者可以动态修复某些有问题的类，热更新代码。</p>\n<p>下面来实现一个<code>网络类加载器</code>，这个加载器可以从网络上动态下载 .class 文件并加载到虚拟机中使用。</p>\n<p>后面我还会写作与 <code>热修复／动态更新</code> 相关的文章，这里先学习 Java 层 <code>NetworkClassLoader</code> 相关的原理。</p>\n<ol>\n<li>作为一个 <code>NetworkClassLoader</code>，它首先要继承 <code>ClassLoader</code>；</li>\n<li>然后它要实现<code>ClassLoader</code>内的 <code>findClass()</code> 方法。注意，不是<code>loadClass()</code>方法，因为<code>ClassLoader</code>提供了<code>loadClass()</code>（如上面的源码），它会基于<code>双亲委托</code>机制去搜索某个 class，直到搜索不到才会调用自身的<code>findClass()</code>，如果直接复写<code>loadClass()</code>，那还要实现<code>双亲委托</code>机制；</li>\n<li>在 <code>findClass()</code> 方法里，要从网络上下载一个 .class 文件，然后转化成 Class 对象供虚拟机使用。</li>\n</ol>\n<p>具体实现代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Load class from network</div><div class=\"line\"> */</div><div class=\"line\">public class NetworkClassLoader extends ClassLoader &#123;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</div><div class=\"line\">        byte[] classData = downloadClassData(name); // 从远程下载</div><div class=\"line\">        if (classData == null) &#123;</div><div class=\"line\">            super.findClass(name); // 未找到，抛异常</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            return defineClass(name, classData, 0, classData.length); // convert class byte data to Class&lt;?&gt; object</div><div class=\"line\">        &#125;</div><div class=\"line\">        return null;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    private byte[] downloadClassData(String name) &#123;</div><div class=\"line\">        // 从 localhost 下载 .class 文件</div><div class=\"line\">        String path = &quot;http://localhost&quot; + File.separatorChar + &quot;java&quot; + File.separatorChar + name.replace(&apos;.&apos;, File.separatorChar) + &quot;.class&quot;; </div><div class=\"line\"></div><div class=\"line\">        try &#123;</div><div class=\"line\">            URL url = new URL(path);</div><div class=\"line\">            InputStream ins = url.openStream();</div><div class=\"line\">            ByteArrayOutputStream baos = new ByteArrayOutputStream();</div><div class=\"line\">            int bufferSize = 4096;</div><div class=\"line\">            byte[] buffer = new byte[bufferSize];</div><div class=\"line\">            int bytesNumRead = 0;</div><div class=\"line\">            while ((bytesNumRead = ins.read(buffer)) != -1) &#123;</div><div class=\"line\">                baos.write(buffer, 0, bytesNumRead); // 把下载的二进制数据存入 ByteArrayOutputStream</div><div class=\"line\">            &#125;</div><div class=\"line\">            return baos.toByteArray();</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">        &#125;</div><div class=\"line\">        return null;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public String getName() &#123;</div><div class=\"line\">        System.out.printf(&quot;Real NetworkClassLoader\\n&quot;);</div><div class=\"line\">        return &quot;networkClassLoader&quot;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这个类的作用是从网络上（这里是本人的 local apache 服务器 <a href=\"http://localhost/java\" target=\"_blank\" rel=\"external\">http://localhost/java</a> 上）目录里去下载对应的 .class 文件，并转换成 Class&lt;?&gt; 返回回去使用。</p>\n<p>下面我们来利用这个 <code>NetworkClassLoader</code> 去加载 localhost 上的 <code>MusicPlayer</code> 类：</p>\n<ol>\n<li>首先把 <code>MusicPlayer.class</code> 放置于 <code>/Library/WebServer/Documents/java</code> （MacOS）目录下，由于 MacOS 自带 apache 服务器，这里是服务器的默认目录；</li>\n<li><p>执行下面一段代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">String className = &quot;classloader.NetworkClass&quot;;</div><div class=\"line\">NetworkClassLoader networkClassLoader = new NetworkClassLoader();</div><div class=\"line\">Class&lt;?&gt; clazz  = networkClassLoader.loadClass(className);</div></pre></td></tr></table></figure>\n</li>\n<li><p>正常运行，加载 <code>http://localhost/java/classloader/MusicPlayer.class</code>成功。</p>\n</li>\n</ol>\n<p>可以看出 <code>NetworkClassLoader</code> 可以正常工作，如果读者要用的话，只要稍微修改 url 的拼接方式即可自行使用。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>类加载方式是 Java 上非常创新的一项技术，给未来的热修复技术提供了可能。本文力求通过简单的语言和合适的例子来讲解其中<code>双亲委托机制</code>、<code>自定义加载器</code>等，并开发了自定义的<code>NetworkClassLoader</code>。</p>\n<p>当然，类加载是很有意思的技术，很难覆盖所有知识点，比如不同类加载器加载同一个类，得到的实例却不是同一个等等。</p>\n<p>之后我还会写作关于热修复／动态更新相关的技术，欢迎关注。</p>\n<p>谢谢。</p>\n<p>wingjay</p>\n<p><a href=\"http://wingjay.com\">http://wingjay.com</a></p>\n<p><img src=\"https://avatars0.githubusercontent.com/u/9619875?v=3&amp;s=460\" alt=\"\"></p>","sticky":0},{"title":"Java 里如何实现线程间通信？","date":"2017-04-09T09:24:06.000Z","commentIssueId":7,"_content":"> 正常情况下，每个子线程完成各自的任务就可以结束了。不过有的时候，我们希望多个线程协同工作来完成某个任务，这时就涉及到了线程间通信了。\n\n> 本文涉及到的知识点：`thread.join()`, `object.wait()`, `object.notify()`, `CountdownLatch`, `CyclicBarrier`, `FutureTask`, `Callable` 等。\n\n> 本文涉及代码：\nhttps://github.com/wingjay/HelloJava/blob/master/multi-thread/src/ForArticle.java\n\n<!-- more -->\n\n下面我从几个例子作为切入点来讲解下 Java 里有哪些方法来实现线程间通信。\n\n- 如何让两个线程依次执行？\n- 那如何让`两`个线程按照指定方式有序交叉运行呢？\n- 四个线程 A B C D，其中 D 要等到 A B C 全执行完毕后才执行，而且 A B C 是同步运行的\n- 三个运动员各自准备，等到三个人都准备好后，再一起跑\n- 子线程完成某件任务后，把得到的结果回传给主线程\n\n\n## 如何让两个线程依次执行？\n假设有两个线程，一个是线程 A，另一个是线程 B，两个线程分别依次打印 1-3 三个数字即可。我们来看下代码：\n```\nprivate static void demo1() {\n    Thread A = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            printNumber(\"A\");\n        }\n    });\n\n    Thread B = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            printNumber(\"B\");\n        }\n    });\n\n    A.start();\n    B.start();\n}\n```\n其中的 `printNumber(String)` 实现如下，用来依次打印 `1`, `2`, `3` 三个数字：\n```\nprivate static void printNumber(String threadName) {\n    int i=0;\n    while (i++ < 3) {\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(threadName + \" print: \" + i);\n    }\n}\n```\n\n这时我们得到的结果是：\n>B print: 1\nA print: 1\nB print: 2\nA print: 2\nB print: 3\nA print: 3\n\n可以看到 A 和 B 是同时打印的。\n\n那么，如果我们希望 B 在 A `全部打印`完后再开始打印呢？我们可以利用 `thread.join()` 方法，代码如下:\n```\nprivate static void demo2() {\n    Thread A = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            printNumber(\"A\");\n        }\n    });\n\n    Thread B = new Thread(new Runnable() {\n        @Override\n        public void run() {\n        \tSystem.out.println(\"B 开始等待 A\");\n            try {\n                A.join();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            printNumber(\"B\");\n        }\n    });\n\n    B.start();\n    A.start();\n}\n```\n\n得到的结果如下：\n\n>B 开始等待 A\nA print: 1\nA print: 2\nA print: 3\n\n>B print: 1\nB print: 2\nB print: 3\n\n所以我们能看到 `A.join()` 方法会让 B 一直等待直到 A 运行完毕。\n\n## 那如何让`两`个线程按照指定方式有序交叉运行呢？\n还是上面那个例子，我现在希望 A 在打印完 `1` 后，再让 B 打印 `1`, `2`, `3`，最后再回到 A 继续打印 `2`, `3`。这种需求下，显然 `Thread.join()` 已经不能满足了。我们需要更细粒度的锁来控制执行顺序。\n\n这里，我们可以利用 `object.wait()` 和 `object.notify()` 两个方法来实现。代码如下：\n```\n/**\n * A 1, B 1, B 2, B 3, A 2, A 3\n */\nprivate static void demo3() {\n    Object lock = new Object();\n\n    Thread A = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            synchronized (lock) {\n                System.out.println(\"A 1\");\n                try {\n                    lock.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n\n                System.out.println(\"A 2\");\n                System.out.println(\"A 3\");\n            }\n\n        }\n    });\n\n    Thread B = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            synchronized (lock) {\n                System.out.println(\"B 1\");\n                System.out.println(\"B 2\");\n                System.out.println(\"B 3\");\n\n                lock.notify();\n            }\n        }\n    });\n\n    A.start();\n    B.start();\n}\n```\n\n打印结果如下：\n>A 1\nA waiting...\n\n>B 1\nB 2\nB 3\nA 2\nA 3\n\n正是我们要的结果。\n\n那么，这个过程发生了什么呢？\n1. 首先创建一个 A 和 B 共享的对象锁 lock = new Object();\n2. 当 A 得到锁后，先打印 1，然后调用 `lock.wait()` 方法，交出锁的控制权，进入 `wait` 状态；\n3. 对 B 而言，由于 A 最开始得到了锁，导致 B 无法执行；直到 A 调用 `lock.wait()` 释放控制权后， B 才得到了锁；\n4. B 在得到锁后打印 1， 2， 3；然后调用 `lock.notify()` 方法，唤醒正在 `wait` 的 A;\n5. A 被唤醒后，继续打印剩下的 2，3。\n\n为了更好理解，我在上面的代码里加上 log 方便读者查看。\n\n\n```\nprivate static void demo3() {\n    Object lock = new Object();\n    Thread A = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            System.out.println(\"INFO: A 等待锁\");\n            synchronized (lock) {\n                System.out.println(\"INFO: A 得到了锁 lock\");\n                System.out.println(\"A 1\");\n                try {\n                    System.out.println(\"INFO: A 准备进入等待状态，放弃锁 lock 的控制权\");\n                    lock.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"INFO: 有人唤醒了 A, A 重新获得锁 lock\");\n                System.out.println(\"A 2\");\n                System.out.println(\"A 3\");\n            }\n\n        }\n    });\n    Thread B = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            System.out.println(\"INFO: B 等待锁\");\n            synchronized (lock) {\n                System.out.println(\"INFO: B 得到了锁 lock\");\n                System.out.println(\"B 1\");\n                System.out.println(\"B 2\");\n                System.out.println(\"B 3\");\n\n                System.out.println(\"INFO: B 打印完毕，调用 notify 方法\");\n                lock.notify();\n            }\n        }\n    });\n    A.start();\n    B.start();\n}\n```\n\n打印结果如下:\n\n>INFO: A 等待锁\nINFO: A 得到了锁 lock\nA 1\nINFO: A 准备进入等待状态，调用 lock.wait() 放弃锁 lock 的控制权\nINFO: B 等待锁\nINFO: B 得到了锁 lock\nB 1\nB 2\nB 3\nINFO: B 打印完毕，调用 lock.notify() 方法\nINFO: 有人唤醒了 A, A 重新获得锁 lock\nA 2\nA 3\n\n## 四个线程 A B C D，其中 D 要等到 A B C 全执行完毕后才执行，而且 A B C 是同步运行的\n最开始我们介绍了 `thread.join()`，可以让一个线程等另一个线程运行完毕后再继续执行，那我们可以在 D 线程里依次 join A B C，不过这也就使得 A B C 必须依次执行，而我们要的是这三者能同步运行。\n\n或者说，我们希望达到的目的是：A B C 三个线程同时运行，各自独立运行完后通知 D；对 D 而言，只要A B C 都运行完了，D 再开始运行。针对这种情况，我们可以利用 `CountdownLatch` 来实现这类通信方式。它的基本用法是：\n\n1. 创建一个计数器，设置初始值，CountdownLatch countDownLatch = new CountDownLatch(2);\n2. 在`等待线程`里调用 `countDownLatch.await()` 方法，进入等待状态，直到计数值变成 0；\n3. 在`其他线程`里，调用 `countDownLatch.countDown()` 方法，该方法会将计数值减小 1；\n4. 当`其他线程`的 `countDown()` 方法把计数值变成 0 时，`等待线程` 里的 `countDownLatch.await()` 立即退出，继续执行下面的代码。\n\n实现代码如下：\n```\nprivate static void runDAfterABC() {\n    int worker = 3;\n    CountDownLatch countDownLatch = new CountDownLatch(worker);\n\n    new Thread(new Runnable() {\n        @Override\n        public void run() {\n            System.out.println(\"D is waiting for other three threads\");\n            try {\n                countDownLatch.await();\n                System.out.println(\"All done, D starts working\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n        }\n    }).start();\n\n    for (char threadName='A'; threadName <= 'C'; threadName++) {\n        final String tN = String.valueOf(threadName);\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(tN + \" is working\");\n                try {\n                    Thread.sleep(100);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n\n                System.out.println(tN + \" finished\");\n                countDownLatch.countDown();\n            }\n        }).start();\n    }\n}\n```\n下面是运行结果：\n>D is waiting for other three threads\nA is working\nB is working\nC is working\n\n>A finished\nC finished\nB finished\nAll done, D starts working\n\n\n其实简单点来说，`CountDownLatch` 就是一个倒计数器，我们把初始计数值设置为`3`，当 `D` 运行时，先调用 `countDownLatch.await()` 检查计数器值是否为 `0`，若不为 `0` 则保持等待状态；当`A` `B` `C` 各自运行完后都会利用`countDownLatch.countDown()`，将倒计数器减 `1`，当三个都运行完后，计数器被减至 `0`；此时立即触发 `D` 的 `await()` 运行结束，继续向下执行。\n\n因此，`CountDownLatch` 适用于一个线程去等待多个线程的情况。\n\n## 三个运动员各自准备，等到三个人都准备好后，再一起跑\n上面是一个形象的比喻，针对`线程 A B C 各自开始准备，直到三者都准备完毕，然后再同时运行`。也就是要实现一种`线程之间互相等待`的效果，那应该怎么来实现呢？\n\n上面的 `CountDownLatch` 可以用来倒计数，但当计数完毕，只有一个线程的 `await()` 会得到响应，无法让多个线程同时触发。\n\n为了实现线程间互相等待这种需求，我们可以利用 `CyclicBarrier` 数据结构，它的基本用法是：\n\n1. 先创建一个公共 `CyclicBarrier` 对象，设置`同时等待`的线程数，CyclicBarrier cyclicBarrier = new CyclicBarrier(3);\n2. 这些线程同时开始自己做准备，自身准备完毕后，需要等待别人准备完毕，这时调用 `cyclicBarrier.await();` 即可开始等待别人；\n3. 当指定的`同时等待`的线程数都调用了 `cyclicBarrier.await();`时，意味着这些线程都准备完毕好，然后这些线程才`同时继续执行`。\n\n实现代码如下，设想有三个跑步运动员，各自准备好后等待其他人，全部准备好后才开始跑：\n```\nprivate static void runABCWhenAllReady() {\n    int runner = 3;\n    CyclicBarrier cyclicBarrier = new CyclicBarrier(runner);\n\n    final Random random = new Random();\n    for (char runnerName='A'; runnerName <= 'C'; runnerName++) {\n        final String rN = String.valueOf(runnerName);\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                long prepareTime = random.nextInt(10000) + 100;\n                System.out.println(rN + \" is preparing for time: \" + prepareTime);\n                try {\n                    Thread.sleep(prepareTime);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n\n                try {\n                    System.out.println(rN + \" is prepared, waiting for others\");\n                    cyclicBarrier.await(); // 当前运动员准备完毕，等待别人准备好\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } catch (BrokenBarrierException e) {\n                    e.printStackTrace();\n                }\n\n                System.out.println(rN + \" starts running\"); // 所有运动员都准备好了，一起开始跑\n            }\n        }).start();\n    }\n}\n```\n\n打印的结果如下：\n>A is preparing for time: 4131\nB is preparing for time: 6349\nC is preparing for time: 8206\n\n>A is prepared, waiting for others\n\n>B is prepared, waiting for others\n\n>C is prepared, waiting for others\n\n>C starts running\nA starts running\nB starts running\n\n\n## 子线程完成某件任务后，把得到的结果回传给主线程\n实际的开发中，我们经常要创建子线程来做一些耗时任务，然后把任务执行结果回传给主线程使用，这种情况在 Java 里要如何实现呢？\n\n回顾线程的创建，我们一般会把 `Runnable` 对象传给 Thread 去执行。`Runnable`定义如下：\n```\npublic interface Runnable {\n    public abstract void run();\n}\n```\n可以看到 `run()` 在执行完后不会返回任何结果。那如果希望返回结果呢？这里可以利用另一个类似的接口类 `Callable`：\n```\n@FunctionalInterface\npublic interface Callable<V> {\n    /**\n     * Computes a result, or throws an exception if unable to do so.\n     *\n     * @return computed result\n     * @throws Exception if unable to compute a result\n     */\n    V call() throws Exception;\n}\n```\n可以看出 `Callable` 最大区别就是返回范型 `V` 结果。\n\n那么下一个问题就是，如何把子线程的结果回传回来呢？在 Java 里，有一个类是配合 Callable 使用的：`FutureTask`，不过注意，它获取结果的 `get` 方法会阻塞主线程。\n\n举例，我们想让子线程去计算从1加到100，并把算出的结果返回到主线程。\n```\nprivate static void doTaskWithResultInWorker() {\n    Callable<Integer> callable = new Callable<Integer>() {\n        @Override\n        public Integer call() throws Exception {\n            System.out.println(\"Task starts\");\n            Thread.sleep(1000);\n            int result = 0;\n            for (int i=0; i<=100; i++) {\n                result += i;\n            }\n            System.out.println(\"Task finished and return result\");\n            return result;\n        }\n    };\n\n    FutureTask<Integer> futureTask = new FutureTask<>(callable);\n    new Thread(futureTask).start();\n\n\n    try {\n        System.out.println(\"Before futureTask.get()\");\n        System.out.println(\"Result: \" + futureTask.get());\n        System.out.println(\"After futureTask.get()\");\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    } catch (ExecutionException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n打印结果如下：\n>Before futureTask.get()\n\n>Task starts\nTask finished and return result\n\n>Result: 5050\nAfter futureTask.get()\n\n\n可以看到，主线程调用 `futureTask.get()` 方法时阻塞主线程；然后 `Callable` 内部开始执行，并返回运算结果；此时 `futureTask.get()` 得到结果，主线程恢复运行。\n\n这里我们可以学到，通过 `FutureTask` 和 `Callable` 可以直接在主线程获得子线程的运算结果，只不过需要阻塞主线程。当然，如果不希望阻塞主线程，可以考虑利用 `ExecutorService`，把 `FutureTask` 放到线程池去管理执行。\n\n## 小结\n多线程是现代语言的共同特性，而线程间通信、线程同步、线程安全是很重要的话题。本文针对 Java 的线程间通信进行了大致的讲解，后续还会对线程同步、线程安全进行讲解。\n\n谢谢。\n\n\nwingjay\n\nhttp://wingjay.com\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n\n\n\n\n\n\n\n\n","source":"_posts/Java里如何实现线程间通信？.md","raw":"title: Java里如何实现线程间通信？\ndate: 2017-04-09 17:24:06\ncategories:\n  - 深入理解Java技术\ntags: \n  - Java\n  - 多线程\ncommentIssueId: 7  \n---\n> 正常情况下，每个子线程完成各自的任务就可以结束了。不过有的时候，我们希望多个线程协同工作来完成某个任务，这时就涉及到了线程间通信了。\n\n> 本文涉及到的知识点：`thread.join()`, `object.wait()`, `object.notify()`, `CountdownLatch`, `CyclicBarrier`, `FutureTask`, `Callable` 等。\n\n> 本文涉及代码：\nhttps://github.com/wingjay/HelloJava/blob/master/multi-thread/src/ForArticle.java\n\n<!-- more -->\n\n下面我从几个例子作为切入点来讲解下 Java 里有哪些方法来实现线程间通信。\n\n- 如何让两个线程依次执行？\n- 那如何让`两`个线程按照指定方式有序交叉运行呢？\n- 四个线程 A B C D，其中 D 要等到 A B C 全执行完毕后才执行，而且 A B C 是同步运行的\n- 三个运动员各自准备，等到三个人都准备好后，再一起跑\n- 子线程完成某件任务后，把得到的结果回传给主线程\n\n\n## 如何让两个线程依次执行？\n假设有两个线程，一个是线程 A，另一个是线程 B，两个线程分别依次打印 1-3 三个数字即可。我们来看下代码：\n```\nprivate static void demo1() {\n    Thread A = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            printNumber(\"A\");\n        }\n    });\n\n    Thread B = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            printNumber(\"B\");\n        }\n    });\n\n    A.start();\n    B.start();\n}\n```\n其中的 `printNumber(String)` 实现如下，用来依次打印 `1`, `2`, `3` 三个数字：\n```\nprivate static void printNumber(String threadName) {\n    int i=0;\n    while (i++ < 3) {\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(threadName + \" print: \" + i);\n    }\n}\n```\n\n这时我们得到的结果是：\n>B print: 1\nA print: 1\nB print: 2\nA print: 2\nB print: 3\nA print: 3\n\n可以看到 A 和 B 是同时打印的。\n\n那么，如果我们希望 B 在 A `全部打印`完后再开始打印呢？我们可以利用 `thread.join()` 方法，代码如下:\n```\nprivate static void demo2() {\n    Thread A = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            printNumber(\"A\");\n        }\n    });\n\n    Thread B = new Thread(new Runnable() {\n        @Override\n        public void run() {\n        \tSystem.out.println(\"B 开始等待 A\");\n            try {\n                A.join();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            printNumber(\"B\");\n        }\n    });\n\n    B.start();\n    A.start();\n}\n```\n\n得到的结果如下：\n\n>B 开始等待 A\nA print: 1\nA print: 2\nA print: 3\n\n>B print: 1\nB print: 2\nB print: 3\n\n所以我们能看到 `A.join()` 方法会让 B 一直等待直到 A 运行完毕。\n\n## 那如何让`两`个线程按照指定方式有序交叉运行呢？\n还是上面那个例子，我现在希望 A 在打印完 `1` 后，再让 B 打印 `1`, `2`, `3`，最后再回到 A 继续打印 `2`, `3`。这种需求下，显然 `Thread.join()` 已经不能满足了。我们需要更细粒度的锁来控制执行顺序。\n\n这里，我们可以利用 `object.wait()` 和 `object.notify()` 两个方法来实现。代码如下：\n```\n/**\n * A 1, B 1, B 2, B 3, A 2, A 3\n */\nprivate static void demo3() {\n    Object lock = new Object();\n\n    Thread A = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            synchronized (lock) {\n                System.out.println(\"A 1\");\n                try {\n                    lock.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n\n                System.out.println(\"A 2\");\n                System.out.println(\"A 3\");\n            }\n\n        }\n    });\n\n    Thread B = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            synchronized (lock) {\n                System.out.println(\"B 1\");\n                System.out.println(\"B 2\");\n                System.out.println(\"B 3\");\n\n                lock.notify();\n            }\n        }\n    });\n\n    A.start();\n    B.start();\n}\n```\n\n打印结果如下：\n>A 1\nA waiting...\n\n>B 1\nB 2\nB 3\nA 2\nA 3\n\n正是我们要的结果。\n\n那么，这个过程发生了什么呢？\n1. 首先创建一个 A 和 B 共享的对象锁 lock = new Object();\n2. 当 A 得到锁后，先打印 1，然后调用 `lock.wait()` 方法，交出锁的控制权，进入 `wait` 状态；\n3. 对 B 而言，由于 A 最开始得到了锁，导致 B 无法执行；直到 A 调用 `lock.wait()` 释放控制权后， B 才得到了锁；\n4. B 在得到锁后打印 1， 2， 3；然后调用 `lock.notify()` 方法，唤醒正在 `wait` 的 A;\n5. A 被唤醒后，继续打印剩下的 2，3。\n\n为了更好理解，我在上面的代码里加上 log 方便读者查看。\n\n\n```\nprivate static void demo3() {\n    Object lock = new Object();\n    Thread A = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            System.out.println(\"INFO: A 等待锁\");\n            synchronized (lock) {\n                System.out.println(\"INFO: A 得到了锁 lock\");\n                System.out.println(\"A 1\");\n                try {\n                    System.out.println(\"INFO: A 准备进入等待状态，放弃锁 lock 的控制权\");\n                    lock.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"INFO: 有人唤醒了 A, A 重新获得锁 lock\");\n                System.out.println(\"A 2\");\n                System.out.println(\"A 3\");\n            }\n\n        }\n    });\n    Thread B = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            System.out.println(\"INFO: B 等待锁\");\n            synchronized (lock) {\n                System.out.println(\"INFO: B 得到了锁 lock\");\n                System.out.println(\"B 1\");\n                System.out.println(\"B 2\");\n                System.out.println(\"B 3\");\n\n                System.out.println(\"INFO: B 打印完毕，调用 notify 方法\");\n                lock.notify();\n            }\n        }\n    });\n    A.start();\n    B.start();\n}\n```\n\n打印结果如下:\n\n>INFO: A 等待锁\nINFO: A 得到了锁 lock\nA 1\nINFO: A 准备进入等待状态，调用 lock.wait() 放弃锁 lock 的控制权\nINFO: B 等待锁\nINFO: B 得到了锁 lock\nB 1\nB 2\nB 3\nINFO: B 打印完毕，调用 lock.notify() 方法\nINFO: 有人唤醒了 A, A 重新获得锁 lock\nA 2\nA 3\n\n## 四个线程 A B C D，其中 D 要等到 A B C 全执行完毕后才执行，而且 A B C 是同步运行的\n最开始我们介绍了 `thread.join()`，可以让一个线程等另一个线程运行完毕后再继续执行，那我们可以在 D 线程里依次 join A B C，不过这也就使得 A B C 必须依次执行，而我们要的是这三者能同步运行。\n\n或者说，我们希望达到的目的是：A B C 三个线程同时运行，各自独立运行完后通知 D；对 D 而言，只要A B C 都运行完了，D 再开始运行。针对这种情况，我们可以利用 `CountdownLatch` 来实现这类通信方式。它的基本用法是：\n\n1. 创建一个计数器，设置初始值，CountdownLatch countDownLatch = new CountDownLatch(2);\n2. 在`等待线程`里调用 `countDownLatch.await()` 方法，进入等待状态，直到计数值变成 0；\n3. 在`其他线程`里，调用 `countDownLatch.countDown()` 方法，该方法会将计数值减小 1；\n4. 当`其他线程`的 `countDown()` 方法把计数值变成 0 时，`等待线程` 里的 `countDownLatch.await()` 立即退出，继续执行下面的代码。\n\n实现代码如下：\n```\nprivate static void runDAfterABC() {\n    int worker = 3;\n    CountDownLatch countDownLatch = new CountDownLatch(worker);\n\n    new Thread(new Runnable() {\n        @Override\n        public void run() {\n            System.out.println(\"D is waiting for other three threads\");\n            try {\n                countDownLatch.await();\n                System.out.println(\"All done, D starts working\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n        }\n    }).start();\n\n    for (char threadName='A'; threadName <= 'C'; threadName++) {\n        final String tN = String.valueOf(threadName);\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(tN + \" is working\");\n                try {\n                    Thread.sleep(100);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n\n                System.out.println(tN + \" finished\");\n                countDownLatch.countDown();\n            }\n        }).start();\n    }\n}\n```\n下面是运行结果：\n>D is waiting for other three threads\nA is working\nB is working\nC is working\n\n>A finished\nC finished\nB finished\nAll done, D starts working\n\n\n其实简单点来说，`CountDownLatch` 就是一个倒计数器，我们把初始计数值设置为`3`，当 `D` 运行时，先调用 `countDownLatch.await()` 检查计数器值是否为 `0`，若不为 `0` 则保持等待状态；当`A` `B` `C` 各自运行完后都会利用`countDownLatch.countDown()`，将倒计数器减 `1`，当三个都运行完后，计数器被减至 `0`；此时立即触发 `D` 的 `await()` 运行结束，继续向下执行。\n\n因此，`CountDownLatch` 适用于一个线程去等待多个线程的情况。\n\n## 三个运动员各自准备，等到三个人都准备好后，再一起跑\n上面是一个形象的比喻，针对`线程 A B C 各自开始准备，直到三者都准备完毕，然后再同时运行`。也就是要实现一种`线程之间互相等待`的效果，那应该怎么来实现呢？\n\n上面的 `CountDownLatch` 可以用来倒计数，但当计数完毕，只有一个线程的 `await()` 会得到响应，无法让多个线程同时触发。\n\n为了实现线程间互相等待这种需求，我们可以利用 `CyclicBarrier` 数据结构，它的基本用法是：\n\n1. 先创建一个公共 `CyclicBarrier` 对象，设置`同时等待`的线程数，CyclicBarrier cyclicBarrier = new CyclicBarrier(3);\n2. 这些线程同时开始自己做准备，自身准备完毕后，需要等待别人准备完毕，这时调用 `cyclicBarrier.await();` 即可开始等待别人；\n3. 当指定的`同时等待`的线程数都调用了 `cyclicBarrier.await();`时，意味着这些线程都准备完毕好，然后这些线程才`同时继续执行`。\n\n实现代码如下，设想有三个跑步运动员，各自准备好后等待其他人，全部准备好后才开始跑：\n```\nprivate static void runABCWhenAllReady() {\n    int runner = 3;\n    CyclicBarrier cyclicBarrier = new CyclicBarrier(runner);\n\n    final Random random = new Random();\n    for (char runnerName='A'; runnerName <= 'C'; runnerName++) {\n        final String rN = String.valueOf(runnerName);\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                long prepareTime = random.nextInt(10000) + 100;\n                System.out.println(rN + \" is preparing for time: \" + prepareTime);\n                try {\n                    Thread.sleep(prepareTime);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n\n                try {\n                    System.out.println(rN + \" is prepared, waiting for others\");\n                    cyclicBarrier.await(); // 当前运动员准备完毕，等待别人准备好\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } catch (BrokenBarrierException e) {\n                    e.printStackTrace();\n                }\n\n                System.out.println(rN + \" starts running\"); // 所有运动员都准备好了，一起开始跑\n            }\n        }).start();\n    }\n}\n```\n\n打印的结果如下：\n>A is preparing for time: 4131\nB is preparing for time: 6349\nC is preparing for time: 8206\n\n>A is prepared, waiting for others\n\n>B is prepared, waiting for others\n\n>C is prepared, waiting for others\n\n>C starts running\nA starts running\nB starts running\n\n\n## 子线程完成某件任务后，把得到的结果回传给主线程\n实际的开发中，我们经常要创建子线程来做一些耗时任务，然后把任务执行结果回传给主线程使用，这种情况在 Java 里要如何实现呢？\n\n回顾线程的创建，我们一般会把 `Runnable` 对象传给 Thread 去执行。`Runnable`定义如下：\n```\npublic interface Runnable {\n    public abstract void run();\n}\n```\n可以看到 `run()` 在执行完后不会返回任何结果。那如果希望返回结果呢？这里可以利用另一个类似的接口类 `Callable`：\n```\n@FunctionalInterface\npublic interface Callable<V> {\n    /**\n     * Computes a result, or throws an exception if unable to do so.\n     *\n     * @return computed result\n     * @throws Exception if unable to compute a result\n     */\n    V call() throws Exception;\n}\n```\n可以看出 `Callable` 最大区别就是返回范型 `V` 结果。\n\n那么下一个问题就是，如何把子线程的结果回传回来呢？在 Java 里，有一个类是配合 Callable 使用的：`FutureTask`，不过注意，它获取结果的 `get` 方法会阻塞主线程。\n\n举例，我们想让子线程去计算从1加到100，并把算出的结果返回到主线程。\n```\nprivate static void doTaskWithResultInWorker() {\n    Callable<Integer> callable = new Callable<Integer>() {\n        @Override\n        public Integer call() throws Exception {\n            System.out.println(\"Task starts\");\n            Thread.sleep(1000);\n            int result = 0;\n            for (int i=0; i<=100; i++) {\n                result += i;\n            }\n            System.out.println(\"Task finished and return result\");\n            return result;\n        }\n    };\n\n    FutureTask<Integer> futureTask = new FutureTask<>(callable);\n    new Thread(futureTask).start();\n\n\n    try {\n        System.out.println(\"Before futureTask.get()\");\n        System.out.println(\"Result: \" + futureTask.get());\n        System.out.println(\"After futureTask.get()\");\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    } catch (ExecutionException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n打印结果如下：\n>Before futureTask.get()\n\n>Task starts\nTask finished and return result\n\n>Result: 5050\nAfter futureTask.get()\n\n\n可以看到，主线程调用 `futureTask.get()` 方法时阻塞主线程；然后 `Callable` 内部开始执行，并返回运算结果；此时 `futureTask.get()` 得到结果，主线程恢复运行。\n\n这里我们可以学到，通过 `FutureTask` 和 `Callable` 可以直接在主线程获得子线程的运算结果，只不过需要阻塞主线程。当然，如果不希望阻塞主线程，可以考虑利用 `ExecutorService`，把 `FutureTask` 放到线程池去管理执行。\n\n## 小结\n多线程是现代语言的共同特性，而线程间通信、线程同步、线程安全是很重要的话题。本文针对 Java 的线程间通信进行了大致的讲解，后续还会对线程同步、线程安全进行讲解。\n\n谢谢。\n\n\nwingjay\n\nhttp://wingjay.com\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n\n\n\n\n\n\n\n\n","slug":"Java里如何实现线程间通信？","published":1,"updated":"2018-11-26T06:56:27.481Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplsi2002k3dn88ayzwdq1","content":"<blockquote>\n<p>正常情况下，每个子线程完成各自的任务就可以结束了。不过有的时候，我们希望多个线程协同工作来完成某个任务，这时就涉及到了线程间通信了。</p>\n<p>本文涉及到的知识点：<code>thread.join()</code>, <code>object.wait()</code>, <code>object.notify()</code>, <code>CountdownLatch</code>, <code>CyclicBarrier</code>, <code>FutureTask</code>, <code>Callable</code> 等。</p>\n<p>本文涉及代码：<br><a href=\"https://github.com/wingjay/HelloJava/blob/master/multi-thread/src/ForArticle.java\" target=\"_blank\" rel=\"external\">https://github.com/wingjay/HelloJava/blob/master/multi-thread/src/ForArticle.java</a></p>\n</blockquote>\n<a id=\"more\"></a>\n<p>下面我从几个例子作为切入点来讲解下 Java 里有哪些方法来实现线程间通信。</p>\n<ul>\n<li>如何让两个线程依次执行？</li>\n<li>那如何让 <code> 两</code>个线程按照指定方式有序交叉运行呢？</li>\n<li>四个线程 A B C D，其中 D 要等到 A B C 全执行完毕后才执行，而且 A B C 是同步运行的</li>\n<li>三个运动员各自准备，等到三个人都准备好后，再一起跑</li>\n<li>子线程完成某件任务后，把得到的结果回传给主线程</li>\n</ul>\n<h2 id=\"如何让两个线程依次执行？\"><a href=\"# 如何让两个线程依次执行？\" class=\"headerlink\" title=\"如何让两个线程依次执行？\"></a>如何让两个线程依次执行？</h2><p>假设有两个线程，一个是线程 A，另一个是线程 B，两个线程分别依次打印 1-3 三个数字即可。我们来看下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void demo1() &#123;</div><div class=\"line\">    Thread A = new Thread(new Runnable() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void run() &#123;</div><div class=\"line\">            printNumber(&quot;A&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    Thread B = new Thread(new Runnable() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void run() &#123;</div><div class=\"line\">            printNumber(&quot;B&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    A.start();</div><div class=\"line\">    B.start();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中的 <code>printNumber(String)</code> 实现如下，用来依次打印 <code>1</code>, <code>2</code>, <code>3</code> 三个数字：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void printNumber(String threadName) &#123;</div><div class=\"line\">    int i=0;</div><div class=\"line\">    while (i++ &lt; 3) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            Thread.sleep(100);</div><div class=\"line\">        &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">        &#125;</div><div class=\"line\">        System.out.println(threadName + &quot; print: &quot; + i);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这时我们得到的结果是：</p>\n<blockquote>\n<p>B print: 1<br>A print: 1<br>B print: 2<br>A print: 2<br>B print: 3<br>A print: 3</p>\n</blockquote>\n<p>可以看到 A 和 B 是同时打印的。</p>\n<p>那么，如果我们希望 B 在 A <code>全部打印 </code> 完后再开始打印呢？我们可以利用 <code>thread.join()</code> 方法，代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void demo2() &#123;</div><div class=\"line\">    Thread A = new Thread(new Runnable() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void run() &#123;</div><div class=\"line\">            printNumber(&quot;A&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    Thread B = new Thread(new Runnable() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void run() &#123;</div><div class=\"line\">        \tSystem.out.println(&quot;B 开始等待 A&quot;);</div><div class=\"line\">            try &#123;</div><div class=\"line\">                A.join();</div><div class=\"line\">            &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">                e.printStackTrace();</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            printNumber(&quot;B&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    B.start();</div><div class=\"line\">    A.start();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>得到的结果如下：</p>\n<blockquote>\n<p>B 开始等待 A<br>A print: 1<br>A print: 2<br>A print: 3</p>\n<p>B print: 1<br>B print: 2<br>B print: 3</p>\n</blockquote>\n<p>所以我们能看到 <code>A.join()</code> 方法会让 B 一直等待直到 A 运行完毕。</p>\n<h2 id=\"那如何让两个线程按照指定方式有序交叉运行呢？\"><a href=\"# 那如何让两个线程按照指定方式有序交叉运行呢？\" class=\"headerlink\" title=\"那如何让两个线程按照指定方式有序交叉运行呢？\"></a>那如何让 <code> 两</code>个线程按照指定方式有序交叉运行呢？</h2><p>还是上面那个例子，我现在希望 A 在打印完 <code>1</code> 后，再让 B 打印 <code>1</code>, <code>2</code>, <code>3</code>，最后再回到 A 继续打印 <code>2</code>, <code>3</code>。这种需求下，显然 <code>Thread.join()</code> 已经不能满足了。我们需要更细粒度的锁来控制执行顺序。</p>\n<p>这里，我们可以利用 <code>object.wait()</code> 和 <code>object.notify()</code> 两个方法来实现。代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * A 1, B 1, B 2, B 3, A 2, A 3</div><div class=\"line\"> */</div><div class=\"line\">private static void demo3() &#123;</div><div class=\"line\">    Object lock = new Object();</div><div class=\"line\"></div><div class=\"line\">    Thread A = new Thread(new Runnable() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void run() &#123;</div><div class=\"line\">            synchronized (lock) &#123;</div><div class=\"line\">                System.out.println(&quot;A 1&quot;);</div><div class=\"line\">                try &#123;</div><div class=\"line\">                    lock.wait();</div><div class=\"line\">                &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">                    e.printStackTrace();</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                System.out.println(&quot;A 2&quot;);</div><div class=\"line\">                System.out.println(&quot;A 3&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    Thread B = new Thread(new Runnable() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void run() &#123;</div><div class=\"line\">            synchronized (lock) &#123;</div><div class=\"line\">                System.out.println(&quot;B 1&quot;);</div><div class=\"line\">                System.out.println(&quot;B 2&quot;);</div><div class=\"line\">                System.out.println(&quot;B 3&quot;);</div><div class=\"line\"></div><div class=\"line\">                lock.notify();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    A.start();</div><div class=\"line\">    B.start();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>打印结果如下：</p>\n<blockquote>\n<p>A 1<br>A waiting…</p>\n<p>B 1<br>B 2<br>B 3<br>A 2<br>A 3</p>\n</blockquote>\n<p>正是我们要的结果。</p>\n<p>那么，这个过程发生了什么呢？</p>\n<ol>\n<li>首先创建一个 A 和 B 共享的对象锁 lock = new Object();</li>\n<li>当 A 得到锁后，先打印 1，然后调用 <code>lock.wait()</code> 方法，交出锁的控制权，进入 <code>wait</code> 状态；</li>\n<li>对 B 而言，由于 A 最开始得到了锁，导致 B 无法执行；直到 A 调用 <code>lock.wait()</code> 释放控制权后， B 才得到了锁；</li>\n<li>B 在得到锁后打印 1， 2， 3；然后调用 <code>lock.notify()</code> 方法，唤醒正在 <code>wait</code> 的 A;</li>\n<li>A 被唤醒后，继续打印剩下的 2，3。</li>\n</ol>\n<p>为了更好理解，我在上面的代码里加上 log 方便读者查看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void demo3() &#123;</div><div class=\"line\">    Object lock = new Object();</div><div class=\"line\">    Thread A = new Thread(new Runnable() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void run() &#123;</div><div class=\"line\">            System.out.println(&quot;INFO: A 等待锁 &quot;);</div><div class=\"line\">            synchronized (lock) &#123;</div><div class=\"line\">                System.out.println(&quot;INFO: A 得到了锁 lock&quot;);</div><div class=\"line\">                System.out.println(&quot;A 1&quot;);</div><div class=\"line\">                try &#123;</div><div class=\"line\">                    System.out.println(&quot;INFO: A 准备进入等待状态，放弃锁 lock 的控制权 &quot;);</div><div class=\"line\">                    lock.wait();</div><div class=\"line\">                &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">                    e.printStackTrace();</div><div class=\"line\">                &#125;</div><div class=\"line\">                System.out.println(&quot;INFO: 有人唤醒了 A, A 重新获得锁 lock&quot;);</div><div class=\"line\">                System.out.println(&quot;A 2&quot;);</div><div class=\"line\">                System.out.println(&quot;A 3&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    Thread B = new Thread(new Runnable() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void run() &#123;</div><div class=\"line\">            System.out.println(&quot;INFO: B 等待锁 &quot;);</div><div class=\"line\">            synchronized (lock) &#123;</div><div class=\"line\">                System.out.println(&quot;INFO: B 得到了锁 lock&quot;);</div><div class=\"line\">                System.out.println(&quot;B 1&quot;);</div><div class=\"line\">                System.out.println(&quot;B 2&quot;);</div><div class=\"line\">                System.out.println(&quot;B 3&quot;);</div><div class=\"line\"></div><div class=\"line\">                System.out.println(&quot;INFO: B 打印完毕，调用 notify 方法 &quot;);</div><div class=\"line\">                lock.notify();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    A.start();</div><div class=\"line\">    B.start();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>打印结果如下:</p>\n<blockquote>\n<p>INFO: A 等待锁<br>INFO: A 得到了锁 lock<br>A 1<br>INFO: A 准备进入等待状态，调用 lock.wait() 放弃锁 lock 的控制权<br>INFO: B 等待锁<br>INFO: B 得到了锁 lock<br>B 1<br>B 2<br>B 3<br>INFO: B 打印完毕，调用 lock.notify() 方法<br>INFO: 有人唤醒了 A, A 重新获得锁 lock<br>A 2<br>A 3</p>\n</blockquote>\n<h2 id=\"四个线程 -A-B-C-D，其中 -D- 要等到 -A-B-C- 全执行完毕后才执行，而且 -A-B-C- 是同步运行的\"><a href=\"# 四个线程 -A-B-C-D，其中 -D- 要等到 -A-B-C- 全执行完毕后才执行，而且 -A-B-C- 是同步运行的\" class=\"headerlink\" title=\"四个线程 A B C D，其中 D 要等到 A B C 全执行完毕后才执行，而且 A B C 是同步运行的\"></a>四个线程 A B C D，其中 D 要等到 A B C 全执行完毕后才执行，而且 A B C 是同步运行的 </h2><p> 最开始我们介绍了 <code>thread.join()</code>，可以让一个线程等另一个线程运行完毕后再继续执行，那我们可以在 D 线程里依次 join A B C，不过这也就使得 A B C 必须依次执行，而我们要的是这三者能同步运行。</p>\n<p>或者说，我们希望达到的目的是：A B C 三个线程同时运行，各自独立运行完后通知 D；对 D 而言，只要 A B C 都运行完了，D 再开始运行。针对这种情况，我们可以利用 <code>CountdownLatch</code> 来实现这类通信方式。它的基本用法是：</p>\n<ol>\n<li>创建一个计数器，设置初始值，CountdownLatch countDownLatch = new CountDownLatch(2);</li>\n<li>在 <code> 等待线程 </code> 里调用 <code>countDownLatch.await()</code> 方法，进入等待状态，直到计数值变成 0；</li>\n<li>在 <code> 其他线程 </code> 里，调用 <code>countDownLatch.countDown()</code> 方法，该方法会将计数值减小 1；</li>\n<li>当 <code> 其他线程 </code> 的 <code>countDown()</code> 方法把计数值变成 0 时，<code>等待线程</code> 里的 <code>countDownLatch.await()</code> 立即退出，继续执行下面的代码。</li>\n</ol>\n<p>实现代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void runDAfterABC() &#123;</div><div class=\"line\">    int worker = 3;</div><div class=\"line\">    CountDownLatch countDownLatch = new CountDownLatch(worker);</div><div class=\"line\"></div><div class=\"line\">    new Thread(new Runnable() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void run() &#123;</div><div class=\"line\">            System.out.println(&quot;D is waiting for other three threads&quot;);</div><div class=\"line\">            try &#123;</div><div class=\"line\">                countDownLatch.await();</div><div class=\"line\">                System.out.println(&quot;All done, D starts working&quot;);</div><div class=\"line\">            &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">                e.printStackTrace();</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;).start();</div><div class=\"line\"></div><div class=\"line\">    for (char threadName=&apos;A&apos;; threadName &lt;= &apos;C&apos;; threadName++) &#123;</div><div class=\"line\">        final String tN = String.valueOf(threadName);</div><div class=\"line\">        new Thread(new Runnable() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void run() &#123;</div><div class=\"line\">                System.out.println(tN + &quot; is working&quot;);</div><div class=\"line\">                try &#123;</div><div class=\"line\">                    Thread.sleep(100);</div><div class=\"line\">                &#125; catch (Exception e) &#123;</div><div class=\"line\">                    e.printStackTrace();</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                System.out.println(tN + &quot; finished&quot;);</div><div class=\"line\">                countDownLatch.countDown();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).start();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>下面是运行结果：</p>\n<blockquote>\n<p>D is waiting for other three threads<br>A is working<br>B is working<br>C is working</p>\n<p>A finished<br>C finished<br>B finished<br>All done, D starts working</p>\n</blockquote>\n<p>其实简单点来说，<code>CountDownLatch</code> 就是一个倒计数器，我们把初始计数值设置为<code>3</code>，当 <code>D</code> 运行时，先调用 <code>countDownLatch.await()</code> 检查计数器值是否为 <code>0</code>，若不为 <code>0</code> 则保持等待状态；当<code>A</code> <code>B</code> <code>C</code> 各自运行完后都会利用<code>countDownLatch.countDown()</code>，将倒计数器减 <code>1</code>，当三个都运行完后，计数器被减至 <code>0</code>；此时立即触发 <code>D</code> 的 <code>await()</code> 运行结束，继续向下执行。</p>\n<p>因此，<code>CountDownLatch</code> 适用于一个线程去等待多个线程的情况。</p>\n<h2 id=\"三个运动员各自准备，等到三个人都准备好后，再一起跑\"><a href=\"# 三个运动员各自准备，等到三个人都准备好后，再一起跑\" class=\"headerlink\" title=\"三个运动员各自准备，等到三个人都准备好后，再一起跑\"></a>三个运动员各自准备，等到三个人都准备好后，再一起跑 </h2><p> 上面是一个形象的比喻，针对 <code> 线程 A B C 各自开始准备，直到三者都准备完毕，然后再同时运行 </code>。也就是要实现一种<code> 线程之间互相等待 </code> 的效果，那应该怎么来实现呢？</p>\n<p>上面的 <code>CountDownLatch</code> 可以用来倒计数，但当计数完毕，只有一个线程的 <code>await()</code> 会得到响应，无法让多个线程同时触发。</p>\n<p>为了实现线程间互相等待这种需求，我们可以利用 <code>CyclicBarrier</code> 数据结构，它的基本用法是：</p>\n<ol>\n<li>先创建一个公共 <code>CyclicBarrier</code> 对象，设置 <code> 同时等待 </code> 的线程数，CyclicBarrier cyclicBarrier = new CyclicBarrier(3);</li>\n<li>这些线程同时开始自己做准备，自身准备完毕后，需要等待别人准备完毕，这时调用 <code>cyclicBarrier.await();</code> 即可开始等待别人；</li>\n<li>当指定的 <code> 同时等待 </code> 的线程数都调用了 <code>cyclicBarrier.await();</code>时，意味着这些线程都准备完毕好，然后这些线程才 <code> 同时继续执行</code>。</li>\n</ol>\n<p>实现代码如下，设想有三个跑步运动员，各自准备好后等待其他人，全部准备好后才开始跑：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void runABCWhenAllReady() &#123;</div><div class=\"line\">    int runner = 3;</div><div class=\"line\">    CyclicBarrier cyclicBarrier = new CyclicBarrier(runner);</div><div class=\"line\"></div><div class=\"line\">    final Random random = new Random();</div><div class=\"line\">    for (char runnerName=&apos;A&apos;; runnerName &lt;= &apos;C&apos;; runnerName++) &#123;</div><div class=\"line\">        final String rN = String.valueOf(runnerName);</div><div class=\"line\">        new Thread(new Runnable() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void run() &#123;</div><div class=\"line\">                long prepareTime = random.nextInt(10000) + 100;</div><div class=\"line\">                System.out.println(rN + &quot; is preparing for time: &quot; + prepareTime);</div><div class=\"line\">                try &#123;</div><div class=\"line\">                    Thread.sleep(prepareTime);</div><div class=\"line\">                &#125; catch (Exception e) &#123;</div><div class=\"line\">                    e.printStackTrace();</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                try &#123;</div><div class=\"line\">                    System.out.println(rN + &quot; is prepared, waiting for others&quot;);</div><div class=\"line\">                    cyclicBarrier.await(); // 当前运动员准备完毕，等待别人准备好</div><div class=\"line\">                &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">                    e.printStackTrace();</div><div class=\"line\">                &#125; catch (BrokenBarrierException e) &#123;</div><div class=\"line\">                    e.printStackTrace();</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                System.out.println(rN + &quot; starts running&quot;); // 所有运动员都准备好了，一起开始跑</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).start();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>打印的结果如下：</p>\n<blockquote>\n<p>A is preparing for time: 4131<br>B is preparing for time: 6349<br>C is preparing for time: 8206</p>\n<p>A is prepared, waiting for others</p>\n<p>B is prepared, waiting for others</p>\n<p>C is prepared, waiting for others</p>\n<p>C starts running<br>A starts running<br>B starts running</p>\n</blockquote>\n<h2 id=\"子线程完成某件任务后，把得到的结果回传给主线程\"><a href=\"# 子线程完成某件任务后，把得到的结果回传给主线程\" class=\"headerlink\" title=\"子线程完成某件任务后，把得到的结果回传给主线程\"></a>子线程完成某件任务后，把得到的结果回传给主线程 </h2><p> 实际的开发中，我们经常要创建子线程来做一些耗时任务，然后把任务执行结果回传给主线程使用，这种情况在 Java 里要如何实现呢？</p>\n<p>回顾线程的创建，我们一般会把 <code>Runnable</code> 对象传给 Thread 去执行。<code>Runnable</code>定义如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public interface Runnable &#123;</div><div class=\"line\">    public abstract void run();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到 <code>run()</code> 在执行完后不会返回任何结果。那如果希望返回结果呢？这里可以利用另一个类似的接口类 <code>Callable</code>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">@FunctionalInterface</div><div class=\"line\">public interface Callable&lt;V&gt; &#123;</div><div class=\"line\">    /**</div><div class=\"line\">     * Computes a result, or throws an exception if unable to do so.</div><div class=\"line\">     *</div><div class=\"line\">     * @return computed result</div><div class=\"line\">     * @throws Exception if unable to compute a result</div><div class=\"line\">     */</div><div class=\"line\">    V call() throws Exception;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看出 <code>Callable</code> 最大区别就是返回范型 <code>V</code> 结果。</p>\n<p>那么下一个问题就是，如何把子线程的结果回传回来呢？在 Java 里，有一个类是配合 Callable 使用的：<code>FutureTask</code>，不过注意，它获取结果的 <code>get</code> 方法会阻塞主线程。</p>\n<p>举例，我们想让子线程去计算从 1 加到 100，并把算出的结果返回到主线程。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void doTaskWithResultInWorker() &#123;</div><div class=\"line\">    Callable&lt;Integer&gt; callable = new Callable&lt;Integer&gt;() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public Integer call() throws Exception &#123;</div><div class=\"line\">            System.out.println(&quot;Task starts&quot;);</div><div class=\"line\">            Thread.sleep(1000);</div><div class=\"line\">            int result = 0;</div><div class=\"line\">            for (int i=0; i&lt;=100; i++) &#123;</div><div class=\"line\">                result += i;</div><div class=\"line\">            &#125;</div><div class=\"line\">            System.out.println(&quot;Task finished and return result&quot;);</div><div class=\"line\">            return result;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(callable);</div><div class=\"line\">    new Thread(futureTask).start();</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        System.out.println(&quot;Before futureTask.get()&quot;);</div><div class=\"line\">        System.out.println(&quot;Result: &quot; + futureTask.get());</div><div class=\"line\">        System.out.println(&quot;After futureTask.get()&quot;);</div><div class=\"line\">    &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">        e.printStackTrace();</div><div class=\"line\">    &#125; catch (ExecutionException e) &#123;</div><div class=\"line\">        e.printStackTrace();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>打印结果如下：</p>\n<blockquote>\n<p>Before futureTask.get()</p>\n<p>Task starts<br>Task finished and return result</p>\n<p>Result: 5050<br>After futureTask.get()</p>\n</blockquote>\n<p>可以看到，主线程调用 <code>futureTask.get()</code> 方法时阻塞主线程；然后 <code>Callable</code> 内部开始执行，并返回运算结果；此时 <code>futureTask.get()</code> 得到结果，主线程恢复运行。</p>\n<p>这里我们可以学到，通过 <code>FutureTask</code> 和 <code>Callable</code> 可以直接在主线程获得子线程的运算结果，只不过需要阻塞主线程。当然，如果不希望阻塞主线程，可以考虑利用 <code>ExecutorService</code>，把 <code>FutureTask</code> 放到线程池去管理执行。</p>\n<h2 id=\"小结\"><a href=\"# 小结\" class=\"headerlink\" title=\"小结\"></a>小结 </h2><p> 多线程是现代语言的共同特性，而线程间通信、线程同步、线程安全是很重要的话题。本文针对 Java 的线程间通信进行了大致的讲解，后续还会对线程同步、线程安全进行讲解。</p>\n<p>谢谢。</p>\n<p>wingjay</p>\n<p><a href=\"http://wingjay.com\">http://wingjay.com</a></p>\n<p><img src=\"https://avatars0.githubusercontent.com/u/9619875?v=3&amp;s=460\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>正常情况下，每个子线程完成各自的任务就可以结束了。不过有的时候，我们希望多个线程协同工作来完成某个任务，这时就涉及到了线程间通信了。</p>\n<p>本文涉及到的知识点：<code>thread.join()</code>, <code>object.wait()</code>, <code>object.notify()</code>, <code>CountdownLatch</code>, <code>CyclicBarrier</code>, <code>FutureTask</code>, <code>Callable</code> 等。</p>\n<p>本文涉及代码：<br><a href=\"https://github.com/wingjay/HelloJava/blob/master/multi-thread/src/ForArticle.java\" target=\"_blank\" rel=\"external\">https://github.com/wingjay/HelloJava/blob/master/multi-thread/src/ForArticle.java</a></p>\n</blockquote>","more":"<p>下面我从几个例子作为切入点来讲解下 Java 里有哪些方法来实现线程间通信。</p>\n<ul>\n<li>如何让两个线程依次执行？</li>\n<li>那如何让<code>两</code>个线程按照指定方式有序交叉运行呢？</li>\n<li>四个线程 A B C D，其中 D 要等到 A B C 全执行完毕后才执行，而且 A B C 是同步运行的</li>\n<li>三个运动员各自准备，等到三个人都准备好后，再一起跑</li>\n<li>子线程完成某件任务后，把得到的结果回传给主线程</li>\n</ul>\n<h2 id=\"如何让两个线程依次执行？\"><a href=\"#如何让两个线程依次执行？\" class=\"headerlink\" title=\"如何让两个线程依次执行？\"></a>如何让两个线程依次执行？</h2><p>假设有两个线程，一个是线程 A，另一个是线程 B，两个线程分别依次打印 1-3 三个数字即可。我们来看下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void demo1() &#123;</div><div class=\"line\">    Thread A = new Thread(new Runnable() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void run() &#123;</div><div class=\"line\">            printNumber(&quot;A&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    Thread B = new Thread(new Runnable() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void run() &#123;</div><div class=\"line\">            printNumber(&quot;B&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    A.start();</div><div class=\"line\">    B.start();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中的 <code>printNumber(String)</code> 实现如下，用来依次打印 <code>1</code>, <code>2</code>, <code>3</code> 三个数字：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void printNumber(String threadName) &#123;</div><div class=\"line\">    int i=0;</div><div class=\"line\">    while (i++ &lt; 3) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            Thread.sleep(100);</div><div class=\"line\">        &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">        &#125;</div><div class=\"line\">        System.out.println(threadName + &quot; print: &quot; + i);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这时我们得到的结果是：</p>\n<blockquote>\n<p>B print: 1<br>A print: 1<br>B print: 2<br>A print: 2<br>B print: 3<br>A print: 3</p>\n</blockquote>\n<p>可以看到 A 和 B 是同时打印的。</p>\n<p>那么，如果我们希望 B 在 A <code>全部打印</code>完后再开始打印呢？我们可以利用 <code>thread.join()</code> 方法，代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void demo2() &#123;</div><div class=\"line\">    Thread A = new Thread(new Runnable() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void run() &#123;</div><div class=\"line\">            printNumber(&quot;A&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    Thread B = new Thread(new Runnable() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void run() &#123;</div><div class=\"line\">        \tSystem.out.println(&quot;B 开始等待 A&quot;);</div><div class=\"line\">            try &#123;</div><div class=\"line\">                A.join();</div><div class=\"line\">            &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">                e.printStackTrace();</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            printNumber(&quot;B&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    B.start();</div><div class=\"line\">    A.start();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>得到的结果如下：</p>\n<blockquote>\n<p>B 开始等待 A<br>A print: 1<br>A print: 2<br>A print: 3</p>\n<p>B print: 1<br>B print: 2<br>B print: 3</p>\n</blockquote>\n<p>所以我们能看到 <code>A.join()</code> 方法会让 B 一直等待直到 A 运行完毕。</p>\n<h2 id=\"那如何让两个线程按照指定方式有序交叉运行呢？\"><a href=\"#那如何让两个线程按照指定方式有序交叉运行呢？\" class=\"headerlink\" title=\"那如何让两个线程按照指定方式有序交叉运行呢？\"></a>那如何让<code>两</code>个线程按照指定方式有序交叉运行呢？</h2><p>还是上面那个例子，我现在希望 A 在打印完 <code>1</code> 后，再让 B 打印 <code>1</code>, <code>2</code>, <code>3</code>，最后再回到 A 继续打印 <code>2</code>, <code>3</code>。这种需求下，显然 <code>Thread.join()</code> 已经不能满足了。我们需要更细粒度的锁来控制执行顺序。</p>\n<p>这里，我们可以利用 <code>object.wait()</code> 和 <code>object.notify()</code> 两个方法来实现。代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * A 1, B 1, B 2, B 3, A 2, A 3</div><div class=\"line\"> */</div><div class=\"line\">private static void demo3() &#123;</div><div class=\"line\">    Object lock = new Object();</div><div class=\"line\"></div><div class=\"line\">    Thread A = new Thread(new Runnable() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void run() &#123;</div><div class=\"line\">            synchronized (lock) &#123;</div><div class=\"line\">                System.out.println(&quot;A 1&quot;);</div><div class=\"line\">                try &#123;</div><div class=\"line\">                    lock.wait();</div><div class=\"line\">                &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">                    e.printStackTrace();</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                System.out.println(&quot;A 2&quot;);</div><div class=\"line\">                System.out.println(&quot;A 3&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    Thread B = new Thread(new Runnable() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void run() &#123;</div><div class=\"line\">            synchronized (lock) &#123;</div><div class=\"line\">                System.out.println(&quot;B 1&quot;);</div><div class=\"line\">                System.out.println(&quot;B 2&quot;);</div><div class=\"line\">                System.out.println(&quot;B 3&quot;);</div><div class=\"line\"></div><div class=\"line\">                lock.notify();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    A.start();</div><div class=\"line\">    B.start();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>打印结果如下：</p>\n<blockquote>\n<p>A 1<br>A waiting…</p>\n<p>B 1<br>B 2<br>B 3<br>A 2<br>A 3</p>\n</blockquote>\n<p>正是我们要的结果。</p>\n<p>那么，这个过程发生了什么呢？</p>\n<ol>\n<li>首先创建一个 A 和 B 共享的对象锁 lock = new Object();</li>\n<li>当 A 得到锁后，先打印 1，然后调用 <code>lock.wait()</code> 方法，交出锁的控制权，进入 <code>wait</code> 状态；</li>\n<li>对 B 而言，由于 A 最开始得到了锁，导致 B 无法执行；直到 A 调用 <code>lock.wait()</code> 释放控制权后， B 才得到了锁；</li>\n<li>B 在得到锁后打印 1， 2， 3；然后调用 <code>lock.notify()</code> 方法，唤醒正在 <code>wait</code> 的 A;</li>\n<li>A 被唤醒后，继续打印剩下的 2，3。</li>\n</ol>\n<p>为了更好理解，我在上面的代码里加上 log 方便读者查看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void demo3() &#123;</div><div class=\"line\">    Object lock = new Object();</div><div class=\"line\">    Thread A = new Thread(new Runnable() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void run() &#123;</div><div class=\"line\">            System.out.println(&quot;INFO: A 等待锁&quot;);</div><div class=\"line\">            synchronized (lock) &#123;</div><div class=\"line\">                System.out.println(&quot;INFO: A 得到了锁 lock&quot;);</div><div class=\"line\">                System.out.println(&quot;A 1&quot;);</div><div class=\"line\">                try &#123;</div><div class=\"line\">                    System.out.println(&quot;INFO: A 准备进入等待状态，放弃锁 lock 的控制权&quot;);</div><div class=\"line\">                    lock.wait();</div><div class=\"line\">                &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">                    e.printStackTrace();</div><div class=\"line\">                &#125;</div><div class=\"line\">                System.out.println(&quot;INFO: 有人唤醒了 A, A 重新获得锁 lock&quot;);</div><div class=\"line\">                System.out.println(&quot;A 2&quot;);</div><div class=\"line\">                System.out.println(&quot;A 3&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    Thread B = new Thread(new Runnable() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void run() &#123;</div><div class=\"line\">            System.out.println(&quot;INFO: B 等待锁&quot;);</div><div class=\"line\">            synchronized (lock) &#123;</div><div class=\"line\">                System.out.println(&quot;INFO: B 得到了锁 lock&quot;);</div><div class=\"line\">                System.out.println(&quot;B 1&quot;);</div><div class=\"line\">                System.out.println(&quot;B 2&quot;);</div><div class=\"line\">                System.out.println(&quot;B 3&quot;);</div><div class=\"line\"></div><div class=\"line\">                System.out.println(&quot;INFO: B 打印完毕，调用 notify 方法&quot;);</div><div class=\"line\">                lock.notify();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    A.start();</div><div class=\"line\">    B.start();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>打印结果如下:</p>\n<blockquote>\n<p>INFO: A 等待锁<br>INFO: A 得到了锁 lock<br>A 1<br>INFO: A 准备进入等待状态，调用 lock.wait() 放弃锁 lock 的控制权<br>INFO: B 等待锁<br>INFO: B 得到了锁 lock<br>B 1<br>B 2<br>B 3<br>INFO: B 打印完毕，调用 lock.notify() 方法<br>INFO: 有人唤醒了 A, A 重新获得锁 lock<br>A 2<br>A 3</p>\n</blockquote>\n<h2 id=\"四个线程-A-B-C-D，其中-D-要等到-A-B-C-全执行完毕后才执行，而且-A-B-C-是同步运行的\"><a href=\"#四个线程-A-B-C-D，其中-D-要等到-A-B-C-全执行完毕后才执行，而且-A-B-C-是同步运行的\" class=\"headerlink\" title=\"四个线程 A B C D，其中 D 要等到 A B C 全执行完毕后才执行，而且 A B C 是同步运行的\"></a>四个线程 A B C D，其中 D 要等到 A B C 全执行完毕后才执行，而且 A B C 是同步运行的</h2><p>最开始我们介绍了 <code>thread.join()</code>，可以让一个线程等另一个线程运行完毕后再继续执行，那我们可以在 D 线程里依次 join A B C，不过这也就使得 A B C 必须依次执行，而我们要的是这三者能同步运行。</p>\n<p>或者说，我们希望达到的目的是：A B C 三个线程同时运行，各自独立运行完后通知 D；对 D 而言，只要A B C 都运行完了，D 再开始运行。针对这种情况，我们可以利用 <code>CountdownLatch</code> 来实现这类通信方式。它的基本用法是：</p>\n<ol>\n<li>创建一个计数器，设置初始值，CountdownLatch countDownLatch = new CountDownLatch(2);</li>\n<li>在<code>等待线程</code>里调用 <code>countDownLatch.await()</code> 方法，进入等待状态，直到计数值变成 0；</li>\n<li>在<code>其他线程</code>里，调用 <code>countDownLatch.countDown()</code> 方法，该方法会将计数值减小 1；</li>\n<li>当<code>其他线程</code>的 <code>countDown()</code> 方法把计数值变成 0 时，<code>等待线程</code> 里的 <code>countDownLatch.await()</code> 立即退出，继续执行下面的代码。</li>\n</ol>\n<p>实现代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void runDAfterABC() &#123;</div><div class=\"line\">    int worker = 3;</div><div class=\"line\">    CountDownLatch countDownLatch = new CountDownLatch(worker);</div><div class=\"line\"></div><div class=\"line\">    new Thread(new Runnable() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void run() &#123;</div><div class=\"line\">            System.out.println(&quot;D is waiting for other three threads&quot;);</div><div class=\"line\">            try &#123;</div><div class=\"line\">                countDownLatch.await();</div><div class=\"line\">                System.out.println(&quot;All done, D starts working&quot;);</div><div class=\"line\">            &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">                e.printStackTrace();</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;).start();</div><div class=\"line\"></div><div class=\"line\">    for (char threadName=&apos;A&apos;; threadName &lt;= &apos;C&apos;; threadName++) &#123;</div><div class=\"line\">        final String tN = String.valueOf(threadName);</div><div class=\"line\">        new Thread(new Runnable() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void run() &#123;</div><div class=\"line\">                System.out.println(tN + &quot; is working&quot;);</div><div class=\"line\">                try &#123;</div><div class=\"line\">                    Thread.sleep(100);</div><div class=\"line\">                &#125; catch (Exception e) &#123;</div><div class=\"line\">                    e.printStackTrace();</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                System.out.println(tN + &quot; finished&quot;);</div><div class=\"line\">                countDownLatch.countDown();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).start();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>下面是运行结果：</p>\n<blockquote>\n<p>D is waiting for other three threads<br>A is working<br>B is working<br>C is working</p>\n<p>A finished<br>C finished<br>B finished<br>All done, D starts working</p>\n</blockquote>\n<p>其实简单点来说，<code>CountDownLatch</code> 就是一个倒计数器，我们把初始计数值设置为<code>3</code>，当 <code>D</code> 运行时，先调用 <code>countDownLatch.await()</code> 检查计数器值是否为 <code>0</code>，若不为 <code>0</code> 则保持等待状态；当<code>A</code> <code>B</code> <code>C</code> 各自运行完后都会利用<code>countDownLatch.countDown()</code>，将倒计数器减 <code>1</code>，当三个都运行完后，计数器被减至 <code>0</code>；此时立即触发 <code>D</code> 的 <code>await()</code> 运行结束，继续向下执行。</p>\n<p>因此，<code>CountDownLatch</code> 适用于一个线程去等待多个线程的情况。</p>\n<h2 id=\"三个运动员各自准备，等到三个人都准备好后，再一起跑\"><a href=\"#三个运动员各自准备，等到三个人都准备好后，再一起跑\" class=\"headerlink\" title=\"三个运动员各自准备，等到三个人都准备好后，再一起跑\"></a>三个运动员各自准备，等到三个人都准备好后，再一起跑</h2><p>上面是一个形象的比喻，针对<code>线程 A B C 各自开始准备，直到三者都准备完毕，然后再同时运行</code>。也就是要实现一种<code>线程之间互相等待</code>的效果，那应该怎么来实现呢？</p>\n<p>上面的 <code>CountDownLatch</code> 可以用来倒计数，但当计数完毕，只有一个线程的 <code>await()</code> 会得到响应，无法让多个线程同时触发。</p>\n<p>为了实现线程间互相等待这种需求，我们可以利用 <code>CyclicBarrier</code> 数据结构，它的基本用法是：</p>\n<ol>\n<li>先创建一个公共 <code>CyclicBarrier</code> 对象，设置<code>同时等待</code>的线程数，CyclicBarrier cyclicBarrier = new CyclicBarrier(3);</li>\n<li>这些线程同时开始自己做准备，自身准备完毕后，需要等待别人准备完毕，这时调用 <code>cyclicBarrier.await();</code> 即可开始等待别人；</li>\n<li>当指定的<code>同时等待</code>的线程数都调用了 <code>cyclicBarrier.await();</code>时，意味着这些线程都准备完毕好，然后这些线程才<code>同时继续执行</code>。</li>\n</ol>\n<p>实现代码如下，设想有三个跑步运动员，各自准备好后等待其他人，全部准备好后才开始跑：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void runABCWhenAllReady() &#123;</div><div class=\"line\">    int runner = 3;</div><div class=\"line\">    CyclicBarrier cyclicBarrier = new CyclicBarrier(runner);</div><div class=\"line\"></div><div class=\"line\">    final Random random = new Random();</div><div class=\"line\">    for (char runnerName=&apos;A&apos;; runnerName &lt;= &apos;C&apos;; runnerName++) &#123;</div><div class=\"line\">        final String rN = String.valueOf(runnerName);</div><div class=\"line\">        new Thread(new Runnable() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void run() &#123;</div><div class=\"line\">                long prepareTime = random.nextInt(10000) + 100;</div><div class=\"line\">                System.out.println(rN + &quot; is preparing for time: &quot; + prepareTime);</div><div class=\"line\">                try &#123;</div><div class=\"line\">                    Thread.sleep(prepareTime);</div><div class=\"line\">                &#125; catch (Exception e) &#123;</div><div class=\"line\">                    e.printStackTrace();</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                try &#123;</div><div class=\"line\">                    System.out.println(rN + &quot; is prepared, waiting for others&quot;);</div><div class=\"line\">                    cyclicBarrier.await(); // 当前运动员准备完毕，等待别人准备好</div><div class=\"line\">                &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">                    e.printStackTrace();</div><div class=\"line\">                &#125; catch (BrokenBarrierException e) &#123;</div><div class=\"line\">                    e.printStackTrace();</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                System.out.println(rN + &quot; starts running&quot;); // 所有运动员都准备好了，一起开始跑</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).start();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>打印的结果如下：</p>\n<blockquote>\n<p>A is preparing for time: 4131<br>B is preparing for time: 6349<br>C is preparing for time: 8206</p>\n<p>A is prepared, waiting for others</p>\n<p>B is prepared, waiting for others</p>\n<p>C is prepared, waiting for others</p>\n<p>C starts running<br>A starts running<br>B starts running</p>\n</blockquote>\n<h2 id=\"子线程完成某件任务后，把得到的结果回传给主线程\"><a href=\"#子线程完成某件任务后，把得到的结果回传给主线程\" class=\"headerlink\" title=\"子线程完成某件任务后，把得到的结果回传给主线程\"></a>子线程完成某件任务后，把得到的结果回传给主线程</h2><p>实际的开发中，我们经常要创建子线程来做一些耗时任务，然后把任务执行结果回传给主线程使用，这种情况在 Java 里要如何实现呢？</p>\n<p>回顾线程的创建，我们一般会把 <code>Runnable</code> 对象传给 Thread 去执行。<code>Runnable</code>定义如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public interface Runnable &#123;</div><div class=\"line\">    public abstract void run();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到 <code>run()</code> 在执行完后不会返回任何结果。那如果希望返回结果呢？这里可以利用另一个类似的接口类 <code>Callable</code>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">@FunctionalInterface</div><div class=\"line\">public interface Callable&lt;V&gt; &#123;</div><div class=\"line\">    /**</div><div class=\"line\">     * Computes a result, or throws an exception if unable to do so.</div><div class=\"line\">     *</div><div class=\"line\">     * @return computed result</div><div class=\"line\">     * @throws Exception if unable to compute a result</div><div class=\"line\">     */</div><div class=\"line\">    V call() throws Exception;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看出 <code>Callable</code> 最大区别就是返回范型 <code>V</code> 结果。</p>\n<p>那么下一个问题就是，如何把子线程的结果回传回来呢？在 Java 里，有一个类是配合 Callable 使用的：<code>FutureTask</code>，不过注意，它获取结果的 <code>get</code> 方法会阻塞主线程。</p>\n<p>举例，我们想让子线程去计算从1加到100，并把算出的结果返回到主线程。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void doTaskWithResultInWorker() &#123;</div><div class=\"line\">    Callable&lt;Integer&gt; callable = new Callable&lt;Integer&gt;() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public Integer call() throws Exception &#123;</div><div class=\"line\">            System.out.println(&quot;Task starts&quot;);</div><div class=\"line\">            Thread.sleep(1000);</div><div class=\"line\">            int result = 0;</div><div class=\"line\">            for (int i=0; i&lt;=100; i++) &#123;</div><div class=\"line\">                result += i;</div><div class=\"line\">            &#125;</div><div class=\"line\">            System.out.println(&quot;Task finished and return result&quot;);</div><div class=\"line\">            return result;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(callable);</div><div class=\"line\">    new Thread(futureTask).start();</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        System.out.println(&quot;Before futureTask.get()&quot;);</div><div class=\"line\">        System.out.println(&quot;Result: &quot; + futureTask.get());</div><div class=\"line\">        System.out.println(&quot;After futureTask.get()&quot;);</div><div class=\"line\">    &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">        e.printStackTrace();</div><div class=\"line\">    &#125; catch (ExecutionException e) &#123;</div><div class=\"line\">        e.printStackTrace();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>打印结果如下：</p>\n<blockquote>\n<p>Before futureTask.get()</p>\n<p>Task starts<br>Task finished and return result</p>\n<p>Result: 5050<br>After futureTask.get()</p>\n</blockquote>\n<p>可以看到，主线程调用 <code>futureTask.get()</code> 方法时阻塞主线程；然后 <code>Callable</code> 内部开始执行，并返回运算结果；此时 <code>futureTask.get()</code> 得到结果，主线程恢复运行。</p>\n<p>这里我们可以学到，通过 <code>FutureTask</code> 和 <code>Callable</code> 可以直接在主线程获得子线程的运算结果，只不过需要阻塞主线程。当然，如果不希望阻塞主线程，可以考虑利用 <code>ExecutorService</code>，把 <code>FutureTask</code> 放到线程池去管理执行。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>多线程是现代语言的共同特性，而线程间通信、线程同步、线程安全是很重要的话题。本文针对 Java 的线程间通信进行了大致的讲解，后续还会对线程同步、线程安全进行讲解。</p>\n<p>谢谢。</p>\n<p>wingjay</p>\n<p><a href=\"http://wingjay.com\">http://wingjay.com</a></p>\n<p><img src=\"https://avatars0.githubusercontent.com/u/9619875?v=3&amp;s=460\" alt=\"\"></p>","sticky":0},{"title":"《亿级 Android 架构》专栏随谈","date":"2018-11-26T06:34:44.000Z","commentIssueId":31,"_content":"各位好，很久没空来写点东西（忙+懒），快年底了，准备抽空写一写。由于今年一直在做一些Android架构方面的工作，所以准备以这个角度为切入点。\n\n本篇文章随谈一些关于Android架构的东西，包括写这个专栏的初衷、具体包括哪些技术点等。\n\n## 业务同学需要了解架构吗？\n有的同学会问，我平常都在写业务代码、写页面、调用SDK，有必要去了解架构吗？答案很简单，**业务是表，架构是里**。变化万千的业务背后都是大同小异的架构。时代更迭，业务变迁，理解架构的技术人员可以处变不惊，而非疲于奔命。\n\n因此，本人建议业务同学在繁重的业务开发之余，可以多去研究一些底层库原理，而非停留在花式调用SDK的阶段，这会让你具备更强的技术竞争力。\n\n<!-- more -->\n\n## 架构孵化于业务，服务于业务\n不少公司的架构同学和业务同学都存在一种矛盾：架构与业务互相独立，导致输出的技术总是不能很好的满足业务需求，导致的结果是：架构同学有心无力，业务同学有苦难言。\n\n实际上，真正好的架构是从业务中孵化出来的，而且能服务于更广阔的业务形态。\n\n举几个例子大家就清楚了。\n\n大家都知道阿里主营电商业务，而电商是**强运营**的，所以对于**动态化**有非常强的需求，也就是希望App尽可能像网页一样，能够随时更新页面内容。于是，阿里内部孵化出了**[Weex](https://github.com/alibaba/weex)**，通过远程开发部署js代码，即可实时更新页面内容；\n\n另外，手淘App对于整个阿里集团的战略意义非常大，它不仅是盈利怪兽，而且是整个集团的流量入口（手淘DAU自2015年即达1.1亿）。这也就是阿里曾提出的“航母策略”：手淘如一座航母，集团内各种业务形态如飞猪、闲鱼、天猫等都可坐落在其上。于是，**[Atlas](https://github.com/alibaba/atlas)**诞生了，所有App都可以轻松集成到手淘上，享受流量滋养。\n\n类似的例子还有很多，比如大家熟知的**微信**，需要保证消息在任何复杂网络下都能有最高的到达率。因此微信自研了一套跨平台长连接方案，提出智能心跳方案、多种弱网应对策略如多级超时等，最终推出了**[Mars](https://github.com/Tencent/mars)**，保证了全国各种网络环境下的用户都能稳定的收发消息。\n\n有些同学可能了解阿里15年提出的“大中台，小前台战略”，搭建集团数据中台、技术中台，帮助各种前台业务快跑前进；这样的技术架构和组织架构帮助阿里快速孵化出各种新的业务，比如18年初的**淘宝特价版**，据朋友了解整个App从启动到上线只用了短短一个多月的时间。今年，腾讯组织架构调整，担任CTO的张志东就提到：“没有能帮助到公司级的数据中台建设，我个人也蛮遗憾。”，自此腾讯也正式启动了“中台架构”建设。\n\n所以说，不同的业务形态，能孵化出特有的架构。\n\n架构是根，扎得越深，业务才越能开枝散叶。\n\n## 专栏技术图谱\n闲话说了不少，下面正式谈一谈本专栏会覆盖的一些技术点吧。这些技术点会基于本人日常的工作积累，同时结合各大厂开源的技术体系，（当然对于阿里闭源的会尽量规避掉，线下可以做一些技术探讨）。\n\n下面，我把后面专栏会覆盖到的技术点列出来，当然在写作的过程中还会逐步调整。\n\n1. 动态化专题\n由于App获客成本不断提高，**动态化**是近年来越来越重要的技术架构，例如React Native、小程序、快应用等都在试图让App具备实时更新、随手可得。本专题会对各厂提出的动态化方案进行分析，如JsBridge；包括小程序方案的一些实现思路，比如多进程的H5容器架构；另外，还会分析一些适用于移动平台的动态化编程语言如Lua，Javascript等。\n\n2. 图片专题\n对于亿级App而言，图片的任何优化都对于流量、体验等具有重要意义。比如Google+ App采用 WebP 图片格式后，每天节省了 **50TB**数据存储空间。因此，本专题会谈一下各大厂如腾讯、FB、Google等在图片优化方面提出过哪些方案，比如WebP vs SharpP；另外也会分析一些大家用的比较多的Glide、Fresco是如何做图片缓存、如何基于Dalvik/Art不同的内存结构来优化。\n\n3. 省流专题\n上面谈到了图片的压缩，其实节省流量是一个永恒的话题，它不仅能改善用户体验，也能帮助减少用户流量开销，节省公司成本。因此，本专题会谈一谈如何监控Android流量；有哪些常用的Diff及压缩算法，比如Tinker里自研的Diff算法 vs Google提出的google-diff vs BsDiff等；如何选用数据通信格式如json、ProtoBuf；FastJson、Jackson各自的优势等等。\n\n4. 网络专题\n大多数业务同学对网络的认识就是`OkHttp+Json解析`，实际上，网络这一块还存在非常多值得研究的技术点。一个优质的App，除了在网络良好的环境下运行，更重要的是，必须在`弱网、网络劫持、网络慢`等复杂环境下也要良好运行，而且还得快，这也就涉及到`DNS加速、网络结果缓存`等。\n之前大厂都在提“页面秒开”的概念，页面打开速度很大程度取决于当下的网络环境，也对于用户体验和留存有非常大的影响。这个专题我们谈谈网络相关的技术点。\n\n5. 监控与日志专题\n对于监控和日志，多数人的印象是集成一个第三方SDK，如Fabric、Bugly等。业务同学或许对日志了解不是特别多，但实际上日志是至关重要的，尤其是在排查复杂问题时。\n本专题我们谈一下如何做到日志不丢失，如何后台上报且不影响App运行，最有意思的一点：`如何利用长连接等技术，实时拉取任意用户的本地详细日志`。\n\n6. 安全专题\n安全专题就离多数比较远了，这里我们讲解一些常见的和业务相关的安全话题，具体后续补充。\n\n7. 高可用专题\n后续补充\n8. GC专题\n后续补充\n\n## 专题计划技术点列表\n1. 动态化专题\n    - 如何让JavaScript与App交互\n    - 如何实现“即点即用”之小程序、快应用\n    - H5容器之多进程架构\n    - 动态化编程之Lua\n    - ...等\n2. 图片专题\n    - 图片压缩之WebP与腾讯SharpP的实现机制\n    - 图片内存优化之Glide和Fresco原理篇\n    - png jpg等常用图片格式的内存、解压速度分析\n    - ...等\n3. 省流专题\n    - Android流量监控\n    - 文件压缩 zip 7z gzip等\n    - 增量更新之diff算法，案例：Tinker自研diff/patch算法\n    - 图片缓存技术\n    - WebView缓存优化\n    - 数据传输协议对比之ProfoBuf、FastJson、Jackson\n    - ...等\n4. 网络专题\n    - 可靠长连接的意义\n    - HTTPDNS DNS劫持\n    - 网络嗅探\n    - Http2/Https/QUIC协议对比\n    - CDN 削峰填谷\n    - 如何做全局网络限流，保证业务流量高优先级\n    - ...等\n5. 监控与日志专题\n    - `mmap`日志落地方式，开源项目`Logan`，`xlog`等分析\n    - 通过长连接动态拉取日志\n    - 如果长连接断开、通过短连接兜底拉取日志\n    - 日志上报，本地分片存储及后台上报策略\n    - ...等\n6. 安全专题\n    - 移动端的加密算法之对称与非对称，防篡改\n    - 常规编码方式一览 md5 base64\n    - ...等\n\n---\n### 《亿级Android架构》小专栏介绍\n业务的快速增长离不开稳定可靠的架构。[《亿级Android架构》](https://xiaozhuanlan.com/AndroidArch)小专栏会基于作者实际工作经验，结合国内大厂如阿里、腾讯、美团等基础架构现状，尝试谈谈如何设计一套好的架构来支持业务从0到1，甚至到亿，希望与大家多多探讨。\n\n本专栏主要内容：\n1. 当前大厂有哪些Android架构；\n2. 这些架构能解决什么问题；\n3. 这些架构的原理是什么；\n4. 学习这些架构对我们自身的意义。\n\n**[《亿级Android架构》](https://xiaozhuanlan.com/AndroidArch)小专栏文章列表：**\n\n[《亿级 Android 架构》专栏随谈》](https://xiaozhuanlan.com/topic/1934527806)\n\n[《Android 架构之网络连接与加速》](https://xiaozhuanlan.com/topic/6982074351)\n\n[《Android 架构之长连接技术》](https://xiaozhuanlan.com/topic/3758142906)\n\n[《Android 架构之高可用移动网络连接》](https://xiaozhuanlan.com/topic/2130768549)\n\n[《Android 架构之网络安全演进》](https://xiaozhuanlan.com/topic/8159302674)\n\n[《Android 架构之高性能移动端日志系统》](https://xiaozhuanlan.com/topic/2694081375)\n\n---    \n","source":"_posts/《亿级-Android-架构》专栏随谈.md","raw":"title: 《亿级 Android 架构》专栏随谈\ndate: 2018-11-26 14:34:44\npermalink:\ncategories:\n  - Android\n  - 亿级Android架构\ntags: \n\t- Android\n\t- 架构\ncommentIssueId: 31\n---\n各位好，很久没空来写点东西（忙+懒），快年底了，准备抽空写一写。由于今年一直在做一些Android架构方面的工作，所以准备以这个角度为切入点。\n\n本篇文章随谈一些关于Android架构的东西，包括写这个专栏的初衷、具体包括哪些技术点等。\n\n## 业务同学需要了解架构吗？\n有的同学会问，我平常都在写业务代码、写页面、调用SDK，有必要去了解架构吗？答案很简单，**业务是表，架构是里**。变化万千的业务背后都是大同小异的架构。时代更迭，业务变迁，理解架构的技术人员可以处变不惊，而非疲于奔命。\n\n因此，本人建议业务同学在繁重的业务开发之余，可以多去研究一些底层库原理，而非停留在花式调用SDK的阶段，这会让你具备更强的技术竞争力。\n\n<!-- more -->\n\n## 架构孵化于业务，服务于业务\n不少公司的架构同学和业务同学都存在一种矛盾：架构与业务互相独立，导致输出的技术总是不能很好的满足业务需求，导致的结果是：架构同学有心无力，业务同学有苦难言。\n\n实际上，真正好的架构是从业务中孵化出来的，而且能服务于更广阔的业务形态。\n\n举几个例子大家就清楚了。\n\n大家都知道阿里主营电商业务，而电商是**强运营**的，所以对于**动态化**有非常强的需求，也就是希望App尽可能像网页一样，能够随时更新页面内容。于是，阿里内部孵化出了**[Weex](https://github.com/alibaba/weex)**，通过远程开发部署js代码，即可实时更新页面内容；\n\n另外，手淘App对于整个阿里集团的战略意义非常大，它不仅是盈利怪兽，而且是整个集团的流量入口（手淘DAU自2015年即达1.1亿）。这也就是阿里曾提出的“航母策略”：手淘如一座航母，集团内各种业务形态如飞猪、闲鱼、天猫等都可坐落在其上。于是，**[Atlas](https://github.com/alibaba/atlas)**诞生了，所有App都可以轻松集成到手淘上，享受流量滋养。\n\n类似的例子还有很多，比如大家熟知的**微信**，需要保证消息在任何复杂网络下都能有最高的到达率。因此微信自研了一套跨平台长连接方案，提出智能心跳方案、多种弱网应对策略如多级超时等，最终推出了**[Mars](https://github.com/Tencent/mars)**，保证了全国各种网络环境下的用户都能稳定的收发消息。\n\n有些同学可能了解阿里15年提出的“大中台，小前台战略”，搭建集团数据中台、技术中台，帮助各种前台业务快跑前进；这样的技术架构和组织架构帮助阿里快速孵化出各种新的业务，比如18年初的**淘宝特价版**，据朋友了解整个App从启动到上线只用了短短一个多月的时间。今年，腾讯组织架构调整，担任CTO的张志东就提到：“没有能帮助到公司级的数据中台建设，我个人也蛮遗憾。”，自此腾讯也正式启动了“中台架构”建设。\n\n所以说，不同的业务形态，能孵化出特有的架构。\n\n架构是根，扎得越深，业务才越能开枝散叶。\n\n## 专栏技术图谱\n闲话说了不少，下面正式谈一谈本专栏会覆盖的一些技术点吧。这些技术点会基于本人日常的工作积累，同时结合各大厂开源的技术体系，（当然对于阿里闭源的会尽量规避掉，线下可以做一些技术探讨）。\n\n下面，我把后面专栏会覆盖到的技术点列出来，当然在写作的过程中还会逐步调整。\n\n1. 动态化专题\n由于App获客成本不断提高，**动态化**是近年来越来越重要的技术架构，例如React Native、小程序、快应用等都在试图让App具备实时更新、随手可得。本专题会对各厂提出的动态化方案进行分析，如JsBridge；包括小程序方案的一些实现思路，比如多进程的H5容器架构；另外，还会分析一些适用于移动平台的动态化编程语言如Lua，Javascript等。\n\n2. 图片专题\n对于亿级App而言，图片的任何优化都对于流量、体验等具有重要意义。比如Google+ App采用 WebP 图片格式后，每天节省了 **50TB**数据存储空间。因此，本专题会谈一下各大厂如腾讯、FB、Google等在图片优化方面提出过哪些方案，比如WebP vs SharpP；另外也会分析一些大家用的比较多的Glide、Fresco是如何做图片缓存、如何基于Dalvik/Art不同的内存结构来优化。\n\n3. 省流专题\n上面谈到了图片的压缩，其实节省流量是一个永恒的话题，它不仅能改善用户体验，也能帮助减少用户流量开销，节省公司成本。因此，本专题会谈一谈如何监控Android流量；有哪些常用的Diff及压缩算法，比如Tinker里自研的Diff算法 vs Google提出的google-diff vs BsDiff等；如何选用数据通信格式如json、ProtoBuf；FastJson、Jackson各自的优势等等。\n\n4. 网络专题\n大多数业务同学对网络的认识就是`OkHttp+Json解析`，实际上，网络这一块还存在非常多值得研究的技术点。一个优质的App，除了在网络良好的环境下运行，更重要的是，必须在`弱网、网络劫持、网络慢`等复杂环境下也要良好运行，而且还得快，这也就涉及到`DNS加速、网络结果缓存`等。\n之前大厂都在提“页面秒开”的概念，页面打开速度很大程度取决于当下的网络环境，也对于用户体验和留存有非常大的影响。这个专题我们谈谈网络相关的技术点。\n\n5. 监控与日志专题\n对于监控和日志，多数人的印象是集成一个第三方SDK，如Fabric、Bugly等。业务同学或许对日志了解不是特别多，但实际上日志是至关重要的，尤其是在排查复杂问题时。\n本专题我们谈一下如何做到日志不丢失，如何后台上报且不影响App运行，最有意思的一点：`如何利用长连接等技术，实时拉取任意用户的本地详细日志`。\n\n6. 安全专题\n安全专题就离多数比较远了，这里我们讲解一些常见的和业务相关的安全话题，具体后续补充。\n\n7. 高可用专题\n后续补充\n8. GC专题\n后续补充\n\n## 专题计划技术点列表\n1. 动态化专题\n    - 如何让JavaScript与App交互\n    - 如何实现“即点即用”之小程序、快应用\n    - H5容器之多进程架构\n    - 动态化编程之Lua\n    - ...等\n2. 图片专题\n    - 图片压缩之WebP与腾讯SharpP的实现机制\n    - 图片内存优化之Glide和Fresco原理篇\n    - png jpg等常用图片格式的内存、解压速度分析\n    - ...等\n3. 省流专题\n    - Android流量监控\n    - 文件压缩 zip 7z gzip等\n    - 增量更新之diff算法，案例：Tinker自研diff/patch算法\n    - 图片缓存技术\n    - WebView缓存优化\n    - 数据传输协议对比之ProfoBuf、FastJson、Jackson\n    - ...等\n4. 网络专题\n    - 可靠长连接的意义\n    - HTTPDNS DNS劫持\n    - 网络嗅探\n    - Http2/Https/QUIC协议对比\n    - CDN 削峰填谷\n    - 如何做全局网络限流，保证业务流量高优先级\n    - ...等\n5. 监控与日志专题\n    - `mmap`日志落地方式，开源项目`Logan`，`xlog`等分析\n    - 通过长连接动态拉取日志\n    - 如果长连接断开、通过短连接兜底拉取日志\n    - 日志上报，本地分片存储及后台上报策略\n    - ...等\n6. 安全专题\n    - 移动端的加密算法之对称与非对称，防篡改\n    - 常规编码方式一览 md5 base64\n    - ...等\n\n---\n### 《亿级Android架构》小专栏介绍\n业务的快速增长离不开稳定可靠的架构。[《亿级Android架构》](https://xiaozhuanlan.com/AndroidArch)小专栏会基于作者实际工作经验，结合国内大厂如阿里、腾讯、美团等基础架构现状，尝试谈谈如何设计一套好的架构来支持业务从0到1，甚至到亿，希望与大家多多探讨。\n\n本专栏主要内容：\n1. 当前大厂有哪些Android架构；\n2. 这些架构能解决什么问题；\n3. 这些架构的原理是什么；\n4. 学习这些架构对我们自身的意义。\n\n**[《亿级Android架构》](https://xiaozhuanlan.com/AndroidArch)小专栏文章列表：**\n\n[《亿级 Android 架构》专栏随谈》](https://xiaozhuanlan.com/topic/1934527806)\n\n[《Android 架构之网络连接与加速》](https://xiaozhuanlan.com/topic/6982074351)\n\n[《Android 架构之长连接技术》](https://xiaozhuanlan.com/topic/3758142906)\n\n[《Android 架构之高可用移动网络连接》](https://xiaozhuanlan.com/topic/2130768549)\n\n[《Android 架构之网络安全演进》](https://xiaozhuanlan.com/topic/8159302674)\n\n[《Android 架构之高性能移动端日志系统》](https://xiaozhuanlan.com/topic/2694081375)\n\n---    \n","slug":"《亿级-Android-架构》专栏随谈","published":1,"updated":"2019-01-16T03:40:33.390Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplsi4002o3dn8im65h72w","content":"<p>各位好，很久没空来写点东西（忙 + 懒），快年底了，准备抽空写一写。由于今年一直在做一些 Android 架构方面的工作，所以准备以这个角度为切入点。</p>\n<p>本篇文章随谈一些关于 Android 架构的东西，包括写这个专栏的初衷、具体包括哪些技术点等。</p>\n<h2 id=\"业务同学需要了解架构吗？\"><a href=\"# 业务同学需要了解架构吗？\" class=\"headerlink\" title=\"业务同学需要了解架构吗？\"></a>业务同学需要了解架构吗？</h2><p>有的同学会问，我平常都在写业务代码、写页面、调用 SDK，有必要去了解架构吗？答案很简单，<strong>业务是表，架构是里</strong>。变化万千的业务背后都是大同小异的架构。时代更迭，业务变迁，理解架构的技术人员可以处变不惊，而非疲于奔命。</p>\n<p>因此，本人建议业务同学在繁重的业务开发之余，可以多去研究一些底层库原理，而非停留在花式调用 SDK 的阶段，这会让你具备更强的技术竞争力。</p>\n<a id=\"more\"></a>\n<h2 id=\"架构孵化于业务，服务于业务\"><a href=\"# 架构孵化于业务，服务于业务\" class=\"headerlink\" title=\"架构孵化于业务，服务于业务\"></a>架构孵化于业务，服务于业务 </h2><p> 不少公司的架构同学和业务同学都存在一种矛盾：架构与业务互相独立，导致输出的技术总是不能很好的满足业务需求，导致的结果是：架构同学有心无力，业务同学有苦难言。</p>\n<p>实际上，真正好的架构是从业务中孵化出来的，而且能服务于更广阔的业务形态。</p>\n<p>举几个例子大家就清楚了。</p>\n<p>大家都知道阿里主营电商业务，而电商是 <strong> 强运营 </strong> 的，所以对于 <strong> 动态化 </strong> 有非常强的需求，也就是希望 App 尽可能像网页一样，能够随时更新页面内容。于是，阿里内部孵化出了<strong><a href=\"https://github.com/alibaba/weex\" target=\"_blank\" rel=\"external\">Weex</a></strong>，通过远程开发部署 js 代码，即可实时更新页面内容；</p>\n<p>另外，手淘 App 对于整个阿里集团的战略意义非常大，它不仅是盈利怪兽，而且是整个集团的流量入口（手淘 DAU 自 2015 年即达 1.1 亿）。这也就是阿里曾提出的“航母策略”：手淘如一座航母，集团内各种业务形态如飞猪、闲鱼、天猫等都可坐落在其上。于是，<strong><a href=\"https://github.com/alibaba/atlas\" target=\"_blank\" rel=\"external\">Atlas</a></strong>诞生了，所有 App 都可以轻松集成到手淘上，享受流量滋养。</p>\n<p>类似的例子还有很多，比如大家熟知的 <strong> 微信</strong>，需要保证消息在任何复杂网络下都能有最高的到达率。因此微信自研了一套跨平台长连接方案，提出智能心跳方案、多种弱网应对策略如多级超时等，最终推出了<strong><a href=\"https://github.com/Tencent/mars\" target=\"_blank\" rel=\"external\">Mars</a></strong>，保证了全国各种网络环境下的用户都能稳定的收发消息。</p>\n<p>有些同学可能了解阿里 15 年提出的“大中台，小前台战略”，搭建集团数据中台、技术中台，帮助各种前台业务快跑前进；这样的技术架构和组织架构帮助阿里快速孵化出各种新的业务，比如 18 年初的 <strong> 淘宝特价版</strong>，据朋友了解整个 App 从启动到上线只用了短短一个多月的时间。今年，腾讯组织架构调整，担任 CTO 的张志东就提到：“没有能帮助到公司级的数据中台建设，我个人也蛮遗憾。”，自此腾讯也正式启动了“中台架构”建设。</p>\n<p>所以说，不同的业务形态，能孵化出特有的架构。</p>\n<p>架构是根，扎得越深，业务才越能开枝散叶。</p>\n<h2 id=\"专栏技术图谱\"><a href=\"# 专栏技术图谱\" class=\"headerlink\" title=\"专栏技术图谱\"></a>专栏技术图谱 </h2><p> 闲话说了不少，下面正式谈一谈本专栏会覆盖的一些技术点吧。这些技术点会基于本人日常的工作积累，同时结合各大厂开源的技术体系，（当然对于阿里闭源的会尽量规避掉，线下可以做一些技术探讨）。</p>\n<p>下面，我把后面专栏会覆盖到的技术点列出来，当然在写作的过程中还会逐步调整。</p>\n<ol>\n<li><p>动态化专题 <br> 由于 App 获客成本不断提高，<strong>动态化 </strong> 是近年来越来越重要的技术架构，例如 React Native、小程序、快应用等都在试图让 App 具备实时更新、随手可得。本专题会对各厂提出的动态化方案进行分析，如 JsBridge；包括小程序方案的一些实现思路，比如多进程的 H5 容器架构；另外，还会分析一些适用于移动平台的动态化编程语言如 Lua，Javascript 等。</p>\n</li>\n<li><p>图片专题 <br> 对于亿级 App 而言，图片的任何优化都对于流量、体验等具有重要意义。比如 Google+ App 采用 WebP 图片格式后，每天节省了 <strong>50TB</strong>数据存储空间。因此，本专题会谈一下各大厂如腾讯、FB、Google 等在图片优化方面提出过哪些方案，比如 WebP vs SharpP；另外也会分析一些大家用的比较多的 Glide、Fresco 是如何做图片缓存、如何基于 Dalvik/Art 不同的内存结构来优化。</p>\n</li>\n<li><p>省流专题 <br> 上面谈到了图片的压缩，其实节省流量是一个永恒的话题，它不仅能改善用户体验，也能帮助减少用户流量开销，节省公司成本。因此，本专题会谈一谈如何监控 Android 流量；有哪些常用的 Diff 及压缩算法，比如 Tinker 里自研的 Diff 算法 vs Google 提出的 google-diff vs BsDiff 等；如何选用数据通信格式如 json、ProtoBuf；FastJson、Jackson 各自的优势等等。</p>\n</li>\n<li><p>网络专题 <br> 大多数业务同学对网络的认识就是 <code>OkHttp+Json 解析</code>，实际上，网络这一块还存在非常多值得研究的技术点。一个优质的 App，除了在网络良好的环境下运行，更重要的是，必须在<code> 弱网、网络劫持、网络慢 </code> 等复杂环境下也要良好运行，而且还得快，这也就涉及到 <code>DNS 加速、网络结果缓存</code> 等。<br>之前大厂都在提“页面秒开”的概念，页面打开速度很大程度取决于当下的网络环境，也对于用户体验和留存有非常大的影响。这个专题我们谈谈网络相关的技术点。</p>\n</li>\n<li><p>监控与日志专题 <br> 对于监控和日志，多数人的印象是集成一个第三方 SDK，如 Fabric、Bugly 等。业务同学或许对日志了解不是特别多，但实际上日志是至关重要的，尤其是在排查复杂问题时。<br>本专题我们谈一下如何做到日志不丢失，如何后台上报且不影响 App 运行，最有意思的一点：<code>如何利用长连接等技术，实时拉取任意用户的本地详细日志</code>。</p>\n</li>\n<li><p>安全专题 <br> 安全专题就离多数比较远了，这里我们讲解一些常见的和业务相关的安全话题，具体后续补充。</p>\n</li>\n<li><p>高可用专题 <br> 后续补充</p>\n</li>\n<li>GC 专题 <br> 后续补充</li>\n</ol>\n<h2 id=\"专题计划技术点列表\"><a href=\"# 专题计划技术点列表\" class=\"headerlink\" title=\"专题计划技术点列表\"></a>专题计划技术点列表</h2><ol>\n<li>动态化专题<ul>\n<li>如何让 JavaScript 与 App 交互</li>\n<li>如何实现“即点即用”之小程序、快应用</li>\n<li>H5 容器之多进程架构</li>\n<li>动态化编程之 Lua</li>\n<li>…等</li>\n</ul>\n</li>\n<li>图片专题<ul>\n<li>图片压缩之 WebP 与腾讯 SharpP 的实现机制</li>\n<li>图片内存优化之 Glide 和 Fresco 原理篇</li>\n<li>png jpg 等常用图片格式的内存、解压速度分析</li>\n<li>…等</li>\n</ul>\n</li>\n<li>省流专题<ul>\n<li>Android 流量监控</li>\n<li>文件压缩 zip 7z gzip 等</li>\n<li>增量更新之 diff 算法，案例：Tinker 自研 diff/patch 算法</li>\n<li>图片缓存技术</li>\n<li>WebView 缓存优化</li>\n<li>数据传输协议对比之 ProfoBuf、FastJson、Jackson</li>\n<li>…等</li>\n</ul>\n</li>\n<li>网络专题<ul>\n<li>可靠长连接的意义</li>\n<li>HTTPDNS DNS 劫持</li>\n<li>网络嗅探</li>\n<li>Http2/Https/QUIC 协议对比</li>\n<li>CDN 削峰填谷</li>\n<li>如何做全局网络限流，保证业务流量高优先级</li>\n<li>…等</li>\n</ul>\n</li>\n<li>监控与日志专题<ul>\n<li><code>mmap</code>日志落地方式，开源项目 <code>Logan</code>，<code>xlog</code> 等分析</li>\n<li>通过长连接动态拉取日志</li>\n<li>如果长连接断开、通过短连接兜底拉取日志</li>\n<li>日志上报，本地分片存储及后台上报策略</li>\n<li>…等</li>\n</ul>\n</li>\n<li>安全专题<ul>\n<li>移动端的加密算法之对称与非对称，防篡改</li>\n<li>常规编码方式一览 md5 base64</li>\n<li>…等</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"《亿级 Android 架构》小专栏介绍\"><a href=\"#《亿级 Android 架构》小专栏介绍\" class=\"headerlink\" title=\"《亿级 Android 架构》小专栏介绍\"></a>《亿级 Android 架构》小专栏介绍 </h3><p> 业务的快速增长离不开稳定可靠的架构。<a href=\"https://xiaozhuanlan.com/AndroidArch\" target=\"_blank\" rel=\"external\">《亿级 Android 架构》</a>小专栏会基于作者实际工作经验，结合国内大厂如阿里、腾讯、美团等基础架构现状，尝试谈谈如何设计一套好的架构来支持业务从 0 到 1，甚至到亿，希望与大家多多探讨。</p>\n<p>本专栏主要内容：</p>\n<ol>\n<li>当前大厂有哪些 Android 架构；</li>\n<li>这些架构能解决什么问题；</li>\n<li>这些架构的原理是什么；</li>\n<li>学习这些架构对我们自身的意义。</li>\n</ol>\n<p><strong><a href=\"https://xiaozhuanlan.com/AndroidArch\" target=\"_blank\" rel=\"external\">《亿级 Android 架构》</a>小专栏文章列表：</strong></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/1934527806\" target=\"_blank\" rel=\"external\">《亿级 Android 架构》专栏随谈》</a></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/6982074351\" target=\"_blank\" rel=\"external\">《Android 架构之网络连接与加速》</a></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/3758142906\" target=\"_blank\" rel=\"external\">《Android 架构之长连接技术》</a></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/2130768549\" target=\"_blank\" rel=\"external\">《Android 架构之高可用移动网络连接》</a></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/8159302674\" target=\"_blank\" rel=\"external\">《Android 架构之网络安全演进》</a></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/2694081375\" target=\"_blank\" rel=\"external\">《Android 架构之高性能移动端日志系统》</a></p>\n<hr>\n","site":{"data":{}},"excerpt":"<p>各位好，很久没空来写点东西（忙+懒），快年底了，准备抽空写一写。由于今年一直在做一些Android架构方面的工作，所以准备以这个角度为切入点。</p>\n<p>本篇文章随谈一些关于Android架构的东西，包括写这个专栏的初衷、具体包括哪些技术点等。</p>\n<h2 id=\"业务同学需要了解架构吗？\"><a href=\"#业务同学需要了解架构吗？\" class=\"headerlink\" title=\"业务同学需要了解架构吗？\"></a>业务同学需要了解架构吗？</h2><p>有的同学会问，我平常都在写业务代码、写页面、调用SDK，有必要去了解架构吗？答案很简单，<strong>业务是表，架构是里</strong>。变化万千的业务背后都是大同小异的架构。时代更迭，业务变迁，理解架构的技术人员可以处变不惊，而非疲于奔命。</p>\n<p>因此，本人建议业务同学在繁重的业务开发之余，可以多去研究一些底层库原理，而非停留在花式调用SDK的阶段，这会让你具备更强的技术竞争力。</p>","more":"<h2 id=\"架构孵化于业务，服务于业务\"><a href=\"#架构孵化于业务，服务于业务\" class=\"headerlink\" title=\"架构孵化于业务，服务于业务\"></a>架构孵化于业务，服务于业务</h2><p>不少公司的架构同学和业务同学都存在一种矛盾：架构与业务互相独立，导致输出的技术总是不能很好的满足业务需求，导致的结果是：架构同学有心无力，业务同学有苦难言。</p>\n<p>实际上，真正好的架构是从业务中孵化出来的，而且能服务于更广阔的业务形态。</p>\n<p>举几个例子大家就清楚了。</p>\n<p>大家都知道阿里主营电商业务，而电商是<strong>强运营</strong>的，所以对于<strong>动态化</strong>有非常强的需求，也就是希望App尽可能像网页一样，能够随时更新页面内容。于是，阿里内部孵化出了<strong><a href=\"https://github.com/alibaba/weex\" target=\"_blank\" rel=\"external\">Weex</a></strong>，通过远程开发部署js代码，即可实时更新页面内容；</p>\n<p>另外，手淘App对于整个阿里集团的战略意义非常大，它不仅是盈利怪兽，而且是整个集团的流量入口（手淘DAU自2015年即达1.1亿）。这也就是阿里曾提出的“航母策略”：手淘如一座航母，集团内各种业务形态如飞猪、闲鱼、天猫等都可坐落在其上。于是，<strong><a href=\"https://github.com/alibaba/atlas\" target=\"_blank\" rel=\"external\">Atlas</a></strong>诞生了，所有App都可以轻松集成到手淘上，享受流量滋养。</p>\n<p>类似的例子还有很多，比如大家熟知的<strong>微信</strong>，需要保证消息在任何复杂网络下都能有最高的到达率。因此微信自研了一套跨平台长连接方案，提出智能心跳方案、多种弱网应对策略如多级超时等，最终推出了<strong><a href=\"https://github.com/Tencent/mars\" target=\"_blank\" rel=\"external\">Mars</a></strong>，保证了全国各种网络环境下的用户都能稳定的收发消息。</p>\n<p>有些同学可能了解阿里15年提出的“大中台，小前台战略”，搭建集团数据中台、技术中台，帮助各种前台业务快跑前进；这样的技术架构和组织架构帮助阿里快速孵化出各种新的业务，比如18年初的<strong>淘宝特价版</strong>，据朋友了解整个App从启动到上线只用了短短一个多月的时间。今年，腾讯组织架构调整，担任CTO的张志东就提到：“没有能帮助到公司级的数据中台建设，我个人也蛮遗憾。”，自此腾讯也正式启动了“中台架构”建设。</p>\n<p>所以说，不同的业务形态，能孵化出特有的架构。</p>\n<p>架构是根，扎得越深，业务才越能开枝散叶。</p>\n<h2 id=\"专栏技术图谱\"><a href=\"#专栏技术图谱\" class=\"headerlink\" title=\"专栏技术图谱\"></a>专栏技术图谱</h2><p>闲话说了不少，下面正式谈一谈本专栏会覆盖的一些技术点吧。这些技术点会基于本人日常的工作积累，同时结合各大厂开源的技术体系，（当然对于阿里闭源的会尽量规避掉，线下可以做一些技术探讨）。</p>\n<p>下面，我把后面专栏会覆盖到的技术点列出来，当然在写作的过程中还会逐步调整。</p>\n<ol>\n<li><p>动态化专题<br>由于App获客成本不断提高，<strong>动态化</strong>是近年来越来越重要的技术架构，例如React Native、小程序、快应用等都在试图让App具备实时更新、随手可得。本专题会对各厂提出的动态化方案进行分析，如JsBridge；包括小程序方案的一些实现思路，比如多进程的H5容器架构；另外，还会分析一些适用于移动平台的动态化编程语言如Lua，Javascript等。</p>\n</li>\n<li><p>图片专题<br>对于亿级App而言，图片的任何优化都对于流量、体验等具有重要意义。比如Google+ App采用 WebP 图片格式后，每天节省了 <strong>50TB</strong>数据存储空间。因此，本专题会谈一下各大厂如腾讯、FB、Google等在图片优化方面提出过哪些方案，比如WebP vs SharpP；另外也会分析一些大家用的比较多的Glide、Fresco是如何做图片缓存、如何基于Dalvik/Art不同的内存结构来优化。</p>\n</li>\n<li><p>省流专题<br>上面谈到了图片的压缩，其实节省流量是一个永恒的话题，它不仅能改善用户体验，也能帮助减少用户流量开销，节省公司成本。因此，本专题会谈一谈如何监控Android流量；有哪些常用的Diff及压缩算法，比如Tinker里自研的Diff算法 vs Google提出的google-diff vs BsDiff等；如何选用数据通信格式如json、ProtoBuf；FastJson、Jackson各自的优势等等。</p>\n</li>\n<li><p>网络专题<br>大多数业务同学对网络的认识就是<code>OkHttp+Json解析</code>，实际上，网络这一块还存在非常多值得研究的技术点。一个优质的App，除了在网络良好的环境下运行，更重要的是，必须在<code>弱网、网络劫持、网络慢</code>等复杂环境下也要良好运行，而且还得快，这也就涉及到<code>DNS加速、网络结果缓存</code>等。<br>之前大厂都在提“页面秒开”的概念，页面打开速度很大程度取决于当下的网络环境，也对于用户体验和留存有非常大的影响。这个专题我们谈谈网络相关的技术点。</p>\n</li>\n<li><p>监控与日志专题<br>对于监控和日志，多数人的印象是集成一个第三方SDK，如Fabric、Bugly等。业务同学或许对日志了解不是特别多，但实际上日志是至关重要的，尤其是在排查复杂问题时。<br>本专题我们谈一下如何做到日志不丢失，如何后台上报且不影响App运行，最有意思的一点：<code>如何利用长连接等技术，实时拉取任意用户的本地详细日志</code>。</p>\n</li>\n<li><p>安全专题<br>安全专题就离多数比较远了，这里我们讲解一些常见的和业务相关的安全话题，具体后续补充。</p>\n</li>\n<li><p>高可用专题<br>后续补充</p>\n</li>\n<li>GC专题<br>后续补充</li>\n</ol>\n<h2 id=\"专题计划技术点列表\"><a href=\"#专题计划技术点列表\" class=\"headerlink\" title=\"专题计划技术点列表\"></a>专题计划技术点列表</h2><ol>\n<li>动态化专题<ul>\n<li>如何让JavaScript与App交互</li>\n<li>如何实现“即点即用”之小程序、快应用</li>\n<li>H5容器之多进程架构</li>\n<li>动态化编程之Lua</li>\n<li>…等</li>\n</ul>\n</li>\n<li>图片专题<ul>\n<li>图片压缩之WebP与腾讯SharpP的实现机制</li>\n<li>图片内存优化之Glide和Fresco原理篇</li>\n<li>png jpg等常用图片格式的内存、解压速度分析</li>\n<li>…等</li>\n</ul>\n</li>\n<li>省流专题<ul>\n<li>Android流量监控</li>\n<li>文件压缩 zip 7z gzip等</li>\n<li>增量更新之diff算法，案例：Tinker自研diff/patch算法</li>\n<li>图片缓存技术</li>\n<li>WebView缓存优化</li>\n<li>数据传输协议对比之ProfoBuf、FastJson、Jackson</li>\n<li>…等</li>\n</ul>\n</li>\n<li>网络专题<ul>\n<li>可靠长连接的意义</li>\n<li>HTTPDNS DNS劫持</li>\n<li>网络嗅探</li>\n<li>Http2/Https/QUIC协议对比</li>\n<li>CDN 削峰填谷</li>\n<li>如何做全局网络限流，保证业务流量高优先级</li>\n<li>…等</li>\n</ul>\n</li>\n<li>监控与日志专题<ul>\n<li><code>mmap</code>日志落地方式，开源项目<code>Logan</code>，<code>xlog</code>等分析</li>\n<li>通过长连接动态拉取日志</li>\n<li>如果长连接断开、通过短连接兜底拉取日志</li>\n<li>日志上报，本地分片存储及后台上报策略</li>\n<li>…等</li>\n</ul>\n</li>\n<li>安全专题<ul>\n<li>移动端的加密算法之对称与非对称，防篡改</li>\n<li>常规编码方式一览 md5 base64</li>\n<li>…等</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"《亿级Android架构》小专栏介绍\"><a href=\"#《亿级Android架构》小专栏介绍\" class=\"headerlink\" title=\"《亿级Android架构》小专栏介绍\"></a>《亿级Android架构》小专栏介绍</h3><p>业务的快速增长离不开稳定可靠的架构。<a href=\"https://xiaozhuanlan.com/AndroidArch\" target=\"_blank\" rel=\"external\">《亿级Android架构》</a>小专栏会基于作者实际工作经验，结合国内大厂如阿里、腾讯、美团等基础架构现状，尝试谈谈如何设计一套好的架构来支持业务从0到1，甚至到亿，希望与大家多多探讨。</p>\n<p>本专栏主要内容：</p>\n<ol>\n<li>当前大厂有哪些Android架构；</li>\n<li>这些架构能解决什么问题；</li>\n<li>这些架构的原理是什么；</li>\n<li>学习这些架构对我们自身的意义。</li>\n</ol>\n<p><strong><a href=\"https://xiaozhuanlan.com/AndroidArch\" target=\"_blank\" rel=\"external\">《亿级Android架构》</a>小专栏文章列表：</strong></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/1934527806\" target=\"_blank\" rel=\"external\">《亿级 Android 架构》专栏随谈》</a></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/6982074351\" target=\"_blank\" rel=\"external\">《Android 架构之网络连接与加速》</a></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/3758142906\" target=\"_blank\" rel=\"external\">《Android 架构之长连接技术》</a></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/2130768549\" target=\"_blank\" rel=\"external\">《Android 架构之高可用移动网络连接》</a></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/8159302674\" target=\"_blank\" rel=\"external\">《Android 架构之网络安全演进》</a></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/2694081375\" target=\"_blank\" rel=\"external\">《Android 架构之高性能移动端日志系统》</a></p>\n<hr>","sticky":0},{"title":"如何在一天之内搭建以你自己名字为域名又具备 cool 属性的个人博客","date":"2015-12-07T12:03:33.000Z","commentIssueId":20,"_content":">对程序员而言，最好的简历就是个人博客和GitHub。\n\n<!-- more -->\n\n\n![个人博客](/img/myblog.png)\n\n\n## 个人博客\n每个优秀的程序员都会有个人独占的一方网络空间，那里是他个人的舞台，听说过他的人会逐渐汇聚进来，认识他，熟悉他，鼓励他，赞扬他。而对他个人而言，他有了一个可以畅所欲言的小房间，他可以专研学术，聊聊情怀。同时和喜爱他的读者成为好友，共同成长。\n\n这难道不是一件很cool的事情吗？\n\n## 先看成果\n教方法前先来看看最终的效果吧。[http://wingjay.com](http://wingjay.com)是本人搭建的个人博客，主要有以下几点：\n\n    1. 个人域名: wingjay.com\n    2. 无需购置服务器，本站同时挂载在Github Pages 和 GitCafe Pages上，免服务器费的同时还能做负载均衡，想想还有点小激动\n    3. 在GitHub上同时管理你的博客和相应代码，再也不用担心博客遗失\n    4. SSL支持，即\"http://\" -> \"https://\"，更安全也更高大上\n\n## 再看兵器\n - 博客框架：[Hexo 3](https://hexo.io)，这是一款能快速、简洁且高效的博客框架，支持[Markdown编辑](https://help.github.com/articles/markdown-basics/)，自动渲染出漂亮的静态页面。\n - 前端主题：[Next](https://github.com/iissnan/hexo-theme-next)，效果参考[http://wingjay.com](http://wingjay.com)\n - 域名购买：[万网](http://wanwang.aliyun.com/)，你可以选购自己名字的域名，一年几十元左右，两杯咖啡的钱。\n - SSL：[CloudFlare](https://www.cloudflare.com)\n\n\n## 抄起家伙\n本文写作方式是`安装流程主线` + `优质参考文章`。由于网络上关于Hexo搭建博客的教程玲琅满目，若读者完全自己动手则要一篇篇找，浪费时间走弯路；相反，若作者悉数摘抄进来，反倒未必符合各人情况，且不利阅读。\n\n所以，`主线`讲解思路，`参考`深入阅读。\n\n下文以搭建 http://wingjay.com 个人博客为例。\n\n### GitHub Pages\n在不购买服务器的前提下，我们的网站需要挂在GitHub Pages上。GitHub Pages是面向用户、组织和项目开放的公共静态页面搭建托管服务，可用于搭建个人博客。\n\n0. 你需要拥有一个[GitHub账号](https://github.com)，去完成新手任务吧。\n1. 进入[GitHub Pages](https://pages.github.com/)，一步步做，完成后就能在浏览器打开[http://wingjay.github.io](http://wingjay.github.io)了。\n\n至此，我们已经利用GitHub Pages搭建好了个人博客雏形了。下面要做的，就是个性化了。\n\n### 安装Hexo博客框架\n经过上面步骤，我们已经拥有了一个初步域名：http://username.github.io 加一个免费网络空间了。好比房间有了，但还没有任何家具。所以下面我们需要把空白的博客丰富起来。\n\n放心，不需要你手写一大堆html、css文件，也不用找jQuery来实现酷炫的页面效果。[Hexo](https://hexo.io)是一款博客框架，它会帮我们搭建。\n\n#### 安装Hexo\n参考[中文文档](https://hexo.io/docs/)或[英文文档](https://hexo.io/zh-cn/docs/index.html)。完成该步后，你的电脑便拥有了Git、Node.js和Hexo。\n\n#### GitHub管理\n为了让自己未来的博客和代码处在git管理之下，我们要把刚刚在Github上博客项目拉到本地。如本人创建的[https://github.com/wingjay/wingjay.github.io](https://github.com/wingjay/wingjay.github.io)，在本地创建文件夹，名字任意，此处设为`myblog`，进入该文件夹，把项目代码clone下来。\n```\ngit clone https://github.com/wingjay/wingjay.github.io\n```\n好了，此时会自动在`myblog`目录下创建子文件夹`wingjay.github.io`,那里就是我们博客的代码，以后的操作都在git的管理之下了，此时默认的branch为`master`。\n\n#### 初始化Hexo\n请参考[文档](https://hexo.io/docs/setup.html)。init命令中的`<folder>`就是文件夹`wingjay.github.io`。初始化后，`wingjay.github.io`里面就已经有完整的Hexo框架了。\n\n#### 熟悉Hexo\n为了让读者快速了解`Hexo`，我作几个简单介绍吧。当然，更多的还是需要仔细阅读[文档](https://hexo.io/docs/writing.html)才能了解更详细。\n\n![hexo目录结构](/img/hexo-directory.png)\n\n - `_config.yml`是整体的配置文件，很多基础配置、插件配置等都需要在里面进行。要注意的是，该文件格式要求极为严格，缺少一个空格都会导致运行错误。小提示：不要用Tab缩进，用两个空格符。\n - `layout`，包括`draft(草稿)、page(页面)、post(文章)`。这个就是三种文件的基本格式，其中`post`是你发表的文章，会显示在你的网站里，一篇post会包括`title标题、date日期、tags标签`等信息；`draft`是草稿，只有你在本地能看到，必须要`publish`后才能成为`post`，draft和post差别是date，因为draft没有发表，所以不需要指定日期。`page`是一个页面，对应一个新的html页面，比如[博客内容展示页](http://wingjay.com/2015/12/06/%E8%AF%B4%E4%B8%80%E8%AF%B4%E5%8D%9A%E5%AE%A2/)是一个页面，[留言本](http://wingjay.com/guestbook/)也是一个页面。\n - `public文件夹`，这个文件夹是最终会发布到网站上的真实内容。怎么理解呢？我们可以把`public`文件夹当作是真正的被用户看到的，而其他的`source、themes`等都是为`public`服务的。Hexo里有一个很重要的指令`hexo generate`，这个指令就是利用所有代码里的配置信息、source里写的文章、themes里的样式，共同生成最终的`静态html文件`，存入`public`文件夹内。在我们执行了发布指令`hexo deploy`后，就会把`public`的内容部署到`GitHub Pages`上。当用户在访问我们的博客时，他们会看到public里生成的html文件。这个概念非常重要，即`代码和真实静态页面是独立的`。\n - `generate和deploy`，`generate`会把我们的配置、文章和主题结合起来生成一堆酷炫的html静态文件放在public里面。但此时用户还看不到`本地public文件`里的页面，我们必须用后一个指令`deploy`才能把静态文件部署到`GitHub Pages`上。不过，在部署前，需要配置让它自动部署到我们前面创建的[Github项目](https://github.com/wingjay/wingjay.github.io)中。\n - `deploy`相关配置。为了能够让项目自动把public文件夹的内容部署到[GitHub项目](https://github.com/wingjay/wingjay.github.io)中，我们可以按[部署文档](https://hexo.io/docs/deployment.html)进行配置，其中选择的`branch`为`master`。此后，每次运行deploy后，项目就会自动把public文件夹内容全部覆盖到[当前的GitHub项目master分支上](https://github.com/wingjay/wingjay.github.io/tree/master)。\n - `代码`和`静态文件`分开管理。根据上面知道，每次部署后，public文件内容会`覆盖`掉项目整个master分支。这样可以实现网站`静态文件`的版本控制，但是，仔细对比这个master分支，我们会发现里面**只剩下静态文件**了，我们的代码比如source、themes统统没有了，这就导致无法对代码进行版本管理了。这意味着我换一台电脑，我就再也找不到`代码`了，只剩下一堆之前编译出来的静态文件。所以，为了对代码也进行版本控制，我们创建一个[新的分支：code](https://github.com/wingjay/wingjay.github.io/tree/code)，然后在这个分支里进行代码控制，master里则保存部署的新的静态文件。大家可以自行比对这两个branch的内容差异。\n\n#### 配置Hexo\n做一些基础配置即可，请参考[配置文档](https://hexo.io/docs/configuration.html)\n\n#### 小结\n到这里，我们已经完成了hexo的配置，我们可以在GitHub用不同branch分别管理代码和静态文件。执行deploy操作后，刷新你的网页 http://username.github.io 你就能看到默认的内容了。\n\n但此时还是默认主题，不够美观，所以下一步要配置Next主题。\n\n### 配置主题Next\nHexo主题非常多，可以参考[丰富多彩的Hexo主题](https://hexo.io/themes/)，本文选Next为主题，样式参考[我的博客](http://wingjay.com)。\n\n进入配置阶段，最好的文档还是[官方文档](http://theme-next.iissnan.com/)，简单得不能再细致了。下面只提几点注意：\n\n- 第三方评论系统。评论系统很重要，你可以与读者进行更多交流，配置也简单，建议采用[DISQUS](https://disqus.com/)，更国际化一点，[配置见此](http://theme-next.iissnan.com/third-party-services.html#DISUQS)。另外，前期建议开启`不登陆评论`，即在Disqus的`Comment Rule`里允许`Guest comment`。\n- 创建留言板。熟悉`page`的创建与使用，[参考这里](http://www.arao.me/2015/hexo-next-theme-optimize-base/#为你的hexo网站NexT主题增加留言页)\n- 给自己博客做`SEO`。有好的SEO便于搜索引擎索引你的网站，随着以后读者增多，他们可以更好搜索到你的网站。[具体方法见此](http://www.arao.me/2015/hexo-next-theme-optimize-seo/)\n\n<!-- ![Disqus评论系统](/img/Disqus评论系统.png) -->\n\n### 替换自己的域名\n好了，经过上面的步骤，博客已经拥有了一个全新的主题啦。\n\n下面，我们要对域名 http://wingjay.github.io 下手啦。\n\n#### 购买域名\n速速前往[万网](http://wanwang.aliyun.com/)，支付宝刷的一声，你就拥有了一个闪闪发光的个人域名啦\n\n#### 域名解析_1\n以购买的域名`wingjay.com`为例，我们希望在访问这个域名时能自动进入Github Pages，所以我们要在万网建立一个CNAME纪录来帮我们做一个域名跳转：`wingjay.com` -> `wingjay.github.io`，`www.wingjay.com` -> `wingjay.github.io`。添加方法[参考这里](http://www.sudu.cn/service/detail/1/0/0/3/10036.html)，添加后可以看到两条记录：![域名解析](/img/host.png)。然后万网会在世界各地的DNS服务器上添加这两条记录，当用户访问`wingjay.com`时会自动去访问`wingjay.github.io`。\n\n#### 域名解析_2\n但是，此时并不能成功访问，因为github pages是有限制的，它不允许任意域名都跳转过来，而是只限制一个域名，而且这个域名必须声明在CNAME文件中。\n\n所以，我们需要添加一个CNAME文件到项目的master中才行，[参考这里](https://help.github.com/articles/adding-a-cname-file-to-your-repository/)。读者可以参考本人的[CNAME文件内容](https://github.com/wingjay/wingjay.github.io/blob/master/CNAME)。\n\n不过，对于`Hexo 3`，**这里有一个坑要注意**：大家应该还记得上文说的，master分支里的内容都是自动生成的，而且会完全覆盖之前的内容。如果我们直接创建一个新文件CNAME，填好域名。但会发现在下一次部署后这个文件就消失了。不用惊讶，因为hexo并不会自动生成CNAME文件，所以在部署时被覆盖删除了。\n\n所以，我们就需要这个CNAME工具[hexo-generator-cname](https://github.com/leecrossley/hexo-generator-cname)，这时会自动在public里生成一个CNAME文件，把你的域名加进去再部署一下吧！\n\n### HTTP -> HTTPS\nHTTPS是安全版的HTTP协议，它在http协议与TCP之间加入SSL层，采用端口443，不仅会对传输数据加密，还会进行身份验证。当然个人博客并没有强制性要求采用该协议，这也只是本人的好奇而为。\n\n[Update] 目前，我的博客采用了[Kloudsec](https://kloudsec.com/github-pages)来做的https，大家可以点进去看。通过与服务商联系后，我了解到目前这项服务是免费的，不仅做https还能做负载均衡。\n\n\n### 疑难杂症\n1. 本地deploy成功，但是github上的master并没有收到该commit。\n目前不知道是什么原因，本人感觉是two-factor的开启，使得本地不具备权限直接push。比较无语。\n解决方法：\n在code分支上，创建一个.deploy的文件夹，在该文件夹内把master clone下来；\n当有新的改动后，generate后把public文件夹的内容拷入进上面clone的文件夹内；\n进入上面clone下来的文件夹，手动push到master上来更新。\n该思路就是自己维护一个master文件夹，手动把生成的public内容复制进去，再push上去。\n\n快捷命令：\nalias hexodeploy='cd ~/Documents/blog/wingjay.github.io;hexo generate;cp -R public/ .deploy/wingjay.github.io;cd .deploy/wingjay.github.io;git add .;git commit -m \"update\";    git push origin master; cd -; git add .; git commit -m \"source code\"; git push origin code'\n\n\n## 总结\n经过上面的步骤，我们已经能够通过访问自己的域名进入自己酷炫的博客了。本文的任务也就告一段落。\n\n除了上面的功能，本人还完成了`支持双域名同时登陆`，其中，支持双域名的解决思路是考虑到[Github Pages的CNAME纪录只允许添加一个域名](https://help.github.com/articles/adding-a-cname-file-to-your-repository/)，所以本人又在[Gitcafe](https://gitcafe.com)上部署了一套。不过考虑到这点大家不一定能用的上，就没有做介绍，有需要的话可以看下文的联系方式联系我。\n\n## 一天变cool系列文章\n[如何在一天之内完成一款具备cool属性的Android产品<简诗>](http://www.jianshu.com/p/cf496fc408b2)\n\n[如何在一天之内搭建以你自己名字为域名且具备cool属性的个人博客](http://www.jianshu.com/p/99665608d295)\n\n谢谢！\n\nwingjay\n\n\n\n\n\n欢迎各位关注\n[我的Github](https://github.com/wingjay): <https://github.com/wingjay> \n和 \n[我的个人博客](http://wingjay.com): <http://wingjay.com>\n和\n[我的简书](http://www.jianshu.com/users/da333fd63fe5/latest_articles): <http://www.jianshu.com/users/da333fd63fe5/latest_articles>\n和\n[微博 iam_wingjay](http://weibo.com/u/1625892654): <http://weibo.com/u/1625892654>\n如果有问题，可以给我留言或发邮件<mailto:yinjiesh@126.com>\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/如何在一天之内搭建以你自己名字为域名的很cool的个人博客.md","raw":"title: 如何在一天之内搭建以你自己名字为域名又具备cool属性的个人博客\ncategories:\n  - cool stuff\n  - 个人博客\n  - 一天变cool  \ntags:\n  - 一天变cool\n  - 个人博客\ndate: 2015-12-07 20:03:33\ncommentIssueId: 20\n---\n>对程序员而言，最好的简历就是个人博客和GitHub。\n\n<!-- more -->\n\n\n![个人博客](/img/myblog.png)\n\n\n## 个人博客\n每个优秀的程序员都会有个人独占的一方网络空间，那里是他个人的舞台，听说过他的人会逐渐汇聚进来，认识他，熟悉他，鼓励他，赞扬他。而对他个人而言，他有了一个可以畅所欲言的小房间，他可以专研学术，聊聊情怀。同时和喜爱他的读者成为好友，共同成长。\n\n这难道不是一件很cool的事情吗？\n\n## 先看成果\n教方法前先来看看最终的效果吧。[http://wingjay.com](http://wingjay.com)是本人搭建的个人博客，主要有以下几点：\n\n    1. 个人域名: wingjay.com\n    2. 无需购置服务器，本站同时挂载在Github Pages 和 GitCafe Pages上，免服务器费的同时还能做负载均衡，想想还有点小激动\n    3. 在GitHub上同时管理你的博客和相应代码，再也不用担心博客遗失\n    4. SSL支持，即\"http://\" -> \"https://\"，更安全也更高大上\n\n## 再看兵器\n - 博客框架：[Hexo 3](https://hexo.io)，这是一款能快速、简洁且高效的博客框架，支持[Markdown编辑](https://help.github.com/articles/markdown-basics/)，自动渲染出漂亮的静态页面。\n - 前端主题：[Next](https://github.com/iissnan/hexo-theme-next)，效果参考[http://wingjay.com](http://wingjay.com)\n - 域名购买：[万网](http://wanwang.aliyun.com/)，你可以选购自己名字的域名，一年几十元左右，两杯咖啡的钱。\n - SSL：[CloudFlare](https://www.cloudflare.com)\n\n\n## 抄起家伙\n本文写作方式是`安装流程主线` + `优质参考文章`。由于网络上关于Hexo搭建博客的教程玲琅满目，若读者完全自己动手则要一篇篇找，浪费时间走弯路；相反，若作者悉数摘抄进来，反倒未必符合各人情况，且不利阅读。\n\n所以，`主线`讲解思路，`参考`深入阅读。\n\n下文以搭建 http://wingjay.com 个人博客为例。\n\n### GitHub Pages\n在不购买服务器的前提下，我们的网站需要挂在GitHub Pages上。GitHub Pages是面向用户、组织和项目开放的公共静态页面搭建托管服务，可用于搭建个人博客。\n\n0. 你需要拥有一个[GitHub账号](https://github.com)，去完成新手任务吧。\n1. 进入[GitHub Pages](https://pages.github.com/)，一步步做，完成后就能在浏览器打开[http://wingjay.github.io](http://wingjay.github.io)了。\n\n至此，我们已经利用GitHub Pages搭建好了个人博客雏形了。下面要做的，就是个性化了。\n\n### 安装Hexo博客框架\n经过上面步骤，我们已经拥有了一个初步域名：http://username.github.io 加一个免费网络空间了。好比房间有了，但还没有任何家具。所以下面我们需要把空白的博客丰富起来。\n\n放心，不需要你手写一大堆html、css文件，也不用找jQuery来实现酷炫的页面效果。[Hexo](https://hexo.io)是一款博客框架，它会帮我们搭建。\n\n#### 安装Hexo\n参考[中文文档](https://hexo.io/docs/)或[英文文档](https://hexo.io/zh-cn/docs/index.html)。完成该步后，你的电脑便拥有了Git、Node.js和Hexo。\n\n#### GitHub管理\n为了让自己未来的博客和代码处在git管理之下，我们要把刚刚在Github上博客项目拉到本地。如本人创建的[https://github.com/wingjay/wingjay.github.io](https://github.com/wingjay/wingjay.github.io)，在本地创建文件夹，名字任意，此处设为`myblog`，进入该文件夹，把项目代码clone下来。\n```\ngit clone https://github.com/wingjay/wingjay.github.io\n```\n好了，此时会自动在`myblog`目录下创建子文件夹`wingjay.github.io`,那里就是我们博客的代码，以后的操作都在git的管理之下了，此时默认的branch为`master`。\n\n#### 初始化Hexo\n请参考[文档](https://hexo.io/docs/setup.html)。init命令中的`<folder>`就是文件夹`wingjay.github.io`。初始化后，`wingjay.github.io`里面就已经有完整的Hexo框架了。\n\n#### 熟悉Hexo\n为了让读者快速了解`Hexo`，我作几个简单介绍吧。当然，更多的还是需要仔细阅读[文档](https://hexo.io/docs/writing.html)才能了解更详细。\n\n![hexo目录结构](/img/hexo-directory.png)\n\n - `_config.yml`是整体的配置文件，很多基础配置、插件配置等都需要在里面进行。要注意的是，该文件格式要求极为严格，缺少一个空格都会导致运行错误。小提示：不要用Tab缩进，用两个空格符。\n - `layout`，包括`draft(草稿)、page(页面)、post(文章)`。这个就是三种文件的基本格式，其中`post`是你发表的文章，会显示在你的网站里，一篇post会包括`title标题、date日期、tags标签`等信息；`draft`是草稿，只有你在本地能看到，必须要`publish`后才能成为`post`，draft和post差别是date，因为draft没有发表，所以不需要指定日期。`page`是一个页面，对应一个新的html页面，比如[博客内容展示页](http://wingjay.com/2015/12/06/%E8%AF%B4%E4%B8%80%E8%AF%B4%E5%8D%9A%E5%AE%A2/)是一个页面，[留言本](http://wingjay.com/guestbook/)也是一个页面。\n - `public文件夹`，这个文件夹是最终会发布到网站上的真实内容。怎么理解呢？我们可以把`public`文件夹当作是真正的被用户看到的，而其他的`source、themes`等都是为`public`服务的。Hexo里有一个很重要的指令`hexo generate`，这个指令就是利用所有代码里的配置信息、source里写的文章、themes里的样式，共同生成最终的`静态html文件`，存入`public`文件夹内。在我们执行了发布指令`hexo deploy`后，就会把`public`的内容部署到`GitHub Pages`上。当用户在访问我们的博客时，他们会看到public里生成的html文件。这个概念非常重要，即`代码和真实静态页面是独立的`。\n - `generate和deploy`，`generate`会把我们的配置、文章和主题结合起来生成一堆酷炫的html静态文件放在public里面。但此时用户还看不到`本地public文件`里的页面，我们必须用后一个指令`deploy`才能把静态文件部署到`GitHub Pages`上。不过，在部署前，需要配置让它自动部署到我们前面创建的[Github项目](https://github.com/wingjay/wingjay.github.io)中。\n - `deploy`相关配置。为了能够让项目自动把public文件夹的内容部署到[GitHub项目](https://github.com/wingjay/wingjay.github.io)中，我们可以按[部署文档](https://hexo.io/docs/deployment.html)进行配置，其中选择的`branch`为`master`。此后，每次运行deploy后，项目就会自动把public文件夹内容全部覆盖到[当前的GitHub项目master分支上](https://github.com/wingjay/wingjay.github.io/tree/master)。\n - `代码`和`静态文件`分开管理。根据上面知道，每次部署后，public文件内容会`覆盖`掉项目整个master分支。这样可以实现网站`静态文件`的版本控制，但是，仔细对比这个master分支，我们会发现里面**只剩下静态文件**了，我们的代码比如source、themes统统没有了，这就导致无法对代码进行版本管理了。这意味着我换一台电脑，我就再也找不到`代码`了，只剩下一堆之前编译出来的静态文件。所以，为了对代码也进行版本控制，我们创建一个[新的分支：code](https://github.com/wingjay/wingjay.github.io/tree/code)，然后在这个分支里进行代码控制，master里则保存部署的新的静态文件。大家可以自行比对这两个branch的内容差异。\n\n#### 配置Hexo\n做一些基础配置即可，请参考[配置文档](https://hexo.io/docs/configuration.html)\n\n#### 小结\n到这里，我们已经完成了hexo的配置，我们可以在GitHub用不同branch分别管理代码和静态文件。执行deploy操作后，刷新你的网页 http://username.github.io 你就能看到默认的内容了。\n\n但此时还是默认主题，不够美观，所以下一步要配置Next主题。\n\n### 配置主题Next\nHexo主题非常多，可以参考[丰富多彩的Hexo主题](https://hexo.io/themes/)，本文选Next为主题，样式参考[我的博客](http://wingjay.com)。\n\n进入配置阶段，最好的文档还是[官方文档](http://theme-next.iissnan.com/)，简单得不能再细致了。下面只提几点注意：\n\n- 第三方评论系统。评论系统很重要，你可以与读者进行更多交流，配置也简单，建议采用[DISQUS](https://disqus.com/)，更国际化一点，[配置见此](http://theme-next.iissnan.com/third-party-services.html#DISUQS)。另外，前期建议开启`不登陆评论`，即在Disqus的`Comment Rule`里允许`Guest comment`。\n- 创建留言板。熟悉`page`的创建与使用，[参考这里](http://www.arao.me/2015/hexo-next-theme-optimize-base/#为你的hexo网站NexT主题增加留言页)\n- 给自己博客做`SEO`。有好的SEO便于搜索引擎索引你的网站，随着以后读者增多，他们可以更好搜索到你的网站。[具体方法见此](http://www.arao.me/2015/hexo-next-theme-optimize-seo/)\n\n<!-- ![Disqus评论系统](/img/Disqus评论系统.png) -->\n\n### 替换自己的域名\n好了，经过上面的步骤，博客已经拥有了一个全新的主题啦。\n\n下面，我们要对域名 http://wingjay.github.io 下手啦。\n\n#### 购买域名\n速速前往[万网](http://wanwang.aliyun.com/)，支付宝刷的一声，你就拥有了一个闪闪发光的个人域名啦\n\n#### 域名解析_1\n以购买的域名`wingjay.com`为例，我们希望在访问这个域名时能自动进入Github Pages，所以我们要在万网建立一个CNAME纪录来帮我们做一个域名跳转：`wingjay.com` -> `wingjay.github.io`，`www.wingjay.com` -> `wingjay.github.io`。添加方法[参考这里](http://www.sudu.cn/service/detail/1/0/0/3/10036.html)，添加后可以看到两条记录：![域名解析](/img/host.png)。然后万网会在世界各地的DNS服务器上添加这两条记录，当用户访问`wingjay.com`时会自动去访问`wingjay.github.io`。\n\n#### 域名解析_2\n但是，此时并不能成功访问，因为github pages是有限制的，它不允许任意域名都跳转过来，而是只限制一个域名，而且这个域名必须声明在CNAME文件中。\n\n所以，我们需要添加一个CNAME文件到项目的master中才行，[参考这里](https://help.github.com/articles/adding-a-cname-file-to-your-repository/)。读者可以参考本人的[CNAME文件内容](https://github.com/wingjay/wingjay.github.io/blob/master/CNAME)。\n\n不过，对于`Hexo 3`，**这里有一个坑要注意**：大家应该还记得上文说的，master分支里的内容都是自动生成的，而且会完全覆盖之前的内容。如果我们直接创建一个新文件CNAME，填好域名。但会发现在下一次部署后这个文件就消失了。不用惊讶，因为hexo并不会自动生成CNAME文件，所以在部署时被覆盖删除了。\n\n所以，我们就需要这个CNAME工具[hexo-generator-cname](https://github.com/leecrossley/hexo-generator-cname)，这时会自动在public里生成一个CNAME文件，把你的域名加进去再部署一下吧！\n\n### HTTP -> HTTPS\nHTTPS是安全版的HTTP协议，它在http协议与TCP之间加入SSL层，采用端口443，不仅会对传输数据加密，还会进行身份验证。当然个人博客并没有强制性要求采用该协议，这也只是本人的好奇而为。\n\n[Update] 目前，我的博客采用了[Kloudsec](https://kloudsec.com/github-pages)来做的https，大家可以点进去看。通过与服务商联系后，我了解到目前这项服务是免费的，不仅做https还能做负载均衡。\n\n\n### 疑难杂症\n1. 本地deploy成功，但是github上的master并没有收到该commit。\n目前不知道是什么原因，本人感觉是two-factor的开启，使得本地不具备权限直接push。比较无语。\n解决方法：\n在code分支上，创建一个.deploy的文件夹，在该文件夹内把master clone下来；\n当有新的改动后，generate后把public文件夹的内容拷入进上面clone的文件夹内；\n进入上面clone下来的文件夹，手动push到master上来更新。\n该思路就是自己维护一个master文件夹，手动把生成的public内容复制进去，再push上去。\n\n快捷命令：\nalias hexodeploy='cd ~/Documents/blog/wingjay.github.io;hexo generate;cp -R public/ .deploy/wingjay.github.io;cd .deploy/wingjay.github.io;git add .;git commit -m \"update\";    git push origin master; cd -; git add .; git commit -m \"source code\"; git push origin code'\n\n\n## 总结\n经过上面的步骤，我们已经能够通过访问自己的域名进入自己酷炫的博客了。本文的任务也就告一段落。\n\n除了上面的功能，本人还完成了`支持双域名同时登陆`，其中，支持双域名的解决思路是考虑到[Github Pages的CNAME纪录只允许添加一个域名](https://help.github.com/articles/adding-a-cname-file-to-your-repository/)，所以本人又在[Gitcafe](https://gitcafe.com)上部署了一套。不过考虑到这点大家不一定能用的上，就没有做介绍，有需要的话可以看下文的联系方式联系我。\n\n## 一天变cool系列文章\n[如何在一天之内完成一款具备cool属性的Android产品<简诗>](http://www.jianshu.com/p/cf496fc408b2)\n\n[如何在一天之内搭建以你自己名字为域名且具备cool属性的个人博客](http://www.jianshu.com/p/99665608d295)\n\n谢谢！\n\nwingjay\n\n\n\n\n\n欢迎各位关注\n[我的Github](https://github.com/wingjay): <https://github.com/wingjay> \n和 \n[我的个人博客](http://wingjay.com): <http://wingjay.com>\n和\n[我的简书](http://www.jianshu.com/users/da333fd63fe5/latest_articles): <http://www.jianshu.com/users/da333fd63fe5/latest_articles>\n和\n[微博 iam_wingjay](http://weibo.com/u/1625892654): <http://weibo.com/u/1625892654>\n如果有问题，可以给我留言或发邮件<mailto:yinjiesh@126.com>\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"如何在一天之内搭建以你自己名字为域名的很cool的个人博客","published":1,"updated":"2018-11-26T06:56:27.484Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplsi4002r3dn8c6e72keo","content":"<blockquote>\n<p>对程序员而言，最好的简历就是个人博客和 GitHub。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p><img src=\"/img/myblog.png\" alt=\"个人博客\"></p>\n<h2 id=\"个人博客\"><a href=\"# 个人博客\" class=\"headerlink\" title=\"个人博客\"></a>个人博客 </h2><p> 每个优秀的程序员都会有个人独占的一方网络空间，那里是他个人的舞台，听说过他的人会逐渐汇聚进来，认识他，熟悉他，鼓励他，赞扬他。而对他个人而言，他有了一个可以畅所欲言的小房间，他可以专研学术，聊聊情怀。同时和喜爱他的读者成为好友，共同成长。</p>\n<p>这难道不是一件很 cool 的事情吗？</p>\n<h2 id=\"先看成果\"><a href=\"# 先看成果\" class=\"headerlink\" title=\"先看成果\"></a>先看成果 </h2><p> 教方法前先来看看最终的效果吧。<a href=\"http://wingjay.com\">http://wingjay.com</a>是本人搭建的个人博客，主要有以下几点：</p>\n<pre><code>1. 个人域名: wingjay.com\n2. 无需购置服务器，本站同时挂载在 Github Pages 和 GitCafe Pages 上，免服务器费的同时还能做负载均衡，想想还有点小激动\n3. 在 GitHub 上同时管理你的博客和相应代码，再也不用担心博客遗失\n4. SSL 支持，即 &quot;http://&quot; -&gt; &quot;https://&quot;，更安全也更高大上\n</code></pre><h2 id=\"再看兵器\"><a href=\"# 再看兵器\" class=\"headerlink\" title=\"再看兵器\"></a>再看兵器</h2><ul>\n<li>博客框架：<a href=\"https://hexo.io\" target=\"_blank\" rel=\"external\">Hexo 3</a>，这是一款能快速、简洁且高效的博客框架，支持<a href=\"https://help.github.com/articles/markdown-basics/\" target=\"_blank\" rel=\"external\">Markdown 编辑</a>，自动渲染出漂亮的静态页面。</li>\n<li>前端主题：<a href=\"https://github.com/iissnan/hexo-theme-next\" target=\"_blank\" rel=\"external\">Next</a>，效果参考<a href=\"http://wingjay.com\">http://wingjay.com</a></li>\n<li>域名购买：<a href=\"http://wanwang.aliyun.com/\" target=\"_blank\" rel=\"external\">万网</a>，你可以选购自己名字的域名，一年几十元左右，两杯咖啡的钱。</li>\n<li>SSL：<a href=\"https://www.cloudflare.com\" target=\"_blank\" rel=\"external\">CloudFlare</a></li>\n</ul>\n<h2 id=\"抄起家伙\"><a href=\"# 抄起家伙\" class=\"headerlink\" title=\"抄起家伙\"></a>抄起家伙 </h2><p> 本文写作方式是 <code> 安装流程主线 </code> + <code> 优质参考文章</code>。由于网络上关于 Hexo 搭建博客的教程玲琅满目，若读者完全自己动手则要一篇篇找，浪费时间走弯路；相反，若作者悉数摘抄进来，反倒未必符合各人情况，且不利阅读。</p>\n<p>所以，<code>主线 </code> 讲解思路，<code>参考 </code> 深入阅读。</p>\n<p>下文以搭建 <a href=\"http://wingjay.com\">http://wingjay.com</a> 个人博客为例。</p>\n<h3 id=\"GitHub-Pages\"><a href=\"#GitHub-Pages\" class=\"headerlink\" title=\"GitHub Pages\"></a>GitHub Pages</h3><p>在不购买服务器的前提下，我们的网站需要挂在 GitHub Pages 上。GitHub Pages 是面向用户、组织和项目开放的公共静态页面搭建托管服务，可用于搭建个人博客。</p>\n<ol>\n<li>你需要拥有一个<a href=\"https://github.com\" target=\"_blank\" rel=\"external\">GitHub 账号</a>，去完成新手任务吧。</li>\n<li>进入 <a href=\"https://pages.github.com/\" target=\"_blank\" rel=\"external\">GitHub Pages</a>，一步步做，完成后就能在浏览器打开<a href=\"http://wingjay.github.io\" target=\"_blank\" rel=\"external\">http://wingjay.github.io</a> 了。</li>\n</ol>\n<p>至此，我们已经利用 GitHub Pages 搭建好了个人博客雏形了。下面要做的，就是个性化了。</p>\n<h3 id=\"安装 Hexo 博客框架\"><a href=\"# 安装 Hexo 博客框架\" class=\"headerlink\" title=\"安装 Hexo 博客框架\"></a>安装 Hexo 博客框架 </h3><p> 经过上面步骤，我们已经拥有了一个初步域名：<a href=\"http://username.github.io\" target=\"_blank\" rel=\"external\">http://username.github.io</a> 加一个免费网络空间了。好比房间有了，但还没有任何家具。所以下面我们需要把空白的博客丰富起来。</p>\n<p>放心，不需要你手写一大堆 html、css 文件，也不用找 jQuery 来实现酷炫的页面效果。<a href=\"https://hexo.io\" target=\"_blank\" rel=\"external\">Hexo</a>是一款博客框架，它会帮我们搭建。</p>\n<h4 id=\"安装 Hexo\"><a href=\"# 安装 Hexo\" class=\"headerlink\" title=\"安装 Hexo\"></a>安装 Hexo</h4><p>参考 <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\"> 中文文档 </a> 或<a href=\"https://hexo.io/zh-cn/docs/index.html\" target=\"_blank\" rel=\"external\">英文文档</a>。完成该步后，你的电脑便拥有了 Git、Node.js 和 Hexo。</p>\n<h4 id=\"GitHub 管理\"><a href=\"#GitHub 管理\" class=\"headerlink\" title=\"GitHub 管理\"></a>GitHub 管理 </h4><p> 为了让自己未来的博客和代码处在 git 管理之下，我们要把刚刚在 Github 上博客项目拉到本地。如本人创建的<a href=\"https://github.com/wingjay/wingjay.github.io\" target=\"_blank\" rel=\"external\">https://github.com/wingjay/wingjay.github.io</a>，在本地创建文件夹，名字任意，此处设为<code>myblog</code>，进入该文件夹，把项目代码 clone 下来。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone https://github.com/wingjay/wingjay.github.io</div></pre></td></tr></table></figure></p>\n<p>好了，此时会自动在 <code>myblog</code> 目录下创建子文件夹<code>wingjay.github.io</code>, 那里就是我们博客的代码，以后的操作都在 git 的管理之下了，此时默认的 branch 为<code>master</code>。</p>\n<h4 id=\"初始化 Hexo\"><a href=\"# 初始化 Hexo\" class=\"headerlink\" title=\"初始化 Hexo\"></a>初始化 Hexo</h4><p>请参考 <a href=\"https://hexo.io/docs/setup.html\" target=\"_blank\" rel=\"external\"> 文档 </a>。init 命令中的<code>&lt;folder&gt;</code> 就是文件夹 <code>wingjay.github.io</code>。初始化后，<code>wingjay.github.io</code> 里面就已经有完整的 Hexo 框架了。</p>\n<h4 id=\"熟悉 Hexo\"><a href=\"# 熟悉 Hexo\" class=\"headerlink\" title=\"熟悉 Hexo\"></a>熟悉 Hexo</h4><p>为了让读者快速了解 <code>Hexo</code>，我作几个简单介绍吧。当然，更多的还是需要仔细阅读<a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\"> 文档 </a> 才能了解更详细。</p>\n<p><img src=\"/img/hexo-directory.png\" alt=\"hexo 目录结构\"></p>\n<ul>\n<li><code>_config.yml</code>是整体的配置文件，很多基础配置、插件配置等都需要在里面进行。要注意的是，该文件格式要求极为严格，缺少一个空格都会导致运行错误。小提示：不要用 Tab 缩进，用两个空格符。</li>\n<li><code>layout</code>，包括 <code>draft(草稿)、page(页面)、post(文章)</code>。这个就是三种文件的基本格式，其中<code>post</code> 是你发表的文章，会显示在你的网站里，一篇 post 会包括 <code>title 标题、date 日期、tags 标签</code> 等信息；<code>draft</code>是草稿，只有你在本地能看到，必须要 <code>publish</code> 后才能成为 <code>post</code>，draft 和 post 差别是 date，因为 draft 没有发表，所以不需要指定日期。<code>page</code> 是一个页面，对应一个新的 html 页面，比如 <a href=\"http://wingjay.com/2015/12/06/%E8%AF%B4%E4%B8%80%E8%AF%B4%E5%8D%9A%E5%AE%A2/\"> 博客内容展示页 </a> 是一个页面，<a href=\"http://wingjay.com/guestbook/\">留言本 </a> 也是一个页面。</li>\n<li><code>public 文件夹 </code>，这个文件夹是最终会发布到网站上的真实内容。怎么理解呢？我们可以把<code>public</code> 文件夹当作是真正的被用户看到的，而其他的 <code>source、themes</code> 等都是为 <code>public</code> 服务的。Hexo 里有一个很重要的指令 <code>hexo generate</code>，这个指令就是利用所有代码里的配置信息、source 里写的文章、themes 里的样式，共同生成最终的<code> 静态 html 文件 </code>，存入<code>public</code> 文件夹内。在我们执行了发布指令 <code>hexo deploy</code> 后，就会把 <code>public</code> 的内容部署到 <code>GitHub Pages</code> 上。当用户在访问我们的博客时，他们会看到 public 里生成的 html 文件。这个概念非常重要，即 <code> 代码和真实静态页面是独立的</code>。</li>\n<li><code>generate 和 deploy</code>，<code>generate</code>会把我们的配置、文章和主题结合起来生成一堆酷炫的 html 静态文件放在 public 里面。但此时用户还看不到 <code> 本地 public 文件 </code> 里的页面，我们必须用后一个指令 <code>deploy</code> 才能把静态文件部署到 <code>GitHub Pages</code> 上。不过，在部署前，需要配置让它自动部署到我们前面创建的 <a href=\"https://github.com/wingjay/wingjay.github.io\" target=\"_blank\" rel=\"external\">Github 项目</a> 中。</li>\n<li><code>deploy</code>相关配置。为了能够让项目自动把 public 文件夹的内容部署到 <a href=\"https://github.com/wingjay/wingjay.github.io\" target=\"_blank\" rel=\"external\">GitHub 项目</a> 中，我们可以按 <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\"> 部署文档 </a> 进行配置，其中选择的 <code>branch</code> 为<code>master</code>。此后，每次运行 deploy 后，项目就会自动把 public 文件夹内容全部覆盖到 <a href=\"https://github.com/wingjay/wingjay.github.io/tree/master\" target=\"_blank\" rel=\"external\"> 当前的 GitHub 项目 master 分支上</a>。</li>\n<li><code>代码 </code> 和<code>静态文件 </code> 分开管理。根据上面知道，每次部署后，public 文件内容会 <code> 覆盖 </code> 掉项目整个 master 分支。这样可以实现网站 <code> 静态文件 </code> 的版本控制，但是，仔细对比这个 master 分支，我们会发现里面 <strong> 只剩下静态文件 </strong> 了，我们的代码比如 source、themes 统统没有了，这就导致无法对代码进行版本管理了。这意味着我换一台电脑，我就再也找不到 <code> 代码 </code> 了，只剩下一堆之前编译出来的静态文件。所以，为了对代码也进行版本控制，我们创建一个 <a href=\"https://github.com/wingjay/wingjay.github.io/tree/code\" target=\"_blank\" rel=\"external\"> 新的分支：code</a>，然后在这个分支里进行代码控制，master 里则保存部署的新的静态文件。大家可以自行比对这两个 branch 的内容差异。</li>\n</ul>\n<h4 id=\"配置 Hexo\"><a href=\"# 配置 Hexo\" class=\"headerlink\" title=\"配置 Hexo\"></a>配置 Hexo</h4><p>做一些基础配置即可，请参考 <a href=\"https://hexo.io/docs/configuration.html\" target=\"_blank\" rel=\"external\"> 配置文档</a></p>\n<h4 id=\"小结\"><a href=\"# 小结\" class=\"headerlink\" title=\"小结\"></a>小结 </h4><p> 到这里，我们已经完成了 hexo 的配置，我们可以在 GitHub 用不同 branch 分别管理代码和静态文件。执行 deploy 操作后，刷新你的网页 <a href=\"http://username.github.io\" target=\"_blank\" rel=\"external\">http://username.github.io</a> 你就能看到默认的内容了。</p>\n<p>但此时还是默认主题，不够美观，所以下一步要配置 Next 主题。</p>\n<h3 id=\"配置主题 Next\"><a href=\"# 配置主题 Next\" class=\"headerlink\" title=\"配置主题 Next\"></a>配置主题 Next</h3><p>Hexo 主题非常多，可以参考 <a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"external\"> 丰富多彩的 Hexo 主题 </a>，本文选 Next 为主题，样式参考<a href=\"http://wingjay.com\"> 我的博客</a>。</p>\n<p>进入配置阶段，最好的文档还是 <a href=\"http://theme-next.iissnan.com/\" target=\"_blank\" rel=\"external\"> 官方文档</a>，简单得不能再细致了。下面只提几点注意：</p>\n<ul>\n<li>第三方评论系统。评论系统很重要，你可以与读者进行更多交流，配置也简单，建议采用 <a href=\"https://disqus.com/\" target=\"_blank\" rel=\"external\">DISQUS</a>，更国际化一点，<a href=\"http://theme-next.iissnan.com/third-party-services.html#DISUQS\" target=\"_blank\" rel=\"external\"> 配置见此 </a>。另外，前期建议开启<code> 不登陆评论 </code>，即在 Disqus 的<code>Comment Rule</code> 里允许<code>Guest comment</code>。</li>\n<li>创建留言板。熟悉 <code>page</code> 的创建与使用，<a href=\"http://www.arao.me/2015/hexo-next-theme-optimize-base/# 为你的 hexo 网站 NexT 主题增加留言页\" target=\"_blank\" rel=\"external\">参考这里</a></li>\n<li>给自己博客做 <code>SEO</code>。有好的 SEO 便于搜索引擎索引你的网站，随着以后读者增多，他们可以更好搜索到你的网站。<a href=\"http://www.arao.me/2015/hexo-next-theme-optimize-seo/\" target=\"_blank\" rel=\"external\"> 具体方法见此</a></li>\n</ul>\n<!-- ![Disqus 评论系统](/img/Disqus 评论系统.png) -->\n<h3 id=\"替换自己的域名\"><a href=\"# 替换自己的域名\" class=\"headerlink\" title=\"替换自己的域名\"></a>替换自己的域名 </h3><p> 好了，经过上面的步骤，博客已经拥有了一个全新的主题啦。</p>\n<p>下面，我们要对域名 <a href=\"http://wingjay.github.io\" target=\"_blank\" rel=\"external\">http://wingjay.github.io</a> 下手啦。</p>\n<h4 id=\"购买域名\"><a href=\"# 购买域名\" class=\"headerlink\" title=\"购买域名\"></a>购买域名 </h4><p> 速速前往 <a href=\"http://wanwang.aliyun.com/\" target=\"_blank\" rel=\"external\"> 万网</a>，支付宝刷的一声，你就拥有了一个闪闪发光的个人域名啦</p>\n<h4 id=\"域名解析 -1\"><a href=\"# 域名解析 -1\" class=\"headerlink\" title=\"域名解析_1\"></a>域名解析_1</h4><p>以购买的域名 <code>wingjay.com</code> 为例，我们希望在访问这个域名时能自动进入 Github Pages，所以我们要在万网建立一个 CNAME 纪录来帮我们做一个域名跳转：<code>wingjay.com</code> -&gt; <code>wingjay.github.io</code>，<code>www.wingjay.com</code> -&gt; <code>wingjay.github.io</code>。添加方法 <a href=\"http://www.sudu.cn/service/detail/1/0/0/3/10036.html\" target=\"_blank\" rel=\"external\"> 参考这里 </a>，添加后可以看到两条记录：<img src=\"/img/host.png\" alt=\"域名解析\">。然后万网会在世界各地的 DNS 服务器上添加这两条记录，当用户访问<code>wingjay.com</code> 时会自动去访问<code>wingjay.github.io</code>。</p>\n<h4 id=\"域名解析 -2\"><a href=\"# 域名解析 -2\" class=\"headerlink\" title=\"域名解析_2\"></a>域名解析_2</h4><p>但是，此时并不能成功访问，因为 github pages 是有限制的，它不允许任意域名都跳转过来，而是只限制一个域名，而且这个域名必须声明在 CNAME 文件中。</p>\n<p>所以，我们需要添加一个 CNAME 文件到项目的 master 中才行，<a href=\"https://help.github.com/articles/adding-a-cname-file-to-your-repository/\" target=\"_blank\" rel=\"external\">参考这里</a>。读者可以参考本人的<a href=\"https://github.com/wingjay/wingjay.github.io/blob/master/CNAME\" target=\"_blank\" rel=\"external\">CNAME 文件内容</a>。</p>\n<p>不过，对于 <code>Hexo 3</code>，<strong> 这里有一个坑要注意</strong>：大家应该还记得上文说的，master 分支里的内容都是自动生成的，而且会完全覆盖之前的内容。如果我们直接创建一个新文件 CNAME，填好域名。但会发现在下一次部署后这个文件就消失了。不用惊讶，因为 hexo 并不会自动生成 CNAME 文件，所以在部署时被覆盖删除了。</p>\n<p>所以，我们就需要这个 CNAME 工具<a href=\"https://github.com/leecrossley/hexo-generator-cname\" target=\"_blank\" rel=\"external\">hexo-generator-cname</a>，这时会自动在 public 里生成一个 CNAME 文件，把你的域名加进去再部署一下吧！</p>\n<h3 id=\"HTTP-gt-HTTPS\"><a href=\"#HTTP-gt-HTTPS\" class=\"headerlink\" title=\"HTTP -&gt; HTTPS\"></a>HTTP -&gt; HTTPS</h3><p>HTTPS 是安全版的 HTTP 协议，它在 http 协议与 TCP 之间加入 SSL 层，采用端口 443，不仅会对传输数据加密，还会进行身份验证。当然个人博客并没有强制性要求采用该协议，这也只是本人的好奇而为。</p>\n<p>[Update] 目前，我的博客采用了 <a href=\"https://kloudsec.com/github-pages\" target=\"_blank\" rel=\"external\">Kloudsec</a> 来做的 https，大家可以点进去看。通过与服务商联系后，我了解到目前这项服务是免费的，不仅做 https 还能做负载均衡。</p>\n<h3 id=\"疑难杂症\"><a href=\"# 疑难杂症\" class=\"headerlink\" title=\"疑难杂症\"></a>疑难杂症</h3><ol>\n<li>本地 deploy 成功，但是 github 上的 master 并没有收到该 commit。<br>目前不知道是什么原因，本人感觉是 two-factor 的开启，使得本地不具备权限直接 push。比较无语。<br>解决方法：<br>在 code 分支上，创建一个.deploy 的文件夹，在该文件夹内把 master clone 下来；<br>当有新的改动后，generate 后把 public 文件夹的内容拷入进上面 clone 的文件夹内；<br>进入上面 clone 下来的文件夹，手动 push 到 master 上来更新。<br>该思路就是自己维护一个 master 文件夹，手动把生成的 public 内容复制进去，再 push 上去。</li>\n</ol>\n<p>快捷命令：<br>alias hexodeploy=’cd ~/Documents/blog/wingjay.github.io;hexo generate;cp -R public/ .deploy/wingjay.github.io;cd .deploy/wingjay.github.io;git add .;git commit -m “update”;    git push origin master; cd -; git add .; git commit -m “source code”; git push origin code’</p>\n<h2 id=\"总结\"><a href=\"# 总结\" class=\"headerlink\" title=\"总结\"></a>总结 </h2><p> 经过上面的步骤，我们已经能够通过访问自己的域名进入自己酷炫的博客了。本文的任务也就告一段落。</p>\n<p>除了上面的功能，本人还完成了 <code> 支持双域名同时登陆 </code>，其中，支持双域名的解决思路是考虑到<a href=\"https://help.github.com/articles/adding-a-cname-file-to-your-repository/\" target=\"_blank\" rel=\"external\">Github Pages 的 CNAME 纪录只允许添加一个域名</a>，所以本人又在<a href=\"https://gitcafe.com\" target=\"_blank\" rel=\"external\">Gitcafe</a> 上部署了一套。不过考虑到这点大家不一定能用的上，就没有做介绍，有需要的话可以看下文的联系方式联系我。</p>\n<h2 id=\"一天变 cool 系列文章\"><a href=\"# 一天变 cool 系列文章\" class=\"headerlink\" title=\"一天变 cool 系列文章\"></a>一天变 cool 系列文章 </h2><p><a href=\"http://www.jianshu.com/p/cf496fc408b2\" target=\"_blank\" rel=\"external\"> 如何在一天之内完成一款具备 cool 属性的 Android 产品 &lt; 简诗 &gt;</a></p>\n<p><a href=\"http://www.jianshu.com/p/99665608d295\" target=\"_blank\" rel=\"external\">如何在一天之内搭建以你自己名字为域名且具备 cool 属性的个人博客</a></p>\n<p>谢谢！</p>\n<p>wingjay</p>\n<p>欢迎各位关注 <br><a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\"> 我的 Github</a>: <a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\">https://github.com/wingjay</a><br>和 <br><a href=\"http://wingjay.com\"> 我的个人博客 </a>: <a href=\"http://wingjay.com\">http://wingjay.com</a><br> 和<br><a href=\"http://www.jianshu.com/users/da333fd63fe5/latest_articles\" target=\"_blank\" rel=\"external\">我的简书 </a>: <a href=\"http://www.jianshu.com/users/da333fd63fe5/latest_articles\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/users/da333fd63fe5/latest_articles</a><br> 和<br><a href=\"http://weibo.com/u/1625892654\" target=\"_blank\" rel=\"external\">微博 iam_wingjay</a>: <a href=\"http://weibo.com/u/1625892654\" target=\"_blank\" rel=\"external\">http://weibo.com/u/1625892654</a><br>如果有问题，可以给我留言或发邮件<a href=\"&#109;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#x79;&#105;&#110;&#x6a;&#105;&#101;&#115;&#x68;&#64;&#49;&#50;&#x36;&#46;&#x63;&#111;&#109;\">&#x79;&#105;&#110;&#x6a;&#105;&#101;&#115;&#x68;&#64;&#49;&#50;&#x36;&#46;&#x63;&#111;&#109;</a></p>\n<p><img src=\"https://avatars0.githubusercontent.com/u/9619875?v=3&amp;s=460\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>对程序员而言，最好的简历就是个人博客和GitHub。</p>\n</blockquote>","more":"<p><img src=\"/img/myblog.png\" alt=\"个人博客\"></p>\n<h2 id=\"个人博客\"><a href=\"#个人博客\" class=\"headerlink\" title=\"个人博客\"></a>个人博客</h2><p>每个优秀的程序员都会有个人独占的一方网络空间，那里是他个人的舞台，听说过他的人会逐渐汇聚进来，认识他，熟悉他，鼓励他，赞扬他。而对他个人而言，他有了一个可以畅所欲言的小房间，他可以专研学术，聊聊情怀。同时和喜爱他的读者成为好友，共同成长。</p>\n<p>这难道不是一件很cool的事情吗？</p>\n<h2 id=\"先看成果\"><a href=\"#先看成果\" class=\"headerlink\" title=\"先看成果\"></a>先看成果</h2><p>教方法前先来看看最终的效果吧。<a href=\"http://wingjay.com\">http://wingjay.com</a>是本人搭建的个人博客，主要有以下几点：</p>\n<pre><code>1. 个人域名: wingjay.com\n2. 无需购置服务器，本站同时挂载在Github Pages 和 GitCafe Pages上，免服务器费的同时还能做负载均衡，想想还有点小激动\n3. 在GitHub上同时管理你的博客和相应代码，再也不用担心博客遗失\n4. SSL支持，即&quot;http://&quot; -&gt; &quot;https://&quot;，更安全也更高大上\n</code></pre><h2 id=\"再看兵器\"><a href=\"#再看兵器\" class=\"headerlink\" title=\"再看兵器\"></a>再看兵器</h2><ul>\n<li>博客框架：<a href=\"https://hexo.io\" target=\"_blank\" rel=\"external\">Hexo 3</a>，这是一款能快速、简洁且高效的博客框架，支持<a href=\"https://help.github.com/articles/markdown-basics/\" target=\"_blank\" rel=\"external\">Markdown编辑</a>，自动渲染出漂亮的静态页面。</li>\n<li>前端主题：<a href=\"https://github.com/iissnan/hexo-theme-next\" target=\"_blank\" rel=\"external\">Next</a>，效果参考<a href=\"http://wingjay.com\">http://wingjay.com</a></li>\n<li>域名购买：<a href=\"http://wanwang.aliyun.com/\" target=\"_blank\" rel=\"external\">万网</a>，你可以选购自己名字的域名，一年几十元左右，两杯咖啡的钱。</li>\n<li>SSL：<a href=\"https://www.cloudflare.com\" target=\"_blank\" rel=\"external\">CloudFlare</a></li>\n</ul>\n<h2 id=\"抄起家伙\"><a href=\"#抄起家伙\" class=\"headerlink\" title=\"抄起家伙\"></a>抄起家伙</h2><p>本文写作方式是<code>安装流程主线</code> + <code>优质参考文章</code>。由于网络上关于Hexo搭建博客的教程玲琅满目，若读者完全自己动手则要一篇篇找，浪费时间走弯路；相反，若作者悉数摘抄进来，反倒未必符合各人情况，且不利阅读。</p>\n<p>所以，<code>主线</code>讲解思路，<code>参考</code>深入阅读。</p>\n<p>下文以搭建 <a href=\"http://wingjay.com\">http://wingjay.com</a> 个人博客为例。</p>\n<h3 id=\"GitHub-Pages\"><a href=\"#GitHub-Pages\" class=\"headerlink\" title=\"GitHub Pages\"></a>GitHub Pages</h3><p>在不购买服务器的前提下，我们的网站需要挂在GitHub Pages上。GitHub Pages是面向用户、组织和项目开放的公共静态页面搭建托管服务，可用于搭建个人博客。</p>\n<ol>\n<li>你需要拥有一个<a href=\"https://github.com\" target=\"_blank\" rel=\"external\">GitHub账号</a>，去完成新手任务吧。</li>\n<li>进入<a href=\"https://pages.github.com/\" target=\"_blank\" rel=\"external\">GitHub Pages</a>，一步步做，完成后就能在浏览器打开<a href=\"http://wingjay.github.io\" target=\"_blank\" rel=\"external\">http://wingjay.github.io</a>了。</li>\n</ol>\n<p>至此，我们已经利用GitHub Pages搭建好了个人博客雏形了。下面要做的，就是个性化了。</p>\n<h3 id=\"安装Hexo博客框架\"><a href=\"#安装Hexo博客框架\" class=\"headerlink\" title=\"安装Hexo博客框架\"></a>安装Hexo博客框架</h3><p>经过上面步骤，我们已经拥有了一个初步域名：<a href=\"http://username.github.io\" target=\"_blank\" rel=\"external\">http://username.github.io</a> 加一个免费网络空间了。好比房间有了，但还没有任何家具。所以下面我们需要把空白的博客丰富起来。</p>\n<p>放心，不需要你手写一大堆html、css文件，也不用找jQuery来实现酷炫的页面效果。<a href=\"https://hexo.io\" target=\"_blank\" rel=\"external\">Hexo</a>是一款博客框架，它会帮我们搭建。</p>\n<h4 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h4><p>参考<a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">中文文档</a>或<a href=\"https://hexo.io/zh-cn/docs/index.html\" target=\"_blank\" rel=\"external\">英文文档</a>。完成该步后，你的电脑便拥有了Git、Node.js和Hexo。</p>\n<h4 id=\"GitHub管理\"><a href=\"#GitHub管理\" class=\"headerlink\" title=\"GitHub管理\"></a>GitHub管理</h4><p>为了让自己未来的博客和代码处在git管理之下，我们要把刚刚在Github上博客项目拉到本地。如本人创建的<a href=\"https://github.com/wingjay/wingjay.github.io\" target=\"_blank\" rel=\"external\">https://github.com/wingjay/wingjay.github.io</a>，在本地创建文件夹，名字任意，此处设为<code>myblog</code>，进入该文件夹，把项目代码clone下来。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone https://github.com/wingjay/wingjay.github.io</div></pre></td></tr></table></figure></p>\n<p>好了，此时会自动在<code>myblog</code>目录下创建子文件夹<code>wingjay.github.io</code>,那里就是我们博客的代码，以后的操作都在git的管理之下了，此时默认的branch为<code>master</code>。</p>\n<h4 id=\"初始化Hexo\"><a href=\"#初始化Hexo\" class=\"headerlink\" title=\"初始化Hexo\"></a>初始化Hexo</h4><p>请参考<a href=\"https://hexo.io/docs/setup.html\" target=\"_blank\" rel=\"external\">文档</a>。init命令中的<code>&lt;folder&gt;</code>就是文件夹<code>wingjay.github.io</code>。初始化后，<code>wingjay.github.io</code>里面就已经有完整的Hexo框架了。</p>\n<h4 id=\"熟悉Hexo\"><a href=\"#熟悉Hexo\" class=\"headerlink\" title=\"熟悉Hexo\"></a>熟悉Hexo</h4><p>为了让读者快速了解<code>Hexo</code>，我作几个简单介绍吧。当然，更多的还是需要仔细阅读<a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">文档</a>才能了解更详细。</p>\n<p><img src=\"/img/hexo-directory.png\" alt=\"hexo目录结构\"></p>\n<ul>\n<li><code>_config.yml</code>是整体的配置文件，很多基础配置、插件配置等都需要在里面进行。要注意的是，该文件格式要求极为严格，缺少一个空格都会导致运行错误。小提示：不要用Tab缩进，用两个空格符。</li>\n<li><code>layout</code>，包括<code>draft(草稿)、page(页面)、post(文章)</code>。这个就是三种文件的基本格式，其中<code>post</code>是你发表的文章，会显示在你的网站里，一篇post会包括<code>title标题、date日期、tags标签</code>等信息；<code>draft</code>是草稿，只有你在本地能看到，必须要<code>publish</code>后才能成为<code>post</code>，draft和post差别是date，因为draft没有发表，所以不需要指定日期。<code>page</code>是一个页面，对应一个新的html页面，比如<a href=\"http://wingjay.com/2015/12/06/%E8%AF%B4%E4%B8%80%E8%AF%B4%E5%8D%9A%E5%AE%A2/\">博客内容展示页</a>是一个页面，<a href=\"http://wingjay.com/guestbook/\">留言本</a>也是一个页面。</li>\n<li><code>public文件夹</code>，这个文件夹是最终会发布到网站上的真实内容。怎么理解呢？我们可以把<code>public</code>文件夹当作是真正的被用户看到的，而其他的<code>source、themes</code>等都是为<code>public</code>服务的。Hexo里有一个很重要的指令<code>hexo generate</code>，这个指令就是利用所有代码里的配置信息、source里写的文章、themes里的样式，共同生成最终的<code>静态html文件</code>，存入<code>public</code>文件夹内。在我们执行了发布指令<code>hexo deploy</code>后，就会把<code>public</code>的内容部署到<code>GitHub Pages</code>上。当用户在访问我们的博客时，他们会看到public里生成的html文件。这个概念非常重要，即<code>代码和真实静态页面是独立的</code>。</li>\n<li><code>generate和deploy</code>，<code>generate</code>会把我们的配置、文章和主题结合起来生成一堆酷炫的html静态文件放在public里面。但此时用户还看不到<code>本地public文件</code>里的页面，我们必须用后一个指令<code>deploy</code>才能把静态文件部署到<code>GitHub Pages</code>上。不过，在部署前，需要配置让它自动部署到我们前面创建的<a href=\"https://github.com/wingjay/wingjay.github.io\" target=\"_blank\" rel=\"external\">Github项目</a>中。</li>\n<li><code>deploy</code>相关配置。为了能够让项目自动把public文件夹的内容部署到<a href=\"https://github.com/wingjay/wingjay.github.io\" target=\"_blank\" rel=\"external\">GitHub项目</a>中，我们可以按<a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">部署文档</a>进行配置，其中选择的<code>branch</code>为<code>master</code>。此后，每次运行deploy后，项目就会自动把public文件夹内容全部覆盖到<a href=\"https://github.com/wingjay/wingjay.github.io/tree/master\" target=\"_blank\" rel=\"external\">当前的GitHub项目master分支上</a>。</li>\n<li><code>代码</code>和<code>静态文件</code>分开管理。根据上面知道，每次部署后，public文件内容会<code>覆盖</code>掉项目整个master分支。这样可以实现网站<code>静态文件</code>的版本控制，但是，仔细对比这个master分支，我们会发现里面<strong>只剩下静态文件</strong>了，我们的代码比如source、themes统统没有了，这就导致无法对代码进行版本管理了。这意味着我换一台电脑，我就再也找不到<code>代码</code>了，只剩下一堆之前编译出来的静态文件。所以，为了对代码也进行版本控制，我们创建一个<a href=\"https://github.com/wingjay/wingjay.github.io/tree/code\" target=\"_blank\" rel=\"external\">新的分支：code</a>，然后在这个分支里进行代码控制，master里则保存部署的新的静态文件。大家可以自行比对这两个branch的内容差异。</li>\n</ul>\n<h4 id=\"配置Hexo\"><a href=\"#配置Hexo\" class=\"headerlink\" title=\"配置Hexo\"></a>配置Hexo</h4><p>做一些基础配置即可，请参考<a href=\"https://hexo.io/docs/configuration.html\" target=\"_blank\" rel=\"external\">配置文档</a></p>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>到这里，我们已经完成了hexo的配置，我们可以在GitHub用不同branch分别管理代码和静态文件。执行deploy操作后，刷新你的网页 <a href=\"http://username.github.io\" target=\"_blank\" rel=\"external\">http://username.github.io</a> 你就能看到默认的内容了。</p>\n<p>但此时还是默认主题，不够美观，所以下一步要配置Next主题。</p>\n<h3 id=\"配置主题Next\"><a href=\"#配置主题Next\" class=\"headerlink\" title=\"配置主题Next\"></a>配置主题Next</h3><p>Hexo主题非常多，可以参考<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"external\">丰富多彩的Hexo主题</a>，本文选Next为主题，样式参考<a href=\"http://wingjay.com\">我的博客</a>。</p>\n<p>进入配置阶段，最好的文档还是<a href=\"http://theme-next.iissnan.com/\" target=\"_blank\" rel=\"external\">官方文档</a>，简单得不能再细致了。下面只提几点注意：</p>\n<ul>\n<li>第三方评论系统。评论系统很重要，你可以与读者进行更多交流，配置也简单，建议采用<a href=\"https://disqus.com/\" target=\"_blank\" rel=\"external\">DISQUS</a>，更国际化一点，<a href=\"http://theme-next.iissnan.com/third-party-services.html#DISUQS\" target=\"_blank\" rel=\"external\">配置见此</a>。另外，前期建议开启<code>不登陆评论</code>，即在Disqus的<code>Comment Rule</code>里允许<code>Guest comment</code>。</li>\n<li>创建留言板。熟悉<code>page</code>的创建与使用，<a href=\"http://www.arao.me/2015/hexo-next-theme-optimize-base/#为你的hexo网站NexT主题增加留言页\" target=\"_blank\" rel=\"external\">参考这里</a></li>\n<li>给自己博客做<code>SEO</code>。有好的SEO便于搜索引擎索引你的网站，随着以后读者增多，他们可以更好搜索到你的网站。<a href=\"http://www.arao.me/2015/hexo-next-theme-optimize-seo/\" target=\"_blank\" rel=\"external\">具体方法见此</a></li>\n</ul>\n<!-- ![Disqus评论系统](/img/Disqus评论系统.png) -->\n<h3 id=\"替换自己的域名\"><a href=\"#替换自己的域名\" class=\"headerlink\" title=\"替换自己的域名\"></a>替换自己的域名</h3><p>好了，经过上面的步骤，博客已经拥有了一个全新的主题啦。</p>\n<p>下面，我们要对域名 <a href=\"http://wingjay.github.io\" target=\"_blank\" rel=\"external\">http://wingjay.github.io</a> 下手啦。</p>\n<h4 id=\"购买域名\"><a href=\"#购买域名\" class=\"headerlink\" title=\"购买域名\"></a>购买域名</h4><p>速速前往<a href=\"http://wanwang.aliyun.com/\" target=\"_blank\" rel=\"external\">万网</a>，支付宝刷的一声，你就拥有了一个闪闪发光的个人域名啦</p>\n<h4 id=\"域名解析-1\"><a href=\"#域名解析-1\" class=\"headerlink\" title=\"域名解析_1\"></a>域名解析_1</h4><p>以购买的域名<code>wingjay.com</code>为例，我们希望在访问这个域名时能自动进入Github Pages，所以我们要在万网建立一个CNAME纪录来帮我们做一个域名跳转：<code>wingjay.com</code> -&gt; <code>wingjay.github.io</code>，<code>www.wingjay.com</code> -&gt; <code>wingjay.github.io</code>。添加方法<a href=\"http://www.sudu.cn/service/detail/1/0/0/3/10036.html\" target=\"_blank\" rel=\"external\">参考这里</a>，添加后可以看到两条记录：<img src=\"/img/host.png\" alt=\"域名解析\">。然后万网会在世界各地的DNS服务器上添加这两条记录，当用户访问<code>wingjay.com</code>时会自动去访问<code>wingjay.github.io</code>。</p>\n<h4 id=\"域名解析-2\"><a href=\"#域名解析-2\" class=\"headerlink\" title=\"域名解析_2\"></a>域名解析_2</h4><p>但是，此时并不能成功访问，因为github pages是有限制的，它不允许任意域名都跳转过来，而是只限制一个域名，而且这个域名必须声明在CNAME文件中。</p>\n<p>所以，我们需要添加一个CNAME文件到项目的master中才行，<a href=\"https://help.github.com/articles/adding-a-cname-file-to-your-repository/\" target=\"_blank\" rel=\"external\">参考这里</a>。读者可以参考本人的<a href=\"https://github.com/wingjay/wingjay.github.io/blob/master/CNAME\" target=\"_blank\" rel=\"external\">CNAME文件内容</a>。</p>\n<p>不过，对于<code>Hexo 3</code>，<strong>这里有一个坑要注意</strong>：大家应该还记得上文说的，master分支里的内容都是自动生成的，而且会完全覆盖之前的内容。如果我们直接创建一个新文件CNAME，填好域名。但会发现在下一次部署后这个文件就消失了。不用惊讶，因为hexo并不会自动生成CNAME文件，所以在部署时被覆盖删除了。</p>\n<p>所以，我们就需要这个CNAME工具<a href=\"https://github.com/leecrossley/hexo-generator-cname\" target=\"_blank\" rel=\"external\">hexo-generator-cname</a>，这时会自动在public里生成一个CNAME文件，把你的域名加进去再部署一下吧！</p>\n<h3 id=\"HTTP-gt-HTTPS\"><a href=\"#HTTP-gt-HTTPS\" class=\"headerlink\" title=\"HTTP -&gt; HTTPS\"></a>HTTP -&gt; HTTPS</h3><p>HTTPS是安全版的HTTP协议，它在http协议与TCP之间加入SSL层，采用端口443，不仅会对传输数据加密，还会进行身份验证。当然个人博客并没有强制性要求采用该协议，这也只是本人的好奇而为。</p>\n<p>[Update] 目前，我的博客采用了<a href=\"https://kloudsec.com/github-pages\" target=\"_blank\" rel=\"external\">Kloudsec</a>来做的https，大家可以点进去看。通过与服务商联系后，我了解到目前这项服务是免费的，不仅做https还能做负载均衡。</p>\n<h3 id=\"疑难杂症\"><a href=\"#疑难杂症\" class=\"headerlink\" title=\"疑难杂症\"></a>疑难杂症</h3><ol>\n<li>本地deploy成功，但是github上的master并没有收到该commit。<br>目前不知道是什么原因，本人感觉是two-factor的开启，使得本地不具备权限直接push。比较无语。<br>解决方法：<br>在code分支上，创建一个.deploy的文件夹，在该文件夹内把master clone下来；<br>当有新的改动后，generate后把public文件夹的内容拷入进上面clone的文件夹内；<br>进入上面clone下来的文件夹，手动push到master上来更新。<br>该思路就是自己维护一个master文件夹，手动把生成的public内容复制进去，再push上去。</li>\n</ol>\n<p>快捷命令：<br>alias hexodeploy=’cd ~/Documents/blog/wingjay.github.io;hexo generate;cp -R public/ .deploy/wingjay.github.io;cd .deploy/wingjay.github.io;git add .;git commit -m “update”;    git push origin master; cd -; git add .; git commit -m “source code”; git push origin code’</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>经过上面的步骤，我们已经能够通过访问自己的域名进入自己酷炫的博客了。本文的任务也就告一段落。</p>\n<p>除了上面的功能，本人还完成了<code>支持双域名同时登陆</code>，其中，支持双域名的解决思路是考虑到<a href=\"https://help.github.com/articles/adding-a-cname-file-to-your-repository/\" target=\"_blank\" rel=\"external\">Github Pages的CNAME纪录只允许添加一个域名</a>，所以本人又在<a href=\"https://gitcafe.com\" target=\"_blank\" rel=\"external\">Gitcafe</a>上部署了一套。不过考虑到这点大家不一定能用的上，就没有做介绍，有需要的话可以看下文的联系方式联系我。</p>\n<h2 id=\"一天变cool系列文章\"><a href=\"#一天变cool系列文章\" class=\"headerlink\" title=\"一天变cool系列文章\"></a>一天变cool系列文章</h2><p><a href=\"http://www.jianshu.com/p/cf496fc408b2\" target=\"_blank\" rel=\"external\">如何在一天之内完成一款具备cool属性的Android产品&lt;简诗&gt;</a></p>\n<p><a href=\"http://www.jianshu.com/p/99665608d295\" target=\"_blank\" rel=\"external\">如何在一天之内搭建以你自己名字为域名且具备cool属性的个人博客</a></p>\n<p>谢谢！</p>\n<p>wingjay</p>\n<p>欢迎各位关注<br><a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\">我的Github</a>: <a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\">https://github.com/wingjay</a><br>和<br><a href=\"http://wingjay.com\">我的个人博客</a>: <a href=\"http://wingjay.com\">http://wingjay.com</a><br>和<br><a href=\"http://www.jianshu.com/users/da333fd63fe5/latest_articles\" target=\"_blank\" rel=\"external\">我的简书</a>: <a href=\"http://www.jianshu.com/users/da333fd63fe5/latest_articles\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/users/da333fd63fe5/latest_articles</a><br>和<br><a href=\"http://weibo.com/u/1625892654\" target=\"_blank\" rel=\"external\">微博 iam_wingjay</a>: <a href=\"http://weibo.com/u/1625892654\" target=\"_blank\" rel=\"external\">http://weibo.com/u/1625892654</a><br>如果有问题，可以给我留言或发邮件<a href=\"&#109;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#x79;&#105;&#110;&#x6a;&#105;&#101;&#115;&#x68;&#64;&#49;&#50;&#x36;&#46;&#x63;&#111;&#109;\">&#x79;&#105;&#110;&#x6a;&#105;&#101;&#115;&#x68;&#64;&#49;&#50;&#x36;&#46;&#x63;&#111;&#109;</a></p>\n<p><img src=\"https://avatars0.githubusercontent.com/u/9619875?v=3&amp;s=460\" alt=\"\"></p>","sticky":0},{"title":"带你学开源项目：Meizhi Android 之 RxJava & Retrofit 最佳实践","date":"2016-04-12T16:17:28.000Z","commentIssueId":16,"_content":"> 私以为，阅读开源项目是与世界级技术大牛直接对话的最好方式。\n此次来分享下 Meizhi Android 源码的分析。\n\n<!-- more -->\n\n## 零、背景\n比起阅读枯燥的技术文档，独自苦苦摸索新技术的基本用法，还有一种更好更快速也更有效的提高自身技术的方法，那就是阅读学习优质的开源项目，通过仿写、练习最终达到理解，潜移默化提升自身编程技能。\n\n《带你学开源项目》系列将带领你深入阅读及分析当前流行的一些开源项目，并针对其中采用的新技术与精妙之处进行细致的阐述，以期让你快速掌握Android开发中的多种强大技能点。\n\n\n## 一、本期开源项目Meizhi Android\n本次的开源项目选择了[Meizhi Android](https://github.com/drakeet/Meizhi)，本文主要介绍该项目中采用的`RxJava`、`Retrofit`两种技术，这二者在Android开发者中非常流行，不仅能够`优美地处理异步回调`，而且能`提高代码的性能和稳定性`。而Meizhi Android中较好的覆盖了二者的多种应用场景，能够给多数开发者一个全面的学习。\n\n下面本人会`对原项目的代码进行详细的介绍`，同时为了读者看的清楚其中的逻辑关系，可能会做一定调整以帮助读者理解，比如把lambda表达式还原成普通java函数形式，以避免很多读者对lambda并不熟悉。\n\n## 二、原项目分析\n### 0. clone项目到本地\n第一步当然是把项目clone下来，编译，运行。有兴趣的同学可以执行这一步。\n### 1. 添加`Stetho`抓包工具\n首先，由于我们要分析retrofit，所以为了查看app的网络请求，有兴趣的同学可以手动在代码里添加[Stetho](http://facebook.github.io/stetho/)。`Stetho`是Facebook推出的一款黑科技，能够在chrome里轻松查看app所有的网络请求，比起iOS需要装个[Charles](https://www.charlesproxy.com/)查看http请求方便多咯。\n\n![Stetho使用场景](http://upload-images.jianshu.io/upload_images/281665-50854bb575db05f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 2. Retrofit结构\n从下图我们可以看到，首页里有很多card，每一个card里有两个元素：`妹纸图片`， `描述文字`，具体UI实现我们不在乎，只要明白一点，这两个元素数据是来自于两个不同的api。其中，`妹纸图片`来自于`http://gank.io/api/data/福利/10`;`描述文字`来自于`http://gank.io/api/data/休息视频/10`。\n\napp中为了请求网络数据，采用了[Retrofit](http://square.github.io/retrofit/)。具体关于retrofit如何配置请各位参考官网，这里只讲解如何使用`Retrofit`。\n\n该项目中主要创建了以下几个类来实现`Retrofit`结构，大家可以作为参考用于自己的项目中。\n\n ##### i. `GankApi`：这个类用来定义相关的`http`接口，这是符合retrofit规范的定义形式，每一个api返回的为`Observable<T>`格式结果，方便`RxJava`进行进一步处理。\n    @GET(\"/data/福利/{page}\") Observable<MeizhiList> getMeizhiList(@Path(\"page\") int page);\n    @GET(\"/data/休息视频/{page}\") Observable<GankVideoList> getGankVideoList(@Path(\"page\") int page);\n##### ii. `DrakeetRetrofit`：这个类用来对`Retrofit`进行相关配置并生成`GankApi`实例`gankApi`\n    OkHttpClient client = new OkHttpClient();\n    RestAdapter.Builder builder = new RestAdapter.Builder();\n    builder.setClient(new OkClient(client))\n          .setLogLevel(RestAdapter.LogLevel.FULL) \n          .setEndpoint(\"http://gank.io/api\")\n          .setConverter(new GsonConverter(gson));\n    RestAdapter gankRestAdapter = builder.build();\n    GankApi gankApi = gankRestAdapter.create(GankApi.class);\n\n    public GankApi getGankApi() {    \n        return gankApi;\n    }\n##### iii. `DrakeetFactory`： 这个类用来对外生成单例`GankApi`实例，为确保`GankApi`实例只生成一次。\n    public static GankApi getGankApi() {    \n        if (sGankApi == null) {\n            synchronized (monitor) {        \n               if (sGankApi == null) {            \n                  sGankApi = new DrakeetRetrofit().getGankApi();        \n               }       \n               return sGankApi;    \n            }\n        }\n    }\n\n所以，在实际应用场景中，比如我们想要发起一个http请求来获取`福利`数据，那么我们可以采用以下方式：\n\n    GankApi gankApi = DrakeetFactory.getGankApi();\n    Observable<MeizhiList> meizhiList = gankApi. getMeizhiList(10);\n\n\n![首页.png](http://upload-images.jianshu.io/upload_images/281665-2129d871aff9a884.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 3. 首页的RxJava的实现\n既然我们已经把网络框架搭建好了，那么可以开始从服务器获取数据并显示了。我们首先看首页的数据。下面，我来对首页数据进行分析，一步步推出所需要的RxJava表达式。\n\n上面已经介绍过，每一个card里有两部分数据：`妹纸图片`(红色方框)和`描述文本`(绿色方框)。\n\n- `妹纸图片`数据来自于`\"/data/福利/{page}\"`这个api，该api会返回妹纸图片的url；\n- `描述文本`来自于`\"/data/休息视频/{page}\"`这个api，该api会返回休息视频及相关描述信息，card里会把描述信息显示出来；\n- 两个api均可以携带`page`字段，即一次请求可以获得多个数据。如我们在`\"/data/福利/{page}\"`里设置`page=10`，那么我们一次请求可以得到10条`福利`数据，即`10张妹纸图片url`；\n- 由于我们一次可以获得多张妹纸图片url和多个视频信息，那我们就需要把`二者进行合并`，即`单拎出来一张妹纸图片和一个视频信息组装成一个card`。然后按这种方式生成其他的card。\n\n小结一下，根据以上描述，假如我们把两个api的page都设置为`10`，那么两个请求同时发出去后，我们能得到`10张妹纸图片url`（如`http://img.com/1.png`, `http://img.com/2.png`, ...）和`10个视频信息`(如`舌尖上的中国`, `星际穿越`， ...)，然后我们将二者组装成`10个card所需要的数据`，放入每个card里显示即可。\n\n好，终于可以开始动手写代码了。上面的分析看似复杂，然后只要你学会了如何分析，很快就能写出对应的RxJava代码。下面我结合RxJava的`数据流思想`和`具体操作符`来介绍实现代码。\n\n##### i. 在网络请求数据之前，我们要创建几个数据entry对象来将获取回来的json字符串转化为object\n    public class Meizhi {\n        public String url;\n        public Date publishDate;\n    } //这是一个Meizhi对象，存储妹纸图片的url，图片描述信息和创建日期\n\n    public class Video {\n      public String desc;\n      public Date publishDate;\n    } //这是一个视频对象，存储视频描述信息和创建日期\n\n    public class MeizhiList {\n      public List<Meizhi> meizhiList;\n    } //由于我们一次请求能获取到10个(根据`page`设置)，所以我们用MeizhiList来存储结果\n\n    public class VideoList {\n      public List<Video> videoList;\n    } //原理同上，存储多个video对象\n\n    public class MeizhiWithVideo {\n      public String url;\n      public String desc;\n      public Date publishDate;\n    }//将video信息合并入meizhi对象中\n    \n    public class MeizhiWithVideoList {\n      public List<MeizhiWithVideoList> data;\n    }\n  \n##### ii. zip: 将两个retrofit接口请求后得到的两个数据源Observable<MeizhiList>  Observable<VideoList>进行合并\n我们需要把这两个数据源的数据拼接起来，所以我们可以考虑使用[zip操作符](http://reactivex.io/documentation/operators/zip.html)，该操作符可以将两个数据源发射出来的数据依次组装在一起。\n\n比如一个`Observable数据源`依次发射出`1, 3, 5, 7`, 另一个`Observable数据源`依次发射出`a, b, c, d`，那么`zip操作符`组装后会对外发射出`1a, 3b, 5c, 7d`这样的数据。\n\n而我们需要的正是这样。\n\n`Observable<MeizhiList>`一次对外发射一个`MeizhiList`对象，`Observable<VideoList>`一次对外发射一个`VideoList`对象，我们将二者合并成一个`MeizhiWithVideoList`对象。然后把`MeizhiWithVideoList`对象拿给UI去进行显示即可。\n\n所以，我们可以得到：\n\n    Observable<MeizhiList> meizhiListObservable = gankApi.getMeizhiList(10);\n    Observable<VideoList> videoListObservable = gankApi.getVideoList(10);\n    Observable<MeizhiWithVideoList> meizhiWithVideoListObservable = \n    Observable.zip(meizhiListObservable, videoListObservable, this::mergeVideoWithMeizhi)\n\n其中`mergeVideoWithMeizhi`是一个合并函数，把`video`信息与`meizhi`信息合并成新的`MeizhiWithVideo对象`。\n\n    public MeizhiWithVideoList\n    mergeVideoWithMeizhi(MeizhiList meizhiList, VideoList videoList) {//省略...}\n\n![RxJava - zip](http://upload-images.jianshu.io/upload_images/281665-91320f2cce108a8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n##### iii. 对MeizhiWithVideo对象进行排序。\n在上面，我们通过合并，得到了  `Observable<MeizhiWithVideoList>`数据源，这个数据源对外发射出一个`MeizhiWithVideoList`对象，这个对象里有10个`MeizhiWithVideo`数据，我们可以对这10个数据利用它们的发布日期进行排序。\n\n所以我们要实现以下几步：\n- 先把`Observable<MeizhiWithVideoList>`数据源转化为`Observable<List<MeizhiWithVideo>>`，从对外发一个`MeizhiWithVideoList`对象变成对外发射一个`List<MeizhiWithVideo>`对象；\n\n- 再把`Observale<List<MeizhiWithVideo>>`转化为`Observable<MeizhiWithVideo>`数据源，变成了对外发射出10个`MeizhiWithVideo`对象;\n\n- 对这10个`MeizhiWithVideo`对象基于`publishDate`进行排序；\n\n- 其中比较操作很耗cpu，所以我们放在`Schedulers.computation()`线程中做\n\n代码实现：\n    \n    meizhiWithVideoListObservable.map(new Func1<MeizhiWithVideoList, List<MeizhiWithVideo>>() {    \n          @Override    \n          public List<Meizhi> call(MeizhiList meizhiList) {                \n                return MeizhiWithVideoList.data;    \n          }\n    })\n    .flatMap(new Func1<List<MeizhiWithVideo>, Observable<MeizhiWithVideo>>() {    \n          @Override    \n          public Observable<MeizhiWithVideo> call(List<MeizhiWithVideo> meizhiWithVideos) {        \n                return Observable.from(meizhiWithVideos);    \n          }\n    })\n    .toSortedList(new Func2<MeizhiWithVideo, MeizhiWithVideo, Integer>() {    \n          @Override    \n          public Integer call(MeizhiWithVideo meizhiWithVideo1, MeizhiWithVideo meizhiWithVideo2) {        \n                return meizhiWithVideo2.publishedAt.compareTo(meizhiWithVideo1.publishedAt);    \n          }\n    })\n    .subscribeOn(Schedulers.computation());\n\n##### iv. 排序后，我们得到`Observable<List<MeizhiWithVideo>>`数据源，传给adapter去更新UI\n上面的`toSortedList(xxx)`方法会把`Observable<MeizhiWithVideo>`排序后重新组装成`Observable<List<MeizhiWithVideo>>`对象`sortedMVListObservable`，该对象对外发射一个`有序的List<MeizhiWithVideo>`。我们将该数据源提供给adapter供显示。\n\n代码如下：\n\n    sortedMVListObservable.observeOn(AndroidSchedulers.mainThread())\n    .subscribe(new Subscriber<List<MeizhiWithVideo>>() {    \n        @Override    \n        public void onCompleted() {            \n            setRefresh(false); // stop refreshing data.                 \n        }    \n        @Override    \n        public void onError(Throwable e) {    \n\n        }\n        @Override    \n        public void onNext(List<MeizhiWithVideo> meizhiWithVideoList) {    \n            adapter.setData(meizhiWithVideoList);\n            adapter.notifyDataSetChanged(); // update UI\n        }\n    })\n\n### 4. 利用`Subscription`来管理异步处理与Activity生命周期\n对于异步我们知道一直存在一个问题，假设一个页面要同时发出很多个http请求，如http1, http2, http3...，然后这些请求会被放在一个队列里依次发出，而且每个请求发出后需要等待一段时间才能得到返回数据。\n\n那么问题就来了，假设在A页面发出了多个网络请求，在这些网络请求还在等待响应时用户就跳转到了B页面，在以前的情况下是，A页面的网络请求仍然进行直到所有数据返回，而且当数据返回时会尝试去调用A页面的UI进行修改，而此时已经进入了B页面，所以，这不仅造成了网络资源的浪费，也存在一定的风险。\n\n有了RxJava，我们可以把每一个网络请求转化为一个`Subscription`对象，这个`Subscription`对象可以被手动`unsubscribe`，即停止订阅所请求的数据源，这样就可以暂定数据请求，而且即使数据返回回来，由于我已经取消订阅了，所以不会再接收到这些数据了。\n\n代码实现：\n在`BaseActivity`中，创建一个`CompositeSubscription`对象来进行管理\n\n    `BaseActivity`\n    private CompositeSubscription mCompositeSubscription;\n    protected void addSubscription(Subscription s) {   \n       if (this.mCompositeSubscription == null) {                \n            this.mCompositeSubscription = new CompositeSubscription();    \n        }    \n        this.mCompositeSubscription.add(s);\n    }\n\n    @Override \n    protected void onDestroy() {    \n          super.onDestroy();    \n          if (this.mCompositeSubscription != null) {                \n                this.mCompositeSubscription.unsubscribe();    \n          }\n    }\n\n在实际的Activity中的网络请求:\n\n    public class MyActivity extends BaseActivity {\n      \n        private void loadData() {\n            Subscription s = gankApi.getMeizhiList(10)                           \n                                         .subscribeOn(Schedulers.io())\n                                         .observeOn(AndroidSchedulers.mainThread())\n                                         .subscribe(...);\n            addSubscription(s);\n        }\n    }\n\n## 三、改进及总结\n本文通过对开源项目[Meizhi Android](https://github.com/drakeet/Meizhi)进行分析，了解了`Retrofit`，`RxJava`的实际应用场景，也对于二者有了更加深入的认识。\n\n不过本人认为该项目还有一些可以改善的地方，比如`Retrofit`中利用`DrakeetFactory`工厂来生成`GankApi`的单例，但是`new DrakeetRetrofit().getGankApi();`也是一个可以生成`GankApi`的方法，而且是`public`的，那么如果新的开发者忘记调用`DrakeetFactory`来生成`GankApi`的实例，而是采用后者，那么工厂模式就达不到预期的目的了。我认为可以把`new DrakeetRetrofit().getGankApi();`这个操作内容放在`DrakeetFactory`工厂内部，并且设置为`private`属性，这样的话如果想要获得`GankApi`实例，就必须依靠`DrakeetFactory`来生成，从而真正保证了`单例`的优势。\n\n最后，如果读者有意见欢迎评论，本人后续还会挑选优质的开源项目，分析其精髓，供读者学习领悟。\n\n谢谢！\n\nwingjay\n\n\n\n\n\n欢迎各位关注\n[我的Github](https://github.com/wingjay): <https://github.com/wingjay> \n和\n[我的简书](http://www.jianshu.com/users/da333fd63fe5/latest_articles): <http://www.jianshu.com/users/da333fd63fe5/latest_articles>\n和\n[微博 iam_wingjay](http://weibo.com/u/1625892654): <http://weibo.com/u/1625892654>\n如果有问题，可以给我留言或发邮件<mailto:yinjiesh@126.com>\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n","source":"_posts/带你学开源项目：Meizhi-Android之RxJava-Retrofit最佳实践.md","raw":"title: '带你学开源项目：Meizhi Android之RxJava & Retrofit最佳实践'\ndate: 2016-04-13 00:17:28\ncategories:\n  - Android\n  - 带你学开源项目\ntags:\n\t- Android\n  - 带你学开源项目\ncommentIssueId: 16  \n---\n> 私以为，阅读开源项目是与世界级技术大牛直接对话的最好方式。\n此次来分享下 Meizhi Android 源码的分析。\n\n<!-- more -->\n\n## 零、背景\n比起阅读枯燥的技术文档，独自苦苦摸索新技术的基本用法，还有一种更好更快速也更有效的提高自身技术的方法，那就是阅读学习优质的开源项目，通过仿写、练习最终达到理解，潜移默化提升自身编程技能。\n\n《带你学开源项目》系列将带领你深入阅读及分析当前流行的一些开源项目，并针对其中采用的新技术与精妙之处进行细致的阐述，以期让你快速掌握Android开发中的多种强大技能点。\n\n\n## 一、本期开源项目Meizhi Android\n本次的开源项目选择了[Meizhi Android](https://github.com/drakeet/Meizhi)，本文主要介绍该项目中采用的`RxJava`、`Retrofit`两种技术，这二者在Android开发者中非常流行，不仅能够`优美地处理异步回调`，而且能`提高代码的性能和稳定性`。而Meizhi Android中较好的覆盖了二者的多种应用场景，能够给多数开发者一个全面的学习。\n\n下面本人会`对原项目的代码进行详细的介绍`，同时为了读者看的清楚其中的逻辑关系，可能会做一定调整以帮助读者理解，比如把lambda表达式还原成普通java函数形式，以避免很多读者对lambda并不熟悉。\n\n## 二、原项目分析\n### 0. clone项目到本地\n第一步当然是把项目clone下来，编译，运行。有兴趣的同学可以执行这一步。\n### 1. 添加`Stetho`抓包工具\n首先，由于我们要分析retrofit，所以为了查看app的网络请求，有兴趣的同学可以手动在代码里添加[Stetho](http://facebook.github.io/stetho/)。`Stetho`是Facebook推出的一款黑科技，能够在chrome里轻松查看app所有的网络请求，比起iOS需要装个[Charles](https://www.charlesproxy.com/)查看http请求方便多咯。\n\n![Stetho使用场景](http://upload-images.jianshu.io/upload_images/281665-50854bb575db05f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 2. Retrofit结构\n从下图我们可以看到，首页里有很多card，每一个card里有两个元素：`妹纸图片`， `描述文字`，具体UI实现我们不在乎，只要明白一点，这两个元素数据是来自于两个不同的api。其中，`妹纸图片`来自于`http://gank.io/api/data/福利/10`;`描述文字`来自于`http://gank.io/api/data/休息视频/10`。\n\napp中为了请求网络数据，采用了[Retrofit](http://square.github.io/retrofit/)。具体关于retrofit如何配置请各位参考官网，这里只讲解如何使用`Retrofit`。\n\n该项目中主要创建了以下几个类来实现`Retrofit`结构，大家可以作为参考用于自己的项目中。\n\n ##### i. `GankApi`：这个类用来定义相关的`http`接口，这是符合retrofit规范的定义形式，每一个api返回的为`Observable<T>`格式结果，方便`RxJava`进行进一步处理。\n    @GET(\"/data/福利/{page}\") Observable<MeizhiList> getMeizhiList(@Path(\"page\") int page);\n    @GET(\"/data/休息视频/{page}\") Observable<GankVideoList> getGankVideoList(@Path(\"page\") int page);\n##### ii. `DrakeetRetrofit`：这个类用来对`Retrofit`进行相关配置并生成`GankApi`实例`gankApi`\n    OkHttpClient client = new OkHttpClient();\n    RestAdapter.Builder builder = new RestAdapter.Builder();\n    builder.setClient(new OkClient(client))\n          .setLogLevel(RestAdapter.LogLevel.FULL) \n          .setEndpoint(\"http://gank.io/api\")\n          .setConverter(new GsonConverter(gson));\n    RestAdapter gankRestAdapter = builder.build();\n    GankApi gankApi = gankRestAdapter.create(GankApi.class);\n\n    public GankApi getGankApi() {    \n        return gankApi;\n    }\n##### iii. `DrakeetFactory`： 这个类用来对外生成单例`GankApi`实例，为确保`GankApi`实例只生成一次。\n    public static GankApi getGankApi() {    \n        if (sGankApi == null) {\n            synchronized (monitor) {        \n               if (sGankApi == null) {            \n                  sGankApi = new DrakeetRetrofit().getGankApi();        \n               }       \n               return sGankApi;    \n            }\n        }\n    }\n\n所以，在实际应用场景中，比如我们想要发起一个http请求来获取`福利`数据，那么我们可以采用以下方式：\n\n    GankApi gankApi = DrakeetFactory.getGankApi();\n    Observable<MeizhiList> meizhiList = gankApi. getMeizhiList(10);\n\n\n![首页.png](http://upload-images.jianshu.io/upload_images/281665-2129d871aff9a884.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 3. 首页的RxJava的实现\n既然我们已经把网络框架搭建好了，那么可以开始从服务器获取数据并显示了。我们首先看首页的数据。下面，我来对首页数据进行分析，一步步推出所需要的RxJava表达式。\n\n上面已经介绍过，每一个card里有两部分数据：`妹纸图片`(红色方框)和`描述文本`(绿色方框)。\n\n- `妹纸图片`数据来自于`\"/data/福利/{page}\"`这个api，该api会返回妹纸图片的url；\n- `描述文本`来自于`\"/data/休息视频/{page}\"`这个api，该api会返回休息视频及相关描述信息，card里会把描述信息显示出来；\n- 两个api均可以携带`page`字段，即一次请求可以获得多个数据。如我们在`\"/data/福利/{page}\"`里设置`page=10`，那么我们一次请求可以得到10条`福利`数据，即`10张妹纸图片url`；\n- 由于我们一次可以获得多张妹纸图片url和多个视频信息，那我们就需要把`二者进行合并`，即`单拎出来一张妹纸图片和一个视频信息组装成一个card`。然后按这种方式生成其他的card。\n\n小结一下，根据以上描述，假如我们把两个api的page都设置为`10`，那么两个请求同时发出去后，我们能得到`10张妹纸图片url`（如`http://img.com/1.png`, `http://img.com/2.png`, ...）和`10个视频信息`(如`舌尖上的中国`, `星际穿越`， ...)，然后我们将二者组装成`10个card所需要的数据`，放入每个card里显示即可。\n\n好，终于可以开始动手写代码了。上面的分析看似复杂，然后只要你学会了如何分析，很快就能写出对应的RxJava代码。下面我结合RxJava的`数据流思想`和`具体操作符`来介绍实现代码。\n\n##### i. 在网络请求数据之前，我们要创建几个数据entry对象来将获取回来的json字符串转化为object\n    public class Meizhi {\n        public String url;\n        public Date publishDate;\n    } //这是一个Meizhi对象，存储妹纸图片的url，图片描述信息和创建日期\n\n    public class Video {\n      public String desc;\n      public Date publishDate;\n    } //这是一个视频对象，存储视频描述信息和创建日期\n\n    public class MeizhiList {\n      public List<Meizhi> meizhiList;\n    } //由于我们一次请求能获取到10个(根据`page`设置)，所以我们用MeizhiList来存储结果\n\n    public class VideoList {\n      public List<Video> videoList;\n    } //原理同上，存储多个video对象\n\n    public class MeizhiWithVideo {\n      public String url;\n      public String desc;\n      public Date publishDate;\n    }//将video信息合并入meizhi对象中\n    \n    public class MeizhiWithVideoList {\n      public List<MeizhiWithVideoList> data;\n    }\n  \n##### ii. zip: 将两个retrofit接口请求后得到的两个数据源Observable<MeizhiList>  Observable<VideoList>进行合并\n我们需要把这两个数据源的数据拼接起来，所以我们可以考虑使用[zip操作符](http://reactivex.io/documentation/operators/zip.html)，该操作符可以将两个数据源发射出来的数据依次组装在一起。\n\n比如一个`Observable数据源`依次发射出`1, 3, 5, 7`, 另一个`Observable数据源`依次发射出`a, b, c, d`，那么`zip操作符`组装后会对外发射出`1a, 3b, 5c, 7d`这样的数据。\n\n而我们需要的正是这样。\n\n`Observable<MeizhiList>`一次对外发射一个`MeizhiList`对象，`Observable<VideoList>`一次对外发射一个`VideoList`对象，我们将二者合并成一个`MeizhiWithVideoList`对象。然后把`MeizhiWithVideoList`对象拿给UI去进行显示即可。\n\n所以，我们可以得到：\n\n    Observable<MeizhiList> meizhiListObservable = gankApi.getMeizhiList(10);\n    Observable<VideoList> videoListObservable = gankApi.getVideoList(10);\n    Observable<MeizhiWithVideoList> meizhiWithVideoListObservable = \n    Observable.zip(meizhiListObservable, videoListObservable, this::mergeVideoWithMeizhi)\n\n其中`mergeVideoWithMeizhi`是一个合并函数，把`video`信息与`meizhi`信息合并成新的`MeizhiWithVideo对象`。\n\n    public MeizhiWithVideoList\n    mergeVideoWithMeizhi(MeizhiList meizhiList, VideoList videoList) {//省略...}\n\n![RxJava - zip](http://upload-images.jianshu.io/upload_images/281665-91320f2cce108a8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n##### iii. 对MeizhiWithVideo对象进行排序。\n在上面，我们通过合并，得到了  `Observable<MeizhiWithVideoList>`数据源，这个数据源对外发射出一个`MeizhiWithVideoList`对象，这个对象里有10个`MeizhiWithVideo`数据，我们可以对这10个数据利用它们的发布日期进行排序。\n\n所以我们要实现以下几步：\n- 先把`Observable<MeizhiWithVideoList>`数据源转化为`Observable<List<MeizhiWithVideo>>`，从对外发一个`MeizhiWithVideoList`对象变成对外发射一个`List<MeizhiWithVideo>`对象；\n\n- 再把`Observale<List<MeizhiWithVideo>>`转化为`Observable<MeizhiWithVideo>`数据源，变成了对外发射出10个`MeizhiWithVideo`对象;\n\n- 对这10个`MeizhiWithVideo`对象基于`publishDate`进行排序；\n\n- 其中比较操作很耗cpu，所以我们放在`Schedulers.computation()`线程中做\n\n代码实现：\n    \n    meizhiWithVideoListObservable.map(new Func1<MeizhiWithVideoList, List<MeizhiWithVideo>>() {    \n          @Override    \n          public List<Meizhi> call(MeizhiList meizhiList) {                \n                return MeizhiWithVideoList.data;    \n          }\n    })\n    .flatMap(new Func1<List<MeizhiWithVideo>, Observable<MeizhiWithVideo>>() {    \n          @Override    \n          public Observable<MeizhiWithVideo> call(List<MeizhiWithVideo> meizhiWithVideos) {        \n                return Observable.from(meizhiWithVideos);    \n          }\n    })\n    .toSortedList(new Func2<MeizhiWithVideo, MeizhiWithVideo, Integer>() {    \n          @Override    \n          public Integer call(MeizhiWithVideo meizhiWithVideo1, MeizhiWithVideo meizhiWithVideo2) {        \n                return meizhiWithVideo2.publishedAt.compareTo(meizhiWithVideo1.publishedAt);    \n          }\n    })\n    .subscribeOn(Schedulers.computation());\n\n##### iv. 排序后，我们得到`Observable<List<MeizhiWithVideo>>`数据源，传给adapter去更新UI\n上面的`toSortedList(xxx)`方法会把`Observable<MeizhiWithVideo>`排序后重新组装成`Observable<List<MeizhiWithVideo>>`对象`sortedMVListObservable`，该对象对外发射一个`有序的List<MeizhiWithVideo>`。我们将该数据源提供给adapter供显示。\n\n代码如下：\n\n    sortedMVListObservable.observeOn(AndroidSchedulers.mainThread())\n    .subscribe(new Subscriber<List<MeizhiWithVideo>>() {    \n        @Override    \n        public void onCompleted() {            \n            setRefresh(false); // stop refreshing data.                 \n        }    \n        @Override    \n        public void onError(Throwable e) {    \n\n        }\n        @Override    \n        public void onNext(List<MeizhiWithVideo> meizhiWithVideoList) {    \n            adapter.setData(meizhiWithVideoList);\n            adapter.notifyDataSetChanged(); // update UI\n        }\n    })\n\n### 4. 利用`Subscription`来管理异步处理与Activity生命周期\n对于异步我们知道一直存在一个问题，假设一个页面要同时发出很多个http请求，如http1, http2, http3...，然后这些请求会被放在一个队列里依次发出，而且每个请求发出后需要等待一段时间才能得到返回数据。\n\n那么问题就来了，假设在A页面发出了多个网络请求，在这些网络请求还在等待响应时用户就跳转到了B页面，在以前的情况下是，A页面的网络请求仍然进行直到所有数据返回，而且当数据返回时会尝试去调用A页面的UI进行修改，而此时已经进入了B页面，所以，这不仅造成了网络资源的浪费，也存在一定的风险。\n\n有了RxJava，我们可以把每一个网络请求转化为一个`Subscription`对象，这个`Subscription`对象可以被手动`unsubscribe`，即停止订阅所请求的数据源，这样就可以暂定数据请求，而且即使数据返回回来，由于我已经取消订阅了，所以不会再接收到这些数据了。\n\n代码实现：\n在`BaseActivity`中，创建一个`CompositeSubscription`对象来进行管理\n\n    `BaseActivity`\n    private CompositeSubscription mCompositeSubscription;\n    protected void addSubscription(Subscription s) {   \n       if (this.mCompositeSubscription == null) {                \n            this.mCompositeSubscription = new CompositeSubscription();    \n        }    \n        this.mCompositeSubscription.add(s);\n    }\n\n    @Override \n    protected void onDestroy() {    \n          super.onDestroy();    \n          if (this.mCompositeSubscription != null) {                \n                this.mCompositeSubscription.unsubscribe();    \n          }\n    }\n\n在实际的Activity中的网络请求:\n\n    public class MyActivity extends BaseActivity {\n      \n        private void loadData() {\n            Subscription s = gankApi.getMeizhiList(10)                           \n                                         .subscribeOn(Schedulers.io())\n                                         .observeOn(AndroidSchedulers.mainThread())\n                                         .subscribe(...);\n            addSubscription(s);\n        }\n    }\n\n## 三、改进及总结\n本文通过对开源项目[Meizhi Android](https://github.com/drakeet/Meizhi)进行分析，了解了`Retrofit`，`RxJava`的实际应用场景，也对于二者有了更加深入的认识。\n\n不过本人认为该项目还有一些可以改善的地方，比如`Retrofit`中利用`DrakeetFactory`工厂来生成`GankApi`的单例，但是`new DrakeetRetrofit().getGankApi();`也是一个可以生成`GankApi`的方法，而且是`public`的，那么如果新的开发者忘记调用`DrakeetFactory`来生成`GankApi`的实例，而是采用后者，那么工厂模式就达不到预期的目的了。我认为可以把`new DrakeetRetrofit().getGankApi();`这个操作内容放在`DrakeetFactory`工厂内部，并且设置为`private`属性，这样的话如果想要获得`GankApi`实例，就必须依靠`DrakeetFactory`来生成，从而真正保证了`单例`的优势。\n\n最后，如果读者有意见欢迎评论，本人后续还会挑选优质的开源项目，分析其精髓，供读者学习领悟。\n\n谢谢！\n\nwingjay\n\n\n\n\n\n欢迎各位关注\n[我的Github](https://github.com/wingjay): <https://github.com/wingjay> \n和\n[我的简书](http://www.jianshu.com/users/da333fd63fe5/latest_articles): <http://www.jianshu.com/users/da333fd63fe5/latest_articles>\n和\n[微博 iam_wingjay](http://weibo.com/u/1625892654): <http://weibo.com/u/1625892654>\n如果有问题，可以给我留言或发邮件<mailto:yinjiesh@126.com>\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n","slug":"带你学开源项目：Meizhi-Android之RxJava-Retrofit最佳实践","published":1,"updated":"2018-11-26T06:56:27.485Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplsi6002w3dn8toyria3y","content":"<blockquote>\n<p>私以为，阅读开源项目是与世界级技术大牛直接对话的最好方式。<br>此次来分享下 Meizhi Android 源码的分析。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"零、背景\"><a href=\"# 零、背景\" class=\"headerlink\" title=\"零、背景\"></a>零、背景 </h2><p> 比起阅读枯燥的技术文档，独自苦苦摸索新技术的基本用法，还有一种更好更快速也更有效的提高自身技术的方法，那就是阅读学习优质的开源项目，通过仿写、练习最终达到理解，潜移默化提升自身编程技能。</p>\n<p>《带你学开源项目》系列将带领你深入阅读及分析当前流行的一些开源项目，并针对其中采用的新技术与精妙之处进行细致的阐述，以期让你快速掌握 Android 开发中的多种强大技能点。</p>\n<h2 id=\"一、本期开源项目 Meizhi-Android\"><a href=\"# 一、本期开源项目 Meizhi-Android\" class=\"headerlink\" title=\"一、本期开源项目 Meizhi Android\"></a>一、本期开源项目 Meizhi Android</h2><p>本次的开源项目选择了 <a href=\"https://github.com/drakeet/Meizhi\" target=\"_blank\" rel=\"external\">Meizhi Android</a>，本文主要介绍该项目中采用的<code>RxJava</code>、<code>Retrofit</code> 两种技术，这二者在 Android 开发者中非常流行，不仅能够 <code> 优美地处理异步回调 </code>，而且能<code> 提高代码的性能和稳定性</code>。而 Meizhi Android 中较好的覆盖了二者的多种应用场景，能够给多数开发者一个全面的学习。</p>\n<p>下面本人会 <code> 对原项目的代码进行详细的介绍</code>，同时为了读者看的清楚其中的逻辑关系，可能会做一定调整以帮助读者理解，比如把 lambda 表达式还原成普通 java 函数形式，以避免很多读者对 lambda 并不熟悉。</p>\n<h2 id=\"二、原项目分析\"><a href=\"# 二、原项目分析\" class=\"headerlink\" title=\"二、原项目分析\"></a>二、原项目分析 </h2><h3 id=\"0-clone 项目到本地\"><a href=\"#0-clone 项目到本地\" class=\"headerlink\" title=\"0. clone 项目到本地\"></a>0. clone 项目到本地</h3><p> 第一步当然是把项目 clone 下来，编译，运行。有兴趣的同学可以执行这一步。</p>\n<h3 id=\"1- 添加 Stetho 抓包工具\"><a href=\"#1- 添加 Stetho 抓包工具\" class=\"headerlink\" title=\"1. 添加 Stetho 抓包工具\"></a>1. 添加 <code>Stetho</code> 抓包工具 </h3><p> 首先，由于我们要分析 retrofit，所以为了查看 app 的网络请求，有兴趣的同学可以手动在代码里添加 <a href=\"http://facebook.github.io/stetho/\" target=\"_blank\" rel=\"external\">Stetho</a>。<code>Stetho</code> 是 Facebook 推出的一款黑科技，能够在 chrome 里轻松查看 app 所有的网络请求，比起 iOS 需要装个 <a href=\"https://www.charlesproxy.com/\" target=\"_blank\" rel=\"external\">Charles</a> 查看 http 请求方便多咯。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/281665-50854bb575db05f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Stetho 使用场景\"></p>\n<h3 id=\"2-Retrofit 结构\"><a href=\"#2-Retrofit 结构\" class=\"headerlink\" title=\"2. Retrofit 结构\"></a>2. Retrofit 结构 </h3><p> 从下图我们可以看到，首页里有很多 card，每一个 card 里有两个元素：<code>妹纸图片 </code>， <code> 描述文字 </code>，具体 UI 实现我们不在乎，只要明白一点，这两个元素数据是来自于两个不同的 api。其中，<code> 妹纸图片 </code> 来自于 <code>http://gank.io/api/data/ 福利 /10</code>;<code> 描述文字 </code> 来自于<code>http://gank.io/api/data/ 休息视频 /10</code>。</p>\n<p>app 中为了请求网络数据，采用了<a href=\"http://square.github.io/retrofit/\" target=\"_blank\" rel=\"external\">Retrofit</a>。具体关于 retrofit 如何配置请各位参考官网，这里只讲解如何使用<code>Retrofit</code>。</p>\n<p>该项目中主要创建了以下几个类来实现 <code>Retrofit</code> 结构，大家可以作为参考用于自己的项目中。</p>\n<h5 id=\"i-GankApi：这个类用来定义相关的 http 接口，这是符合 retrofit 规范的定义形式，每一个 api 返回的为 Observable-lt-T-gt- 格式结果，方便 RxJava 进行进一步处理。\"><a href=\"#i-GankApi：这个类用来定义相关的 http 接口，这是符合 retrofit 规范的定义形式，每一个 api 返回的为 Observable-lt-T-gt- 格式结果，方便 RxJava 进行进一步处理。\" class=\"headerlink\" title=\"i. GankApi：这个类用来定义相关的 http 接口，这是符合 retrofit 规范的定义形式，每一个 api 返回的为 Observable&lt;T&gt; 格式结果，方便 RxJava 进行进一步处理。\"></a>i. <code>GankApi</code>：这个类用来定义相关的 <code>http</code> 接口，这是符合 retrofit 规范的定义形式，每一个 api 返回的为 <code>Observable&lt;T&gt;</code> 格式结果，方便 <code>RxJava</code> 进行进一步处理。</h5><pre><code>@GET(&quot;/data/ 福利 /{page}&quot;) Observable&lt;MeizhiList&gt; getMeizhiList(@Path(&quot;page&quot;) int page);\n@GET(&quot;/data/ 休息视频 /{page}&quot;) Observable&lt;GankVideoList&gt; getGankVideoList(@Path(&quot;page&quot;) int page);\n</code></pre><h5 id=\"ii-DrakeetRetrofit：这个类用来对 Retrofit 进行相关配置并生成 GankApi 实例 gankApi\"><a href=\"#ii-DrakeetRetrofit：这个类用来对 Retrofit 进行相关配置并生成 GankApi 实例 gankApi\" class=\"headerlink\" title=\"ii. DrakeetRetrofit：这个类用来对 Retrofit 进行相关配置并生成 GankApi 实例 gankApi\"></a>ii. <code>DrakeetRetrofit</code>：这个类用来对 <code>Retrofit</code> 进行相关配置并生成 <code>GankApi</code> 实例<code>gankApi</code></h5><pre><code>OkHttpClient client = new OkHttpClient();\nRestAdapter.Builder builder = new RestAdapter.Builder();\nbuilder.setClient(new OkClient(client))\n      .setLogLevel(RestAdapter.LogLevel.FULL) \n      .setEndpoint(&quot;http://gank.io/api&quot;)\n      .setConverter(new GsonConverter(gson));\nRestAdapter gankRestAdapter = builder.build();\nGankApi gankApi = gankRestAdapter.create(GankApi.class);\n\npublic GankApi getGankApi() {return gankApi;}\n</code></pre><h5 id=\"iii-DrakeetFactory：- 这个类用来对外生成单例 GankApi 实例，为确保 GankApi 实例只生成一次。\"><a href=\"#iii-DrakeetFactory：- 这个类用来对外生成单例 GankApi 实例，为确保 GankApi 实例只生成一次。\" class=\"headerlink\" title=\"iii. DrakeetFactory： 这个类用来对外生成单例 GankApi 实例，为确保 GankApi 实例只生成一次。\"></a>iii. <code>DrakeetFactory</code>： 这个类用来对外生成单例 <code>GankApi</code> 实例，为确保 <code>GankApi</code> 实例只生成一次。</h5><pre><code>public static GankApi getGankApi() {if (sGankApi == null) {synchronized (monitor) {if (sGankApi == null) {sGankApi = new DrakeetRetrofit().getGankApi();}       \n           return sGankApi;    \n        }\n    }\n}\n</code></pre><p>所以，在实际应用场景中，比如我们想要发起一个 http 请求来获取 <code> 福利 </code> 数据，那么我们可以采用以下方式：</p>\n<pre><code>GankApi gankApi = DrakeetFactory.getGankApi();\nObservable&lt;MeizhiList&gt; meizhiList = gankApi. getMeizhiList(10);\n</code></pre><p><img src=\"http://upload-images.jianshu.io/upload_images/281665-2129d871aff9a884.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"首页.png\"></p>\n<h3 id=\"3- 首页的 RxJava 的实现\"><a href=\"#3- 首页的 RxJava 的实现\" class=\"headerlink\" title=\"3. 首页的 RxJava 的实现\"></a>3. 首页的 RxJava 的实现 </h3><p> 既然我们已经把网络框架搭建好了，那么可以开始从服务器获取数据并显示了。我们首先看首页的数据。下面，我来对首页数据进行分析，一步步推出所需要的 RxJava 表达式。</p>\n<p>上面已经介绍过，每一个 card 里有两部分数据：<code>妹纸图片 </code>(红色方框) 和<code>描述文本</code>(绿色方框)。</p>\n<ul>\n<li><code>妹纸图片 </code> 数据来自于 <code>&quot;/data/ 福利 /{page}&quot;</code> 这个 api，该 api 会返回妹纸图片的 url；</li>\n<li><code>描述文本 </code> 来自于 <code>&quot;/data/ 休息视频 /{page}&quot;</code> 这个 api，该 api 会返回休息视频及相关描述信息，card 里会把描述信息显示出来；</li>\n<li>两个 api 均可以携带 <code>page</code> 字段，即一次请求可以获得多个数据。如我们在 <code>&quot;/data/ 福利 /{page}&quot;</code> 里设置 <code>page=10</code>，那么我们一次请求可以得到 10 条<code> 福利 </code> 数据，即<code>10 张妹纸图片 url</code>；</li>\n<li>由于我们一次可以获得多张妹纸图片 url 和多个视频信息，那我们就需要把 <code> 二者进行合并 </code>，即<code> 单拎出来一张妹纸图片和一个视频信息组装成一个 card</code>。然后按这种方式生成其他的 card。</li>\n</ul>\n<p>小结一下，根据以上描述，假如我们把两个 api 的 page 都设置为 <code>10</code>，那么两个请求同时发出去后，我们能得到<code>10 张妹纸图片 url</code>（如<code>http://img.com/1.png</code>, <code>http://img.com/2.png</code>, …）和<code>10 个视频信息</code>(如<code> 舌尖上的中国 </code>, <code> 星际穿越</code>， …)，然后我们将二者组装成<code>10 个 card 所需要的数据</code>，放入每个 card 里显示即可。</p>\n<p>好，终于可以开始动手写代码了。上面的分析看似复杂，然后只要你学会了如何分析，很快就能写出对应的 RxJava 代码。下面我结合 RxJava 的 <code> 数据流思想 </code> 和<code>具体操作符 </code> 来介绍实现代码。</p>\n<h5 id=\"i- 在网络请求数据之前，我们要创建几个数据 entry 对象来将获取回来的 json 字符串转化为 object\"><a href=\"#i- 在网络请求数据之前，我们要创建几个数据 entry 对象来将获取回来的 json 字符串转化为 object\" class=\"headerlink\" title=\"i. 在网络请求数据之前，我们要创建几个数据 entry 对象来将获取回来的 json 字符串转化为 object\"></a>i. 在网络请求数据之前，我们要创建几个数据 entry 对象来将获取回来的 json 字符串转化为 object</h5><pre><code>public class Meizhi {\n    public String url;\n    public Date publishDate;\n} // 这是一个 Meizhi 对象，存储妹纸图片的 url，图片描述信息和创建日期\n\npublic class Video {\n  public String desc;\n  public Date publishDate;\n} // 这是一个视频对象，存储视频描述信息和创建日期\n\npublic class MeizhiList {public List&lt;Meizhi&gt; meizhiList;} // 由于我们一次请求能获取到 10 个(根据 `page` 设置)，所以我们用 MeizhiList 来存储结果\n\npublic class VideoList {public List&lt;Video&gt; videoList;} // 原理同上，存储多个 video 对象\n\npublic class MeizhiWithVideo {\n  public String url;\n  public String desc;\n  public Date publishDate;\n}// 将 video 信息合并入 meizhi 对象中\n\npublic class MeizhiWithVideoList {public List&lt;MeizhiWithVideoList&gt; data;}\n</code></pre><h5 id=\"ii-zip- 将两个 retrofit 接口请求后得到的两个数据源 Observable-Observable 进行合并\"><a href=\"#ii-zip- 将两个 retrofit 接口请求后得到的两个数据源 Observable-Observable 进行合并\" class=\"headerlink\" title=\"ii. zip: 将两个 retrofit 接口请求后得到的两个数据源 Observable  Observable 进行合并\"></a>ii. zip: 将两个 retrofit 接口请求后得到的两个数据源 Observable<meizhilist>  Observable<videolist>进行合并 </videolist></meizhilist></h5><p> 我们需要把这两个数据源的数据拼接起来，所以我们可以考虑使用<a href=\"http://reactivex.io/documentation/operators/zip.html\" target=\"_blank\" rel=\"external\">zip 操作符</a>，该操作符可以将两个数据源发射出来的数据依次组装在一起。</p>\n<p>比如一个 <code>Observable 数据源</code> 依次发射出 <code>1, 3, 5, 7</code>, 另一个<code>Observable 数据源</code> 依次发射出 <code>a, b, c, d</code>，那么<code>zip 操作符</code> 组装后会对外发射出 <code>1a, 3b, 5c, 7d</code> 这样的数据。</p>\n<p>而我们需要的正是这样。</p>\n<p><code>Observable&lt;MeizhiList&gt;</code>一次对外发射一个 <code>MeizhiList</code> 对象，<code>Observable&lt;VideoList&gt;</code>一次对外发射一个 <code>VideoList</code> 对象，我们将二者合并成一个 <code>MeizhiWithVideoList</code> 对象。然后把 <code>MeizhiWithVideoList</code> 对象拿给 UI 去进行显示即可。</p>\n<p>所以，我们可以得到：</p>\n<pre><code>Observable&lt;MeizhiList&gt; meizhiListObservable = gankApi.getMeizhiList(10);\nObservable&lt;VideoList&gt; videoListObservable = gankApi.getVideoList(10);\nObservable&lt;MeizhiWithVideoList&gt; meizhiWithVideoListObservable = \nObservable.zip(meizhiListObservable, videoListObservable, this::mergeVideoWithMeizhi)\n</code></pre><p>其中 <code>mergeVideoWithMeizhi</code> 是一个合并函数，把 <code>video</code> 信息与 <code>meizhi</code> 信息合并成新的<code>MeizhiWithVideo 对象</code>。</p>\n<pre><code>public MeizhiWithVideoList\nmergeVideoWithMeizhi(MeizhiList meizhiList, VideoList videoList) {// 省略...}\n</code></pre><p><img src=\"http://upload-images.jianshu.io/upload_images/281665-91320f2cce108a8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"RxJava - zip\"></p>\n<h5 id=\"iii- 对 MeizhiWithVideo 对象进行排序。\"><a href=\"#iii- 对 MeizhiWithVideo 对象进行排序。\" class=\"headerlink\" title=\"iii. 对 MeizhiWithVideo 对象进行排序。\"></a>iii. 对 MeizhiWithVideo 对象进行排序。</h5><p>在上面，我们通过合并，得到了  <code>Observable&lt;MeizhiWithVideoList&gt;</code>数据源，这个数据源对外发射出一个 <code>MeizhiWithVideoList</code> 对象，这个对象里有 10 个 <code>MeizhiWithVideo</code> 数据，我们可以对这 10 个数据利用它们的发布日期进行排序。</p>\n<p>所以我们要实现以下几步：</p>\n<ul>\n<li><p>先把 <code>Observable&lt;MeizhiWithVideoList&gt;</code> 数据源转化为 <code>Observable&lt;List&lt;MeizhiWithVideo&gt;&gt;</code>，从对外发一个<code>MeizhiWithVideoList</code> 对象变成对外发射一个 <code>List&lt;MeizhiWithVideo&gt;</code> 对象；</p>\n</li>\n<li><p>再把 <code>Observale&lt;List&lt;MeizhiWithVideo&gt;&gt;</code> 转化为 <code>Observable&lt;MeizhiWithVideo&gt;</code> 数据源，变成了对外发射出 10 个 <code>MeizhiWithVideo</code> 对象;</p>\n</li>\n<li><p>对这 10 个 <code>MeizhiWithVideo</code> 对象基于 <code>publishDate</code> 进行排序；</p>\n</li>\n<li><p>其中比较操作很耗 cpu，所以我们放在 <code>Schedulers.computation()</code> 线程中做</p>\n</li>\n</ul>\n<p>代码实现：</p>\n<pre><code>meizhiWithVideoListObservable.map(new Func1&lt;MeizhiWithVideoList, List&lt;MeizhiWithVideo&gt;&gt;() {    \n      @Override    \n      public List&lt;Meizhi&gt; call(MeizhiList meizhiList) {return MeizhiWithVideoList.data;}\n})\n.flatMap(new Func1&lt;List&lt;MeizhiWithVideo&gt;, Observable&lt;MeizhiWithVideo&gt;&gt;() {    \n      @Override    \n      public Observable&lt;MeizhiWithVideo&gt; call(List&lt;MeizhiWithVideo&gt; meizhiWithVideos) {return Observable.from(meizhiWithVideos);    \n      }\n})\n.toSortedList(new Func2&lt;MeizhiWithVideo, MeizhiWithVideo, Integer&gt;() {    \n      @Override    \n      public Integer call(MeizhiWithVideo meizhiWithVideo1, MeizhiWithVideo meizhiWithVideo2) {return meizhiWithVideo2.publishedAt.compareTo(meizhiWithVideo1.publishedAt);    \n      }\n})\n.subscribeOn(Schedulers.computation());\n</code></pre><h5 id=\"iv- 排序后，我们得到 Observable-lt-List-lt-MeizhiWithVideo-gt-gt- 数据源，传给 adapter 去更新 UI\"><a href=\"#iv- 排序后，我们得到 Observable-lt-List-lt-MeizhiWithVideo-gt-gt- 数据源，传给 adapter 去更新 UI\" class=\"headerlink\" title=\"iv. 排序后，我们得到 Observable&lt;List&lt;MeizhiWithVideo&gt;&gt; 数据源，传给 adapter 去更新 UI\"></a>iv. 排序后，我们得到 <code>Observable&lt;List&lt;MeizhiWithVideo&gt;&gt;</code> 数据源，传给 adapter 去更新 UI</h5><p>上面的 <code>toSortedList(xxx)</code> 方法会把 <code>Observable&lt;MeizhiWithVideo&gt;</code> 排序后重新组装成 <code>Observable&lt;List&lt;MeizhiWithVideo&gt;&gt;</code> 对象 <code>sortedMVListObservable</code>，该对象对外发射一个<code> 有序的 List&lt;MeizhiWithVideo&gt;</code>。我们将该数据源提供给 adapter 供显示。</p>\n<p>代码如下：</p>\n<pre><code>sortedMVListObservable.observeOn(AndroidSchedulers.mainThread())\n.subscribe(new Subscriber&lt;List&lt;MeizhiWithVideo&gt;&gt;() {    \n    @Override    \n    public void onCompleted() {setRefresh(false); // stop refreshing data.                 \n    }    \n    @Override    \n    public void onError(Throwable e) { }\n    @Override    \n    public void onNext(List&lt;MeizhiWithVideo&gt; meizhiWithVideoList) {adapter.setData(meizhiWithVideoList);\n        adapter.notifyDataSetChanged(); // update UI}\n})\n</code></pre><h3 id=\"4- 利用 Subscription 来管理异步处理与 Activity 生命周期\"><a href=\"#4- 利用 Subscription 来管理异步处理与 Activity 生命周期\" class=\"headerlink\" title=\"4. 利用 Subscription 来管理异步处理与 Activity 生命周期\"></a>4. 利用 <code>Subscription</code> 来管理异步处理与 Activity 生命周期 </h3><p> 对于异步我们知道一直存在一个问题，假设一个页面要同时发出很多个 http 请求，如 http1, http2, http3…，然后这些请求会被放在一个队列里依次发出，而且每个请求发出后需要等待一段时间才能得到返回数据。</p>\n<p>那么问题就来了，假设在 A 页面发出了多个网络请求，在这些网络请求还在等待响应时用户就跳转到了 B 页面，在以前的情况下是，A 页面的网络请求仍然进行直到所有数据返回，而且当数据返回时会尝试去调用 A 页面的 UI 进行修改，而此时已经进入了 B 页面，所以，这不仅造成了网络资源的浪费，也存在一定的风险。</p>\n<p>有了 RxJava，我们可以把每一个网络请求转化为一个 <code>Subscription</code> 对象，这个 <code>Subscription</code> 对象可以被手动<code>unsubscribe</code>，即停止订阅所请求的数据源，这样就可以暂定数据请求，而且即使数据返回回来，由于我已经取消订阅了，所以不会再接收到这些数据了。</p>\n<p>代码实现：<br>在 <code>BaseActivity</code> 中，创建一个 <code>CompositeSubscription</code> 对象来进行管理</p>\n<pre><code>`BaseActivity`\nprivate CompositeSubscription mCompositeSubscription;\nprotected void addSubscription(Subscription s) {if (this.mCompositeSubscription == null) {this.mCompositeSubscription = new CompositeSubscription();    \n    }    \n    this.mCompositeSubscription.add(s);\n}\n\n@Override \nprotected void onDestroy() {super.onDestroy();    \n      if (this.mCompositeSubscription != null) {this.mCompositeSubscription.unsubscribe();    \n      }\n}\n</code></pre><p>在实际的 Activity 中的网络请求:</p>\n<pre><code>public class MyActivity extends BaseActivity {private void loadData() {Subscription s = gankApi.getMeizhiList(10)                           \n                                     .subscribeOn(Schedulers.io())\n                                     .observeOn(AndroidSchedulers.mainThread())\n                                     .subscribe(...);\n        addSubscription(s);\n    }\n}\n</code></pre><h2 id=\"三、改进及总结\"><a href=\"# 三、改进及总结\" class=\"headerlink\" title=\"三、改进及总结\"></a>三、改进及总结 </h2><p> 本文通过对开源项目 <a href=\"https://github.com/drakeet/Meizhi\" target=\"_blank\" rel=\"external\">Meizhi Android</a> 进行分析，了解了 <code>Retrofit</code>，<code>RxJava</code> 的实际应用场景，也对于二者有了更加深入的认识。</p>\n<p>不过本人认为该项目还有一些可以改善的地方，比如 <code>Retrofit</code> 中利用 <code>DrakeetFactory</code> 工厂来生成 <code>GankApi</code> 的单例，但是 <code>new DrakeetRetrofit().getGankApi();</code> 也是一个可以生成 <code>GankApi</code> 的方法，而且是 <code>public</code> 的，那么如果新的开发者忘记调用 <code>DrakeetFactory</code> 来生成 <code>GankApi</code> 的实例，而是采用后者，那么工厂模式就达不到预期的目的了。我认为可以把 <code>new DrakeetRetrofit().getGankApi();</code> 这个操作内容放在 <code>DrakeetFactory</code> 工厂内部，并且设置为 <code>private</code> 属性，这样的话如果想要获得 <code>GankApi</code> 实例，就必须依靠 <code>DrakeetFactory</code> 来生成，从而真正保证了 <code> 单例 </code> 的优势。</p>\n<p>最后，如果读者有意见欢迎评论，本人后续还会挑选优质的开源项目，分析其精髓，供读者学习领悟。</p>\n<p>谢谢！</p>\n<p>wingjay</p>\n<p>欢迎各位关注 <br><a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\"> 我的 Github</a>: <a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\">https://github.com/wingjay</a><br>和 <br><a href=\"http://www.jianshu.com/users/da333fd63fe5/latest_articles\" target=\"_blank\" rel=\"external\"> 我的简书 </a>: <a href=\"http://www.jianshu.com/users/da333fd63fe5/latest_articles\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/users/da333fd63fe5/latest_articles</a><br> 和<br><a href=\"http://weibo.com/u/1625892654\" target=\"_blank\" rel=\"external\">微博 iam_wingjay</a>: <a href=\"http://weibo.com/u/1625892654\" target=\"_blank\" rel=\"external\">http://weibo.com/u/1625892654</a><br>如果有问题，可以给我留言或发邮件<a href=\"&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#x79;&#105;&#x6e;&#106;&#x69;&#x65;&#x73;&#x68;&#x40;&#x31;&#x32;&#x36;&#x2e;&#99;&#x6f;&#109;\">&#x79;&#105;&#x6e;&#106;&#x69;&#x65;&#x73;&#x68;&#x40;&#x31;&#x32;&#x36;&#x2e;&#99;&#x6f;&#109;</a></p>\n<p><img src=\"https://avatars0.githubusercontent.com/u/9619875?v=3&amp;s=460\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>私以为，阅读开源项目是与世界级技术大牛直接对话的最好方式。<br>此次来分享下 Meizhi Android 源码的分析。</p>\n</blockquote>","more":"<h2 id=\"零、背景\"><a href=\"#零、背景\" class=\"headerlink\" title=\"零、背景\"></a>零、背景</h2><p>比起阅读枯燥的技术文档，独自苦苦摸索新技术的基本用法，还有一种更好更快速也更有效的提高自身技术的方法，那就是阅读学习优质的开源项目，通过仿写、练习最终达到理解，潜移默化提升自身编程技能。</p>\n<p>《带你学开源项目》系列将带领你深入阅读及分析当前流行的一些开源项目，并针对其中采用的新技术与精妙之处进行细致的阐述，以期让你快速掌握Android开发中的多种强大技能点。</p>\n<h2 id=\"一、本期开源项目Meizhi-Android\"><a href=\"#一、本期开源项目Meizhi-Android\" class=\"headerlink\" title=\"一、本期开源项目Meizhi Android\"></a>一、本期开源项目Meizhi Android</h2><p>本次的开源项目选择了<a href=\"https://github.com/drakeet/Meizhi\" target=\"_blank\" rel=\"external\">Meizhi Android</a>，本文主要介绍该项目中采用的<code>RxJava</code>、<code>Retrofit</code>两种技术，这二者在Android开发者中非常流行，不仅能够<code>优美地处理异步回调</code>，而且能<code>提高代码的性能和稳定性</code>。而Meizhi Android中较好的覆盖了二者的多种应用场景，能够给多数开发者一个全面的学习。</p>\n<p>下面本人会<code>对原项目的代码进行详细的介绍</code>，同时为了读者看的清楚其中的逻辑关系，可能会做一定调整以帮助读者理解，比如把lambda表达式还原成普通java函数形式，以避免很多读者对lambda并不熟悉。</p>\n<h2 id=\"二、原项目分析\"><a href=\"#二、原项目分析\" class=\"headerlink\" title=\"二、原项目分析\"></a>二、原项目分析</h2><h3 id=\"0-clone项目到本地\"><a href=\"#0-clone项目到本地\" class=\"headerlink\" title=\"0. clone项目到本地\"></a>0. clone项目到本地</h3><p>第一步当然是把项目clone下来，编译，运行。有兴趣的同学可以执行这一步。</p>\n<h3 id=\"1-添加Stetho抓包工具\"><a href=\"#1-添加Stetho抓包工具\" class=\"headerlink\" title=\"1. 添加Stetho抓包工具\"></a>1. 添加<code>Stetho</code>抓包工具</h3><p>首先，由于我们要分析retrofit，所以为了查看app的网络请求，有兴趣的同学可以手动在代码里添加<a href=\"http://facebook.github.io/stetho/\" target=\"_blank\" rel=\"external\">Stetho</a>。<code>Stetho</code>是Facebook推出的一款黑科技，能够在chrome里轻松查看app所有的网络请求，比起iOS需要装个<a href=\"https://www.charlesproxy.com/\" target=\"_blank\" rel=\"external\">Charles</a>查看http请求方便多咯。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/281665-50854bb575db05f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Stetho使用场景\"></p>\n<h3 id=\"2-Retrofit结构\"><a href=\"#2-Retrofit结构\" class=\"headerlink\" title=\"2. Retrofit结构\"></a>2. Retrofit结构</h3><p>从下图我们可以看到，首页里有很多card，每一个card里有两个元素：<code>妹纸图片</code>， <code>描述文字</code>，具体UI实现我们不在乎，只要明白一点，这两个元素数据是来自于两个不同的api。其中，<code>妹纸图片</code>来自于<code>http://gank.io/api/data/福利/10</code>;<code>描述文字</code>来自于<code>http://gank.io/api/data/休息视频/10</code>。</p>\n<p>app中为了请求网络数据，采用了<a href=\"http://square.github.io/retrofit/\" target=\"_blank\" rel=\"external\">Retrofit</a>。具体关于retrofit如何配置请各位参考官网，这里只讲解如何使用<code>Retrofit</code>。</p>\n<p>该项目中主要创建了以下几个类来实现<code>Retrofit</code>结构，大家可以作为参考用于自己的项目中。</p>\n<h5 id=\"i-GankApi：这个类用来定义相关的http接口，这是符合retrofit规范的定义形式，每一个api返回的为Observable-lt-T-gt-格式结果，方便RxJava进行进一步处理。\"><a href=\"#i-GankApi：这个类用来定义相关的http接口，这是符合retrofit规范的定义形式，每一个api返回的为Observable-lt-T-gt-格式结果，方便RxJava进行进一步处理。\" class=\"headerlink\" title=\"i. GankApi：这个类用来定义相关的http接口，这是符合retrofit规范的定义形式，每一个api返回的为Observable&lt;T&gt;格式结果，方便RxJava进行进一步处理。\"></a>i. <code>GankApi</code>：这个类用来定义相关的<code>http</code>接口，这是符合retrofit规范的定义形式，每一个api返回的为<code>Observable&lt;T&gt;</code>格式结果，方便<code>RxJava</code>进行进一步处理。</h5><pre><code>@GET(&quot;/data/福利/{page}&quot;) Observable&lt;MeizhiList&gt; getMeizhiList(@Path(&quot;page&quot;) int page);\n@GET(&quot;/data/休息视频/{page}&quot;) Observable&lt;GankVideoList&gt; getGankVideoList(@Path(&quot;page&quot;) int page);\n</code></pre><h5 id=\"ii-DrakeetRetrofit：这个类用来对Retrofit进行相关配置并生成GankApi实例gankApi\"><a href=\"#ii-DrakeetRetrofit：这个类用来对Retrofit进行相关配置并生成GankApi实例gankApi\" class=\"headerlink\" title=\"ii. DrakeetRetrofit：这个类用来对Retrofit进行相关配置并生成GankApi实例gankApi\"></a>ii. <code>DrakeetRetrofit</code>：这个类用来对<code>Retrofit</code>进行相关配置并生成<code>GankApi</code>实例<code>gankApi</code></h5><pre><code>OkHttpClient client = new OkHttpClient();\nRestAdapter.Builder builder = new RestAdapter.Builder();\nbuilder.setClient(new OkClient(client))\n      .setLogLevel(RestAdapter.LogLevel.FULL) \n      .setEndpoint(&quot;http://gank.io/api&quot;)\n      .setConverter(new GsonConverter(gson));\nRestAdapter gankRestAdapter = builder.build();\nGankApi gankApi = gankRestAdapter.create(GankApi.class);\n\npublic GankApi getGankApi() {    \n    return gankApi;\n}\n</code></pre><h5 id=\"iii-DrakeetFactory：-这个类用来对外生成单例GankApi实例，为确保GankApi实例只生成一次。\"><a href=\"#iii-DrakeetFactory：-这个类用来对外生成单例GankApi实例，为确保GankApi实例只生成一次。\" class=\"headerlink\" title=\"iii. DrakeetFactory： 这个类用来对外生成单例GankApi实例，为确保GankApi实例只生成一次。\"></a>iii. <code>DrakeetFactory</code>： 这个类用来对外生成单例<code>GankApi</code>实例，为确保<code>GankApi</code>实例只生成一次。</h5><pre><code>public static GankApi getGankApi() {    \n    if (sGankApi == null) {\n        synchronized (monitor) {        \n           if (sGankApi == null) {            \n              sGankApi = new DrakeetRetrofit().getGankApi();        \n           }       \n           return sGankApi;    \n        }\n    }\n}\n</code></pre><p>所以，在实际应用场景中，比如我们想要发起一个http请求来获取<code>福利</code>数据，那么我们可以采用以下方式：</p>\n<pre><code>GankApi gankApi = DrakeetFactory.getGankApi();\nObservable&lt;MeizhiList&gt; meizhiList = gankApi. getMeizhiList(10);\n</code></pre><p><img src=\"http://upload-images.jianshu.io/upload_images/281665-2129d871aff9a884.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"首页.png\"></p>\n<h3 id=\"3-首页的RxJava的实现\"><a href=\"#3-首页的RxJava的实现\" class=\"headerlink\" title=\"3. 首页的RxJava的实现\"></a>3. 首页的RxJava的实现</h3><p>既然我们已经把网络框架搭建好了，那么可以开始从服务器获取数据并显示了。我们首先看首页的数据。下面，我来对首页数据进行分析，一步步推出所需要的RxJava表达式。</p>\n<p>上面已经介绍过，每一个card里有两部分数据：<code>妹纸图片</code>(红色方框)和<code>描述文本</code>(绿色方框)。</p>\n<ul>\n<li><code>妹纸图片</code>数据来自于<code>&quot;/data/福利/{page}&quot;</code>这个api，该api会返回妹纸图片的url；</li>\n<li><code>描述文本</code>来自于<code>&quot;/data/休息视频/{page}&quot;</code>这个api，该api会返回休息视频及相关描述信息，card里会把描述信息显示出来；</li>\n<li>两个api均可以携带<code>page</code>字段，即一次请求可以获得多个数据。如我们在<code>&quot;/data/福利/{page}&quot;</code>里设置<code>page=10</code>，那么我们一次请求可以得到10条<code>福利</code>数据，即<code>10张妹纸图片url</code>；</li>\n<li>由于我们一次可以获得多张妹纸图片url和多个视频信息，那我们就需要把<code>二者进行合并</code>，即<code>单拎出来一张妹纸图片和一个视频信息组装成一个card</code>。然后按这种方式生成其他的card。</li>\n</ul>\n<p>小结一下，根据以上描述，假如我们把两个api的page都设置为<code>10</code>，那么两个请求同时发出去后，我们能得到<code>10张妹纸图片url</code>（如<code>http://img.com/1.png</code>, <code>http://img.com/2.png</code>, …）和<code>10个视频信息</code>(如<code>舌尖上的中国</code>, <code>星际穿越</code>， …)，然后我们将二者组装成<code>10个card所需要的数据</code>，放入每个card里显示即可。</p>\n<p>好，终于可以开始动手写代码了。上面的分析看似复杂，然后只要你学会了如何分析，很快就能写出对应的RxJava代码。下面我结合RxJava的<code>数据流思想</code>和<code>具体操作符</code>来介绍实现代码。</p>\n<h5 id=\"i-在网络请求数据之前，我们要创建几个数据entry对象来将获取回来的json字符串转化为object\"><a href=\"#i-在网络请求数据之前，我们要创建几个数据entry对象来将获取回来的json字符串转化为object\" class=\"headerlink\" title=\"i. 在网络请求数据之前，我们要创建几个数据entry对象来将获取回来的json字符串转化为object\"></a>i. 在网络请求数据之前，我们要创建几个数据entry对象来将获取回来的json字符串转化为object</h5><pre><code>public class Meizhi {\n    public String url;\n    public Date publishDate;\n} //这是一个Meizhi对象，存储妹纸图片的url，图片描述信息和创建日期\n\npublic class Video {\n  public String desc;\n  public Date publishDate;\n} //这是一个视频对象，存储视频描述信息和创建日期\n\npublic class MeizhiList {\n  public List&lt;Meizhi&gt; meizhiList;\n} //由于我们一次请求能获取到10个(根据`page`设置)，所以我们用MeizhiList来存储结果\n\npublic class VideoList {\n  public List&lt;Video&gt; videoList;\n} //原理同上，存储多个video对象\n\npublic class MeizhiWithVideo {\n  public String url;\n  public String desc;\n  public Date publishDate;\n}//将video信息合并入meizhi对象中\n\npublic class MeizhiWithVideoList {\n  public List&lt;MeizhiWithVideoList&gt; data;\n}\n</code></pre><h5 id=\"ii-zip-将两个retrofit接口请求后得到的两个数据源Observable-Observable进行合并\"><a href=\"#ii-zip-将两个retrofit接口请求后得到的两个数据源Observable-Observable进行合并\" class=\"headerlink\" title=\"ii. zip: 将两个retrofit接口请求后得到的两个数据源Observable  Observable进行合并\"></a>ii. zip: 将两个retrofit接口请求后得到的两个数据源Observable<meizhilist>  Observable<videolist>进行合并</videolist></meizhilist></h5><p>我们需要把这两个数据源的数据拼接起来，所以我们可以考虑使用<a href=\"http://reactivex.io/documentation/operators/zip.html\" target=\"_blank\" rel=\"external\">zip操作符</a>，该操作符可以将两个数据源发射出来的数据依次组装在一起。</p>\n<p>比如一个<code>Observable数据源</code>依次发射出<code>1, 3, 5, 7</code>, 另一个<code>Observable数据源</code>依次发射出<code>a, b, c, d</code>，那么<code>zip操作符</code>组装后会对外发射出<code>1a, 3b, 5c, 7d</code>这样的数据。</p>\n<p>而我们需要的正是这样。</p>\n<p><code>Observable&lt;MeizhiList&gt;</code>一次对外发射一个<code>MeizhiList</code>对象，<code>Observable&lt;VideoList&gt;</code>一次对外发射一个<code>VideoList</code>对象，我们将二者合并成一个<code>MeizhiWithVideoList</code>对象。然后把<code>MeizhiWithVideoList</code>对象拿给UI去进行显示即可。</p>\n<p>所以，我们可以得到：</p>\n<pre><code>Observable&lt;MeizhiList&gt; meizhiListObservable = gankApi.getMeizhiList(10);\nObservable&lt;VideoList&gt; videoListObservable = gankApi.getVideoList(10);\nObservable&lt;MeizhiWithVideoList&gt; meizhiWithVideoListObservable = \nObservable.zip(meizhiListObservable, videoListObservable, this::mergeVideoWithMeizhi)\n</code></pre><p>其中<code>mergeVideoWithMeizhi</code>是一个合并函数，把<code>video</code>信息与<code>meizhi</code>信息合并成新的<code>MeizhiWithVideo对象</code>。</p>\n<pre><code>public MeizhiWithVideoList\nmergeVideoWithMeizhi(MeizhiList meizhiList, VideoList videoList) {//省略...}\n</code></pre><p><img src=\"http://upload-images.jianshu.io/upload_images/281665-91320f2cce108a8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"RxJava - zip\"></p>\n<h5 id=\"iii-对MeizhiWithVideo对象进行排序。\"><a href=\"#iii-对MeizhiWithVideo对象进行排序。\" class=\"headerlink\" title=\"iii. 对MeizhiWithVideo对象进行排序。\"></a>iii. 对MeizhiWithVideo对象进行排序。</h5><p>在上面，我们通过合并，得到了  <code>Observable&lt;MeizhiWithVideoList&gt;</code>数据源，这个数据源对外发射出一个<code>MeizhiWithVideoList</code>对象，这个对象里有10个<code>MeizhiWithVideo</code>数据，我们可以对这10个数据利用它们的发布日期进行排序。</p>\n<p>所以我们要实现以下几步：</p>\n<ul>\n<li><p>先把<code>Observable&lt;MeizhiWithVideoList&gt;</code>数据源转化为<code>Observable&lt;List&lt;MeizhiWithVideo&gt;&gt;</code>，从对外发一个<code>MeizhiWithVideoList</code>对象变成对外发射一个<code>List&lt;MeizhiWithVideo&gt;</code>对象；</p>\n</li>\n<li><p>再把<code>Observale&lt;List&lt;MeizhiWithVideo&gt;&gt;</code>转化为<code>Observable&lt;MeizhiWithVideo&gt;</code>数据源，变成了对外发射出10个<code>MeizhiWithVideo</code>对象;</p>\n</li>\n<li><p>对这10个<code>MeizhiWithVideo</code>对象基于<code>publishDate</code>进行排序；</p>\n</li>\n<li><p>其中比较操作很耗cpu，所以我们放在<code>Schedulers.computation()</code>线程中做</p>\n</li>\n</ul>\n<p>代码实现：</p>\n<pre><code>meizhiWithVideoListObservable.map(new Func1&lt;MeizhiWithVideoList, List&lt;MeizhiWithVideo&gt;&gt;() {    \n      @Override    \n      public List&lt;Meizhi&gt; call(MeizhiList meizhiList) {                \n            return MeizhiWithVideoList.data;    \n      }\n})\n.flatMap(new Func1&lt;List&lt;MeizhiWithVideo&gt;, Observable&lt;MeizhiWithVideo&gt;&gt;() {    \n      @Override    \n      public Observable&lt;MeizhiWithVideo&gt; call(List&lt;MeizhiWithVideo&gt; meizhiWithVideos) {        \n            return Observable.from(meizhiWithVideos);    \n      }\n})\n.toSortedList(new Func2&lt;MeizhiWithVideo, MeizhiWithVideo, Integer&gt;() {    \n      @Override    \n      public Integer call(MeizhiWithVideo meizhiWithVideo1, MeizhiWithVideo meizhiWithVideo2) {        \n            return meizhiWithVideo2.publishedAt.compareTo(meizhiWithVideo1.publishedAt);    \n      }\n})\n.subscribeOn(Schedulers.computation());\n</code></pre><h5 id=\"iv-排序后，我们得到Observable-lt-List-lt-MeizhiWithVideo-gt-gt-数据源，传给adapter去更新UI\"><a href=\"#iv-排序后，我们得到Observable-lt-List-lt-MeizhiWithVideo-gt-gt-数据源，传给adapter去更新UI\" class=\"headerlink\" title=\"iv. 排序后，我们得到Observable&lt;List&lt;MeizhiWithVideo&gt;&gt;数据源，传给adapter去更新UI\"></a>iv. 排序后，我们得到<code>Observable&lt;List&lt;MeizhiWithVideo&gt;&gt;</code>数据源，传给adapter去更新UI</h5><p>上面的<code>toSortedList(xxx)</code>方法会把<code>Observable&lt;MeizhiWithVideo&gt;</code>排序后重新组装成<code>Observable&lt;List&lt;MeizhiWithVideo&gt;&gt;</code>对象<code>sortedMVListObservable</code>，该对象对外发射一个<code>有序的List&lt;MeizhiWithVideo&gt;</code>。我们将该数据源提供给adapter供显示。</p>\n<p>代码如下：</p>\n<pre><code>sortedMVListObservable.observeOn(AndroidSchedulers.mainThread())\n.subscribe(new Subscriber&lt;List&lt;MeizhiWithVideo&gt;&gt;() {    \n    @Override    \n    public void onCompleted() {            \n        setRefresh(false); // stop refreshing data.                 \n    }    \n    @Override    \n    public void onError(Throwable e) {    \n\n    }\n    @Override    \n    public void onNext(List&lt;MeizhiWithVideo&gt; meizhiWithVideoList) {    \n        adapter.setData(meizhiWithVideoList);\n        adapter.notifyDataSetChanged(); // update UI\n    }\n})\n</code></pre><h3 id=\"4-利用Subscription来管理异步处理与Activity生命周期\"><a href=\"#4-利用Subscription来管理异步处理与Activity生命周期\" class=\"headerlink\" title=\"4. 利用Subscription来管理异步处理与Activity生命周期\"></a>4. 利用<code>Subscription</code>来管理异步处理与Activity生命周期</h3><p>对于异步我们知道一直存在一个问题，假设一个页面要同时发出很多个http请求，如http1, http2, http3…，然后这些请求会被放在一个队列里依次发出，而且每个请求发出后需要等待一段时间才能得到返回数据。</p>\n<p>那么问题就来了，假设在A页面发出了多个网络请求，在这些网络请求还在等待响应时用户就跳转到了B页面，在以前的情况下是，A页面的网络请求仍然进行直到所有数据返回，而且当数据返回时会尝试去调用A页面的UI进行修改，而此时已经进入了B页面，所以，这不仅造成了网络资源的浪费，也存在一定的风险。</p>\n<p>有了RxJava，我们可以把每一个网络请求转化为一个<code>Subscription</code>对象，这个<code>Subscription</code>对象可以被手动<code>unsubscribe</code>，即停止订阅所请求的数据源，这样就可以暂定数据请求，而且即使数据返回回来，由于我已经取消订阅了，所以不会再接收到这些数据了。</p>\n<p>代码实现：<br>在<code>BaseActivity</code>中，创建一个<code>CompositeSubscription</code>对象来进行管理</p>\n<pre><code>`BaseActivity`\nprivate CompositeSubscription mCompositeSubscription;\nprotected void addSubscription(Subscription s) {   \n   if (this.mCompositeSubscription == null) {                \n        this.mCompositeSubscription = new CompositeSubscription();    \n    }    \n    this.mCompositeSubscription.add(s);\n}\n\n@Override \nprotected void onDestroy() {    \n      super.onDestroy();    \n      if (this.mCompositeSubscription != null) {                \n            this.mCompositeSubscription.unsubscribe();    \n      }\n}\n</code></pre><p>在实际的Activity中的网络请求:</p>\n<pre><code>public class MyActivity extends BaseActivity {\n\n    private void loadData() {\n        Subscription s = gankApi.getMeizhiList(10)                           \n                                     .subscribeOn(Schedulers.io())\n                                     .observeOn(AndroidSchedulers.mainThread())\n                                     .subscribe(...);\n        addSubscription(s);\n    }\n}\n</code></pre><h2 id=\"三、改进及总结\"><a href=\"#三、改进及总结\" class=\"headerlink\" title=\"三、改进及总结\"></a>三、改进及总结</h2><p>本文通过对开源项目<a href=\"https://github.com/drakeet/Meizhi\" target=\"_blank\" rel=\"external\">Meizhi Android</a>进行分析，了解了<code>Retrofit</code>，<code>RxJava</code>的实际应用场景，也对于二者有了更加深入的认识。</p>\n<p>不过本人认为该项目还有一些可以改善的地方，比如<code>Retrofit</code>中利用<code>DrakeetFactory</code>工厂来生成<code>GankApi</code>的单例，但是<code>new DrakeetRetrofit().getGankApi();</code>也是一个可以生成<code>GankApi</code>的方法，而且是<code>public</code>的，那么如果新的开发者忘记调用<code>DrakeetFactory</code>来生成<code>GankApi</code>的实例，而是采用后者，那么工厂模式就达不到预期的目的了。我认为可以把<code>new DrakeetRetrofit().getGankApi();</code>这个操作内容放在<code>DrakeetFactory</code>工厂内部，并且设置为<code>private</code>属性，这样的话如果想要获得<code>GankApi</code>实例，就必须依靠<code>DrakeetFactory</code>来生成，从而真正保证了<code>单例</code>的优势。</p>\n<p>最后，如果读者有意见欢迎评论，本人后续还会挑选优质的开源项目，分析其精髓，供读者学习领悟。</p>\n<p>谢谢！</p>\n<p>wingjay</p>\n<p>欢迎各位关注<br><a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\">我的Github</a>: <a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\">https://github.com/wingjay</a><br>和<br><a href=\"http://www.jianshu.com/users/da333fd63fe5/latest_articles\" target=\"_blank\" rel=\"external\">我的简书</a>: <a href=\"http://www.jianshu.com/users/da333fd63fe5/latest_articles\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/users/da333fd63fe5/latest_articles</a><br>和<br><a href=\"http://weibo.com/u/1625892654\" target=\"_blank\" rel=\"external\">微博 iam_wingjay</a>: <a href=\"http://weibo.com/u/1625892654\" target=\"_blank\" rel=\"external\">http://weibo.com/u/1625892654</a><br>如果有问题，可以给我留言或发邮件<a href=\"&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#x79;&#105;&#x6e;&#106;&#x69;&#x65;&#x73;&#x68;&#x40;&#x31;&#x32;&#x36;&#x2e;&#99;&#x6f;&#109;\">&#x79;&#105;&#x6e;&#106;&#x69;&#x65;&#x73;&#x68;&#x40;&#x31;&#x32;&#x36;&#x2e;&#99;&#x6f;&#109;</a></p>\n<p><img src=\"https://avatars0.githubusercontent.com/u/9619875?v=3&amp;s=460\" alt=\"\"></p>","sticky":0},{"title":"我与代码的相知相遇","date":"2015-12-28T16:12:45.000Z","commentIssueId":null,"_content":"> 误打误撞进入了计算机的世界，觉得有趣，就一直留在这里\n\n<!-- more -->\n![](https://drscdn.500px.org/photo/3706985/m%3D2048/d9cba44c9d66f27d27e1628fa7f4606c)\n\nHi，我是wingjay\n------------------------------------------------------------------\n大家好，我是[《如何在一天之内搭建以你自己名字为域名且具备cool属性的个人博客》](http://www.jianshu.com/p/99665608d295)、[如何在一天之内完成一款具备cool属性的Android产品<简诗>](http://www.jianshu.com/p/cf496fc408b2)的作者[wingjay](https://github.com/wingjay)，今天抽空来和大家一起告别2015，迎接新的技术成长的一年。\n\n\n再过半年，我就要从交大硕士毕业了。\n------------------------------------------------------------------\n2013年9月入学交大，自动化小硕，从没想过未来会从事计算机相关行业，因为对于编程我唯一的背景就是大二那年的C语言课程。\n\n我是怎么开始对编程感兴趣的？不记得了，也不会有人关心。只知道那时逢人就介绍智能手机的硬件配置多么发烧，喜欢调侃小米的成功哲学，也跟风追着“大数据”和“云计算”这两朵云奔跑。\n\n慢慢的，觉得搞计算机的人很酷。\n\n那时，我正式入学。\n\n\n也在那时，我缠着父母给我买了一款手机－小米2s。我记得我对着这款手机盯了快半个小时，乐的。\n\n然后开启了两年的研究生生涯。\n\n没有我想象的顺利，但也没有我想象的不堪。\n\n用两句话来概括这两年吧：\n\n1. 第一年我把除了马克思之外所有的课都认真学了一遍，还选修了诸如机器学习、模式识别和数据挖掘等课程，这一年，感觉踏实。\n\n2. 第二年，30%的时间去提心吊胆地帮导师干杂活；70%的时间背着导师更加提心吊胆地去学习编程，这一年，以为自己会消沉，后来没有。\n\n自学编程的那些日子\n------------------------------------------------------------------\n还是那句话，现在吃的苦，都是当年专业没选计算机时脑子进的水。\n\n2014年初，作为一名只会C语言的我而言，真正开始自学计算机，依次经历了以下几步：\n\n1. 14年3月，师兄说要学编程，先学基础。于是我过了一遍数据结构和操作系统的书，过的比较粗略；\n\n2. 14年4月，想学Android开发，在网上发现了Mars的教程视频。于是我每天只要有空就背着导师偷偷看视频，做笔记。学习Android的同时也顺带着学了些Java的知识。每天晚上还会在新浪博客或博客园上把自己的笔记记录上去，虽然这种做法并没什么作用，但那时觉得很happy。\n\n3. 14年6月，视频自学效果不佳，我非常苦恼。那时我非常希望有人能够来帮帮我这个新手，同时我每天去寻找实践的机会。要知道，作为一名研究生，导师每天管着你，不能放开学，很不爽的。不过，上天眷顾，我终于找到一份校内实习，技术开发，离实验室又近，每天还有80元的工资，天，那几天我感觉我复活了！\n\n4. 14年6月中到11月，开始学习网站开发。校内实习启动，我过上了白天实验室，晚上工作室的日子了。工作室四个人，两个大牛，两个菜鸟，我当然是后者。6月到11月，我饥渴地学习！开始做网站，前端、后端、数据库。这半年我差不多每天是白天在实验室干完活之后晚上去写代码，半年下来，差不多把前端的html、css、js和一些框架Bootstrap、jQuery等，后端的php，和如thinkphp等框架，还有数据库MySQL、MongoDB都学了一通。空闲时也自己配置过服务器，搭建自己的网站。\n\n5. 15年3月到5月，算是开始了Android开发学习之路吧。15年，也就是今年，三月开学时，工作室里两个人离开了，一个是被导师抓走干活了，另一个大三的准备毕业了。于是工作室就只剩我和一位大牛。说实话，有点寂寞，但我的热情并没有减少。相反，我仍旧专注于Android的开发和学习。实验室方面，到了今年，反而轻松了些，每天上午和晚上在工作室，下午跑回实验室蹲班。另外在实际的开发中，我发现以前视频学的东西和实际应用相差很大，可能那些更基础吧，总之我几乎又是从零开始去学习，从项目中自学。\n\n6. 15年5月，我学了近三个月的Android开发，虽然工作室另一位大牛偶尔会帮我，但多数时候还是我一头人默默对着电脑学习、研究和修bug。不过好歹这几个月时间把工作室之前的一款Android应用重新写了一遍，每天晚上学到深夜，冒着寒风骑车回宿舍的场景我记得清楚。最后开发完的应用，工作室的指导老师很满意，我也对自己比较满意。\n\n7. 15年5月中到6月，工作室只剩我一人了。我没有想到，在六月某一天，工作室的顶梁柱大牛说要去北京微软亚研院实习了，意味着整个工作室从最初的四个人只剩下我一个了。那时，我真感觉到有点孤单，看着身边做技术的小伙伴依次离开，到最后竟然只剩我自己一人。不过，我还是照常来工作室开发Android、学习，不过，这时只能一人去食堂吃饭，遇到问题也再没有人来指导，完全靠自己。\n\n8. 15年6月初，迷茫地寻找校外实习。我独自在工作室开发近一个月后，由于即将面临毕业，于是也开始寻找实习。那时摆在我眼前有两条路，大公司；创业公司。对我个人而言，我是追求技术成长的，不希望自己受限于某种技术，所以害怕大公司那种只让我一直从事某个项目的某个方面。所以在我心里，虽知大公司稳妥，但我更偏心于创业型公司。另外我也希望提高自己的英语，也希望有还不错的待遇，希望未来有好的职业发展规划。很多的希望，让我很迷茫，不知道能不能找到真正适合自己的企业。\n\n9. 15年6月中，确定实习公司Glow, 正式离开工作室。终于，我也要离开这个伴随我技术成长的地方了。这期间，我参加了一些公司的面试。大小公司都有，也拿到不少开发岗offer。当然，最后我选择了目前我所在的这家硅谷创业公司－－Glow。说到Glow，我就觉得有缘。一年前，我被Glow的招聘帖吸引，便去关注了公众号，说实话，Glow的Google背景、扁平式氛围一瞬间就吸引了我。不过接下来的一年再也没收到任何关于Glow的招聘信息，所以自己也就淡忘了，加之也觉得自己没戏，所以也就没有多想。直到今年找实习时，在路上走着突然想起这家公司，说实话那时除了Glow这个名字和这家公司很独特之外其他都不记得。于是我回到学校，把bbs重新翻了一遍，竟被我找回了那个招聘帖。之后大家就知道了，投递简历，电话面试，onsite面试。然后很快就入职了。\n\n10. 15年6月中到现在，Glow的Android开发实习生活。因为不想有软文的嫌疑，所以我也就不做太多介绍了。我只想说，在Glow的这半年，我和一堆Google大牛相处，技术成长很快。他们并不介怀我非计算机出身，也不担心我只有几个月的Android的开发背景。我想我唯一的优势就是努力了。开始时我还挺有压力，担心会拖他们的后腿，不过在他们的帮助下和我个人的不懈努力下，现在我已经能够很好的与他们合作，也得到了他们的认可。我最爱Glow的扁平氛围，我相信现在很多创业公司也如此，没有上下级，一心做好产品。\n\n在Glow的这半年，我不用提心吊胆担心导师随时来使唤我，我可以全身心来提高技术，而身边的人都随时准备帮助你。\n\n说实话，我感激自己这两年的坚持，感谢这两年遇到的大牛们。\n\n2016年的技术规划\n------------------------------------------------------------------\n2016年对我而言，是个大年。\n\n正式离开校园，步入工作。\n\n下面，简单列一下我的规划吧：\n\n1. 工作方面。目前我在Glow已经独立负责一整块的开发任务了，包括Android和服务器开发。我希望把自己在开源方面学到的新技术应用到我负责的模块上，持续地提高用户体验和稳定性，为用户提供更棒的作品。这点是我每天都在心心念念的。\n\n2. 个人技术方面。由于Glow不用加班，所以我平常会有很多的个人时间。我当然不准备把这些时间用在看剧和睡觉上。我会多去写作，之前在简书上写的几篇文章[《如何在一天之内搭建以你自己名字为域名且具备cool属性的个人博客》](http://www.jianshu.com/p/99665608d295)、[如何在一天之内完成一款具备cool属性的Android产品<简诗>](http://www.jianshu.com/p/cf496fc408b2)收获了不少读者，所以以后会继续努力。同时也会在[个人微博](http://weibo.com/1625892654)和[稀土](http://gold.xitu.io/#/user/562a410800b07d3623109a95)上多多分享优质文章。\n\n3. 开源方面。最近因为又忙实习又忙毕业写论文，就没有花太多时间做开源。只是贡献了两个库：[简诗](https://github.com/wingjay/jianshi) 和[BlurImageView](https://github.com/wingjay/BlurImageView)，加起来快一千个star左右。不过以后还会继续贡献优秀的库和大家分享的。\n\n4. [我的个人博客](http://wingjay.com) http://wingjay.com。\n除了技术，我也会开始提高自己的艺术方面的敏感度。比如开始接触建筑设计、文学方面的，一方面扩大自己的知识面，另一方面也是提高自己的感性思维吧。\n\n最近在读的书\n------------------------------------------------------------------\n1. 《一切始于设计－一个设计师的世博十日手记   －   迪人 著》\n这本书我看到了一位设计师对世界的认知，接触了世界各国的设计思想，如意大利、德国、法国等，收获很大！\n\n2. 《设计中的设计   －   原研哉 著》\n原研哉，无印良品设计总监。感受日本设计思想中留白这一概念，让人重新认识身边的事物。\n\n3. 《Android开发艺术探索  － 任玉刚 著》\n把Android里很多晦涩的概念讲解清楚，超喜欢里面对View的讲解，解开了我一个很大的困惑谜团。\n\n4. 《Android群英传  －  徐宜生 著》\n从实际开发的角度，讲解开发中常见的各种问题，结合上面那本书一起看，差不多能把多数开发问题搞明白。\n\n还有不少书，下次再来推荐吧！\n\n如果你也热爱技术，交个朋友吧\n------------------------------------------------------------------\n我是[wingjay](http://wingjay.com)，你可以通过我的[GitHub](https://github.com/wingjay)或者[简书平台](http://www.jianshu.com/users/da333fd63fe5/latest_articles)来找到我哦。\n\n谢谢！\n\n\n\n\n\n\n\n","source":"_posts/我与代码的相知相遇.md","raw":"title: 我与代码的相知相遇\ncategories:\n  - 随感\ntags:\n  - Goodbye2015 Hi 2016\n  - 随笔\ndate: 2015-12-29 00:12:45\ncommentIssueId: \n---\n> 误打误撞进入了计算机的世界，觉得有趣，就一直留在这里\n\n<!-- more -->\n![](https://drscdn.500px.org/photo/3706985/m%3D2048/d9cba44c9d66f27d27e1628fa7f4606c)\n\nHi，我是wingjay\n------------------------------------------------------------------\n大家好，我是[《如何在一天之内搭建以你自己名字为域名且具备cool属性的个人博客》](http://www.jianshu.com/p/99665608d295)、[如何在一天之内完成一款具备cool属性的Android产品<简诗>](http://www.jianshu.com/p/cf496fc408b2)的作者[wingjay](https://github.com/wingjay)，今天抽空来和大家一起告别2015，迎接新的技术成长的一年。\n\n\n再过半年，我就要从交大硕士毕业了。\n------------------------------------------------------------------\n2013年9月入学交大，自动化小硕，从没想过未来会从事计算机相关行业，因为对于编程我唯一的背景就是大二那年的C语言课程。\n\n我是怎么开始对编程感兴趣的？不记得了，也不会有人关心。只知道那时逢人就介绍智能手机的硬件配置多么发烧，喜欢调侃小米的成功哲学，也跟风追着“大数据”和“云计算”这两朵云奔跑。\n\n慢慢的，觉得搞计算机的人很酷。\n\n那时，我正式入学。\n\n\n也在那时，我缠着父母给我买了一款手机－小米2s。我记得我对着这款手机盯了快半个小时，乐的。\n\n然后开启了两年的研究生生涯。\n\n没有我想象的顺利，但也没有我想象的不堪。\n\n用两句话来概括这两年吧：\n\n1. 第一年我把除了马克思之外所有的课都认真学了一遍，还选修了诸如机器学习、模式识别和数据挖掘等课程，这一年，感觉踏实。\n\n2. 第二年，30%的时间去提心吊胆地帮导师干杂活；70%的时间背着导师更加提心吊胆地去学习编程，这一年，以为自己会消沉，后来没有。\n\n自学编程的那些日子\n------------------------------------------------------------------\n还是那句话，现在吃的苦，都是当年专业没选计算机时脑子进的水。\n\n2014年初，作为一名只会C语言的我而言，真正开始自学计算机，依次经历了以下几步：\n\n1. 14年3月，师兄说要学编程，先学基础。于是我过了一遍数据结构和操作系统的书，过的比较粗略；\n\n2. 14年4月，想学Android开发，在网上发现了Mars的教程视频。于是我每天只要有空就背着导师偷偷看视频，做笔记。学习Android的同时也顺带着学了些Java的知识。每天晚上还会在新浪博客或博客园上把自己的笔记记录上去，虽然这种做法并没什么作用，但那时觉得很happy。\n\n3. 14年6月，视频自学效果不佳，我非常苦恼。那时我非常希望有人能够来帮帮我这个新手，同时我每天去寻找实践的机会。要知道，作为一名研究生，导师每天管着你，不能放开学，很不爽的。不过，上天眷顾，我终于找到一份校内实习，技术开发，离实验室又近，每天还有80元的工资，天，那几天我感觉我复活了！\n\n4. 14年6月中到11月，开始学习网站开发。校内实习启动，我过上了白天实验室，晚上工作室的日子了。工作室四个人，两个大牛，两个菜鸟，我当然是后者。6月到11月，我饥渴地学习！开始做网站，前端、后端、数据库。这半年我差不多每天是白天在实验室干完活之后晚上去写代码，半年下来，差不多把前端的html、css、js和一些框架Bootstrap、jQuery等，后端的php，和如thinkphp等框架，还有数据库MySQL、MongoDB都学了一通。空闲时也自己配置过服务器，搭建自己的网站。\n\n5. 15年3月到5月，算是开始了Android开发学习之路吧。15年，也就是今年，三月开学时，工作室里两个人离开了，一个是被导师抓走干活了，另一个大三的准备毕业了。于是工作室就只剩我和一位大牛。说实话，有点寂寞，但我的热情并没有减少。相反，我仍旧专注于Android的开发和学习。实验室方面，到了今年，反而轻松了些，每天上午和晚上在工作室，下午跑回实验室蹲班。另外在实际的开发中，我发现以前视频学的东西和实际应用相差很大，可能那些更基础吧，总之我几乎又是从零开始去学习，从项目中自学。\n\n6. 15年5月，我学了近三个月的Android开发，虽然工作室另一位大牛偶尔会帮我，但多数时候还是我一头人默默对着电脑学习、研究和修bug。不过好歹这几个月时间把工作室之前的一款Android应用重新写了一遍，每天晚上学到深夜，冒着寒风骑车回宿舍的场景我记得清楚。最后开发完的应用，工作室的指导老师很满意，我也对自己比较满意。\n\n7. 15年5月中到6月，工作室只剩我一人了。我没有想到，在六月某一天，工作室的顶梁柱大牛说要去北京微软亚研院实习了，意味着整个工作室从最初的四个人只剩下我一个了。那时，我真感觉到有点孤单，看着身边做技术的小伙伴依次离开，到最后竟然只剩我自己一人。不过，我还是照常来工作室开发Android、学习，不过，这时只能一人去食堂吃饭，遇到问题也再没有人来指导，完全靠自己。\n\n8. 15年6月初，迷茫地寻找校外实习。我独自在工作室开发近一个月后，由于即将面临毕业，于是也开始寻找实习。那时摆在我眼前有两条路，大公司；创业公司。对我个人而言，我是追求技术成长的，不希望自己受限于某种技术，所以害怕大公司那种只让我一直从事某个项目的某个方面。所以在我心里，虽知大公司稳妥，但我更偏心于创业型公司。另外我也希望提高自己的英语，也希望有还不错的待遇，希望未来有好的职业发展规划。很多的希望，让我很迷茫，不知道能不能找到真正适合自己的企业。\n\n9. 15年6月中，确定实习公司Glow, 正式离开工作室。终于，我也要离开这个伴随我技术成长的地方了。这期间，我参加了一些公司的面试。大小公司都有，也拿到不少开发岗offer。当然，最后我选择了目前我所在的这家硅谷创业公司－－Glow。说到Glow，我就觉得有缘。一年前，我被Glow的招聘帖吸引，便去关注了公众号，说实话，Glow的Google背景、扁平式氛围一瞬间就吸引了我。不过接下来的一年再也没收到任何关于Glow的招聘信息，所以自己也就淡忘了，加之也觉得自己没戏，所以也就没有多想。直到今年找实习时，在路上走着突然想起这家公司，说实话那时除了Glow这个名字和这家公司很独特之外其他都不记得。于是我回到学校，把bbs重新翻了一遍，竟被我找回了那个招聘帖。之后大家就知道了，投递简历，电话面试，onsite面试。然后很快就入职了。\n\n10. 15年6月中到现在，Glow的Android开发实习生活。因为不想有软文的嫌疑，所以我也就不做太多介绍了。我只想说，在Glow的这半年，我和一堆Google大牛相处，技术成长很快。他们并不介怀我非计算机出身，也不担心我只有几个月的Android的开发背景。我想我唯一的优势就是努力了。开始时我还挺有压力，担心会拖他们的后腿，不过在他们的帮助下和我个人的不懈努力下，现在我已经能够很好的与他们合作，也得到了他们的认可。我最爱Glow的扁平氛围，我相信现在很多创业公司也如此，没有上下级，一心做好产品。\n\n在Glow的这半年，我不用提心吊胆担心导师随时来使唤我，我可以全身心来提高技术，而身边的人都随时准备帮助你。\n\n说实话，我感激自己这两年的坚持，感谢这两年遇到的大牛们。\n\n2016年的技术规划\n------------------------------------------------------------------\n2016年对我而言，是个大年。\n\n正式离开校园，步入工作。\n\n下面，简单列一下我的规划吧：\n\n1. 工作方面。目前我在Glow已经独立负责一整块的开发任务了，包括Android和服务器开发。我希望把自己在开源方面学到的新技术应用到我负责的模块上，持续地提高用户体验和稳定性，为用户提供更棒的作品。这点是我每天都在心心念念的。\n\n2. 个人技术方面。由于Glow不用加班，所以我平常会有很多的个人时间。我当然不准备把这些时间用在看剧和睡觉上。我会多去写作，之前在简书上写的几篇文章[《如何在一天之内搭建以你自己名字为域名且具备cool属性的个人博客》](http://www.jianshu.com/p/99665608d295)、[如何在一天之内完成一款具备cool属性的Android产品<简诗>](http://www.jianshu.com/p/cf496fc408b2)收获了不少读者，所以以后会继续努力。同时也会在[个人微博](http://weibo.com/1625892654)和[稀土](http://gold.xitu.io/#/user/562a410800b07d3623109a95)上多多分享优质文章。\n\n3. 开源方面。最近因为又忙实习又忙毕业写论文，就没有花太多时间做开源。只是贡献了两个库：[简诗](https://github.com/wingjay/jianshi) 和[BlurImageView](https://github.com/wingjay/BlurImageView)，加起来快一千个star左右。不过以后还会继续贡献优秀的库和大家分享的。\n\n4. [我的个人博客](http://wingjay.com) http://wingjay.com。\n除了技术，我也会开始提高自己的艺术方面的敏感度。比如开始接触建筑设计、文学方面的，一方面扩大自己的知识面，另一方面也是提高自己的感性思维吧。\n\n最近在读的书\n------------------------------------------------------------------\n1. 《一切始于设计－一个设计师的世博十日手记   －   迪人 著》\n这本书我看到了一位设计师对世界的认知，接触了世界各国的设计思想，如意大利、德国、法国等，收获很大！\n\n2. 《设计中的设计   －   原研哉 著》\n原研哉，无印良品设计总监。感受日本设计思想中留白这一概念，让人重新认识身边的事物。\n\n3. 《Android开发艺术探索  － 任玉刚 著》\n把Android里很多晦涩的概念讲解清楚，超喜欢里面对View的讲解，解开了我一个很大的困惑谜团。\n\n4. 《Android群英传  －  徐宜生 著》\n从实际开发的角度，讲解开发中常见的各种问题，结合上面那本书一起看，差不多能把多数开发问题搞明白。\n\n还有不少书，下次再来推荐吧！\n\n如果你也热爱技术，交个朋友吧\n------------------------------------------------------------------\n我是[wingjay](http://wingjay.com)，你可以通过我的[GitHub](https://github.com/wingjay)或者[简书平台](http://www.jianshu.com/users/da333fd63fe5/latest_articles)来找到我哦。\n\n谢谢！\n\n\n\n\n\n\n\n","slug":"我与代码的相知相遇","published":1,"updated":"2018-11-26T06:56:27.486Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplsi7002z3dn8v2p1ymyv","content":"<blockquote>\n<p>误打误撞进入了计算机的世界，觉得有趣，就一直留在这里</p>\n</blockquote>\n<a id=\"more\"></a>\n<p><img src=\"https://drscdn.500px.org/photo/3706985/m%3D2048/d9cba44c9d66f27d27e1628fa7f4606c\" alt=\"\"></p>\n<h2 id=\"Hi，我是 wingjay\"><a href=\"#Hi，我是 wingjay\" class=\"headerlink\" title=\"Hi，我是 wingjay\"></a>Hi，我是 wingjay</h2><p>大家好，我是 <a href=\"http://www.jianshu.com/p/99665608d295\" target=\"_blank\" rel=\"external\">《如何在一天之内搭建以你自己名字为域名且具备 cool 属性的个人博客》</a>、<a href=\"http://www.jianshu.com/p/cf496fc408b2\" target=\"_blank\" rel=\"external\"> 如何在一天之内完成一款具备 cool 属性的 Android 产品 &lt; 简诗 &gt;</a>的作者<a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\">wingjay</a>，今天抽空来和大家一起告别 2015，迎接新的技术成长的一年。</p>\n<h2 id=\"再过半年，我就要从交大硕士毕业了。\"><a href=\"# 再过半年，我就要从交大硕士毕业了。\" class=\"headerlink\" title=\"再过半年，我就要从交大硕士毕业了。\"></a>再过半年，我就要从交大硕士毕业了。</h2><p>2013 年 9 月入学交大，自动化小硕，从没想过未来会从事计算机相关行业，因为对于编程我唯一的背景就是大二那年的 C 语言课程。</p>\n<p>我是怎么开始对编程感兴趣的？不记得了，也不会有人关心。只知道那时逢人就介绍智能手机的硬件配置多么发烧，喜欢调侃小米的成功哲学，也跟风追着“大数据”和“云计算”这两朵云奔跑。</p>\n<p>慢慢的，觉得搞计算机的人很酷。</p>\n<p>那时，我正式入学。</p>\n<p>也在那时，我缠着父母给我买了一款手机－小米 2s。我记得我对着这款手机盯了快半个小时，乐的。</p>\n<p>然后开启了两年的研究生生涯。</p>\n<p>没有我想象的顺利，但也没有我想象的不堪。</p>\n<p>用两句话来概括这两年吧：</p>\n<ol>\n<li><p>第一年我把除了马克思之外所有的课都认真学了一遍，还选修了诸如机器学习、模式识别和数据挖掘等课程，这一年，感觉踏实。</p>\n</li>\n<li><p>第二年，30% 的时间去提心吊胆地帮导师干杂活；70% 的时间背着导师更加提心吊胆地去学习编程，这一年，以为自己会消沉，后来没有。</p>\n</li>\n</ol>\n<h2 id=\"自学编程的那些日子\"><a href=\"# 自学编程的那些日子\" class=\"headerlink\" title=\"自学编程的那些日子\"></a>自学编程的那些日子 </h2><p> 还是那句话，现在吃的苦，都是当年专业没选计算机时脑子进的水。</p>\n<p>2014 年初，作为一名只会 C 语言的我而言，真正开始自学计算机，依次经历了以下几步：</p>\n<ol>\n<li><p>14 年 3 月，师兄说要学编程，先学基础。于是我过了一遍数据结构和操作系统的书，过的比较粗略；</p>\n</li>\n<li><p>14 年 4 月，想学 Android 开发，在网上发现了 Mars 的教程视频。于是我每天只要有空就背着导师偷偷看视频，做笔记。学习 Android 的同时也顺带着学了些 Java 的知识。每天晚上还会在新浪博客或博客园上把自己的笔记记录上去，虽然这种做法并没什么作用，但那时觉得很 happy。</p>\n</li>\n<li><p>14 年 6 月，视频自学效果不佳，我非常苦恼。那时我非常希望有人能够来帮帮我这个新手，同时我每天去寻找实践的机会。要知道，作为一名研究生，导师每天管着你，不能放开学，很不爽的。不过，上天眷顾，我终于找到一份校内实习，技术开发，离实验室又近，每天还有 80 元的工资，天，那几天我感觉我复活了！</p>\n</li>\n<li><p>14 年 6 月中到 11 月，开始学习网站开发。校内实习启动，我过上了白天实验室，晚上工作室的日子了。工作室四个人，两个大牛，两个菜鸟，我当然是后者。6 月到 11 月，我饥渴地学习！开始做网站，前端、后端、数据库。这半年我差不多每天是白天在实验室干完活之后晚上去写代码，半年下来，差不多把前端的 html、css、js 和一些框架 Bootstrap、jQuery 等，后端的 php，和如 thinkphp 等框架，还有数据库 MySQL、MongoDB 都学了一通。空闲时也自己配置过服务器，搭建自己的网站。</p>\n</li>\n<li><p>15 年 3 月到 5 月，算是开始了 Android 开发学习之路吧。15 年，也就是今年，三月开学时，工作室里两个人离开了，一个是被导师抓走干活了，另一个大三的准备毕业了。于是工作室就只剩我和一位大牛。说实话，有点寂寞，但我的热情并没有减少。相反，我仍旧专注于 Android 的开发和学习。实验室方面，到了今年，反而轻松了些，每天上午和晚上在工作室，下午跑回实验室蹲班。另外在实际的开发中，我发现以前视频学的东西和实际应用相差很大，可能那些更基础吧，总之我几乎又是从零开始去学习，从项目中自学。</p>\n</li>\n<li><p>15 年 5 月，我学了近三个月的 Android 开发，虽然工作室另一位大牛偶尔会帮我，但多数时候还是我一头人默默对着电脑学习、研究和修 bug。不过好歹这几个月时间把工作室之前的一款 Android 应用重新写了一遍，每天晚上学到深夜，冒着寒风骑车回宿舍的场景我记得清楚。最后开发完的应用，工作室的指导老师很满意，我也对自己比较满意。</p>\n</li>\n<li><p>15 年 5 月中到 6 月，工作室只剩我一人了。我没有想到，在六月某一天，工作室的顶梁柱大牛说要去北京微软亚研院实习了，意味着整个工作室从最初的四个人只剩下我一个了。那时，我真感觉到有点孤单，看着身边做技术的小伙伴依次离开，到最后竟然只剩我自己一人。不过，我还是照常来工作室开发 Android、学习，不过，这时只能一人去食堂吃饭，遇到问题也再没有人来指导，完全靠自己。</p>\n</li>\n<li><p>15 年 6 月初，迷茫地寻找校外实习。我独自在工作室开发近一个月后，由于即将面临毕业，于是也开始寻找实习。那时摆在我眼前有两条路，大公司；创业公司。对我个人而言，我是追求技术成长的，不希望自己受限于某种技术，所以害怕大公司那种只让我一直从事某个项目的某个方面。所以在我心里，虽知大公司稳妥，但我更偏心于创业型公司。另外我也希望提高自己的英语，也希望有还不错的待遇，希望未来有好的职业发展规划。很多的希望，让我很迷茫，不知道能不能找到真正适合自己的企业。</p>\n</li>\n<li><p>15 年 6 月中，确定实习公司 Glow, 正式离开工作室。终于，我也要离开这个伴随我技术成长的地方了。这期间，我参加了一些公司的面试。大小公司都有，也拿到不少开发岗 offer。当然，最后我选择了目前我所在的这家硅谷创业公司－－Glow。说到 Glow，我就觉得有缘。一年前，我被 Glow 的招聘帖吸引，便去关注了公众号，说实话，Glow 的 Google 背景、扁平式氛围一瞬间就吸引了我。不过接下来的一年再也没收到任何关于 Glow 的招聘信息，所以自己也就淡忘了，加之也觉得自己没戏，所以也就没有多想。直到今年找实习时，在路上走着突然想起这家公司，说实话那时除了 Glow 这个名字和这家公司很独特之外其他都不记得。于是我回到学校，把 bbs 重新翻了一遍，竟被我找回了那个招聘帖。之后大家就知道了，投递简历，电话面试，onsite 面试。然后很快就入职了。</p>\n</li>\n<li><p>15 年 6 月中到现在，Glow 的 Android 开发实习生活。因为不想有软文的嫌疑，所以我也就不做太多介绍了。我只想说，在 Glow 的这半年，我和一堆 Google 大牛相处，技术成长很快。他们并不介怀我非计算机出身，也不担心我只有几个月的 Android 的开发背景。我想我唯一的优势就是努力了。开始时我还挺有压力，担心会拖他们的后腿，不过在他们的帮助下和我个人的不懈努力下，现在我已经能够很好的与他们合作，也得到了他们的认可。我最爱 Glow 的扁平氛围，我相信现在很多创业公司也如此，没有上下级，一心做好产品。</p>\n</li>\n</ol>\n<p>在 Glow 的这半年，我不用提心吊胆担心导师随时来使唤我，我可以全身心来提高技术，而身边的人都随时准备帮助你。</p>\n<p>说实话，我感激自己这两年的坚持，感谢这两年遇到的大牛们。</p>\n<h2 id=\"2016 年的技术规划\"><a href=\"#2016 年的技术规划\" class=\"headerlink\" title=\"2016 年的技术规划\"></a>2016 年的技术规划</h2><p>2016 年对我而言，是个大年。</p>\n<p>正式离开校园，步入工作。</p>\n<p>下面，简单列一下我的规划吧：</p>\n<ol>\n<li><p>工作方面。目前我在 Glow 已经独立负责一整块的开发任务了，包括 Android 和服务器开发。我希望把自己在开源方面学到的新技术应用到我负责的模块上，持续地提高用户体验和稳定性，为用户提供更棒的作品。这点是我每天都在心心念念的。</p>\n</li>\n<li><p>个人技术方面。由于 Glow 不用加班，所以我平常会有很多的个人时间。我当然不准备把这些时间用在看剧和睡觉上。我会多去写作，之前在简书上写的几篇文章 <a href=\"http://www.jianshu.com/p/99665608d295\" target=\"_blank\" rel=\"external\">《如何在一天之内搭建以你自己名字为域名且具备 cool 属性的个人博客》</a>、<a href=\"http://www.jianshu.com/p/cf496fc408b2\" target=\"_blank\" rel=\"external\"> 如何在一天之内完成一款具备 cool 属性的 Android 产品 &lt; 简诗 &gt;</a>收获了不少读者，所以以后会继续努力。同时也会在 <a href=\"http://weibo.com/1625892654\" target=\"_blank\" rel=\"external\"> 个人微博 </a> 和<a href=\"http://gold.xitu.io/#/user/562a410800b07d3623109a95\" target=\"_blank\" rel=\"external\">稀土 </a> 上多多分享优质文章。</p>\n</li>\n<li><p>开源方面。最近因为又忙实习又忙毕业写论文，就没有花太多时间做开源。只是贡献了两个库：<a href=\"https://github.com/wingjay/jianshi\" target=\"_blank\" rel=\"external\">简诗</a> 和<a href=\"https://github.com/wingjay/BlurImageView\" target=\"_blank\" rel=\"external\">BlurImageView</a>，加起来快一千个 star 左右。不过以后还会继续贡献优秀的库和大家分享的。</p>\n</li>\n<li><p><a href=\"http://wingjay.com\">我的个人博客 </a> <a href=\"http://wingjay.com。\" target=\"_blank\" rel=\"external\">http://wingjay.com。</a><br> 除了技术，我也会开始提高自己的艺术方面的敏感度。比如开始接触建筑设计、文学方面的，一方面扩大自己的知识面，另一方面也是提高自己的感性思维吧。</p>\n</li>\n</ol>\n<h2 id=\"最近在读的书\"><a href=\"# 最近在读的书\" class=\"headerlink\" title=\"最近在读的书\"></a>最近在读的书</h2><ol>\n<li><p>《一切始于设计－一个设计师的世博十日手记   －   迪人 著》<br>这本书我看到了一位设计师对世界的认知，接触了世界各国的设计思想，如意大利、德国、法国等，收获很大！</p>\n</li>\n<li><p>《设计中的设计   －   原研哉 著》<br>原研哉，无印良品设计总监。感受日本设计思想中留白这一概念，让人重新认识身边的事物。</p>\n</li>\n<li><p>《Android 开发艺术探索  － 任玉刚 著》<br>把 Android 里很多晦涩的概念讲解清楚，超喜欢里面对 View 的讲解，解开了我一个很大的困惑谜团。</p>\n</li>\n<li><p>《Android 群英传  －  徐宜生 著》<br>从实际开发的角度，讲解开发中常见的各种问题，结合上面那本书一起看，差不多能把多数开发问题搞明白。</p>\n</li>\n</ol>\n<p>还有不少书，下次再来推荐吧！</p>\n<h2 id=\"如果你也热爱技术，交个朋友吧\"><a href=\"# 如果你也热爱技术，交个朋友吧\" class=\"headerlink\" title=\"如果你也热爱技术，交个朋友吧\"></a>如果你也热爱技术，交个朋友吧 </h2><p> 我是 <a href=\"http://wingjay.com\">wingjay</a>，你可以通过我的<a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\">GitHub</a> 或者 <a href=\"http://www.jianshu.com/users/da333fd63fe5/latest_articles\" target=\"_blank\" rel=\"external\"> 简书平台 </a> 来找到我哦。</p>\n<p>谢谢！</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>误打误撞进入了计算机的世界，觉得有趣，就一直留在这里</p>\n</blockquote>","more":"<p><img src=\"https://drscdn.500px.org/photo/3706985/m%3D2048/d9cba44c9d66f27d27e1628fa7f4606c\" alt=\"\"></p>\n<h2 id=\"Hi，我是wingjay\"><a href=\"#Hi，我是wingjay\" class=\"headerlink\" title=\"Hi，我是wingjay\"></a>Hi，我是wingjay</h2><p>大家好，我是<a href=\"http://www.jianshu.com/p/99665608d295\" target=\"_blank\" rel=\"external\">《如何在一天之内搭建以你自己名字为域名且具备cool属性的个人博客》</a>、<a href=\"http://www.jianshu.com/p/cf496fc408b2\" target=\"_blank\" rel=\"external\">如何在一天之内完成一款具备cool属性的Android产品&lt;简诗&gt;</a>的作者<a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\">wingjay</a>，今天抽空来和大家一起告别2015，迎接新的技术成长的一年。</p>\n<h2 id=\"再过半年，我就要从交大硕士毕业了。\"><a href=\"#再过半年，我就要从交大硕士毕业了。\" class=\"headerlink\" title=\"再过半年，我就要从交大硕士毕业了。\"></a>再过半年，我就要从交大硕士毕业了。</h2><p>2013年9月入学交大，自动化小硕，从没想过未来会从事计算机相关行业，因为对于编程我唯一的背景就是大二那年的C语言课程。</p>\n<p>我是怎么开始对编程感兴趣的？不记得了，也不会有人关心。只知道那时逢人就介绍智能手机的硬件配置多么发烧，喜欢调侃小米的成功哲学，也跟风追着“大数据”和“云计算”这两朵云奔跑。</p>\n<p>慢慢的，觉得搞计算机的人很酷。</p>\n<p>那时，我正式入学。</p>\n<p>也在那时，我缠着父母给我买了一款手机－小米2s。我记得我对着这款手机盯了快半个小时，乐的。</p>\n<p>然后开启了两年的研究生生涯。</p>\n<p>没有我想象的顺利，但也没有我想象的不堪。</p>\n<p>用两句话来概括这两年吧：</p>\n<ol>\n<li><p>第一年我把除了马克思之外所有的课都认真学了一遍，还选修了诸如机器学习、模式识别和数据挖掘等课程，这一年，感觉踏实。</p>\n</li>\n<li><p>第二年，30%的时间去提心吊胆地帮导师干杂活；70%的时间背着导师更加提心吊胆地去学习编程，这一年，以为自己会消沉，后来没有。</p>\n</li>\n</ol>\n<h2 id=\"自学编程的那些日子\"><a href=\"#自学编程的那些日子\" class=\"headerlink\" title=\"自学编程的那些日子\"></a>自学编程的那些日子</h2><p>还是那句话，现在吃的苦，都是当年专业没选计算机时脑子进的水。</p>\n<p>2014年初，作为一名只会C语言的我而言，真正开始自学计算机，依次经历了以下几步：</p>\n<ol>\n<li><p>14年3月，师兄说要学编程，先学基础。于是我过了一遍数据结构和操作系统的书，过的比较粗略；</p>\n</li>\n<li><p>14年4月，想学Android开发，在网上发现了Mars的教程视频。于是我每天只要有空就背着导师偷偷看视频，做笔记。学习Android的同时也顺带着学了些Java的知识。每天晚上还会在新浪博客或博客园上把自己的笔记记录上去，虽然这种做法并没什么作用，但那时觉得很happy。</p>\n</li>\n<li><p>14年6月，视频自学效果不佳，我非常苦恼。那时我非常希望有人能够来帮帮我这个新手，同时我每天去寻找实践的机会。要知道，作为一名研究生，导师每天管着你，不能放开学，很不爽的。不过，上天眷顾，我终于找到一份校内实习，技术开发，离实验室又近，每天还有80元的工资，天，那几天我感觉我复活了！</p>\n</li>\n<li><p>14年6月中到11月，开始学习网站开发。校内实习启动，我过上了白天实验室，晚上工作室的日子了。工作室四个人，两个大牛，两个菜鸟，我当然是后者。6月到11月，我饥渴地学习！开始做网站，前端、后端、数据库。这半年我差不多每天是白天在实验室干完活之后晚上去写代码，半年下来，差不多把前端的html、css、js和一些框架Bootstrap、jQuery等，后端的php，和如thinkphp等框架，还有数据库MySQL、MongoDB都学了一通。空闲时也自己配置过服务器，搭建自己的网站。</p>\n</li>\n<li><p>15年3月到5月，算是开始了Android开发学习之路吧。15年，也就是今年，三月开学时，工作室里两个人离开了，一个是被导师抓走干活了，另一个大三的准备毕业了。于是工作室就只剩我和一位大牛。说实话，有点寂寞，但我的热情并没有减少。相反，我仍旧专注于Android的开发和学习。实验室方面，到了今年，反而轻松了些，每天上午和晚上在工作室，下午跑回实验室蹲班。另外在实际的开发中，我发现以前视频学的东西和实际应用相差很大，可能那些更基础吧，总之我几乎又是从零开始去学习，从项目中自学。</p>\n</li>\n<li><p>15年5月，我学了近三个月的Android开发，虽然工作室另一位大牛偶尔会帮我，但多数时候还是我一头人默默对着电脑学习、研究和修bug。不过好歹这几个月时间把工作室之前的一款Android应用重新写了一遍，每天晚上学到深夜，冒着寒风骑车回宿舍的场景我记得清楚。最后开发完的应用，工作室的指导老师很满意，我也对自己比较满意。</p>\n</li>\n<li><p>15年5月中到6月，工作室只剩我一人了。我没有想到，在六月某一天，工作室的顶梁柱大牛说要去北京微软亚研院实习了，意味着整个工作室从最初的四个人只剩下我一个了。那时，我真感觉到有点孤单，看着身边做技术的小伙伴依次离开，到最后竟然只剩我自己一人。不过，我还是照常来工作室开发Android、学习，不过，这时只能一人去食堂吃饭，遇到问题也再没有人来指导，完全靠自己。</p>\n</li>\n<li><p>15年6月初，迷茫地寻找校外实习。我独自在工作室开发近一个月后，由于即将面临毕业，于是也开始寻找实习。那时摆在我眼前有两条路，大公司；创业公司。对我个人而言，我是追求技术成长的，不希望自己受限于某种技术，所以害怕大公司那种只让我一直从事某个项目的某个方面。所以在我心里，虽知大公司稳妥，但我更偏心于创业型公司。另外我也希望提高自己的英语，也希望有还不错的待遇，希望未来有好的职业发展规划。很多的希望，让我很迷茫，不知道能不能找到真正适合自己的企业。</p>\n</li>\n<li><p>15年6月中，确定实习公司Glow, 正式离开工作室。终于，我也要离开这个伴随我技术成长的地方了。这期间，我参加了一些公司的面试。大小公司都有，也拿到不少开发岗offer。当然，最后我选择了目前我所在的这家硅谷创业公司－－Glow。说到Glow，我就觉得有缘。一年前，我被Glow的招聘帖吸引，便去关注了公众号，说实话，Glow的Google背景、扁平式氛围一瞬间就吸引了我。不过接下来的一年再也没收到任何关于Glow的招聘信息，所以自己也就淡忘了，加之也觉得自己没戏，所以也就没有多想。直到今年找实习时，在路上走着突然想起这家公司，说实话那时除了Glow这个名字和这家公司很独特之外其他都不记得。于是我回到学校，把bbs重新翻了一遍，竟被我找回了那个招聘帖。之后大家就知道了，投递简历，电话面试，onsite面试。然后很快就入职了。</p>\n</li>\n<li><p>15年6月中到现在，Glow的Android开发实习生活。因为不想有软文的嫌疑，所以我也就不做太多介绍了。我只想说，在Glow的这半年，我和一堆Google大牛相处，技术成长很快。他们并不介怀我非计算机出身，也不担心我只有几个月的Android的开发背景。我想我唯一的优势就是努力了。开始时我还挺有压力，担心会拖他们的后腿，不过在他们的帮助下和我个人的不懈努力下，现在我已经能够很好的与他们合作，也得到了他们的认可。我最爱Glow的扁平氛围，我相信现在很多创业公司也如此，没有上下级，一心做好产品。</p>\n</li>\n</ol>\n<p>在Glow的这半年，我不用提心吊胆担心导师随时来使唤我，我可以全身心来提高技术，而身边的人都随时准备帮助你。</p>\n<p>说实话，我感激自己这两年的坚持，感谢这两年遇到的大牛们。</p>\n<h2 id=\"2016年的技术规划\"><a href=\"#2016年的技术规划\" class=\"headerlink\" title=\"2016年的技术规划\"></a>2016年的技术规划</h2><p>2016年对我而言，是个大年。</p>\n<p>正式离开校园，步入工作。</p>\n<p>下面，简单列一下我的规划吧：</p>\n<ol>\n<li><p>工作方面。目前我在Glow已经独立负责一整块的开发任务了，包括Android和服务器开发。我希望把自己在开源方面学到的新技术应用到我负责的模块上，持续地提高用户体验和稳定性，为用户提供更棒的作品。这点是我每天都在心心念念的。</p>\n</li>\n<li><p>个人技术方面。由于Glow不用加班，所以我平常会有很多的个人时间。我当然不准备把这些时间用在看剧和睡觉上。我会多去写作，之前在简书上写的几篇文章<a href=\"http://www.jianshu.com/p/99665608d295\" target=\"_blank\" rel=\"external\">《如何在一天之内搭建以你自己名字为域名且具备cool属性的个人博客》</a>、<a href=\"http://www.jianshu.com/p/cf496fc408b2\" target=\"_blank\" rel=\"external\">如何在一天之内完成一款具备cool属性的Android产品&lt;简诗&gt;</a>收获了不少读者，所以以后会继续努力。同时也会在<a href=\"http://weibo.com/1625892654\" target=\"_blank\" rel=\"external\">个人微博</a>和<a href=\"http://gold.xitu.io/#/user/562a410800b07d3623109a95\" target=\"_blank\" rel=\"external\">稀土</a>上多多分享优质文章。</p>\n</li>\n<li><p>开源方面。最近因为又忙实习又忙毕业写论文，就没有花太多时间做开源。只是贡献了两个库：<a href=\"https://github.com/wingjay/jianshi\" target=\"_blank\" rel=\"external\">简诗</a> 和<a href=\"https://github.com/wingjay/BlurImageView\" target=\"_blank\" rel=\"external\">BlurImageView</a>，加起来快一千个star左右。不过以后还会继续贡献优秀的库和大家分享的。</p>\n</li>\n<li><p><a href=\"http://wingjay.com\">我的个人博客</a> <a href=\"http://wingjay.com。\" target=\"_blank\" rel=\"external\">http://wingjay.com。</a><br>除了技术，我也会开始提高自己的艺术方面的敏感度。比如开始接触建筑设计、文学方面的，一方面扩大自己的知识面，另一方面也是提高自己的感性思维吧。</p>\n</li>\n</ol>\n<h2 id=\"最近在读的书\"><a href=\"#最近在读的书\" class=\"headerlink\" title=\"最近在读的书\"></a>最近在读的书</h2><ol>\n<li><p>《一切始于设计－一个设计师的世博十日手记   －   迪人 著》<br>这本书我看到了一位设计师对世界的认知，接触了世界各国的设计思想，如意大利、德国、法国等，收获很大！</p>\n</li>\n<li><p>《设计中的设计   －   原研哉 著》<br>原研哉，无印良品设计总监。感受日本设计思想中留白这一概念，让人重新认识身边的事物。</p>\n</li>\n<li><p>《Android开发艺术探索  － 任玉刚 著》<br>把Android里很多晦涩的概念讲解清楚，超喜欢里面对View的讲解，解开了我一个很大的困惑谜团。</p>\n</li>\n<li><p>《Android群英传  －  徐宜生 著》<br>从实际开发的角度，讲解开发中常见的各种问题，结合上面那本书一起看，差不多能把多数开发问题搞明白。</p>\n</li>\n</ol>\n<p>还有不少书，下次再来推荐吧！</p>\n<h2 id=\"如果你也热爱技术，交个朋友吧\"><a href=\"#如果你也热爱技术，交个朋友吧\" class=\"headerlink\" title=\"如果你也热爱技术，交个朋友吧\"></a>如果你也热爱技术，交个朋友吧</h2><p>我是<a href=\"http://wingjay.com\">wingjay</a>，你可以通过我的<a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\">GitHub</a>或者<a href=\"http://www.jianshu.com/users/da333fd63fe5/latest_articles\" target=\"_blank\" rel=\"external\">简书平台</a>来找到我哦。</p>\n<p>谢谢！</p>","sticky":0},{"title":"独立全端开发的开源小作：简诗 2.0","date":"2016-11-26T12:11:03.000Z","commentIssueId":11,"_content":"> 简诗是自己的一份追求，对美好设计、全面技术的追求。\n\n<!-- more -->\n\n## 缘由\n大家好，我是 wingjay ，软件工程师，热爱全栈。\n\n简诗 是自己业余时间做的一款优雅、纯粹的文字 Android App ，传统纵书风格，以求为用户带来更质朴的书写体验。加之现有文字 App 要么过于复杂，要么界面不够特色，更促成简诗的诞生。\n\n>下载地址： http://fir.im/vd1r 。 GitHub 开源： https://github.com/wingjay/jianshi\n\n\n简诗 的想法最初来源于我阅读的一本来自 Kevin 的书《 Producter 》，书中介绍了 iOS 小记的开发设计过程。唯一的缺憾是没有开发 Android 版本。因此我联系 Kevin 并获取了开发 Android 版本的授权。\n\n简诗 主要由我独自开发，包括 Android 和 Server 端的，主要利用如周末或平时晚上的业余时间。开发的过程是比较累的，很多周末要熬夜到很晚；但也是充满惊喜的，因为里面有不少来自自己的灵感创意。\n\n抛开天天用的 Google Material Design ，不断思考新鲜的设计并从工程角度去实现它，这总是非常有成就感的。\n\n简诗 2.0 最主要的功能是登录注册、数据云同步。由于 1.0 是单机版，所以数据云备份这一点是最多用户反馈的。也正是这个需求，我决定重新为 简诗 搭建后台，实现数据云存储。也正是因为有了后台支持，简诗 添加了很多以前无法实现的功能，比如无限多实时更新的首页图片和三行诗等等。\n\n希望简诗质朴传统的中国风特质能让用户重新感受到文字的美好，在形影寂寞时，找回一点温暖。\n\n## 入选最美应用\n多谢最美应用对简诗的喜爱，并发表了这篇产品推介采访稿[《简诗—他在业余时间开发的这款「Android 版小记」，带你重新找回写作的乐趣》](http://zuimeia.com/app/4638/)。下面截取采访部分供大家阅读。\n\n**最美应用**：来给大家介绍一下自己吧\n**尹捷** ：大家好，我叫尹捷（wingjay），上海交通大学硕士毕业，软件工程师一枚，现居上海。\n\n**最美应用**： 除了工作，平时喜欢如何规划业余时间呢？\n**尹捷** ： 天气好的话我会在城市里徒步或去户外爬山，摄影；天气不好就宅在家中，开着音响听音乐，下厨、看电影、写代码、看书。\n\n**最美应用**： 开发简诗的初衷是怎样的呢？\n**尹捷** ： 简诗最初的设计稿来自《Producter》一书，该书介绍了 iOS 版小记的开发过程，不过可惜没有 Android 版本，因此我联系小记作者，获取了 Android 版开发授权。\n\n浓郁的中国风色彩和极简的设计风格，是我开发简诗最本质的原因。\n\n作为一名开发者，我看过很多设计风格的App，例如 Google 自家的 Material Design，Apple 的扁平化，锤子的拟物化。相比而言，简诗的设计思路和它们都不一样：别致的中国风纵书体验，大片留白的日式设计理念，体现浓郁传统中国文化的细节，都使得简诗与众不同。\n\n开发一款如此别具一格的 App，在我看来，是一件非常酷的事情。\n\n**最美应用**： 开发过程中，你遇到过哪些有意思的事情，或者是难题？\n**尹捷** ： 简诗的开发主要包括三方面：设计、Android 端、服务端。\n\n－ 设计：在最初《Producter》的设计草稿基础上，我对整个使用体验做了进一步优化：剔除了原始选择年、月、日的步骤；在首页添加实时变化的三行小诗；在撰写页面根据当前时间如正午、夜半，显示不同的提示语以让用户感觉更为亲近；支持更换背景颜色，色值取自中国传统颜色如素、月白、水红等；文章列表页面仿照古代书籍目录设计；分享时会自动生成简诗的印章，借鉴了传统书画作品中的印章；首页添加实时变化背景图片，这些图片均来自全球优质的摄影作品 UnSplash 网站。\n\n－ Android 端：Android 端采用了当前最为流行的移动架构和依赖，运行稳定，代码结构简洁，crash 率只有 0.1% ~ 0.3%，开发比较顺利，没有遇到什么难题。\n\n－ 服务端：本人之前有完整的 PHP 后端开发经验，所以如果采用 PHP 开发的话难度会小很多；不过我最终选择了自己不熟悉的 Python 来进行服务端开发，这给我带来了一些挑战。之所以采用 Python 有两个原因：一是对 Python 这门语言的好奇，软件工程师总是对未知领域充满好奇并想去探索；二是希望通过不同语言的服务端开发，来提升自己对服务端架构的理解。\n\n**最美应用**： 作为一名职业软件工程师，在开发简诗的过程中，是如何分配自己的时间精力的呢？\n**尹捷** ： 简诗 v2.0 的开发主要利用我周末的时间。总共花了三到四个周末，即六天到八天左右，完成了 Android 版本和服务端的开发。开发后段我的一位好友：Ray https://github.com/Panl) 也加入并协助进行了部分开发工作，有几个周六我俩都开发到了大概凌晨四点钟左右，一边阐述自己的产品创意，一边讨论工程实践的可行性，是非常有趣的一段经历。\n\n**最美应用**： 之后，还会对简诗做哪些方面的改进吗？\n**尹捷** ： 目前简诗 v2.0 已经有不少用户了，我们也在积极收集用户的反馈，后面还会有几个大 feature 要做，欢迎期待哦。\n\n**最美应用**： 对简诗有怎样的愿景呢？\n**尹捷** ： 当代的人们逐渐习惯于阅读快速的文字片段，淡忘了写作的体验。而简诗的存在，就是希望让人们重新找回文字的美好之处，重新感受写作的乐趣。或许并非所有人都喜欢简诗，但只要有一部分人，能从简诗里重新感受到文字的温暖，就足够了。\n\n**最美应用**： 来介绍几款自己喜欢或常用的应用吧\n**尹捷** ： Slack + Asana：团队开发效率大幅提高利器\n\nTypora：Mac 端优雅的 Markdown 书写利器\n\nMedium+稀土掘金+湾区日报：阅读优质技术文章，资讯\n\n网易云音乐+落网：前者能为你推荐你喜欢的音乐，后者收集了很多优秀独立音乐人的作品\n\n最美应用 + 豌豆荚一览：优质作品搜索利器\n\nShadowsocks：嗯\n\n**最美应用**： 在软件开发方面，有什么经验心得可以来和大家分享下吗？\n**尹捷** ： 作为一名造诣不够深的开发者，简单分享下两点拙见：\n\n－ 保持开放的心态，如果有可能的话，尝试下全栈。或许全栈这个词已经受到了很多误读，但至少，全栈开发能让你的思维更加全面，让你的思考更贴近工程实际；\n\n－ 追本溯源。我们日常的开发都是基于某些平台或工具，如 Android sdk，Flask 框架或其他开源项目。在熟练使用这些工具之后，我建议还应该去探究它们的实现原理，这样才能真正提高技术水平。\n\n**最美应用**： 还有什么想对大家说的吗？\n**尹捷** ： 作为一名开发者，我也热爱并重视产品设计。平日里会阅读一些如日式设计相关的书籍。不过，我深知自己在设计方面的学识浅的可怜，因此，我希望在业余时间里能和一些优秀的设计师合作，共同开发一些独具匠心的产品给大家使用。\n\n## 截屏\n![](https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/1.PNG)\n![](https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/2.PNG)\n![](https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/3.PNG)\n![](https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/4.PNG)\n![](https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/7.PNG)\n![](https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/8.PNG)\n![](https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/5.jpg)\n\n## 开源\n项目开源地址：https://github.com/wingjay/jianshi\n\n\n谢谢！\n\nwingjay\n\n\n","source":"_posts/独立全端开发的开源小作：简诗2-0.md","raw":"title: 独立全端开发的开源小作：简诗2.0\ncategories:\n  - 全栈\n  - Android\n  - Server\ndate: 2016-11-26 20:11:03\ncommentIssueId: 11\n---\n> 简诗是自己的一份追求，对美好设计、全面技术的追求。\n\n<!-- more -->\n\n## 缘由\n大家好，我是 wingjay ，软件工程师，热爱全栈。\n\n简诗 是自己业余时间做的一款优雅、纯粹的文字 Android App ，传统纵书风格，以求为用户带来更质朴的书写体验。加之现有文字 App 要么过于复杂，要么界面不够特色，更促成简诗的诞生。\n\n>下载地址： http://fir.im/vd1r 。 GitHub 开源： https://github.com/wingjay/jianshi\n\n\n简诗 的想法最初来源于我阅读的一本来自 Kevin 的书《 Producter 》，书中介绍了 iOS 小记的开发设计过程。唯一的缺憾是没有开发 Android 版本。因此我联系 Kevin 并获取了开发 Android 版本的授权。\n\n简诗 主要由我独自开发，包括 Android 和 Server 端的，主要利用如周末或平时晚上的业余时间。开发的过程是比较累的，很多周末要熬夜到很晚；但也是充满惊喜的，因为里面有不少来自自己的灵感创意。\n\n抛开天天用的 Google Material Design ，不断思考新鲜的设计并从工程角度去实现它，这总是非常有成就感的。\n\n简诗 2.0 最主要的功能是登录注册、数据云同步。由于 1.0 是单机版，所以数据云备份这一点是最多用户反馈的。也正是这个需求，我决定重新为 简诗 搭建后台，实现数据云存储。也正是因为有了后台支持，简诗 添加了很多以前无法实现的功能，比如无限多实时更新的首页图片和三行诗等等。\n\n希望简诗质朴传统的中国风特质能让用户重新感受到文字的美好，在形影寂寞时，找回一点温暖。\n\n## 入选最美应用\n多谢最美应用对简诗的喜爱，并发表了这篇产品推介采访稿[《简诗—他在业余时间开发的这款「Android 版小记」，带你重新找回写作的乐趣》](http://zuimeia.com/app/4638/)。下面截取采访部分供大家阅读。\n\n**最美应用**：来给大家介绍一下自己吧\n**尹捷** ：大家好，我叫尹捷（wingjay），上海交通大学硕士毕业，软件工程师一枚，现居上海。\n\n**最美应用**： 除了工作，平时喜欢如何规划业余时间呢？\n**尹捷** ： 天气好的话我会在城市里徒步或去户外爬山，摄影；天气不好就宅在家中，开着音响听音乐，下厨、看电影、写代码、看书。\n\n**最美应用**： 开发简诗的初衷是怎样的呢？\n**尹捷** ： 简诗最初的设计稿来自《Producter》一书，该书介绍了 iOS 版小记的开发过程，不过可惜没有 Android 版本，因此我联系小记作者，获取了 Android 版开发授权。\n\n浓郁的中国风色彩和极简的设计风格，是我开发简诗最本质的原因。\n\n作为一名开发者，我看过很多设计风格的App，例如 Google 自家的 Material Design，Apple 的扁平化，锤子的拟物化。相比而言，简诗的设计思路和它们都不一样：别致的中国风纵书体验，大片留白的日式设计理念，体现浓郁传统中国文化的细节，都使得简诗与众不同。\n\n开发一款如此别具一格的 App，在我看来，是一件非常酷的事情。\n\n**最美应用**： 开发过程中，你遇到过哪些有意思的事情，或者是难题？\n**尹捷** ： 简诗的开发主要包括三方面：设计、Android 端、服务端。\n\n－ 设计：在最初《Producter》的设计草稿基础上，我对整个使用体验做了进一步优化：剔除了原始选择年、月、日的步骤；在首页添加实时变化的三行小诗；在撰写页面根据当前时间如正午、夜半，显示不同的提示语以让用户感觉更为亲近；支持更换背景颜色，色值取自中国传统颜色如素、月白、水红等；文章列表页面仿照古代书籍目录设计；分享时会自动生成简诗的印章，借鉴了传统书画作品中的印章；首页添加实时变化背景图片，这些图片均来自全球优质的摄影作品 UnSplash 网站。\n\n－ Android 端：Android 端采用了当前最为流行的移动架构和依赖，运行稳定，代码结构简洁，crash 率只有 0.1% ~ 0.3%，开发比较顺利，没有遇到什么难题。\n\n－ 服务端：本人之前有完整的 PHP 后端开发经验，所以如果采用 PHP 开发的话难度会小很多；不过我最终选择了自己不熟悉的 Python 来进行服务端开发，这给我带来了一些挑战。之所以采用 Python 有两个原因：一是对 Python 这门语言的好奇，软件工程师总是对未知领域充满好奇并想去探索；二是希望通过不同语言的服务端开发，来提升自己对服务端架构的理解。\n\n**最美应用**： 作为一名职业软件工程师，在开发简诗的过程中，是如何分配自己的时间精力的呢？\n**尹捷** ： 简诗 v2.0 的开发主要利用我周末的时间。总共花了三到四个周末，即六天到八天左右，完成了 Android 版本和服务端的开发。开发后段我的一位好友：Ray https://github.com/Panl) 也加入并协助进行了部分开发工作，有几个周六我俩都开发到了大概凌晨四点钟左右，一边阐述自己的产品创意，一边讨论工程实践的可行性，是非常有趣的一段经历。\n\n**最美应用**： 之后，还会对简诗做哪些方面的改进吗？\n**尹捷** ： 目前简诗 v2.0 已经有不少用户了，我们也在积极收集用户的反馈，后面还会有几个大 feature 要做，欢迎期待哦。\n\n**最美应用**： 对简诗有怎样的愿景呢？\n**尹捷** ： 当代的人们逐渐习惯于阅读快速的文字片段，淡忘了写作的体验。而简诗的存在，就是希望让人们重新找回文字的美好之处，重新感受写作的乐趣。或许并非所有人都喜欢简诗，但只要有一部分人，能从简诗里重新感受到文字的温暖，就足够了。\n\n**最美应用**： 来介绍几款自己喜欢或常用的应用吧\n**尹捷** ： Slack + Asana：团队开发效率大幅提高利器\n\nTypora：Mac 端优雅的 Markdown 书写利器\n\nMedium+稀土掘金+湾区日报：阅读优质技术文章，资讯\n\n网易云音乐+落网：前者能为你推荐你喜欢的音乐，后者收集了很多优秀独立音乐人的作品\n\n最美应用 + 豌豆荚一览：优质作品搜索利器\n\nShadowsocks：嗯\n\n**最美应用**： 在软件开发方面，有什么经验心得可以来和大家分享下吗？\n**尹捷** ： 作为一名造诣不够深的开发者，简单分享下两点拙见：\n\n－ 保持开放的心态，如果有可能的话，尝试下全栈。或许全栈这个词已经受到了很多误读，但至少，全栈开发能让你的思维更加全面，让你的思考更贴近工程实际；\n\n－ 追本溯源。我们日常的开发都是基于某些平台或工具，如 Android sdk，Flask 框架或其他开源项目。在熟练使用这些工具之后，我建议还应该去探究它们的实现原理，这样才能真正提高技术水平。\n\n**最美应用**： 还有什么想对大家说的吗？\n**尹捷** ： 作为一名开发者，我也热爱并重视产品设计。平日里会阅读一些如日式设计相关的书籍。不过，我深知自己在设计方面的学识浅的可怜，因此，我希望在业余时间里能和一些优秀的设计师合作，共同开发一些独具匠心的产品给大家使用。\n\n## 截屏\n![](https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/1.PNG)\n![](https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/2.PNG)\n![](https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/3.PNG)\n![](https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/4.PNG)\n![](https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/7.PNG)\n![](https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/8.PNG)\n![](https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/5.jpg)\n\n## 开源\n项目开源地址：https://github.com/wingjay/jianshi\n\n\n谢谢！\n\nwingjay\n\n\n","slug":"独立全端开发的开源小作：简诗2-0","published":1,"updated":"2018-11-26T06:56:27.487Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplsi800343dn8c3v4lwt0","content":"<blockquote>\n<p>简诗是自己的一份追求，对美好设计、全面技术的追求。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"缘由\"><a href=\"# 缘由\" class=\"headerlink\" title=\"缘由\"></a>缘由 </h2><p> 大家好，我是 wingjay ，软件工程师，热爱全栈。</p>\n<p>简诗 是自己业余时间做的一款优雅、纯粹的文字 Android App ，传统纵书风格，以求为用户带来更质朴的书写体验。加之现有文字 App 要么过于复杂，要么界面不够特色，更促成简诗的诞生。</p>\n<blockquote>\n<p>下载地址： <a href=\"http://fir.im/vd1r\" target=\"_blank\" rel=\"external\">http://fir.im/vd1r</a> 。 GitHub 开源： <a href=\"https://github.com/wingjay/jianshi\" target=\"_blank\" rel=\"external\">https://github.com/wingjay/jianshi</a></p>\n</blockquote>\n<p>简诗 的想法最初来源于我阅读的一本来自 Kevin 的书《 Producter 》，书中介绍了 iOS 小记的开发设计过程。唯一的缺憾是没有开发 Android 版本。因此我联系 Kevin 并获取了开发 Android 版本的授权。</p>\n<p>简诗 主要由我独自开发，包括 Android 和 Server 端的，主要利用如周末或平时晚上的业余时间。开发的过程是比较累的，很多周末要熬夜到很晚；但也是充满惊喜的，因为里面有不少来自自己的灵感创意。</p>\n<p>抛开天天用的 Google Material Design ，不断思考新鲜的设计并从工程角度去实现它，这总是非常有成就感的。</p>\n<p>简诗 2.0 最主要的功能是登录注册、数据云同步。由于 1.0 是单机版，所以数据云备份这一点是最多用户反馈的。也正是这个需求，我决定重新为 简诗 搭建后台，实现数据云存储。也正是因为有了后台支持，简诗 添加了很多以前无法实现的功能，比如无限多实时更新的首页图片和三行诗等等。</p>\n<p>希望简诗质朴传统的中国风特质能让用户重新感受到文字的美好，在形影寂寞时，找回一点温暖。</p>\n<h2 id=\"入选最美应用\"><a href=\"# 入选最美应用\" class=\"headerlink\" title=\"入选最美应用\"></a>入选最美应用 </h2><p> 多谢最美应用对简诗的喜爱，并发表了这篇产品推介采访稿<a href=\"http://zuimeia.com/app/4638/\" target=\"_blank\" rel=\"external\">《简诗—他在业余时间开发的这款「Android 版小记」，带你重新找回写作的乐趣》</a>。下面截取采访部分供大家阅读。</p>\n<p><strong>最美应用 </strong>：来给大家介绍一下自己吧<br><strong> 尹捷</strong> ：大家好，我叫尹捷（wingjay），上海交通大学硕士毕业，软件工程师一枚，现居上海。</p>\n<p><strong>最美应用 </strong>： 除了工作，平时喜欢如何规划业余时间呢？<br><strong> 尹捷</strong> ： 天气好的话我会在城市里徒步或去户外爬山，摄影；天气不好就宅在家中，开着音响听音乐，下厨、看电影、写代码、看书。</p>\n<p><strong>最美应用 </strong>： 开发简诗的初衷是怎样的呢？<br><strong> 尹捷</strong> ： 简诗最初的设计稿来自《Producter》一书，该书介绍了 iOS 版小记的开发过程，不过可惜没有 Android 版本，因此我联系小记作者，获取了 Android 版开发授权。</p>\n<p>浓郁的中国风色彩和极简的设计风格，是我开发简诗最本质的原因。</p>\n<p>作为一名开发者，我看过很多设计风格的 App，例如 Google 自家的 Material Design，Apple 的扁平化，锤子的拟物化。相比而言，简诗的设计思路和它们都不一样：别致的中国风纵书体验，大片留白的日式设计理念，体现浓郁传统中国文化的细节，都使得简诗与众不同。</p>\n<p>开发一款如此别具一格的 App，在我看来，是一件非常酷的事情。</p>\n<p><strong>最美应用 </strong>： 开发过程中，你遇到过哪些有意思的事情，或者是难题？<br><strong> 尹捷</strong> ： 简诗的开发主要包括三方面：设计、Android 端、服务端。</p>\n<p>－ 设计：在最初《Producter》的设计草稿基础上，我对整个使用体验做了进一步优化：剔除了原始选择年、月、日的步骤；在首页添加实时变化的三行小诗；在撰写页面根据当前时间如正午、夜半，显示不同的提示语以让用户感觉更为亲近；支持更换背景颜色，色值取自中国传统颜色如素、月白、水红等；文章列表页面仿照古代书籍目录设计；分享时会自动生成简诗的印章，借鉴了传统书画作品中的印章；首页添加实时变化背景图片，这些图片均来自全球优质的摄影作品 UnSplash 网站。</p>\n<p>－ Android 端：Android 端采用了当前最为流行的移动架构和依赖，运行稳定，代码结构简洁，crash 率只有 0.1% ~ 0.3%，开发比较顺利，没有遇到什么难题。</p>\n<p>－ 服务端：本人之前有完整的 PHP 后端开发经验，所以如果采用 PHP 开发的话难度会小很多；不过我最终选择了自己不熟悉的 Python 来进行服务端开发，这给我带来了一些挑战。之所以采用 Python 有两个原因：一是对 Python 这门语言的好奇，软件工程师总是对未知领域充满好奇并想去探索；二是希望通过不同语言的服务端开发，来提升自己对服务端架构的理解。</p>\n<p><strong>最美应用 </strong>： 作为一名职业软件工程师，在开发简诗的过程中，是如何分配自己的时间精力的呢？<br><strong> 尹捷</strong> ： 简诗 v2.0 的开发主要利用我周末的时间。总共花了三到四个周末，即六天到八天左右，完成了 Android 版本和服务端的开发。开发后段我的一位好友：Ray <a href=\"https://github.com/Panl\" target=\"_blank\" rel=\"external\">https://github.com/Panl</a>) 也加入并协助进行了部分开发工作，有几个周六我俩都开发到了大概凌晨四点钟左右，一边阐述自己的产品创意，一边讨论工程实践的可行性，是非常有趣的一段经历。</p>\n<p><strong>最美应用 </strong>： 之后，还会对简诗做哪些方面的改进吗？<br><strong> 尹捷</strong> ： 目前简诗 v2.0 已经有不少用户了，我们也在积极收集用户的反馈，后面还会有几个大 feature 要做，欢迎期待哦。</p>\n<p><strong>最美应用 </strong>： 对简诗有怎样的愿景呢？<br><strong> 尹捷</strong> ： 当代的人们逐渐习惯于阅读快速的文字片段，淡忘了写作的体验。而简诗的存在，就是希望让人们重新找回文字的美好之处，重新感受写作的乐趣。或许并非所有人都喜欢简诗，但只要有一部分人，能从简诗里重新感受到文字的温暖，就足够了。</p>\n<p><strong>最美应用 </strong>： 来介绍几款自己喜欢或常用的应用吧<br><strong> 尹捷</strong> ： Slack + Asana：团队开发效率大幅提高利器</p>\n<p>Typora：Mac 端优雅的 Markdown 书写利器</p>\n<p>Medium+ 稀土掘金 + 湾区日报：阅读优质技术文章，资讯</p>\n<p>网易云音乐 + 落网：前者能为你推荐你喜欢的音乐，后者收集了很多优秀独立音乐人的作品</p>\n<p>最美应用 + 豌豆荚一览：优质作品搜索利器</p>\n<p>Shadowsocks：嗯</p>\n<p><strong>最美应用 </strong>： 在软件开发方面，有什么经验心得可以来和大家分享下吗？<br><strong> 尹捷</strong> ： 作为一名造诣不够深的开发者，简单分享下两点拙见：</p>\n<p>－ 保持开放的心态，如果有可能的话，尝试下全栈。或许全栈这个词已经受到了很多误读，但至少，全栈开发能让你的思维更加全面，让你的思考更贴近工程实际；</p>\n<p>－ 追本溯源。我们日常的开发都是基于某些平台或工具，如 Android sdk，Flask 框架或其他开源项目。在熟练使用这些工具之后，我建议还应该去探究它们的实现原理，这样才能真正提高技术水平。</p>\n<p><strong>最美应用 </strong>： 还有什么想对大家说的吗？<br><strong> 尹捷</strong> ： 作为一名开发者，我也热爱并重视产品设计。平日里会阅读一些如日式设计相关的书籍。不过，我深知自己在设计方面的学识浅的可怜，因此，我希望在业余时间里能和一些优秀的设计师合作，共同开发一些独具匠心的产品给大家使用。</p>\n<h2 id=\"截屏\"><a href=\"# 截屏\" class=\"headerlink\" title=\"截屏\"></a>截屏</h2><p><img src=\"https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/1.PNG\" alt=\"\"><br><img src=\"https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/2.PNG\"alt=\"\"><br><img src=\"https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/3.PNG\" alt=\"\"><br><img src=\"https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/4.PNG\"alt=\"\"><br><img src=\"https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/7.PNG\" alt=\"\"><br><img src=\"https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/8.PNG\"alt=\"\"><br><img src=\"https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/5.jpg\" alt=\"\"></p>\n<h2 id=\"开源\"><a href=\"# 开源\" class=\"headerlink\" title=\"开源\"></a>开源 </h2><p> 项目开源地址：<a href=\"https://github.com/wingjay/jianshi\" target=\"_blank\" rel=\"external\">https://github.com/wingjay/jianshi</a></p>\n<p>谢谢！</p>\n<p>wingjay</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>简诗是自己的一份追求，对美好设计、全面技术的追求。</p>\n</blockquote>","more":"<h2 id=\"缘由\"><a href=\"#缘由\" class=\"headerlink\" title=\"缘由\"></a>缘由</h2><p>大家好，我是 wingjay ，软件工程师，热爱全栈。</p>\n<p>简诗 是自己业余时间做的一款优雅、纯粹的文字 Android App ，传统纵书风格，以求为用户带来更质朴的书写体验。加之现有文字 App 要么过于复杂，要么界面不够特色，更促成简诗的诞生。</p>\n<blockquote>\n<p>下载地址： <a href=\"http://fir.im/vd1r\" target=\"_blank\" rel=\"external\">http://fir.im/vd1r</a> 。 GitHub 开源： <a href=\"https://github.com/wingjay/jianshi\" target=\"_blank\" rel=\"external\">https://github.com/wingjay/jianshi</a></p>\n</blockquote>\n<p>简诗 的想法最初来源于我阅读的一本来自 Kevin 的书《 Producter 》，书中介绍了 iOS 小记的开发设计过程。唯一的缺憾是没有开发 Android 版本。因此我联系 Kevin 并获取了开发 Android 版本的授权。</p>\n<p>简诗 主要由我独自开发，包括 Android 和 Server 端的，主要利用如周末或平时晚上的业余时间。开发的过程是比较累的，很多周末要熬夜到很晚；但也是充满惊喜的，因为里面有不少来自自己的灵感创意。</p>\n<p>抛开天天用的 Google Material Design ，不断思考新鲜的设计并从工程角度去实现它，这总是非常有成就感的。</p>\n<p>简诗 2.0 最主要的功能是登录注册、数据云同步。由于 1.0 是单机版，所以数据云备份这一点是最多用户反馈的。也正是这个需求，我决定重新为 简诗 搭建后台，实现数据云存储。也正是因为有了后台支持，简诗 添加了很多以前无法实现的功能，比如无限多实时更新的首页图片和三行诗等等。</p>\n<p>希望简诗质朴传统的中国风特质能让用户重新感受到文字的美好，在形影寂寞时，找回一点温暖。</p>\n<h2 id=\"入选最美应用\"><a href=\"#入选最美应用\" class=\"headerlink\" title=\"入选最美应用\"></a>入选最美应用</h2><p>多谢最美应用对简诗的喜爱，并发表了这篇产品推介采访稿<a href=\"http://zuimeia.com/app/4638/\" target=\"_blank\" rel=\"external\">《简诗—他在业余时间开发的这款「Android 版小记」，带你重新找回写作的乐趣》</a>。下面截取采访部分供大家阅读。</p>\n<p><strong>最美应用</strong>：来给大家介绍一下自己吧<br><strong>尹捷</strong> ：大家好，我叫尹捷（wingjay），上海交通大学硕士毕业，软件工程师一枚，现居上海。</p>\n<p><strong>最美应用</strong>： 除了工作，平时喜欢如何规划业余时间呢？<br><strong>尹捷</strong> ： 天气好的话我会在城市里徒步或去户外爬山，摄影；天气不好就宅在家中，开着音响听音乐，下厨、看电影、写代码、看书。</p>\n<p><strong>最美应用</strong>： 开发简诗的初衷是怎样的呢？<br><strong>尹捷</strong> ： 简诗最初的设计稿来自《Producter》一书，该书介绍了 iOS 版小记的开发过程，不过可惜没有 Android 版本，因此我联系小记作者，获取了 Android 版开发授权。</p>\n<p>浓郁的中国风色彩和极简的设计风格，是我开发简诗最本质的原因。</p>\n<p>作为一名开发者，我看过很多设计风格的App，例如 Google 自家的 Material Design，Apple 的扁平化，锤子的拟物化。相比而言，简诗的设计思路和它们都不一样：别致的中国风纵书体验，大片留白的日式设计理念，体现浓郁传统中国文化的细节，都使得简诗与众不同。</p>\n<p>开发一款如此别具一格的 App，在我看来，是一件非常酷的事情。</p>\n<p><strong>最美应用</strong>： 开发过程中，你遇到过哪些有意思的事情，或者是难题？<br><strong>尹捷</strong> ： 简诗的开发主要包括三方面：设计、Android 端、服务端。</p>\n<p>－ 设计：在最初《Producter》的设计草稿基础上，我对整个使用体验做了进一步优化：剔除了原始选择年、月、日的步骤；在首页添加实时变化的三行小诗；在撰写页面根据当前时间如正午、夜半，显示不同的提示语以让用户感觉更为亲近；支持更换背景颜色，色值取自中国传统颜色如素、月白、水红等；文章列表页面仿照古代书籍目录设计；分享时会自动生成简诗的印章，借鉴了传统书画作品中的印章；首页添加实时变化背景图片，这些图片均来自全球优质的摄影作品 UnSplash 网站。</p>\n<p>－ Android 端：Android 端采用了当前最为流行的移动架构和依赖，运行稳定，代码结构简洁，crash 率只有 0.1% ~ 0.3%，开发比较顺利，没有遇到什么难题。</p>\n<p>－ 服务端：本人之前有完整的 PHP 后端开发经验，所以如果采用 PHP 开发的话难度会小很多；不过我最终选择了自己不熟悉的 Python 来进行服务端开发，这给我带来了一些挑战。之所以采用 Python 有两个原因：一是对 Python 这门语言的好奇，软件工程师总是对未知领域充满好奇并想去探索；二是希望通过不同语言的服务端开发，来提升自己对服务端架构的理解。</p>\n<p><strong>最美应用</strong>： 作为一名职业软件工程师，在开发简诗的过程中，是如何分配自己的时间精力的呢？<br><strong>尹捷</strong> ： 简诗 v2.0 的开发主要利用我周末的时间。总共花了三到四个周末，即六天到八天左右，完成了 Android 版本和服务端的开发。开发后段我的一位好友：Ray <a href=\"https://github.com/Panl\" target=\"_blank\" rel=\"external\">https://github.com/Panl</a>) 也加入并协助进行了部分开发工作，有几个周六我俩都开发到了大概凌晨四点钟左右，一边阐述自己的产品创意，一边讨论工程实践的可行性，是非常有趣的一段经历。</p>\n<p><strong>最美应用</strong>： 之后，还会对简诗做哪些方面的改进吗？<br><strong>尹捷</strong> ： 目前简诗 v2.0 已经有不少用户了，我们也在积极收集用户的反馈，后面还会有几个大 feature 要做，欢迎期待哦。</p>\n<p><strong>最美应用</strong>： 对简诗有怎样的愿景呢？<br><strong>尹捷</strong> ： 当代的人们逐渐习惯于阅读快速的文字片段，淡忘了写作的体验。而简诗的存在，就是希望让人们重新找回文字的美好之处，重新感受写作的乐趣。或许并非所有人都喜欢简诗，但只要有一部分人，能从简诗里重新感受到文字的温暖，就足够了。</p>\n<p><strong>最美应用</strong>： 来介绍几款自己喜欢或常用的应用吧<br><strong>尹捷</strong> ： Slack + Asana：团队开发效率大幅提高利器</p>\n<p>Typora：Mac 端优雅的 Markdown 书写利器</p>\n<p>Medium+稀土掘金+湾区日报：阅读优质技术文章，资讯</p>\n<p>网易云音乐+落网：前者能为你推荐你喜欢的音乐，后者收集了很多优秀独立音乐人的作品</p>\n<p>最美应用 + 豌豆荚一览：优质作品搜索利器</p>\n<p>Shadowsocks：嗯</p>\n<p><strong>最美应用</strong>： 在软件开发方面，有什么经验心得可以来和大家分享下吗？<br><strong>尹捷</strong> ： 作为一名造诣不够深的开发者，简单分享下两点拙见：</p>\n<p>－ 保持开放的心态，如果有可能的话，尝试下全栈。或许全栈这个词已经受到了很多误读，但至少，全栈开发能让你的思维更加全面，让你的思考更贴近工程实际；</p>\n<p>－ 追本溯源。我们日常的开发都是基于某些平台或工具，如 Android sdk，Flask 框架或其他开源项目。在熟练使用这些工具之后，我建议还应该去探究它们的实现原理，这样才能真正提高技术水平。</p>\n<p><strong>最美应用</strong>： 还有什么想对大家说的吗？<br><strong>尹捷</strong> ： 作为一名开发者，我也热爱并重视产品设计。平日里会阅读一些如日式设计相关的书籍。不过，我深知自己在设计方面的学识浅的可怜，因此，我希望在业余时间里能和一些优秀的设计师合作，共同开发一些独具匠心的产品给大家使用。</p>\n<h2 id=\"截屏\"><a href=\"#截屏\" class=\"headerlink\" title=\"截屏\"></a>截屏</h2><p><img src=\"https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/1.PNG\" alt=\"\"><br><img src=\"https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/2.PNG\" alt=\"\"><br><img src=\"https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/3.PNG\" alt=\"\"><br><img src=\"https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/4.PNG\" alt=\"\"><br><img src=\"https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/7.PNG\" alt=\"\"><br><img src=\"https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/8.PNG\" alt=\"\"><br><img src=\"https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/5.jpg\" alt=\"\"></p>\n<h2 id=\"开源\"><a href=\"#开源\" class=\"headerlink\" title=\"开源\"></a>开源</h2><p>项目开源地址：<a href=\"https://github.com/wingjay/jianshi\" target=\"_blank\" rel=\"external\">https://github.com/wingjay/jianshi</a></p>\n<p>谢谢！</p>\n<p>wingjay</p>","sticky":0},{"title":"自己动手改造个人博客","date":"2017-06-08T04:12:37.000Z","commentIssueId":1,"_content":"\n个人博客不仅是个人写作的地方，更是一个展示自己个性、扩大个人影响力的产品。\n\n之前我写过一篇《[如何在一天之内搭建以你自己名字为域名且具备cool属性的个人博客](http://www.jianshu.com/p/99665608d295)》帮助不少人从零开始搭建了自己的博客。而今天想做的是把博客当成个人产品来进行迭代开发，以更好地展示个人形象。\n\n<!-- more -->\n\n> 更新：利用脚本为即将发表的文章自动创建一个 Github issue。\n\n下面我将介绍一些关于个人博客的新功能，以及实现功能的过程。[注：建议进入[原文阅读](http://wingjay.com/2017/06/08/rebuild-personal-blog/)，可以查看到功能的具体效果。本站搭建在 Hexo 平台上]\n- 中英文自动添加空格\n- 推荐相关文章\n- 基于GitHub Issue来实现评论功能\n- 个人简历页面\n- RSS订阅\n\n\n## 中英文自动添加空格\n不少有追求的开发者在写博客时追求格式优雅，比如`中英文间隔`。为了达到这个目的，很多时候就不得不在写文时反复调整英文单词与中文的空格。\n\n这里介绍一个小巧的插件：[Auto-Spacing](https://github.com/hexojs/hexo-filter-auto-spacing)，它会在 markdown 文章转化成 html 时，自动为中英文添加空格。\n\n安装方法：\n在项目根目录下，执行 \n```\nnpm install hexo-filter-auto-spacing --save\n```\n\n执行完后可以在根目录的 `package.json` 里找到一行 \n\n```\ndenpendency`:`\"hexo-filter-auto-spacing\": \"^0.2.1\"\n```\n\n**提醒**\n使用这个工具要留意一点：如果你在文章里使用了中英文混合的url，如我本地的图片 `http://wingjay.com/img/我的博客.png`，它会变成 `http://wingjay.com/img/ 我的博客.png`，因此，这里推荐所有图片等资源的url都使用英文。\n\n## 相关文章推荐\n原生的 Hexo 等第三方博客框架并不能提供 `相关文章推荐` 的功能，而对于一款产品而言，增加用户的使用时间是非常好的。\n\n博客也是，当一位读者读完你的某篇文章感觉不错时，再推荐一些相关的文章，读者点击的几率是非常大的。\n\n在连续读完几遍文章后，读者便对你形成了基本的印象：xxx 作者在 Android 方面的 xxx 技术点有不少的研究，以后可以来多关注关注。\n\n下面讲解下如何实现 `相关文章推荐` 功能。\n\n基本思路是：\n1. 改造 hexo theme 里的`博客模板`文件，在模板底部添加一块 html/swig 片段；\n2. 利用 Hexo 提供的 `Helper` 功能，使用 `javascript` 去获取几篇相似文章的链接；\n3. 此处的 `相似`，可以找出相同 tag 的文章，也可以通过其他指标来定义；\n4. 找到了文章列表后，填充在文章模板底部即可。\n\n具体代码实现如下：\n\n0. 先阅读 Hexo 提供的`Helper`功能，https://hexo.io/zh-cn/api/helper.html\n1. 向 `Helper` 里注册函数 `related_posts`，用来抓取相关文章列表。\n进入博客目录的 `themes/next/scripts` 里面，创建 `related_posts.js` 文件，内容如下\n```javascript\n    hexo.extend.helper.register('related_posts', function(currentPost, allPosts){\n        var relatedPosts = [];\n        currentPost.tags.forEach(function (tag) {\n            allPosts.forEach(function (post) {\n                if (isTagRelated(tag.name, post.tags)) {\n                    var relatedPost = {\n                        title: post.title,\n                        path: post.path,\n                        weight: 1\n                    };\n\n                    var index = findItem(relatedPosts, 'path', post.path);\n\n                    if (index != -1) {\n                        relatedPosts[index].weight += 1;\n                    } else{\n                        if (currentPost.path != post.path) {\n                            relatedPosts.push(relatedPost);\n                        };\n                    };\n                };\n            });\n        });\n\n        if (relatedPosts.length == 0) {return ''};\n\n        var result = '<h3>相关文章：</h3><ul class=\"related-posts\">';\n        relatedPosts = relatedPosts.sort(compare('weight'));\n        for (var i = 0; i < Math.min(relatedPosts.length, 10); i++) {\n            result += '<li><a href=\"/' + relatedPosts[i].path + '\">' + relatedPosts[i].title + '</a></li>';\n        };\n        result += '</ul>';\n\n        // console.log(relatedPosts);\n        return result;\n    });\n\n    hexo.extend.helper.register('echo', function(path){\n      return path;\n    });\n\n    function isTagRelated (tagName, TBDtags) {\n        var result = false;\n        TBDtags.forEach(function (tag) {\n            if (tagName == tag.name) {\n                result = true;\n            };\n        })\n\n        return result;\n    }\n\n    function findItem (arrayToSearch, attr, val) {\n        for (var i = 0; i < arrayToSearch.length; i++) {\n            if (arrayToSearch[i][attr] == val) {\n                return i\n            };\n        };\n\n        return -1;\n    }\n\n    function compare (attr) {\n        return function (a, b) {\n            var val1 = a[attr];\n            var val2 = b[attr];\n            return val2 - val1;\n        }\n    }\n```\n2. 修改文章模板 theme/next/layout/_macro/post.swig。在文章底部添加：\n```\n{% if not is_index %} // 不需要显示在首页。\n\t{{ related_posts(post, site.posts) }} // 调用 related_posts\n{% endif %}\n```\n注意，如果是 ejs 文件，则要把`{ { }}`换成\"<\\%- \\%>\"格式，这是 swig 和 ejs 的语法差别。\n\n重新 generate 即可以看到文章底部出现了相关文章推荐。如果想要修改UI，可以在上面的 `related_posts.js` 里返回的 html 片段里添加一些 css 即可。\n\n## 基于GitHub Issue来实现评论功能\n个人博客里的评论功能一直是个很麻烦的存在，博主也一直在寻找合适的解决方案。\n\n“多说”挺好用的，但是今年关闭了；“disqus”是第二个选择，简洁美观，但tm国内经常不打开；“网易云跟帖”也不错，本来是个很好的选择，不过里面的广告留言超级多，过滤机制不好。\n\n本来我都已经放弃了，不过突发奇想，既然我的整个博客都是架在 GitHub 上，那么能不能让 GitHub 来帮我管理评论呢？对于一条评论而言，要能够实现：\n1. 创建评论\n2. 展示评论\n3. 能够过滤广告评论\n\n然后，我想到了 GitHub Issue 和 GitHub API。\n\n不过我几乎没见过国内有博主这么做，于是搜了些国外的文章，做了些调研，果然发现国外也有开发者做过这样的尝试，而且效果我感觉还不错。\n\n具体有两种实现方案：\n1. 读者直接在阅读个人博客时，直接登录 Github 并在文章页面进行评论；\n2. 读者跳转到博客对应的 Github issue处，在 issue 下进行评论，文章展示时会实时获取评论数据。\n\n第一处的用户体验比较好，但是要管理 Github 的第三方登录机制相对麻烦，而且我认为带来的好处没有那么明显。因此我采取了第二种方案，读者跳转到 GitHub Issue 进行评论，文章中利用 Github API 来拉取最新的评论数据。\n\n可以参考文末的评论区，也可以尝试点击到 GitHub Issue 进行评论，给出建议。\n\n实现代码如下：\n1. 在 `themes/myNext/layout/_partials` 创建一个评论 html 片段：`github-comments.swig`，它会自动去 Github 拉取相关的评论，你可以更改`$.ajax(\"https://api.github.com/repos/wingjay/wingjay.github.io/issues/1/comments\",`这句里的 issue url，放上你自己的Github地址。另外，评论里面的 UI 是我自己模仿 GitHub Issue 写的，就是为了保持一个一致性。\n```\n<!doctype html>\n<html>\n<div class=\"clearfix\"></div>\n<br>\n<div id=\"comments\">\n<div class=\"post-header bg-{{site.default_post_color}}\">\n  <h1 class=\"h1 post-title\">评论</h1>\n</div>\n\n<article class=\"post-content\">\n<p>本站评论搭建在 Github Issue 上，请前往 <a href=\"https://github.com/wingjay/wingjay.github.io/issues/1/{{page.commentIssueId}}\">  此文issue</a> 进行评论。（你需要有 Github 账号）<br/>\nWant to leave a comment? Visit <a href=\"https://github.com/wingjay/wingjay.github.io/issues/1/{{page.commentIssueId}}\"> this post's issue page on GitHub</a> (you'll need a GitHub account).</p>\n</article>\n</div>\n\n<style type=\"text/css\">\n.timeline-comment-wrapper {\n    margin-top: 0;\n    position: relative;\n    padding-left: 60px;\n    margin-top: 15px;\n    margin-bottom: 15px;\n    border-top: 2px solid #fff;\n    border-bottom: 2px solid #fff;\n}\n.timeline-comment-avatar {\n    float: left;\n    margin-left: -60px;\n    border-radius: 3px;\n}\n.avatar-parent-child {\n    position: relative;\n}\n.timeline-comment-wrapper a {\n    color: #0366d6;\n    text-decoration: none;\n    background-color: transparent;\n}\n.timeline-comment-wrapper .avatar {\n    display: inline-block;\n    overflow: hidden;\n    line-height: 1;\n    vertical-align: middle;\n    border-radius: 3px;\n}\n.timeline-comment-wrapper .rounded-1 {\n    border-radius: 3px !important;\n}\n.timeline-comment.current-user {\n    border-color: #c0d3eb;\n}\n.timeline-comment {\n    position: relative;\n    background-color: #fff;\n    border: 1px solid #d1d5da;\n    border-radius: 3px;\n}\n.timeline-comment.current-user .timeline-comment-header {\n    background-color: #f1f8ff;\n    border-bottom-color: #c0d3eb;\n}\n.timeline-comment-header {\n    padding-right: 15px;\n    padding-left: 15px;\n    color: #586069;\n    background-color: #f6f8fa;\n    border-bottom: 1px solid #d1d5da;\n    border-top-left-radius: 3px;\n    border-top-right-radius: 3px;\n}\n.timeline-comment-header-text {\n    padding-top: 10px;\n    padding-bottom: 10px;\n}\n.timeline-comment-header h3 {\n    margin-top: 0px;\n    margin-bottom: 0px;\n}\n.timeline-comment-header-text .post-meta {\n    margin-left: 6px;\n}\n.timeline-comment article p {\n    margin: 0px;\n}\n.text-normal {\n    font-weight: normal !important;\n}\n.f5 {\n    font-size: 14px !important;\n}\n</style>\n\n\n\n<script type=\"text/javascript\">\n  function loadComments(data) {\n    for (var i=0; i<data.length; i++) {\n      var cuser = data[i].user.login;\n      var cuserlink = data[i].user.html_url;\n      var avatarlink = data[i].user.avatar_url;\n      var clink = data[i].html_url;\n      var cbody = data[i].body_html;\n      var cavatarlink = data[i].user.avatar_url;      \n      var cdate = new Date(data[i].created_at);\n      var dopts = { month: 'short', day: 'numeric', year: 'numeric' }\n\n      $(\"#comments\").append('<div class=\"timeline-comment-wrapper\"><div class=\"avatar-parent-child timeline-comment-avatar\"><a href=\"' + cuserlink +'\"><img width=\"44\" height=\"44\" class=\"avatar rounded-1\" src=\"' + avatarlink + '\"></a></div><div class=\"timeline-comment current-user\"><div class=\"timeline-comment-header\"><h3 class=\"timeline-comment-header-text text-normal f5\"><strong>' + cuser + '</strong><span class=\"post-meta\">' + cdate.toLocaleDateString(\"en\", dopts) + '</span></h3></div><div style=\"display: block !important; padding: 15px;\"><article class=\"post-content\">' + cbody + '</article></div></div></div>');\n    }\n  }\n  console.log('start load');\n  $.ajax(\"https://api.github.com/repos/wingjay/wingjay.github.io/issues/1/comments\", {\n    headers: {Accept: \"application/vnd.github.v3.html+json\"},\n    dataType: \"json\",\n    success: function(msg){\n      console.log(msg);\n      loadComments(msg);\n   }\n  });\n</script>\n</html>\n```\n2. 然后把上面的html片段放入文章模板里面。`themes/myNext/layout/_macro/post.swig`\n```\n{% if page.commentIssueId %}\n  {% include '../_partials/github-comments.swig' %}\n{% endif %}\n```\n3. 由于上面的 js 代码里用到了 jQuery 的 ajax 语法，因此，还要在 `themes/myNext/layout/_partials/head.swig` 加载 jQuery，此处使用的是国内的 CDN url，加载时间 30ms。\n```\n{% if page.commentIssueId %}\n  <script src=\"https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js\"></script>\n{% endif %}\n```\n4. **更新内容** 通过脚本，自动在 Github 上为该篇文章创建一个 Issue，得到该 Issue ID，设置为该文章的 commentIssueId 值即可。\n  - 指定文章路径，脚本自动读取 commentIssueId 值，若为空，则开始创建 Issue;\n  - 利用 curl 和 Github API 自动创建一个 Issue。其中 YOUR_TOKEN 需要在 Github 的 `Personal access tokens` 里生成一个具备 repo 权限的 token。\n  ```\n  curl -H \"Content-Type: application/json\" -u wingjay:YOUR_TOKEN -X POST -d '{\"title\": \"test\"}' https://api.github.com/repos/wingjay/wingjay.github.io/issues\n  ```\n  - 上面 POST 请求的返回值里的 `number` 值即为需要的 commentIssueId。通过脚本把这个 commentIssueId 添加到原文章中\n  - 最后 deploy 即可。\n  \n上面的步骤都是通过[这个脚本](https://github.com/wingjay/hacker_scripts/blob/master/hexodeploy)实现的，有兴趣的可以看下。\n\n\n## 个人简历页面\n对于一个优秀的博主而言，每天会有很多开发者进入到他的博客。\n\n而无论出于职业生涯还是个人影响力的角度考虑，在博客里放置个人简历是一个很好的展示自己的机会。\n\n下面我们来利用 `hexo` 的 `page` 功能来创建一个新页面，然后用 markdown 来填充这个简历页面。\n\n1. 利用 `hexo new page \"resume\"`，可以看到 `source` 文件夹下出现了 `resume` 目录，里面有一个 `index.md` 文件；\n2. 在 `themes/next/_config.yml` 里的 `menu:` 下添加 `resume: /resume`，它会在首页创建一个新的 menu: resume 入口；\n3. 在 `index.md` 文件里填写自己的简历即可。\n\n最终效果参考本人[简历](/resume)\n  \n## RSS订阅\n目前很多人喜欢用 RSS 阅读器来实时更新某些作者的文章，如果你希望有更多死忠粉，那 RSS 是非常好的渠道把你的文章快速传达给你的读者。\n\n这里我们利用插件 [`hexo-generator-feed`](https://github.com/hexojs/hexo-generator-feed) 来实现这个功能。\n\n1. 安装\nnpm install hexo-generator-feed --save\n2. 修改 _config.yml，具体设置可以参考官方链接里的指示\n```\nfeed:\n  type: atom\n  path: atom.xml\n  limit: 20\n  hub:\n  content:\n```\n3. 在 themes/next/_config.yml 里的 menu 添加 \nrss: /atom.xml\n4. 在 themes/next/languages/zh-Hans.yml 里的 menu 添加中文翻译\nrss: RSS\n\n重新 generate 一下即可看到。\n\n\n## 总结\n好了，这次的功能性博客改造告一段落，欢迎读者提出意见想法。\n\n之后还会对博客做一些加载速度、图片及js文件加载方式等的优化，偏向于流畅性和加载方面。\n\n下次见。\n\n谢谢。\n\nwingjay\n\nhttp://wingjay.com\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n\n## 参考文章\n《[Hexo相关文章的代码实现](https://ethanblog.com/tech/hexo-related-posts.html)》\n《[next主题的模板引擎swig语法介绍](http://jinfang.oschina.io/posts/124966c9/)》\n《[Using GitHub to host blog comments: a working example](http://hydroecology.net/using-github-to-host-blog-comments/)》\n《[GitHub hosted comments for GitHub hosted blogs](http://ivanzuzak.info/2011/02/18/github-hosted-comments-for-github-hosted-blogs.html)》\n《[博客优化点汇总](https://imququ.com/post/summary-of-my-blog-optimization.html)》\n","source":"_posts/自己动手改造个人博客.md","raw":"title: 自己动手改造个人博客\ndate: 2017-06-08 12:12:37\npermalink: rebuild-personal-blog\ncategories:\n  - 个人博客\n  - 一天变cool\ntags:\n  - GitHub\n  - Blog\n  - Hexo\n  - 个人博客\n  - 一天变cool\ncommentIssueId: 1  \n---\n\n个人博客不仅是个人写作的地方，更是一个展示自己个性、扩大个人影响力的产品。\n\n之前我写过一篇《[如何在一天之内搭建以你自己名字为域名且具备cool属性的个人博客](http://www.jianshu.com/p/99665608d295)》帮助不少人从零开始搭建了自己的博客。而今天想做的是把博客当成个人产品来进行迭代开发，以更好地展示个人形象。\n\n<!-- more -->\n\n> 更新：利用脚本为即将发表的文章自动创建一个 Github issue。\n\n下面我将介绍一些关于个人博客的新功能，以及实现功能的过程。[注：建议进入[原文阅读](http://wingjay.com/2017/06/08/rebuild-personal-blog/)，可以查看到功能的具体效果。本站搭建在 Hexo 平台上]\n- 中英文自动添加空格\n- 推荐相关文章\n- 基于GitHub Issue来实现评论功能\n- 个人简历页面\n- RSS订阅\n\n\n## 中英文自动添加空格\n不少有追求的开发者在写博客时追求格式优雅，比如`中英文间隔`。为了达到这个目的，很多时候就不得不在写文时反复调整英文单词与中文的空格。\n\n这里介绍一个小巧的插件：[Auto-Spacing](https://github.com/hexojs/hexo-filter-auto-spacing)，它会在 markdown 文章转化成 html 时，自动为中英文添加空格。\n\n安装方法：\n在项目根目录下，执行 \n```\nnpm install hexo-filter-auto-spacing --save\n```\n\n执行完后可以在根目录的 `package.json` 里找到一行 \n\n```\ndenpendency`:`\"hexo-filter-auto-spacing\": \"^0.2.1\"\n```\n\n**提醒**\n使用这个工具要留意一点：如果你在文章里使用了中英文混合的url，如我本地的图片 `http://wingjay.com/img/我的博客.png`，它会变成 `http://wingjay.com/img/ 我的博客.png`，因此，这里推荐所有图片等资源的url都使用英文。\n\n## 相关文章推荐\n原生的 Hexo 等第三方博客框架并不能提供 `相关文章推荐` 的功能，而对于一款产品而言，增加用户的使用时间是非常好的。\n\n博客也是，当一位读者读完你的某篇文章感觉不错时，再推荐一些相关的文章，读者点击的几率是非常大的。\n\n在连续读完几遍文章后，读者便对你形成了基本的印象：xxx 作者在 Android 方面的 xxx 技术点有不少的研究，以后可以来多关注关注。\n\n下面讲解下如何实现 `相关文章推荐` 功能。\n\n基本思路是：\n1. 改造 hexo theme 里的`博客模板`文件，在模板底部添加一块 html/swig 片段；\n2. 利用 Hexo 提供的 `Helper` 功能，使用 `javascript` 去获取几篇相似文章的链接；\n3. 此处的 `相似`，可以找出相同 tag 的文章，也可以通过其他指标来定义；\n4. 找到了文章列表后，填充在文章模板底部即可。\n\n具体代码实现如下：\n\n0. 先阅读 Hexo 提供的`Helper`功能，https://hexo.io/zh-cn/api/helper.html\n1. 向 `Helper` 里注册函数 `related_posts`，用来抓取相关文章列表。\n进入博客目录的 `themes/next/scripts` 里面，创建 `related_posts.js` 文件，内容如下\n```javascript\n    hexo.extend.helper.register('related_posts', function(currentPost, allPosts){\n        var relatedPosts = [];\n        currentPost.tags.forEach(function (tag) {\n            allPosts.forEach(function (post) {\n                if (isTagRelated(tag.name, post.tags)) {\n                    var relatedPost = {\n                        title: post.title,\n                        path: post.path,\n                        weight: 1\n                    };\n\n                    var index = findItem(relatedPosts, 'path', post.path);\n\n                    if (index != -1) {\n                        relatedPosts[index].weight += 1;\n                    } else{\n                        if (currentPost.path != post.path) {\n                            relatedPosts.push(relatedPost);\n                        };\n                    };\n                };\n            });\n        });\n\n        if (relatedPosts.length == 0) {return ''};\n\n        var result = '<h3>相关文章：</h3><ul class=\"related-posts\">';\n        relatedPosts = relatedPosts.sort(compare('weight'));\n        for (var i = 0; i < Math.min(relatedPosts.length, 10); i++) {\n            result += '<li><a href=\"/' + relatedPosts[i].path + '\">' + relatedPosts[i].title + '</a></li>';\n        };\n        result += '</ul>';\n\n        // console.log(relatedPosts);\n        return result;\n    });\n\n    hexo.extend.helper.register('echo', function(path){\n      return path;\n    });\n\n    function isTagRelated (tagName, TBDtags) {\n        var result = false;\n        TBDtags.forEach(function (tag) {\n            if (tagName == tag.name) {\n                result = true;\n            };\n        })\n\n        return result;\n    }\n\n    function findItem (arrayToSearch, attr, val) {\n        for (var i = 0; i < arrayToSearch.length; i++) {\n            if (arrayToSearch[i][attr] == val) {\n                return i\n            };\n        };\n\n        return -1;\n    }\n\n    function compare (attr) {\n        return function (a, b) {\n            var val1 = a[attr];\n            var val2 = b[attr];\n            return val2 - val1;\n        }\n    }\n```\n2. 修改文章模板 theme/next/layout/_macro/post.swig。在文章底部添加：\n```\n{% if not is_index %} // 不需要显示在首页。\n\t{{ related_posts(post, site.posts) }} // 调用 related_posts\n{% endif %}\n```\n注意，如果是 ejs 文件，则要把`{ { }}`换成\"<\\%- \\%>\"格式，这是 swig 和 ejs 的语法差别。\n\n重新 generate 即可以看到文章底部出现了相关文章推荐。如果想要修改UI，可以在上面的 `related_posts.js` 里返回的 html 片段里添加一些 css 即可。\n\n## 基于GitHub Issue来实现评论功能\n个人博客里的评论功能一直是个很麻烦的存在，博主也一直在寻找合适的解决方案。\n\n“多说”挺好用的，但是今年关闭了；“disqus”是第二个选择，简洁美观，但tm国内经常不打开；“网易云跟帖”也不错，本来是个很好的选择，不过里面的广告留言超级多，过滤机制不好。\n\n本来我都已经放弃了，不过突发奇想，既然我的整个博客都是架在 GitHub 上，那么能不能让 GitHub 来帮我管理评论呢？对于一条评论而言，要能够实现：\n1. 创建评论\n2. 展示评论\n3. 能够过滤广告评论\n\n然后，我想到了 GitHub Issue 和 GitHub API。\n\n不过我几乎没见过国内有博主这么做，于是搜了些国外的文章，做了些调研，果然发现国外也有开发者做过这样的尝试，而且效果我感觉还不错。\n\n具体有两种实现方案：\n1. 读者直接在阅读个人博客时，直接登录 Github 并在文章页面进行评论；\n2. 读者跳转到博客对应的 Github issue处，在 issue 下进行评论，文章展示时会实时获取评论数据。\n\n第一处的用户体验比较好，但是要管理 Github 的第三方登录机制相对麻烦，而且我认为带来的好处没有那么明显。因此我采取了第二种方案，读者跳转到 GitHub Issue 进行评论，文章中利用 Github API 来拉取最新的评论数据。\n\n可以参考文末的评论区，也可以尝试点击到 GitHub Issue 进行评论，给出建议。\n\n实现代码如下：\n1. 在 `themes/myNext/layout/_partials` 创建一个评论 html 片段：`github-comments.swig`，它会自动去 Github 拉取相关的评论，你可以更改`$.ajax(\"https://api.github.com/repos/wingjay/wingjay.github.io/issues/1/comments\",`这句里的 issue url，放上你自己的Github地址。另外，评论里面的 UI 是我自己模仿 GitHub Issue 写的，就是为了保持一个一致性。\n```\n<!doctype html>\n<html>\n<div class=\"clearfix\"></div>\n<br>\n<div id=\"comments\">\n<div class=\"post-header bg-{{site.default_post_color}}\">\n  <h1 class=\"h1 post-title\">评论</h1>\n</div>\n\n<article class=\"post-content\">\n<p>本站评论搭建在 Github Issue 上，请前往 <a href=\"https://github.com/wingjay/wingjay.github.io/issues/1/{{page.commentIssueId}}\">  此文issue</a> 进行评论。（你需要有 Github 账号）<br/>\nWant to leave a comment? Visit <a href=\"https://github.com/wingjay/wingjay.github.io/issues/1/{{page.commentIssueId}}\"> this post's issue page on GitHub</a> (you'll need a GitHub account).</p>\n</article>\n</div>\n\n<style type=\"text/css\">\n.timeline-comment-wrapper {\n    margin-top: 0;\n    position: relative;\n    padding-left: 60px;\n    margin-top: 15px;\n    margin-bottom: 15px;\n    border-top: 2px solid #fff;\n    border-bottom: 2px solid #fff;\n}\n.timeline-comment-avatar {\n    float: left;\n    margin-left: -60px;\n    border-radius: 3px;\n}\n.avatar-parent-child {\n    position: relative;\n}\n.timeline-comment-wrapper a {\n    color: #0366d6;\n    text-decoration: none;\n    background-color: transparent;\n}\n.timeline-comment-wrapper .avatar {\n    display: inline-block;\n    overflow: hidden;\n    line-height: 1;\n    vertical-align: middle;\n    border-radius: 3px;\n}\n.timeline-comment-wrapper .rounded-1 {\n    border-radius: 3px !important;\n}\n.timeline-comment.current-user {\n    border-color: #c0d3eb;\n}\n.timeline-comment {\n    position: relative;\n    background-color: #fff;\n    border: 1px solid #d1d5da;\n    border-radius: 3px;\n}\n.timeline-comment.current-user .timeline-comment-header {\n    background-color: #f1f8ff;\n    border-bottom-color: #c0d3eb;\n}\n.timeline-comment-header {\n    padding-right: 15px;\n    padding-left: 15px;\n    color: #586069;\n    background-color: #f6f8fa;\n    border-bottom: 1px solid #d1d5da;\n    border-top-left-radius: 3px;\n    border-top-right-radius: 3px;\n}\n.timeline-comment-header-text {\n    padding-top: 10px;\n    padding-bottom: 10px;\n}\n.timeline-comment-header h3 {\n    margin-top: 0px;\n    margin-bottom: 0px;\n}\n.timeline-comment-header-text .post-meta {\n    margin-left: 6px;\n}\n.timeline-comment article p {\n    margin: 0px;\n}\n.text-normal {\n    font-weight: normal !important;\n}\n.f5 {\n    font-size: 14px !important;\n}\n</style>\n\n\n\n<script type=\"text/javascript\">\n  function loadComments(data) {\n    for (var i=0; i<data.length; i++) {\n      var cuser = data[i].user.login;\n      var cuserlink = data[i].user.html_url;\n      var avatarlink = data[i].user.avatar_url;\n      var clink = data[i].html_url;\n      var cbody = data[i].body_html;\n      var cavatarlink = data[i].user.avatar_url;      \n      var cdate = new Date(data[i].created_at);\n      var dopts = { month: 'short', day: 'numeric', year: 'numeric' }\n\n      $(\"#comments\").append('<div class=\"timeline-comment-wrapper\"><div class=\"avatar-parent-child timeline-comment-avatar\"><a href=\"' + cuserlink +'\"><img width=\"44\" height=\"44\" class=\"avatar rounded-1\" src=\"' + avatarlink + '\"></a></div><div class=\"timeline-comment current-user\"><div class=\"timeline-comment-header\"><h3 class=\"timeline-comment-header-text text-normal f5\"><strong>' + cuser + '</strong><span class=\"post-meta\">' + cdate.toLocaleDateString(\"en\", dopts) + '</span></h3></div><div style=\"display: block !important; padding: 15px;\"><article class=\"post-content\">' + cbody + '</article></div></div></div>');\n    }\n  }\n  console.log('start load');\n  $.ajax(\"https://api.github.com/repos/wingjay/wingjay.github.io/issues/1/comments\", {\n    headers: {Accept: \"application/vnd.github.v3.html+json\"},\n    dataType: \"json\",\n    success: function(msg){\n      console.log(msg);\n      loadComments(msg);\n   }\n  });\n</script>\n</html>\n```\n2. 然后把上面的html片段放入文章模板里面。`themes/myNext/layout/_macro/post.swig`\n```\n{% if page.commentIssueId %}\n  {% include '../_partials/github-comments.swig' %}\n{% endif %}\n```\n3. 由于上面的 js 代码里用到了 jQuery 的 ajax 语法，因此，还要在 `themes/myNext/layout/_partials/head.swig` 加载 jQuery，此处使用的是国内的 CDN url，加载时间 30ms。\n```\n{% if page.commentIssueId %}\n  <script src=\"https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js\"></script>\n{% endif %}\n```\n4. **更新内容** 通过脚本，自动在 Github 上为该篇文章创建一个 Issue，得到该 Issue ID，设置为该文章的 commentIssueId 值即可。\n  - 指定文章路径，脚本自动读取 commentIssueId 值，若为空，则开始创建 Issue;\n  - 利用 curl 和 Github API 自动创建一个 Issue。其中 YOUR_TOKEN 需要在 Github 的 `Personal access tokens` 里生成一个具备 repo 权限的 token。\n  ```\n  curl -H \"Content-Type: application/json\" -u wingjay:YOUR_TOKEN -X POST -d '{\"title\": \"test\"}' https://api.github.com/repos/wingjay/wingjay.github.io/issues\n  ```\n  - 上面 POST 请求的返回值里的 `number` 值即为需要的 commentIssueId。通过脚本把这个 commentIssueId 添加到原文章中\n  - 最后 deploy 即可。\n  \n上面的步骤都是通过[这个脚本](https://github.com/wingjay/hacker_scripts/blob/master/hexodeploy)实现的，有兴趣的可以看下。\n\n\n## 个人简历页面\n对于一个优秀的博主而言，每天会有很多开发者进入到他的博客。\n\n而无论出于职业生涯还是个人影响力的角度考虑，在博客里放置个人简历是一个很好的展示自己的机会。\n\n下面我们来利用 `hexo` 的 `page` 功能来创建一个新页面，然后用 markdown 来填充这个简历页面。\n\n1. 利用 `hexo new page \"resume\"`，可以看到 `source` 文件夹下出现了 `resume` 目录，里面有一个 `index.md` 文件；\n2. 在 `themes/next/_config.yml` 里的 `menu:` 下添加 `resume: /resume`，它会在首页创建一个新的 menu: resume 入口；\n3. 在 `index.md` 文件里填写自己的简历即可。\n\n最终效果参考本人[简历](/resume)\n  \n## RSS订阅\n目前很多人喜欢用 RSS 阅读器来实时更新某些作者的文章，如果你希望有更多死忠粉，那 RSS 是非常好的渠道把你的文章快速传达给你的读者。\n\n这里我们利用插件 [`hexo-generator-feed`](https://github.com/hexojs/hexo-generator-feed) 来实现这个功能。\n\n1. 安装\nnpm install hexo-generator-feed --save\n2. 修改 _config.yml，具体设置可以参考官方链接里的指示\n```\nfeed:\n  type: atom\n  path: atom.xml\n  limit: 20\n  hub:\n  content:\n```\n3. 在 themes/next/_config.yml 里的 menu 添加 \nrss: /atom.xml\n4. 在 themes/next/languages/zh-Hans.yml 里的 menu 添加中文翻译\nrss: RSS\n\n重新 generate 一下即可看到。\n\n\n## 总结\n好了，这次的功能性博客改造告一段落，欢迎读者提出意见想法。\n\n之后还会对博客做一些加载速度、图片及js文件加载方式等的优化，偏向于流畅性和加载方面。\n\n下次见。\n\n谢谢。\n\nwingjay\n\nhttp://wingjay.com\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n\n## 参考文章\n《[Hexo相关文章的代码实现](https://ethanblog.com/tech/hexo-related-posts.html)》\n《[next主题的模板引擎swig语法介绍](http://jinfang.oschina.io/posts/124966c9/)》\n《[Using GitHub to host blog comments: a working example](http://hydroecology.net/using-github-to-host-blog-comments/)》\n《[GitHub hosted comments for GitHub hosted blogs](http://ivanzuzak.info/2011/02/18/github-hosted-comments-for-github-hosted-blogs.html)》\n《[博客优化点汇总](https://imququ.com/post/summary-of-my-blog-optimization.html)》\n","slug":"rebuild-personal-blog","published":1,"updated":"2018-11-26T06:56:27.487Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplsi900373dn8h6nqebat","content":"<p>个人博客不仅是个人写作的地方，更是一个展示自己个性、扩大个人影响力的产品。</p>\n<p>之前我写过一篇《<a href=\"http://www.jianshu.com/p/99665608d295\" target=\"_blank\" rel=\"external\">如何在一天之内搭建以你自己名字为域名且具备 cool 属性的个人博客</a>》帮助不少人从零开始搭建了自己的博客。而今天想做的是把博客当成个人产品来进行迭代开发，以更好地展示个人形象。</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>更新：利用脚本为即将发表的文章自动创建一个 Github issue。</p>\n</blockquote>\n<p>下面我将介绍一些关于个人博客的新功能，以及实现功能的过程。[注：建议进入 <a href=\"http://wingjay.com/2017/06/08/rebuild-personal-blog/\"> 原文阅读</a>，可以查看到功能的具体效果。本站搭建在 Hexo 平台上]</p>\n<ul>\n<li>中英文自动添加空格</li>\n<li>推荐相关文章</li>\n<li>基于 GitHub Issue 来实现评论功能</li>\n<li>个人简历页面</li>\n<li>RSS 订阅</li>\n</ul>\n<h2 id=\"中英文自动添加空格\"><a href=\"# 中英文自动添加空格\" class=\"headerlink\" title=\"中英文自动添加空格\"></a>中英文自动添加空格 </h2><p> 不少有追求的开发者在写博客时追求格式优雅，比如 <code> 中英文间隔</code>。为了达到这个目的，很多时候就不得不在写文时反复调整英文单词与中文的空格。</p>\n<p>这里介绍一个小巧的插件：<a href=\"https://github.com/hexojs/hexo-filter-auto-spacing\" target=\"_blank\" rel=\"external\">Auto-Spacing</a>，它会在 markdown 文章转化成 html 时，自动为中英文添加空格。</p>\n<p>安装方法：<br>在项目根目录下，执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-filter-auto-spacing --save</div></pre></td></tr></table></figure></p>\n<p>执行完后可以在根目录的 <code>package.json</code> 里找到一行 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">denpendency`:`&quot;hexo-filter-auto-spacing&quot;: &quot;^0.2.1&quot;</div></pre></td></tr></table></figure>\n<p><strong>提醒 </strong><br> 使用这个工具要留意一点：如果你在文章里使用了中英文混合的 url，如我本地的图片 <code>http://wingjay.com/img/ 我的博客.png</code>，它会变成 <code>http://wingjay.com/img/ 我的博客.png</code>，因此，这里推荐所有图片等资源的 url 都使用英文。</p>\n<h2 id=\"相关文章推荐\"><a href=\"# 相关文章推荐\" class=\"headerlink\" title=\"相关文章推荐\"></a>相关文章推荐 </h2><p> 原生的 Hexo 等第三方博客框架并不能提供 <code>相关文章推荐</code> 的功能，而对于一款产品而言，增加用户的使用时间是非常好的。</p>\n<p>博客也是，当一位读者读完你的某篇文章感觉不错时，再推荐一些相关的文章，读者点击的几率是非常大的。</p>\n<p>在连续读完几遍文章后，读者便对你形成了基本的印象：xxx 作者在 Android 方面的 xxx 技术点有不少的研究，以后可以来多关注关注。</p>\n<p>下面讲解下如何实现 <code>相关文章推荐</code> 功能。</p>\n<p>基本思路是：</p>\n<ol>\n<li>改造 hexo theme 里的 <code> 博客模板 </code> 文件，在模板底部添加一块 html/swig 片段；</li>\n<li>利用 Hexo 提供的 <code>Helper</code> 功能，使用 <code>javascript</code> 去获取几篇相似文章的链接；</li>\n<li>此处的 <code>相似</code>，可以找出相同 tag 的文章，也可以通过其他指标来定义；</li>\n<li>找到了文章列表后，填充在文章模板底部即可。</li>\n</ol>\n<p>具体代码实现如下：</p>\n<ol>\n<li>先阅读 Hexo 提供的 <code>Helper</code> 功能，<a href=\"https://hexo.io/zh-cn/api/helper.html\" target=\"_blank\" rel=\"external\">https://hexo.io/zh-cn/api/helper.html</a></li>\n<li><p>向 <code>Helper</code> 里注册函数 <code>related_posts</code>，用来抓取相关文章列表。<br>进入博客目录的 <code>themes/next/scripts</code> 里面，创建 <code>related_posts.js</code> 文件，内容如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo.extend.helper.register(<span class=\"string\">'related_posts'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">currentPost, allPosts</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> relatedPosts = [];</div><div class=\"line\">    currentPost.tags.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">tag</span>) </span>&#123;</div><div class=\"line\">        allPosts.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">post</span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (isTagRelated(tag.name, post.tags)) &#123;</div><div class=\"line\">                <span class=\"keyword\">var</span> relatedPost = &#123;</div><div class=\"line\">                    title: post.title,</div><div class=\"line\">                    path: post.path,</div><div class=\"line\">                    weight: <span class=\"number\">1</span></div><div class=\"line\">                &#125;;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"keyword\">var</span> index = findItem(relatedPosts, <span class=\"string\">'path'</span>, post.path);</div><div class=\"line\"></div><div class=\"line\">                <span class=\"keyword\">if</span> (index != <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">                    relatedPosts[index].weight += <span class=\"number\">1</span>;</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span>&#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (currentPost.path != post.path) &#123;</div><div class=\"line\">                        relatedPosts.push(relatedPost);</div><div class=\"line\">                    &#125;;</div><div class=\"line\">                &#125;;</div><div class=\"line\">            &#125;;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (relatedPosts.length == <span class=\"number\">0</span>) &#123;<span class=\"keyword\">return</span> <span class=\"string\">''</span>&#125;;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> result = <span class=\"string\">'&lt;h3&gt; 相关文章：&lt;/h3&gt;&lt;ul class=\"related-posts\"&gt;'</span>;</div><div class=\"line\">    relatedPosts = relatedPosts.sort(compare(<span class=\"string\">'weight'</span>));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">Math</span>.min(relatedPosts.length, <span class=\"number\">10</span>); i++) &#123;</div><div class=\"line\">        result += <span class=\"string\">'&lt;li&gt;&lt;a href=\"/'</span> + relatedPosts[i].path + <span class=\"string\">'\"&gt;'</span> + relatedPosts[i].title + <span class=\"string\">'&lt;/a&gt;&lt;/li&gt;'</span>;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    result += <span class=\"string\">'&lt;/ul&gt;'</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// console.log(relatedPosts);</span></div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">hexo.extend.helper.register(<span class=\"string\">'echo'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> path;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isTagRelated</span> (<span class=\"params\">tagName, TBDtags</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> result = <span class=\"literal\">false</span>;</div><div class=\"line\">    TBDtags.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">tag</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (tagName == tag.name) &#123;</div><div class=\"line\">            result = <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findItem</span> (<span class=\"params\">arrayToSearch, attr, val</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arrayToSearch.length; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (arrayToSearch[i][attr] == val) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> i</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compare</span> (<span class=\"params\">attr</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> val1 = a[attr];</div><div class=\"line\">        <span class=\"keyword\">var</span> val2 = b[attr];</div><div class=\"line\">        <span class=\"keyword\">return</span> val2 - val1;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>修改文章模板 theme/next/layout/_macro/post.swig。在文章底部添加：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;% if not is_index %&#125; // 不需要显示在首页。</div><div class=\"line\">\t&#123;&#123; related_posts(post, site.posts) &#125;&#125; // 调用 related_posts</div><div class=\"line\">&#123;% endif %&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>注意，如果是 ejs 文件，则要把 <code>{{}}</code> 换成”&lt;\\%- \\%&gt;”格式，这是 swig 和 ejs 的语法差别。</p>\n<p>重新 generate 即可以看到文章底部出现了相关文章推荐。如果想要修改 UI，可以在上面的 <code>related_posts.js</code> 里返回的 html 片段里添加一些 css 即可。</p>\n<h2 id=\"基于 GitHub-Issue 来实现评论功能\"><a href=\"# 基于 GitHub-Issue 来实现评论功能\" class=\"headerlink\" title=\"基于 GitHub Issue 来实现评论功能\"></a>基于 GitHub Issue 来实现评论功能 </h2><p> 个人博客里的评论功能一直是个很麻烦的存在，博主也一直在寻找合适的解决方案。</p>\n<p>“多说”挺好用的，但是今年关闭了；“disqus”是第二个选择，简洁美观，但 tm 国内经常不打开；“网易云跟帖”也不错，本来是个很好的选择，不过里面的广告留言超级多，过滤机制不好。</p>\n<p>本来我都已经放弃了，不过突发奇想，既然我的整个博客都是架在 GitHub 上，那么能不能让 GitHub 来帮我管理评论呢？对于一条评论而言，要能够实现：</p>\n<ol>\n<li>创建评论</li>\n<li>展示评论</li>\n<li>能够过滤广告评论</li>\n</ol>\n<p>然后，我想到了 GitHub Issue 和 GitHub API。</p>\n<p>不过我几乎没见过国内有博主这么做，于是搜了些国外的文章，做了些调研，果然发现国外也有开发者做过这样的尝试，而且效果我感觉还不错。</p>\n<p>具体有两种实现方案：</p>\n<ol>\n<li>读者直接在阅读个人博客时，直接登录 Github 并在文章页面进行评论；</li>\n<li>读者跳转到博客对应的 Github issue 处，在 issue 下进行评论，文章展示时会实时获取评论数据。</li>\n</ol>\n<p>第一处的用户体验比较好，但是要管理 Github 的第三方登录机制相对麻烦，而且我认为带来的好处没有那么明显。因此我采取了第二种方案，读者跳转到 GitHub Issue 进行评论，文章中利用 Github API 来拉取最新的评论数据。</p>\n<p>可以参考文末的评论区，也可以尝试点击到 GitHub Issue 进行评论，给出建议。</p>\n<p>实现代码如下：</p>\n<ol>\n<li><p>在 <code>themes/myNext/layout/_partials</code> 创建一个评论 html 片段：<code>github-comments.swig</code>，它会自动去 Github 拉取相关的评论，你可以更改 <code>$.ajax(&quot;https://api.github.com/repos/wingjay/wingjay.github.io/issues/1/comments&quot;,</code> 这句里的 issue url，放上你自己的 Github 地址。另外，评论里面的 UI 是我自己模仿 GitHub Issue 写的，就是为了保持一个一致性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!doctype html&gt;</div><div class=\"line\">&lt;html&gt;</div><div class=\"line\">&lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;br&gt;</div><div class=\"line\">&lt;div id=&quot;comments&quot;&gt;</div><div class=\"line\">&lt;div class=&quot;post-header bg-&#123;&#123;site.default_post_color&#125;&#125;&quot;&gt;</div><div class=\"line\">  &lt;h1 class=&quot;h1 post-title&quot;&gt; 评论 &lt;/h1&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;article class=&quot;post-content&quot;&gt;</div><div class=\"line\">&lt;p&gt; 本站评论搭建在 Github Issue 上，请前往 &lt;a href=&quot;https://github.com/wingjay/wingjay.github.io/issues/1/&#123;&#123;page.commentIssueId&#125;&#125;&quot;&gt;  此文 issue&lt;/a&gt; 进行评论。（你需要有 Github 账号）&lt;br/&gt;</div><div class=\"line\">Want to leave a comment? Visit &lt;a href=&quot;https://github.com/wingjay/wingjay.github.io/issues/1/&#123;&#123;page.commentIssueId&#125;&#125;&quot;&gt; this post&apos;s issue page on GitHub&lt;/a&gt; (you&apos;ll need a GitHub account).&lt;/p&gt;</div><div class=\"line\">&lt;/article&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;style type=&quot;text/css&quot;&gt;</div><div class=\"line\">.timeline-comment-wrapper &#123;</div><div class=\"line\">    margin-top: 0;</div><div class=\"line\">    position: relative;</div><div class=\"line\">    padding-left: 60px;</div><div class=\"line\">    margin-top: 15px;</div><div class=\"line\">    margin-bottom: 15px;</div><div class=\"line\">    border-top: 2px solid #fff;</div><div class=\"line\">    border-bottom: 2px solid #fff;</div><div class=\"line\">&#125;</div><div class=\"line\">.timeline-comment-avatar &#123;</div><div class=\"line\">    float: left;</div><div class=\"line\">    margin-left: -60px;</div><div class=\"line\">    border-radius: 3px;</div><div class=\"line\">&#125;</div><div class=\"line\">.avatar-parent-child &#123;</div><div class=\"line\">    position: relative;</div><div class=\"line\">&#125;</div><div class=\"line\">.timeline-comment-wrapper a &#123;</div><div class=\"line\">    color: #0366d6;</div><div class=\"line\">    text-decoration: none;</div><div class=\"line\">    background-color: transparent;</div><div class=\"line\">&#125;</div><div class=\"line\">.timeline-comment-wrapper .avatar &#123;</div><div class=\"line\">    display: inline-block;</div><div class=\"line\">    overflow: hidden;</div><div class=\"line\">    line-height: 1;</div><div class=\"line\">    vertical-align: middle;</div><div class=\"line\">    border-radius: 3px;</div><div class=\"line\">&#125;</div><div class=\"line\">.timeline-comment-wrapper .rounded-1 &#123;</div><div class=\"line\">    border-radius: 3px !important;</div><div class=\"line\">&#125;</div><div class=\"line\">.timeline-comment.current-user &#123;</div><div class=\"line\">    border-color: #c0d3eb;</div><div class=\"line\">&#125;</div><div class=\"line\">.timeline-comment &#123;</div><div class=\"line\">    position: relative;</div><div class=\"line\">    background-color: #fff;</div><div class=\"line\">    border: 1px solid #d1d5da;</div><div class=\"line\">    border-radius: 3px;</div><div class=\"line\">&#125;</div><div class=\"line\">.timeline-comment.current-user .timeline-comment-header &#123;</div><div class=\"line\">    background-color: #f1f8ff;</div><div class=\"line\">    border-bottom-color: #c0d3eb;</div><div class=\"line\">&#125;</div><div class=\"line\">.timeline-comment-header &#123;</div><div class=\"line\">    padding-right: 15px;</div><div class=\"line\">    padding-left: 15px;</div><div class=\"line\">    color: #586069;</div><div class=\"line\">    background-color: #f6f8fa;</div><div class=\"line\">    border-bottom: 1px solid #d1d5da;</div><div class=\"line\">    border-top-left-radius: 3px;</div><div class=\"line\">    border-top-right-radius: 3px;</div><div class=\"line\">&#125;</div><div class=\"line\">.timeline-comment-header-text &#123;</div><div class=\"line\">    padding-top: 10px;</div><div class=\"line\">    padding-bottom: 10px;</div><div class=\"line\">&#125;</div><div class=\"line\">.timeline-comment-header h3 &#123;</div><div class=\"line\">    margin-top: 0px;</div><div class=\"line\">    margin-bottom: 0px;</div><div class=\"line\">&#125;</div><div class=\"line\">.timeline-comment-header-text .post-meta &#123;</div><div class=\"line\">    margin-left: 6px;</div><div class=\"line\">&#125;</div><div class=\"line\">.timeline-comment article p &#123;</div><div class=\"line\">    margin: 0px;</div><div class=\"line\">&#125;</div><div class=\"line\">.text-normal &#123;</div><div class=\"line\">    font-weight: normal !important;</div><div class=\"line\">&#125;</div><div class=\"line\">.f5 &#123;</div><div class=\"line\">    font-size: 14px !important;</div><div class=\"line\">&#125;</div><div class=\"line\">&lt;/style&gt;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class=\"line\">  function loadComments(data) &#123;</div><div class=\"line\">    for (var i=0; i&lt;data.length; i++) &#123;</div><div class=\"line\">      var cuser = data[i].user.login;</div><div class=\"line\">      var cuserlink = data[i].user.html_url;</div><div class=\"line\">      var avatarlink = data[i].user.avatar_url;</div><div class=\"line\">      var clink = data[i].html_url;</div><div class=\"line\">      var cbody = data[i].body_html;</div><div class=\"line\">      var cavatarlink = data[i].user.avatar_url;      </div><div class=\"line\">      var cdate = new Date(data[i].created_at);</div><div class=\"line\">      var dopts = &#123; month: &apos;short&apos;, day: &apos;numeric&apos;, year: &apos;numeric&apos; &#125;</div><div class=\"line\"></div><div class=\"line\">      $(&quot;#comments&quot;).append(&apos;&lt;div class=&quot;timeline-comment-wrapper&quot;&gt;&lt;div class=&quot;avatar-parent-child timeline-comment-avatar&quot;&gt;&lt;a href=&quot;&apos; + cuserlink +&apos;&quot;&gt;&lt;img width=&quot;44&quot; height=&quot;44&quot; class=&quot;avatar rounded-1&quot; src=&quot;&apos; + avatarlink + &apos;&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;timeline-comment current-user&quot;&gt;&lt;div class=&quot;timeline-comment-header&quot;&gt;&lt;h3 class=&quot;timeline-comment-header-text text-normal f5&quot;&gt;&lt;strong&gt;&apos; + cuser + &apos;&lt;/strong&gt;&lt;span class=&quot;post-meta&quot;&gt;&apos; + cdate.toLocaleDateString(&quot;en&quot;, dopts) + &apos;&lt;/span&gt;&lt;/h3&gt;&lt;/div&gt;&lt;div style=&quot;display: block !important; padding: 15px;&quot;&gt;&lt;article class=&quot;post-content&quot;&gt;&apos; + cbody + &apos;&lt;/article&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&apos;);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  console.log(&apos;start load&apos;);</div><div class=\"line\">  $.ajax(&quot;https://api.github.com/repos/wingjay/wingjay.github.io/issues/1/comments&quot;, &#123;</div><div class=\"line\">    headers: &#123;Accept: &quot;application/vnd.github.v3.html+json&quot;&#125;,</div><div class=\"line\">    dataType: &quot;json&quot;,</div><div class=\"line\">    success: function(msg)&#123;</div><div class=\"line\">      console.log(msg);</div><div class=\"line\">      loadComments(msg);</div><div class=\"line\">   &#125;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&lt;/script&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>然后把上面的 html 片段放入文章模板里面。<code>themes/myNext/layout/_macro/post.swig</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;% if page.commentIssueId %&#125;</div><div class=\"line\">  &#123;% include &apos;../_partials/github-comments.swig&apos; %&#125;</div><div class=\"line\">&#123;% endif %&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>由于上面的 js 代码里用到了 jQuery 的 ajax 语法，因此，还要在 <code>themes/myNext/layout/_partials/head.swig</code> 加载 jQuery，此处使用的是国内的 CDN url，加载时间 30ms。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;% if page.commentIssueId %&#125;</div><div class=\"line\">  &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&#123;% endif %&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>更新内容</strong> 通过脚本，自动在 Github 上为该篇文章创建一个 Issue，得到该 Issue ID，设置为该文章的 commentIssueId 值即可。</p>\n<ul>\n<li>指定文章路径，脚本自动读取 commentIssueId 值，若为空，则开始创建 Issue;</li>\n<li><p>利用 curl 和 Github API 自动创建一个 Issue。其中 YOUR_TOKEN 需要在 Github 的 <code>Personal access tokens</code> 里生成一个具备 repo 权限的 token。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -H &quot;Content-Type: application/json&quot; -u wingjay:YOUR_TOKEN -X POST -d &apos;&#123;&quot;title&quot;: &quot;test&quot;&#125;&apos; https://api.github.com/repos/wingjay/wingjay.github.io/issues</div></pre></td></tr></table></figure>\n</li>\n<li><p>上面 POST 请求的返回值里的 <code>number</code> 值即为需要的 commentIssueId。通过脚本把这个 commentIssueId 添加到原文章中</p>\n</li>\n<li>最后 deploy 即可。</li>\n</ul>\n</li>\n</ol>\n<p>上面的步骤都是通过 <a href=\"https://github.com/wingjay/hacker_scripts/blob/master/hexodeploy\" target=\"_blank\" rel=\"external\"> 这个脚本 </a> 实现的，有兴趣的可以看下。</p>\n<h2 id=\"个人简历页面\"><a href=\"# 个人简历页面\" class=\"headerlink\" title=\"个人简历页面\"></a>个人简历页面 </h2><p> 对于一个优秀的博主而言，每天会有很多开发者进入到他的博客。</p>\n<p>而无论出于职业生涯还是个人影响力的角度考虑，在博客里放置个人简历是一个很好的展示自己的机会。</p>\n<p>下面我们来利用 <code>hexo</code> 的 <code>page</code> 功能来创建一个新页面，然后用 markdown 来填充这个简历页面。</p>\n<ol>\n<li>利用 <code>hexo new page &quot;resume&quot;</code>，可以看到 <code>source</code> 文件夹下出现了 <code>resume</code> 目录，里面有一个 <code>index.md</code> 文件；</li>\n<li>在 <code>themes/next/_config.yml</code> 里的 <code>menu:</code> 下添加 <code>resume: /resume</code>，它会在首页创建一个新的 menu: resume 入口；</li>\n<li>在 <code>index.md</code> 文件里填写自己的简历即可。</li>\n</ol>\n<p>最终效果参考本人 <a href=\"/resume\"> 简历</a></p>\n<h2 id=\"RSS 订阅\"><a href=\"#RSS 订阅\" class=\"headerlink\" title=\"RSS 订阅\"></a>RSS 订阅 </h2><p> 目前很多人喜欢用 RSS 阅读器来实时更新某些作者的文章，如果你希望有更多死忠粉，那 RSS 是非常好的渠道把你的文章快速传达给你的读者。</p>\n<p>这里我们利用插件 <a href=\"https://github.com/hexojs/hexo-generator-feed\" target=\"_blank\" rel=\"external\"><code>hexo-generator-feed</code></a> 来实现这个功能。</p>\n<ol>\n<li>安装<br>npm install hexo-generator-feed –save</li>\n<li><p>修改 _config.yml，具体设置可以参考官方链接里的指示</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">feed:</div><div class=\"line\">  type: atom</div><div class=\"line\">  path: atom.xml</div><div class=\"line\">  limit: 20</div><div class=\"line\">  hub:</div><div class=\"line\">  content:</div></pre></td></tr></table></figure>\n</li>\n<li><p>在 themes/next/_config.yml 里的 menu 添加<br>rss: /atom.xml</p>\n</li>\n<li>在 themes/next/languages/zh-Hans.yml 里的 menu 添加中文翻译<br>rss: RSS</li>\n</ol>\n<p>重新 generate 一下即可看到。</p>\n<h2 id=\"总结\"><a href=\"# 总结\" class=\"headerlink\" title=\"总结\"></a>总结 </h2><p> 好了，这次的功能性博客改造告一段落，欢迎读者提出意见想法。</p>\n<p>之后还会对博客做一些加载速度、图片及 js 文件加载方式等的优化，偏向于流畅性和加载方面。</p>\n<p>下次见。</p>\n<p>谢谢。</p>\n<p>wingjay</p>\n<p><a href=\"http://wingjay.com\">http://wingjay.com</a></p>\n<p><img src=\"https://avatars0.githubusercontent.com/u/9619875?v=3&amp;s=460\" alt=\"\"></p>\n<h2 id=\"参考文章\"><a href=\"# 参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章 </h2><p>《<a href=\"https://ethanblog.com/tech/hexo-related-posts.html\" target=\"_blank\" rel=\"external\">Hexo 相关文章的代码实现</a>》<br>《<a href=\"http://jinfang.oschina.io/posts/124966c9/\" target=\"_blank\" rel=\"external\">next 主题的模板引擎 swig 语法介绍</a>》<br>《<a href=\"http://hydroecology.net/using-github-to-host-blog-comments/\" target=\"_blank\" rel=\"external\">Using GitHub to host blog comments: a working example</a>》<br>《<a href=\"http://ivanzuzak.info/2011/02/18/github-hosted-comments-for-github-hosted-blogs.html\" target=\"_blank\" rel=\"external\">GitHub hosted comments for GitHub hosted blogs</a>》<br>《<a href=\"https://imququ.com/post/summary-of-my-blog-optimization.html\" target=\"_blank\" rel=\"external\"> 博客优化点汇总</a>》</p>\n","site":{"data":{}},"excerpt":"<p>个人博客不仅是个人写作的地方，更是一个展示自己个性、扩大个人影响力的产品。</p>\n<p>之前我写过一篇《<a href=\"http://www.jianshu.com/p/99665608d295\" target=\"_blank\" rel=\"external\">如何在一天之内搭建以你自己名字为域名且具备cool属性的个人博客</a>》帮助不少人从零开始搭建了自己的博客。而今天想做的是把博客当成个人产品来进行迭代开发，以更好地展示个人形象。</p>","more":"<blockquote>\n<p>更新：利用脚本为即将发表的文章自动创建一个 Github issue。</p>\n</blockquote>\n<p>下面我将介绍一些关于个人博客的新功能，以及实现功能的过程。[注：建议进入<a href=\"http://wingjay.com/2017/06/08/rebuild-personal-blog/\">原文阅读</a>，可以查看到功能的具体效果。本站搭建在 Hexo 平台上]</p>\n<ul>\n<li>中英文自动添加空格</li>\n<li>推荐相关文章</li>\n<li>基于GitHub Issue来实现评论功能</li>\n<li>个人简历页面</li>\n<li>RSS订阅</li>\n</ul>\n<h2 id=\"中英文自动添加空格\"><a href=\"#中英文自动添加空格\" class=\"headerlink\" title=\"中英文自动添加空格\"></a>中英文自动添加空格</h2><p>不少有追求的开发者在写博客时追求格式优雅，比如<code>中英文间隔</code>。为了达到这个目的，很多时候就不得不在写文时反复调整英文单词与中文的空格。</p>\n<p>这里介绍一个小巧的插件：<a href=\"https://github.com/hexojs/hexo-filter-auto-spacing\" target=\"_blank\" rel=\"external\">Auto-Spacing</a>，它会在 markdown 文章转化成 html 时，自动为中英文添加空格。</p>\n<p>安装方法：<br>在项目根目录下，执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-filter-auto-spacing --save</div></pre></td></tr></table></figure></p>\n<p>执行完后可以在根目录的 <code>package.json</code> 里找到一行 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">denpendency`:`&quot;hexo-filter-auto-spacing&quot;: &quot;^0.2.1&quot;</div></pre></td></tr></table></figure>\n<p><strong>提醒</strong><br>使用这个工具要留意一点：如果你在文章里使用了中英文混合的url，如我本地的图片 <code>http://wingjay.com/img/我的博客.png</code>，它会变成 <code>http://wingjay.com/img/ 我的博客.png</code>，因此，这里推荐所有图片等资源的url都使用英文。</p>\n<h2 id=\"相关文章推荐\"><a href=\"#相关文章推荐\" class=\"headerlink\" title=\"相关文章推荐\"></a>相关文章推荐</h2><p>原生的 Hexo 等第三方博客框架并不能提供 <code>相关文章推荐</code> 的功能，而对于一款产品而言，增加用户的使用时间是非常好的。</p>\n<p>博客也是，当一位读者读完你的某篇文章感觉不错时，再推荐一些相关的文章，读者点击的几率是非常大的。</p>\n<p>在连续读完几遍文章后，读者便对你形成了基本的印象：xxx 作者在 Android 方面的 xxx 技术点有不少的研究，以后可以来多关注关注。</p>\n<p>下面讲解下如何实现 <code>相关文章推荐</code> 功能。</p>\n<p>基本思路是：</p>\n<ol>\n<li>改造 hexo theme 里的<code>博客模板</code>文件，在模板底部添加一块 html/swig 片段；</li>\n<li>利用 Hexo 提供的 <code>Helper</code> 功能，使用 <code>javascript</code> 去获取几篇相似文章的链接；</li>\n<li>此处的 <code>相似</code>，可以找出相同 tag 的文章，也可以通过其他指标来定义；</li>\n<li>找到了文章列表后，填充在文章模板底部即可。</li>\n</ol>\n<p>具体代码实现如下：</p>\n<ol>\n<li>先阅读 Hexo 提供的<code>Helper</code>功能，<a href=\"https://hexo.io/zh-cn/api/helper.html\" target=\"_blank\" rel=\"external\">https://hexo.io/zh-cn/api/helper.html</a></li>\n<li><p>向 <code>Helper</code> 里注册函数 <code>related_posts</code>，用来抓取相关文章列表。<br>进入博客目录的 <code>themes/next/scripts</code> 里面，创建 <code>related_posts.js</code> 文件，内容如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo.extend.helper.register(<span class=\"string\">'related_posts'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">currentPost, allPosts</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> relatedPosts = [];</div><div class=\"line\">    currentPost.tags.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">tag</span>) </span>&#123;</div><div class=\"line\">        allPosts.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">post</span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (isTagRelated(tag.name, post.tags)) &#123;</div><div class=\"line\">                <span class=\"keyword\">var</span> relatedPost = &#123;</div><div class=\"line\">                    title: post.title,</div><div class=\"line\">                    path: post.path,</div><div class=\"line\">                    weight: <span class=\"number\">1</span></div><div class=\"line\">                &#125;;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"keyword\">var</span> index = findItem(relatedPosts, <span class=\"string\">'path'</span>, post.path);</div><div class=\"line\"></div><div class=\"line\">                <span class=\"keyword\">if</span> (index != <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">                    relatedPosts[index].weight += <span class=\"number\">1</span>;</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span>&#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (currentPost.path != post.path) &#123;</div><div class=\"line\">                        relatedPosts.push(relatedPost);</div><div class=\"line\">                    &#125;;</div><div class=\"line\">                &#125;;</div><div class=\"line\">            &#125;;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (relatedPosts.length == <span class=\"number\">0</span>) &#123;<span class=\"keyword\">return</span> <span class=\"string\">''</span>&#125;;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> result = <span class=\"string\">'&lt;h3&gt;相关文章：&lt;/h3&gt;&lt;ul class=\"related-posts\"&gt;'</span>;</div><div class=\"line\">    relatedPosts = relatedPosts.sort(compare(<span class=\"string\">'weight'</span>));</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">Math</span>.min(relatedPosts.length, <span class=\"number\">10</span>); i++) &#123;</div><div class=\"line\">        result += <span class=\"string\">'&lt;li&gt;&lt;a href=\"/'</span> + relatedPosts[i].path + <span class=\"string\">'\"&gt;'</span> + relatedPosts[i].title + <span class=\"string\">'&lt;/a&gt;&lt;/li&gt;'</span>;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    result += <span class=\"string\">'&lt;/ul&gt;'</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// console.log(relatedPosts);</span></div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">hexo.extend.helper.register(<span class=\"string\">'echo'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> path;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isTagRelated</span> (<span class=\"params\">tagName, TBDtags</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> result = <span class=\"literal\">false</span>;</div><div class=\"line\">    TBDtags.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">tag</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (tagName == tag.name) &#123;</div><div class=\"line\">            result = <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findItem</span> (<span class=\"params\">arrayToSearch, attr, val</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arrayToSearch.length; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (arrayToSearch[i][attr] == val) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> i</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compare</span> (<span class=\"params\">attr</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> val1 = a[attr];</div><div class=\"line\">        <span class=\"keyword\">var</span> val2 = b[attr];</div><div class=\"line\">        <span class=\"keyword\">return</span> val2 - val1;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>修改文章模板 theme/next/layout/_macro/post.swig。在文章底部添加：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;% if not is_index %&#125; // 不需要显示在首页。</div><div class=\"line\">\t&#123;&#123; related_posts(post, site.posts) &#125;&#125; // 调用 related_posts</div><div class=\"line\">&#123;% endif %&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>注意，如果是 ejs 文件，则要把<code>{ { }}</code>换成”&lt;\\%- \\%&gt;”格式，这是 swig 和 ejs 的语法差别。</p>\n<p>重新 generate 即可以看到文章底部出现了相关文章推荐。如果想要修改UI，可以在上面的 <code>related_posts.js</code> 里返回的 html 片段里添加一些 css 即可。</p>\n<h2 id=\"基于GitHub-Issue来实现评论功能\"><a href=\"#基于GitHub-Issue来实现评论功能\" class=\"headerlink\" title=\"基于GitHub Issue来实现评论功能\"></a>基于GitHub Issue来实现评论功能</h2><p>个人博客里的评论功能一直是个很麻烦的存在，博主也一直在寻找合适的解决方案。</p>\n<p>“多说”挺好用的，但是今年关闭了；“disqus”是第二个选择，简洁美观，但tm国内经常不打开；“网易云跟帖”也不错，本来是个很好的选择，不过里面的广告留言超级多，过滤机制不好。</p>\n<p>本来我都已经放弃了，不过突发奇想，既然我的整个博客都是架在 GitHub 上，那么能不能让 GitHub 来帮我管理评论呢？对于一条评论而言，要能够实现：</p>\n<ol>\n<li>创建评论</li>\n<li>展示评论</li>\n<li>能够过滤广告评论</li>\n</ol>\n<p>然后，我想到了 GitHub Issue 和 GitHub API。</p>\n<p>不过我几乎没见过国内有博主这么做，于是搜了些国外的文章，做了些调研，果然发现国外也有开发者做过这样的尝试，而且效果我感觉还不错。</p>\n<p>具体有两种实现方案：</p>\n<ol>\n<li>读者直接在阅读个人博客时，直接登录 Github 并在文章页面进行评论；</li>\n<li>读者跳转到博客对应的 Github issue处，在 issue 下进行评论，文章展示时会实时获取评论数据。</li>\n</ol>\n<p>第一处的用户体验比较好，但是要管理 Github 的第三方登录机制相对麻烦，而且我认为带来的好处没有那么明显。因此我采取了第二种方案，读者跳转到 GitHub Issue 进行评论，文章中利用 Github API 来拉取最新的评论数据。</p>\n<p>可以参考文末的评论区，也可以尝试点击到 GitHub Issue 进行评论，给出建议。</p>\n<p>实现代码如下：</p>\n<ol>\n<li><p>在 <code>themes/myNext/layout/_partials</code> 创建一个评论 html 片段：<code>github-comments.swig</code>，它会自动去 Github 拉取相关的评论，你可以更改<code>$.ajax(&quot;https://api.github.com/repos/wingjay/wingjay.github.io/issues/1/comments&quot;,</code>这句里的 issue url，放上你自己的Github地址。另外，评论里面的 UI 是我自己模仿 GitHub Issue 写的，就是为了保持一个一致性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!doctype html&gt;</div><div class=\"line\">&lt;html&gt;</div><div class=\"line\">&lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;br&gt;</div><div class=\"line\">&lt;div id=&quot;comments&quot;&gt;</div><div class=\"line\">&lt;div class=&quot;post-header bg-&#123;&#123;site.default_post_color&#125;&#125;&quot;&gt;</div><div class=\"line\">  &lt;h1 class=&quot;h1 post-title&quot;&gt;评论&lt;/h1&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;article class=&quot;post-content&quot;&gt;</div><div class=\"line\">&lt;p&gt;本站评论搭建在 Github Issue 上，请前往 &lt;a href=&quot;https://github.com/wingjay/wingjay.github.io/issues/1/&#123;&#123;page.commentIssueId&#125;&#125;&quot;&gt;  此文issue&lt;/a&gt; 进行评论。（你需要有 Github 账号）&lt;br/&gt;</div><div class=\"line\">Want to leave a comment? Visit &lt;a href=&quot;https://github.com/wingjay/wingjay.github.io/issues/1/&#123;&#123;page.commentIssueId&#125;&#125;&quot;&gt; this post&apos;s issue page on GitHub&lt;/a&gt; (you&apos;ll need a GitHub account).&lt;/p&gt;</div><div class=\"line\">&lt;/article&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;style type=&quot;text/css&quot;&gt;</div><div class=\"line\">.timeline-comment-wrapper &#123;</div><div class=\"line\">    margin-top: 0;</div><div class=\"line\">    position: relative;</div><div class=\"line\">    padding-left: 60px;</div><div class=\"line\">    margin-top: 15px;</div><div class=\"line\">    margin-bottom: 15px;</div><div class=\"line\">    border-top: 2px solid #fff;</div><div class=\"line\">    border-bottom: 2px solid #fff;</div><div class=\"line\">&#125;</div><div class=\"line\">.timeline-comment-avatar &#123;</div><div class=\"line\">    float: left;</div><div class=\"line\">    margin-left: -60px;</div><div class=\"line\">    border-radius: 3px;</div><div class=\"line\">&#125;</div><div class=\"line\">.avatar-parent-child &#123;</div><div class=\"line\">    position: relative;</div><div class=\"line\">&#125;</div><div class=\"line\">.timeline-comment-wrapper a &#123;</div><div class=\"line\">    color: #0366d6;</div><div class=\"line\">    text-decoration: none;</div><div class=\"line\">    background-color: transparent;</div><div class=\"line\">&#125;</div><div class=\"line\">.timeline-comment-wrapper .avatar &#123;</div><div class=\"line\">    display: inline-block;</div><div class=\"line\">    overflow: hidden;</div><div class=\"line\">    line-height: 1;</div><div class=\"line\">    vertical-align: middle;</div><div class=\"line\">    border-radius: 3px;</div><div class=\"line\">&#125;</div><div class=\"line\">.timeline-comment-wrapper .rounded-1 &#123;</div><div class=\"line\">    border-radius: 3px !important;</div><div class=\"line\">&#125;</div><div class=\"line\">.timeline-comment.current-user &#123;</div><div class=\"line\">    border-color: #c0d3eb;</div><div class=\"line\">&#125;</div><div class=\"line\">.timeline-comment &#123;</div><div class=\"line\">    position: relative;</div><div class=\"line\">    background-color: #fff;</div><div class=\"line\">    border: 1px solid #d1d5da;</div><div class=\"line\">    border-radius: 3px;</div><div class=\"line\">&#125;</div><div class=\"line\">.timeline-comment.current-user .timeline-comment-header &#123;</div><div class=\"line\">    background-color: #f1f8ff;</div><div class=\"line\">    border-bottom-color: #c0d3eb;</div><div class=\"line\">&#125;</div><div class=\"line\">.timeline-comment-header &#123;</div><div class=\"line\">    padding-right: 15px;</div><div class=\"line\">    padding-left: 15px;</div><div class=\"line\">    color: #586069;</div><div class=\"line\">    background-color: #f6f8fa;</div><div class=\"line\">    border-bottom: 1px solid #d1d5da;</div><div class=\"line\">    border-top-left-radius: 3px;</div><div class=\"line\">    border-top-right-radius: 3px;</div><div class=\"line\">&#125;</div><div class=\"line\">.timeline-comment-header-text &#123;</div><div class=\"line\">    padding-top: 10px;</div><div class=\"line\">    padding-bottom: 10px;</div><div class=\"line\">&#125;</div><div class=\"line\">.timeline-comment-header h3 &#123;</div><div class=\"line\">    margin-top: 0px;</div><div class=\"line\">    margin-bottom: 0px;</div><div class=\"line\">&#125;</div><div class=\"line\">.timeline-comment-header-text .post-meta &#123;</div><div class=\"line\">    margin-left: 6px;</div><div class=\"line\">&#125;</div><div class=\"line\">.timeline-comment article p &#123;</div><div class=\"line\">    margin: 0px;</div><div class=\"line\">&#125;</div><div class=\"line\">.text-normal &#123;</div><div class=\"line\">    font-weight: normal !important;</div><div class=\"line\">&#125;</div><div class=\"line\">.f5 &#123;</div><div class=\"line\">    font-size: 14px !important;</div><div class=\"line\">&#125;</div><div class=\"line\">&lt;/style&gt;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class=\"line\">  function loadComments(data) &#123;</div><div class=\"line\">    for (var i=0; i&lt;data.length; i++) &#123;</div><div class=\"line\">      var cuser = data[i].user.login;</div><div class=\"line\">      var cuserlink = data[i].user.html_url;</div><div class=\"line\">      var avatarlink = data[i].user.avatar_url;</div><div class=\"line\">      var clink = data[i].html_url;</div><div class=\"line\">      var cbody = data[i].body_html;</div><div class=\"line\">      var cavatarlink = data[i].user.avatar_url;      </div><div class=\"line\">      var cdate = new Date(data[i].created_at);</div><div class=\"line\">      var dopts = &#123; month: &apos;short&apos;, day: &apos;numeric&apos;, year: &apos;numeric&apos; &#125;</div><div class=\"line\"></div><div class=\"line\">      $(&quot;#comments&quot;).append(&apos;&lt;div class=&quot;timeline-comment-wrapper&quot;&gt;&lt;div class=&quot;avatar-parent-child timeline-comment-avatar&quot;&gt;&lt;a href=&quot;&apos; + cuserlink +&apos;&quot;&gt;&lt;img width=&quot;44&quot; height=&quot;44&quot; class=&quot;avatar rounded-1&quot; src=&quot;&apos; + avatarlink + &apos;&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;timeline-comment current-user&quot;&gt;&lt;div class=&quot;timeline-comment-header&quot;&gt;&lt;h3 class=&quot;timeline-comment-header-text text-normal f5&quot;&gt;&lt;strong&gt;&apos; + cuser + &apos;&lt;/strong&gt;&lt;span class=&quot;post-meta&quot;&gt;&apos; + cdate.toLocaleDateString(&quot;en&quot;, dopts) + &apos;&lt;/span&gt;&lt;/h3&gt;&lt;/div&gt;&lt;div style=&quot;display: block !important; padding: 15px;&quot;&gt;&lt;article class=&quot;post-content&quot;&gt;&apos; + cbody + &apos;&lt;/article&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&apos;);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  console.log(&apos;start load&apos;);</div><div class=\"line\">  $.ajax(&quot;https://api.github.com/repos/wingjay/wingjay.github.io/issues/1/comments&quot;, &#123;</div><div class=\"line\">    headers: &#123;Accept: &quot;application/vnd.github.v3.html+json&quot;&#125;,</div><div class=\"line\">    dataType: &quot;json&quot;,</div><div class=\"line\">    success: function(msg)&#123;</div><div class=\"line\">      console.log(msg);</div><div class=\"line\">      loadComments(msg);</div><div class=\"line\">   &#125;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&lt;/script&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>然后把上面的html片段放入文章模板里面。<code>themes/myNext/layout/_macro/post.swig</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;% if page.commentIssueId %&#125;</div><div class=\"line\">  &#123;% include &apos;../_partials/github-comments.swig&apos; %&#125;</div><div class=\"line\">&#123;% endif %&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>由于上面的 js 代码里用到了 jQuery 的 ajax 语法，因此，还要在 <code>themes/myNext/layout/_partials/head.swig</code> 加载 jQuery，此处使用的是国内的 CDN url，加载时间 30ms。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;% if page.commentIssueId %&#125;</div><div class=\"line\">  &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&#123;% endif %&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>更新内容</strong> 通过脚本，自动在 Github 上为该篇文章创建一个 Issue，得到该 Issue ID，设置为该文章的 commentIssueId 值即可。</p>\n<ul>\n<li>指定文章路径，脚本自动读取 commentIssueId 值，若为空，则开始创建 Issue;</li>\n<li><p>利用 curl 和 Github API 自动创建一个 Issue。其中 YOUR_TOKEN 需要在 Github 的 <code>Personal access tokens</code> 里生成一个具备 repo 权限的 token。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -H &quot;Content-Type: application/json&quot; -u wingjay:YOUR_TOKEN -X POST -d &apos;&#123;&quot;title&quot;: &quot;test&quot;&#125;&apos; https://api.github.com/repos/wingjay/wingjay.github.io/issues</div></pre></td></tr></table></figure>\n</li>\n<li><p>上面 POST 请求的返回值里的 <code>number</code> 值即为需要的 commentIssueId。通过脚本把这个 commentIssueId 添加到原文章中</p>\n</li>\n<li>最后 deploy 即可。</li>\n</ul>\n</li>\n</ol>\n<p>上面的步骤都是通过<a href=\"https://github.com/wingjay/hacker_scripts/blob/master/hexodeploy\" target=\"_blank\" rel=\"external\">这个脚本</a>实现的，有兴趣的可以看下。</p>\n<h2 id=\"个人简历页面\"><a href=\"#个人简历页面\" class=\"headerlink\" title=\"个人简历页面\"></a>个人简历页面</h2><p>对于一个优秀的博主而言，每天会有很多开发者进入到他的博客。</p>\n<p>而无论出于职业生涯还是个人影响力的角度考虑，在博客里放置个人简历是一个很好的展示自己的机会。</p>\n<p>下面我们来利用 <code>hexo</code> 的 <code>page</code> 功能来创建一个新页面，然后用 markdown 来填充这个简历页面。</p>\n<ol>\n<li>利用 <code>hexo new page &quot;resume&quot;</code>，可以看到 <code>source</code> 文件夹下出现了 <code>resume</code> 目录，里面有一个 <code>index.md</code> 文件；</li>\n<li>在 <code>themes/next/_config.yml</code> 里的 <code>menu:</code> 下添加 <code>resume: /resume</code>，它会在首页创建一个新的 menu: resume 入口；</li>\n<li>在 <code>index.md</code> 文件里填写自己的简历即可。</li>\n</ol>\n<p>最终效果参考本人<a href=\"/resume\">简历</a></p>\n<h2 id=\"RSS订阅\"><a href=\"#RSS订阅\" class=\"headerlink\" title=\"RSS订阅\"></a>RSS订阅</h2><p>目前很多人喜欢用 RSS 阅读器来实时更新某些作者的文章，如果你希望有更多死忠粉，那 RSS 是非常好的渠道把你的文章快速传达给你的读者。</p>\n<p>这里我们利用插件 <a href=\"https://github.com/hexojs/hexo-generator-feed\" target=\"_blank\" rel=\"external\"><code>hexo-generator-feed</code></a> 来实现这个功能。</p>\n<ol>\n<li>安装<br>npm install hexo-generator-feed –save</li>\n<li><p>修改 _config.yml，具体设置可以参考官方链接里的指示</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">feed:</div><div class=\"line\">  type: atom</div><div class=\"line\">  path: atom.xml</div><div class=\"line\">  limit: 20</div><div class=\"line\">  hub:</div><div class=\"line\">  content:</div></pre></td></tr></table></figure>\n</li>\n<li><p>在 themes/next/_config.yml 里的 menu 添加<br>rss: /atom.xml</p>\n</li>\n<li>在 themes/next/languages/zh-Hans.yml 里的 menu 添加中文翻译<br>rss: RSS</li>\n</ol>\n<p>重新 generate 一下即可看到。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>好了，这次的功能性博客改造告一段落，欢迎读者提出意见想法。</p>\n<p>之后还会对博客做一些加载速度、图片及js文件加载方式等的优化，偏向于流畅性和加载方面。</p>\n<p>下次见。</p>\n<p>谢谢。</p>\n<p>wingjay</p>\n<p><a href=\"http://wingjay.com\">http://wingjay.com</a></p>\n<p><img src=\"https://avatars0.githubusercontent.com/u/9619875?v=3&amp;s=460\" alt=\"\"></p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p>《<a href=\"https://ethanblog.com/tech/hexo-related-posts.html\" target=\"_blank\" rel=\"external\">Hexo相关文章的代码实现</a>》<br>《<a href=\"http://jinfang.oschina.io/posts/124966c9/\" target=\"_blank\" rel=\"external\">next主题的模板引擎swig语法介绍</a>》<br>《<a href=\"http://hydroecology.net/using-github-to-host-blog-comments/\" target=\"_blank\" rel=\"external\">Using GitHub to host blog comments: a working example</a>》<br>《<a href=\"http://ivanzuzak.info/2011/02/18/github-hosted-comments-for-github-hosted-blogs.html\" target=\"_blank\" rel=\"external\">GitHub hosted comments for GitHub hosted blogs</a>》<br>《<a href=\"https://imququ.com/post/summary-of-my-blog-optimization.html\" target=\"_blank\" rel=\"external\">博客优化点汇总</a>》</p>","sticky":0},{"title":"让普通 Java 类自动感知 Activity Lifecycle","date":"2017-11-09T15:00:02.000Z","commentIssueId":23,"_content":"## 背景\n在 Android 开发中，我们都很熟悉 Activity 的 Lifecycle，并且会在特定的 Lifecycle 下执行特定的操作。当然，我们清楚 Lifecycle 本身是带有 Android 特质的，那尝试设想下，如果`普通的 Java Class 也能自动感知\n Lifecycle 呢`？咋一听这个想法似乎背后意义不大，但在实际探索中，我们发现这个特性能为我们达成一些之前未考虑到或者不易实现的优化。\n\n本文分享下我们基于这个思想所开发的框架：`AutoLifecycle` 及其带来的一些有意思的实践。\n\n<!-- more -->\n\n- 优化一：当Activity进入onDestroy时，自动取消网络请求返回\n- 优化二：自动将网络请求时机提前到View渲染之前，提高页面打开速度\n- 优化三：MVP改进，让Presenter和View自动bind/unBind\n\n\n注：下文提到的`Lifecycle-Aware`就是这里指代的`让普通 Java Class 自动获取 Lifecycle `。\n\n## 实践及优化\n### 优化一：当Activity进入onDestroy时，自动取消网络请求返回\n在网络请求时，相信大家都有一个经验：在每个网络结果回来时，我们做的第一件事不是显示数据，而是写个if-else判断Activity还在不在。\n```java\nmTopApiObservable\n  ...\n  .subscribe(new Subscriber<Object>() {\n\t  @Override\n\t  public void onNext(Object data) {\n\t  \tif(activity == null) {\n\t\t\treturn; // 判断Activity是否还在，不在就不去显示数据\n\t\t}\n\t\t\n\t\tdisplay(data); // 显示数据\n\t  }\n\t  ...\n  });\n```\n由于网络请求都是异步的，所以不得不做这样的判断，来防止不可预测的空指针问题或内存泄漏问题。\n\n既然你总是担心`Activity`还在不在，那么如果我们通过`Lifecycle-Aware让每个网络请求能自动感知Activity的onDestroy事件`，\n并在`onDestroy`时，自动把网络请求结果`取消掉不再返回`，那就能够消除这个担忧了。\n```java\nmTopApiObservable\n  ...\n  .compose(bindUntilEvent(ActivityLifecycle.DESTROY)) // 绑定Activity的onDestroy事件\n  .subscribe(new Subscriber<Object>() {\n\t  @Override\n\t  public void onNext(Object data) {\n\t\tdisplay(data); // 直接去显示数据\n\t  }\n\t  ...\n  });\n```\n\n其中最关键的就是`compose(bindUntilEvent(ActivityLifecycle.DESTROY))`这句，它能达到的效果是：一旦`Activity`发生`onDestroy`时，`Observer`的数据就会停止向`Subscriber`里流动。从而保证`onNext`无需担心`Activity`已`Destroy`这种情况。\n\n**在上面网络请求的实践里，你还可以根据自己的情况把`Destroy`换成`Stop`/`Pause`等，而且可以看出，这种自动取消机制可适用于任何`Observable`，不仅仅是网络请求。**\n\n### 优化二：自动将网络请求提前到View Inflate之前，加速页面渲染\n先说下这项优化的原理。\n通常，我们会在`Activity`的`onCreate`里依次执行下面的代码：\n```java\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.XXX);   // Inflate View\n    findViewByIds();                // 初始化View\n    presenter.loadDataFromServer(); // 发起网络请求\n}\n```\n即在`Inflate View`和`初始化View`之后，才发起网络请求去加载数据。\n\n而实际上，网络请求是不占用主线程的，如果能在`Inflate View`之前就在其他线程发起网络请求，可以把整个页面显示耗时缩短`100ms-200ms`。\n> ![LoadBeforeInflate优化效果](http://upload-images.jianshu.io/upload_images/281665-dbf719e2d9a88946.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n现在有了`AutoLifecycle`框架，我们就可以很轻松实现：让Presenter自动监听`Inflate View`这个生命周期，在那时发起网络请求即可。\n\n```java\npublic class NewPresenter {\n\n    public NewPresenter(IView iView) {\n        ...\n\t\t// 向AutoLifecycle注册\n        AutoLifecycle.getInstance().init(this); \n    }\n\n\t// 当Activity Inflate View前自动回调\n    @AutoLifecycleEvent(activity = ActivityLifecycle.PRE_INFLATE)\n    private void onHostPreInflate() {\n         loadDataFromServer(); // 发起网络请求\n    }\n\t...\n}\n```\n\n此时，我们的Activity也不用手动调用`presenter.loadDataFromServer();`了，因为Presenter内会在感知到`Inflate View`事件时自动发起网络请求。\n\n```java\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.XXX);\n    findViewByIds();\n    // 无需手动启动网络请求\n}\n```\n\n经过测试，在保证单个网络请求耗时相同的情况下，页面从`onCreate`到`显示数据`的渲染耗时可以从`550ms`缩短到`367ms`，也就是`30%-40%`的优化，效果是非常不错的，而且代码也更加简洁清晰。\n> ![](http://upload-images.jianshu.io/upload_images/281665-3d050c819f7c158e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n \n\n通过简单的注册`AutoLifecycle`，`Presenter`能够自动感知到所有`Lifecycle`，甚至包括自定义的特殊`Lifecycle`，如下图：\n![LifecycleAwarePresenter](http://upload-images.jianshu.io/upload_images/281665-3c00d59f5cacebcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n### 优化三：MVP改进，让Presenter和View自动bind/unBind\n第一项优化比较直接，可以先让大家形成一个直观印象。\n我们项目是采用MVP项目，对于`Presenter`的使用存在一段固定代码，即在`onCreate`时调用`bindView()`，在`onDestroy`时调用`unBindView()`。如下图：\n```java\npublic class OldActivity extends BaseActivity {\n\n    BasePresenter mPresenter = new BasePresenter();\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\t\tmPresenter.bindView(this); // onCreate时手动bind Presenter 和 IView\n    }\n\n    @Override\n    protected void onDestroy() {\n        mPresenter.unbindView(); // onDestroy时手动unBindView\n        super.onDestroy();\n    }\n}\n```\n\n那么，既然我们现在能`让一个普通类自动感知Lifecycle`，那其实也就能让`Presenter`在感知到`onCreate`时`自动bindView`，在感知到`onDestroy`时`自动unBindView`。\n改进后的代码如下：\n```java\npublic class NewActivity extends BaseActivity {\n\n    NewPresenter mPresenter;\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        mPresenter = new NewPresenter(this); // 只需要创建即可\n    }\n}\n\npublic class NewPresenter {\n\n    private IView mIView;\n\n    public NewPresenter(IView iView) {\n        this.mIView = iView;\n\t\t// 向AutoLifecycle注册即可获得Lifecycle回调\n        AutoLifecycle.getInstance().init(this); \n    }\n\n\t// 当Activity进入onCreate后自动调用\n    @AutoLifecycleEvent(activity = ActivityLifecycle.CREATE)\n    private void onHostCreate() {\n        bindView(mIView); \n    }\n\n\t// 当Activity进入onDestroy后自动调用\n    @AutoLifecycleEvent(activity = ActivityLifecycle.DESTROY)\n    private void onHostDestroy() {\n        unBindView();\n    }\n}\n```\n\n其实，在大家的平常开发中，还会存在许多类似`Presenter`的类：`需要在某个特定的Lifecycle下执行一些动作`。这时就可以基于`Lifecycle-Aware`来让这个普通类自动去执行，而不是去每个`Activity/Fragment`里写一遍，提高类的内聚性。\n\n\n## AutoLifecycle的核心原理\n(TL;DR)\n下面介绍下`AutoLifecycle`的关键实现部分，感兴趣的读者可以参考。\n\n### 1. 让Activity对外发送Lifecycle事件\n使用过`RxJava`的同学知道里面有一个[`PublishSubject`](http://reactivex.io/RxJava/javadoc/rx/subjects/PublishSubject.html)，基于观察者模式，主动发送并接受消息。这里我们用`PublishSubject`来发送Lifecycle事件。见如下：\n![](http://upload-images.jianshu.io/upload_images/281665-2deba2e78165c91a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**这里的Lifecycle事件可以自己定义，比如前面提到的`PRE_INFLATE`事件，是在setContentView之前发送**，类似：\n\n![](http://upload-images.jianshu.io/upload_images/281665-f7c747443273ebe4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 2. 感知某个Lifecycle的发生并自动执行回调\n上面提了，`PublishSubject`不仅能发送消息，还能接受自己的消息。基于这个特点，我们便可以监听每一个LifecycleEvent。如下图：\n![](http://upload-images.jianshu.io/upload_images/281665-0f2d95662cd053f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这里的参数Observable是我们希望被回调的函数，IContextLifecycle是指定的Lifecycle。即当指定的Lifecycle Event发生时，会自动subscribe提供的Observable。\n\n基于这个功能，便可以实现上面场景一和场景二里的`@AutoLifecycleEvent`注解了，即把`@AutoLifecycleEvent`标注的函数包装成一个Observable，通过这个`executeOn`来注册函数的执行生命周期即可。\n\n### 3. 监听Lifecycle并取消网络请求结果\n在场景三里，我们为网络请求的`Observable`提供了一个[`Transformer`](http://reactivex.io/RxJava/javadoc/rx/Observable.Transformer.html)，它能在监听到某个Lifecycle发生时，停止数据流的向下流动。该`Transformer`的核心实现是：\n![](http://upload-images.jianshu.io/upload_images/281665-3de275bde3f6a0a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n可以看出，当指定的Lifecycle一旦发生，我们网络请求Observable就会停止向下传递数据。\n\n### 4. 支持自定义Lifecycle，支持Activity/Fragment/DialogFrament等\n可以看出，`AutoLifecycle`除了支持常规的生命周期，还能支持自定义的特殊生命周期，比如View Inflate前。\n\n另外，上面都是以Activity为例，不过显然这套框架可以灵活扩展，不局限于Activity，还能适用于Fragment、DialogFrament等。\n\n## 源码\n对源码感兴趣的欢迎进入我的【小专栏 https://xiaozhuanlan.com/wingjay】或者 【付费群 http://www.jianshu.com/p/655af849aaf6】\n\n## 总结\n`Lifecycle-Aware`思想是Google官方提出来的概念：赋予普通类自动感知生命周期的能力。而本文也是基于这个思想，提供了一些具体实践和优化的思路，读者同学可以根据自己的情况做更多的改进和尝试。\n\n\n——————\nwingjay\n谢谢。\n\n\n> 欢迎加入【阿里求职付费群】：\n> 1. 及时推送集团内最新岗位空缺信息\n> 2. 定期分享针对阿里的最新Android面试题及相关面试经验\n> 3. 长期提供阿里集团内各岗位的内推。\n> 详情：http://www.jianshu.com/p/655af849aaf6\n\n\n## 参考\nhttps://developer.android.com/topic/libraries/architecture/lifecycle.html\nhttps://www.atatech.org/articles/63098\nhttps://github.com/trello/RxLifecycle\nhttp://reactivex.io/RxJava/javadoc/rx/subjects/PublishSubject.html\nhttp://reactivex.io/RxJava/javadoc/rx/Observable.Transformer.html\n","source":"_posts/让普通-Java-类自动感知-Activity-Lifecycle.md","raw":"title: 让普通 Java 类自动感知 Activity Lifecycle\ndate: 2017-11-09 23:00:02\npermalink: auto-lifecycle\ncategories:\n\t- Android\ntags:\n\t- Android\n\t- Lifecycle\n\t- Java\ncommentIssueId: 23\n---\n## 背景\n在 Android 开发中，我们都很熟悉 Activity 的 Lifecycle，并且会在特定的 Lifecycle 下执行特定的操作。当然，我们清楚 Lifecycle 本身是带有 Android 特质的，那尝试设想下，如果`普通的 Java Class 也能自动感知\n Lifecycle 呢`？咋一听这个想法似乎背后意义不大，但在实际探索中，我们发现这个特性能为我们达成一些之前未考虑到或者不易实现的优化。\n\n本文分享下我们基于这个思想所开发的框架：`AutoLifecycle` 及其带来的一些有意思的实践。\n\n<!-- more -->\n\n- 优化一：当Activity进入onDestroy时，自动取消网络请求返回\n- 优化二：自动将网络请求时机提前到View渲染之前，提高页面打开速度\n- 优化三：MVP改进，让Presenter和View自动bind/unBind\n\n\n注：下文提到的`Lifecycle-Aware`就是这里指代的`让普通 Java Class 自动获取 Lifecycle `。\n\n## 实践及优化\n### 优化一：当Activity进入onDestroy时，自动取消网络请求返回\n在网络请求时，相信大家都有一个经验：在每个网络结果回来时，我们做的第一件事不是显示数据，而是写个if-else判断Activity还在不在。\n```java\nmTopApiObservable\n  ...\n  .subscribe(new Subscriber<Object>() {\n\t  @Override\n\t  public void onNext(Object data) {\n\t  \tif(activity == null) {\n\t\t\treturn; // 判断Activity是否还在，不在就不去显示数据\n\t\t}\n\t\t\n\t\tdisplay(data); // 显示数据\n\t  }\n\t  ...\n  });\n```\n由于网络请求都是异步的，所以不得不做这样的判断，来防止不可预测的空指针问题或内存泄漏问题。\n\n既然你总是担心`Activity`还在不在，那么如果我们通过`Lifecycle-Aware让每个网络请求能自动感知Activity的onDestroy事件`，\n并在`onDestroy`时，自动把网络请求结果`取消掉不再返回`，那就能够消除这个担忧了。\n```java\nmTopApiObservable\n  ...\n  .compose(bindUntilEvent(ActivityLifecycle.DESTROY)) // 绑定Activity的onDestroy事件\n  .subscribe(new Subscriber<Object>() {\n\t  @Override\n\t  public void onNext(Object data) {\n\t\tdisplay(data); // 直接去显示数据\n\t  }\n\t  ...\n  });\n```\n\n其中最关键的就是`compose(bindUntilEvent(ActivityLifecycle.DESTROY))`这句，它能达到的效果是：一旦`Activity`发生`onDestroy`时，`Observer`的数据就会停止向`Subscriber`里流动。从而保证`onNext`无需担心`Activity`已`Destroy`这种情况。\n\n**在上面网络请求的实践里，你还可以根据自己的情况把`Destroy`换成`Stop`/`Pause`等，而且可以看出，这种自动取消机制可适用于任何`Observable`，不仅仅是网络请求。**\n\n### 优化二：自动将网络请求提前到View Inflate之前，加速页面渲染\n先说下这项优化的原理。\n通常，我们会在`Activity`的`onCreate`里依次执行下面的代码：\n```java\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.XXX);   // Inflate View\n    findViewByIds();                // 初始化View\n    presenter.loadDataFromServer(); // 发起网络请求\n}\n```\n即在`Inflate View`和`初始化View`之后，才发起网络请求去加载数据。\n\n而实际上，网络请求是不占用主线程的，如果能在`Inflate View`之前就在其他线程发起网络请求，可以把整个页面显示耗时缩短`100ms-200ms`。\n> ![LoadBeforeInflate优化效果](http://upload-images.jianshu.io/upload_images/281665-dbf719e2d9a88946.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n现在有了`AutoLifecycle`框架，我们就可以很轻松实现：让Presenter自动监听`Inflate View`这个生命周期，在那时发起网络请求即可。\n\n```java\npublic class NewPresenter {\n\n    public NewPresenter(IView iView) {\n        ...\n\t\t// 向AutoLifecycle注册\n        AutoLifecycle.getInstance().init(this); \n    }\n\n\t// 当Activity Inflate View前自动回调\n    @AutoLifecycleEvent(activity = ActivityLifecycle.PRE_INFLATE)\n    private void onHostPreInflate() {\n         loadDataFromServer(); // 发起网络请求\n    }\n\t...\n}\n```\n\n此时，我们的Activity也不用手动调用`presenter.loadDataFromServer();`了，因为Presenter内会在感知到`Inflate View`事件时自动发起网络请求。\n\n```java\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.XXX);\n    findViewByIds();\n    // 无需手动启动网络请求\n}\n```\n\n经过测试，在保证单个网络请求耗时相同的情况下，页面从`onCreate`到`显示数据`的渲染耗时可以从`550ms`缩短到`367ms`，也就是`30%-40%`的优化，效果是非常不错的，而且代码也更加简洁清晰。\n> ![](http://upload-images.jianshu.io/upload_images/281665-3d050c819f7c158e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n \n\n通过简单的注册`AutoLifecycle`，`Presenter`能够自动感知到所有`Lifecycle`，甚至包括自定义的特殊`Lifecycle`，如下图：\n![LifecycleAwarePresenter](http://upload-images.jianshu.io/upload_images/281665-3c00d59f5cacebcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n### 优化三：MVP改进，让Presenter和View自动bind/unBind\n第一项优化比较直接，可以先让大家形成一个直观印象。\n我们项目是采用MVP项目，对于`Presenter`的使用存在一段固定代码，即在`onCreate`时调用`bindView()`，在`onDestroy`时调用`unBindView()`。如下图：\n```java\npublic class OldActivity extends BaseActivity {\n\n    BasePresenter mPresenter = new BasePresenter();\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\t\tmPresenter.bindView(this); // onCreate时手动bind Presenter 和 IView\n    }\n\n    @Override\n    protected void onDestroy() {\n        mPresenter.unbindView(); // onDestroy时手动unBindView\n        super.onDestroy();\n    }\n}\n```\n\n那么，既然我们现在能`让一个普通类自动感知Lifecycle`，那其实也就能让`Presenter`在感知到`onCreate`时`自动bindView`，在感知到`onDestroy`时`自动unBindView`。\n改进后的代码如下：\n```java\npublic class NewActivity extends BaseActivity {\n\n    NewPresenter mPresenter;\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        mPresenter = new NewPresenter(this); // 只需要创建即可\n    }\n}\n\npublic class NewPresenter {\n\n    private IView mIView;\n\n    public NewPresenter(IView iView) {\n        this.mIView = iView;\n\t\t// 向AutoLifecycle注册即可获得Lifecycle回调\n        AutoLifecycle.getInstance().init(this); \n    }\n\n\t// 当Activity进入onCreate后自动调用\n    @AutoLifecycleEvent(activity = ActivityLifecycle.CREATE)\n    private void onHostCreate() {\n        bindView(mIView); \n    }\n\n\t// 当Activity进入onDestroy后自动调用\n    @AutoLifecycleEvent(activity = ActivityLifecycle.DESTROY)\n    private void onHostDestroy() {\n        unBindView();\n    }\n}\n```\n\n其实，在大家的平常开发中，还会存在许多类似`Presenter`的类：`需要在某个特定的Lifecycle下执行一些动作`。这时就可以基于`Lifecycle-Aware`来让这个普通类自动去执行，而不是去每个`Activity/Fragment`里写一遍，提高类的内聚性。\n\n\n## AutoLifecycle的核心原理\n(TL;DR)\n下面介绍下`AutoLifecycle`的关键实现部分，感兴趣的读者可以参考。\n\n### 1. 让Activity对外发送Lifecycle事件\n使用过`RxJava`的同学知道里面有一个[`PublishSubject`](http://reactivex.io/RxJava/javadoc/rx/subjects/PublishSubject.html)，基于观察者模式，主动发送并接受消息。这里我们用`PublishSubject`来发送Lifecycle事件。见如下：\n![](http://upload-images.jianshu.io/upload_images/281665-2deba2e78165c91a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**这里的Lifecycle事件可以自己定义，比如前面提到的`PRE_INFLATE`事件，是在setContentView之前发送**，类似：\n\n![](http://upload-images.jianshu.io/upload_images/281665-f7c747443273ebe4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 2. 感知某个Lifecycle的发生并自动执行回调\n上面提了，`PublishSubject`不仅能发送消息，还能接受自己的消息。基于这个特点，我们便可以监听每一个LifecycleEvent。如下图：\n![](http://upload-images.jianshu.io/upload_images/281665-0f2d95662cd053f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这里的参数Observable是我们希望被回调的函数，IContextLifecycle是指定的Lifecycle。即当指定的Lifecycle Event发生时，会自动subscribe提供的Observable。\n\n基于这个功能，便可以实现上面场景一和场景二里的`@AutoLifecycleEvent`注解了，即把`@AutoLifecycleEvent`标注的函数包装成一个Observable，通过这个`executeOn`来注册函数的执行生命周期即可。\n\n### 3. 监听Lifecycle并取消网络请求结果\n在场景三里，我们为网络请求的`Observable`提供了一个[`Transformer`](http://reactivex.io/RxJava/javadoc/rx/Observable.Transformer.html)，它能在监听到某个Lifecycle发生时，停止数据流的向下流动。该`Transformer`的核心实现是：\n![](http://upload-images.jianshu.io/upload_images/281665-3de275bde3f6a0a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n可以看出，当指定的Lifecycle一旦发生，我们网络请求Observable就会停止向下传递数据。\n\n### 4. 支持自定义Lifecycle，支持Activity/Fragment/DialogFrament等\n可以看出，`AutoLifecycle`除了支持常规的生命周期，还能支持自定义的特殊生命周期，比如View Inflate前。\n\n另外，上面都是以Activity为例，不过显然这套框架可以灵活扩展，不局限于Activity，还能适用于Fragment、DialogFrament等。\n\n## 源码\n对源码感兴趣的欢迎进入我的【小专栏 https://xiaozhuanlan.com/wingjay】或者 【付费群 http://www.jianshu.com/p/655af849aaf6】\n\n## 总结\n`Lifecycle-Aware`思想是Google官方提出来的概念：赋予普通类自动感知生命周期的能力。而本文也是基于这个思想，提供了一些具体实践和优化的思路，读者同学可以根据自己的情况做更多的改进和尝试。\n\n\n——————\nwingjay\n谢谢。\n\n\n> 欢迎加入【阿里求职付费群】：\n> 1. 及时推送集团内最新岗位空缺信息\n> 2. 定期分享针对阿里的最新Android面试题及相关面试经验\n> 3. 长期提供阿里集团内各岗位的内推。\n> 详情：http://www.jianshu.com/p/655af849aaf6\n\n\n## 参考\nhttps://developer.android.com/topic/libraries/architecture/lifecycle.html\nhttps://www.atatech.org/articles/63098\nhttps://github.com/trello/RxLifecycle\nhttp://reactivex.io/RxJava/javadoc/rx/subjects/PublishSubject.html\nhttp://reactivex.io/RxJava/javadoc/rx/Observable.Transformer.html\n","slug":"auto-lifecycle","published":1,"updated":"2018-11-26T06:56:27.488Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplsia003c3dn8yzk4q6op","content":"<h2 id=\"背景\"><a href=\"# 背景\" class=\"headerlink\" title=\"背景\"></a>背景 </h2><p> 在 Android 开发中，我们都很熟悉 Activity 的 Lifecycle，并且会在特定的 Lifecycle 下执行特定的操作。当然，我们清楚 Lifecycle 本身是带有 Android 特质的，那尝试设想下，如果 <code> 普通的 Java Class 也能自动感知\n Lifecycle 呢</code>？咋一听这个想法似乎背后意义不大，但在实际探索中，我们发现这个特性能为我们达成一些之前未考虑到或者不易实现的优化。</p>\n<p>本文分享下我们基于这个思想所开发的框架：<code>AutoLifecycle</code> 及其带来的一些有意思的实践。</p>\n<a id=\"more\"></a>\n<ul>\n<li>优化一：当 Activity 进入 onDestroy 时，自动取消网络请求返回</li>\n<li>优化二：自动将网络请求时机提前到 View 渲染之前，提高页面打开速度</li>\n<li>优化三：MVP 改进，让 Presenter 和 View 自动 bind/unBind</li>\n</ul>\n<p>注：下文提到的 <code>Lifecycle-Aware</code> 就是这里指代的 <code> 让普通 Java Class 自动获取 Lifecycle</code>。</p>\n<h2 id=\"实践及优化\"><a href=\"# 实践及优化\" class=\"headerlink\" title=\"实践及优化\"></a>实践及优化 </h2><h3 id=\"优化一：当 Activity 进入 onDestroy 时，自动取消网络请求返回\"><a href=\"# 优化一：当 Activity 进入 onDestroy 时，自动取消网络请求返回\" class=\"headerlink\" title=\"优化一：当 Activity 进入 onDestroy 时，自动取消网络请求返回\"></a> 优化一：当 Activity 进入 onDestroy 时，自动取消网络请求返回 </h3><p> 在网络请求时，相信大家都有一个经验：在每个网络结果回来时，我们做的第一件事不是显示数据，而是写个 if-else 判断 Activity 还在不在。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">mTopApiObservable</div><div class=\"line\">  ...</div><div class=\"line\">  .subscribe(<span class=\"keyword\">new</span> Subscriber&lt;Object&gt;() &#123;</div><div class=\"line\">\t  <span class=\"meta\">@Override</span></div><div class=\"line\">\t  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(Object data)</span> </span>&#123;</div><div class=\"line\">\t  \t<span class=\"keyword\">if</span>(activity == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span>; <span class=\"comment\">// 判断 Activity 是否还在，不在就不去显示数据</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tdisplay(data); <span class=\"comment\">// 显示数据</span></div><div class=\"line\">\t  &#125;</div><div class=\"line\">\t  ...</div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure></p>\n<p>由于网络请求都是异步的，所以不得不做这样的判断，来防止不可预测的空指针问题或内存泄漏问题。</p>\n<p>既然你总是担心 <code>Activity</code> 还在不在，那么如果我们通过 <code>Lifecycle-Aware 让每个网络请求能自动感知 Activity 的 onDestroy 事件</code>，<br> 并在 <code>onDestroy</code> 时，自动把网络请求结果 <code> 取消掉不再返回</code>，那就能够消除这个担忧了。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">mTopApiObservable</div><div class=\"line\">  ...</div><div class=\"line\">  .compose(bindUntilEvent(ActivityLifecycle.DESTROY)) <span class=\"comment\">// 绑定 Activity 的 onDestroy 事件</span></div><div class=\"line\">  .subscribe(<span class=\"keyword\">new</span> Subscriber&lt;Object&gt;() &#123;</div><div class=\"line\">\t  <span class=\"meta\">@Override</span></div><div class=\"line\">\t  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(Object data)</span> </span>&#123;</div><div class=\"line\">\t\tdisplay(data); <span class=\"comment\">// 直接去显示数据</span></div><div class=\"line\">\t  &#125;</div><div class=\"line\">\t  ...</div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure></p>\n<p>其中最关键的就是 <code>compose(bindUntilEvent(ActivityLifecycle.DESTROY))</code> 这句，它能达到的效果是：一旦 <code>Activity</code> 发生 <code>onDestroy</code> 时，<code>Observer</code>的数据就会停止向 <code>Subscriber</code> 里流动。从而保证 <code>onNext</code> 无需担心 <code>Activity</code> 已<code>Destroy</code>这种情况。</p>\n<p><strong>在上面网络请求的实践里，你还可以根据自己的情况把 <code>Destroy</code> 换成 <code>Stop</code>/<code>Pause</code> 等，而且可以看出，这种自动取消机制可适用于任何<code>Observable</code>，不仅仅是网络请求。</strong></p>\n<h3 id=\"优化二：自动将网络请求提前到 View-Inflate 之前，加速页面渲染\"><a href=\"# 优化二：自动将网络请求提前到 View-Inflate 之前，加速页面渲染\" class=\"headerlink\" title=\"优化二：自动将网络请求提前到 View Inflate 之前，加速页面渲染\"></a>优化二：自动将网络请求提前到 View Inflate 之前，加速页面渲染 </h3><p> 先说下这项优化的原理。<br>通常，我们会在 <code>Activity</code> 的<code>onCreate</code>里依次执行下面的代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">    setContentView(R.layout.XXX);   <span class=\"comment\">// Inflate View</span></div><div class=\"line\">    findViewByIds();                <span class=\"comment\">// 初始化 View</span></div><div class=\"line\">    presenter.loadDataFromServer(); <span class=\"comment\">// 发起网络请求</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>即在 <code>Inflate View</code> 和<code>初始化 View</code>之后，才发起网络请求去加载数据。</p>\n<p>而实际上，网络请求是不占用主线程的，如果能在 <code>Inflate View</code> 之前就在其他线程发起网络请求，可以把整个页面显示耗时缩短<code>100ms-200ms</code>。</p>\n<blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/281665-dbf719e2d9a88946.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"LoadBeforeInflate 优化效果\"></p>\n</blockquote>\n<p>现在有了 <code>AutoLifecycle</code> 框架，我们就可以很轻松实现：让 Presenter 自动监听 <code>Inflate View</code> 这个生命周期，在那时发起网络请求即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NewPresenter</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NewPresenter</span><span class=\"params\">(IView iView)</span> </span>&#123;</div><div class=\"line\">        ...</div><div class=\"line\">\t\t<span class=\"comment\">// 向 AutoLifecycle 注册</span></div><div class=\"line\">        AutoLifecycle.getInstance().init(<span class=\"keyword\">this</span>); </div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// 当 Activity Inflate View 前自动回调</span></div><div class=\"line\">    <span class=\"meta\">@AutoLifecycleEvent</span>(activity = ActivityLifecycle.PRE_INFLATE)</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">onHostPreInflate</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">         loadDataFromServer(); <span class=\"comment\">// 发起网络请求</span></div><div class=\"line\">    &#125;</div><div class=\"line\">\t...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>此时，我们的 Activity 也不用手动调用 <code>presenter.loadDataFromServer();</code> 了，因为 Presenter 内会在感知到 <code>Inflate View</code> 事件时自动发起网络请求。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">    setContentView(R.layout.XXX);</div><div class=\"line\">    findViewByIds();</div><div class=\"line\">    <span class=\"comment\">// 无需手动启动网络请求</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>经过测试，在保证单个网络请求耗时相同的情况下，页面从 <code>onCreate</code> 到<code>显示数据 </code> 的渲染耗时可以从 <code>550ms</code> 缩短到 <code>367ms</code>，也就是<code>30%-40%</code> 的优化，效果是非常不错的，而且代码也更加简洁清晰。</p>\n<blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/281665-3d050c819f7c158e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n</blockquote>\n<p>通过简单的注册 <code>AutoLifecycle</code>，<code>Presenter</code> 能够自动感知到所有<code>Lifecycle</code>，甚至包括自定义的特殊<code>Lifecycle</code>，如下图：<br><img src=\"http://upload-images.jianshu.io/upload_images/281665-3c00d59f5cacebcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"LifecycleAwarePresenter\"></p>\n<h3 id=\"优化三：MVP 改进，让 Presenter 和 View 自动 bind-unBind\"><a href=\"# 优化三：MVP 改进，让 Presenter 和 View 自动 bind-unBind\" class=\"headerlink\" title=\"优化三：MVP 改进，让 Presenter 和 View 自动 bind/unBind\"></a>优化三：MVP 改进，让 Presenter 和 View 自动 bind/unBind</h3><p>第一项优化比较直接，可以先让大家形成一个直观印象。<br>我们项目是采用 MVP 项目，对于 <code>Presenter</code> 的使用存在一段固定代码，即在 <code>onCreate</code> 时调用 <code>bindView()</code>，在<code>onDestroy</code> 时调用<code>unBindView()</code>。如下图：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OldActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseActivity</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    BasePresenter mPresenter = <span class=\"keyword\">new</span> BasePresenter();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">\t\tmPresenter.bindView(<span class=\"keyword\">this</span>); <span class=\"comment\">// onCreate 时手动 bind Presenter 和 IView</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        mPresenter.unbindView(); <span class=\"comment\">// onDestroy 时手动 unBindView</span></div><div class=\"line\">        <span class=\"keyword\">super</span>.onDestroy();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>那么，既然我们现在能 <code> 让一个普通类自动感知 Lifecycle</code>，那其实也就能让 <code>Presenter</code> 在感知到 <code>onCreate</code> 时<code>自动 bindView</code>，在感知到 <code>onDestroy</code> 时<code>自动 unBindView</code>。<br>改进后的代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NewActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseActivity</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    NewPresenter mPresenter;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">        mPresenter = <span class=\"keyword\">new</span> NewPresenter(<span class=\"keyword\">this</span>); <span class=\"comment\">// 只需要创建即可</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NewPresenter</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> IView mIView;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NewPresenter</span><span class=\"params\">(IView iView)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.mIView = iView;</div><div class=\"line\">\t\t<span class=\"comment\">// 向 AutoLifecycle 注册即可获得 Lifecycle 回调</span></div><div class=\"line\">        AutoLifecycle.getInstance().init(<span class=\"keyword\">this</span>); </div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// 当 Activity 进入 onCreate 后自动调用</span></div><div class=\"line\">    <span class=\"meta\">@AutoLifecycleEvent</span>(activity = ActivityLifecycle.CREATE)</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">onHostCreate</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        bindView(mIView); </div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// 当 Activity 进入 onDestroy 后自动调用</span></div><div class=\"line\">    <span class=\"meta\">@AutoLifecycleEvent</span>(activity = ActivityLifecycle.DESTROY)</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">onHostDestroy</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        unBindView();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其实，在大家的平常开发中，还会存在许多类似 <code>Presenter</code> 的类：<code>需要在某个特定的 Lifecycle 下执行一些动作 </code>。这时就可以基于<code>Lifecycle-Aware</code> 来让这个普通类自动去执行，而不是去每个 <code>Activity/Fragment</code> 里写一遍，提高类的内聚性。</p>\n<h2 id=\"AutoLifecycle 的核心原理\"><a href=\"#AutoLifecycle 的核心原理\" class=\"headerlink\" title=\"AutoLifecycle 的核心原理\"></a>AutoLifecycle 的核心原理 </h2><p>(TL;DR)<br> 下面介绍下 <code>AutoLifecycle</code> 的关键实现部分，感兴趣的读者可以参考。</p>\n<h3 id=\"1- 让 Activity 对外发送 Lifecycle 事件\"><a href=\"#1- 让 Activity 对外发送 Lifecycle 事件\" class=\"headerlink\" title=\"1. 让 Activity 对外发送 Lifecycle 事件\"></a>1. 让 Activity 对外发送 Lifecycle 事件 </h3><p> 使用过 <code>RxJava</code> 的同学知道里面有一个 <a href=\"http://reactivex.io/RxJava/javadoc/rx/subjects/PublishSubject.html\" target=\"_blank\" rel=\"external\"><code>PublishSubject</code></a>，基于观察者模式，主动发送并接受消息。这里我们用<code>PublishSubject</code> 来发送 Lifecycle 事件。见如下：<br><img src=\"http://upload-images.jianshu.io/upload_images/281665-2deba2e78165c91a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><strong>这里的 Lifecycle 事件可以自己定义，比如前面提到的 <code>PRE_INFLATE</code> 事件，是在 setContentView 之前发送</strong>，类似：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/281665-f7c747443273ebe4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h3 id=\"2- 感知某个 Lifecycle 的发生并自动执行回调\"><a href=\"#2- 感知某个 Lifecycle 的发生并自动执行回调\" class=\"headerlink\" title=\"2. 感知某个 Lifecycle 的发生并自动执行回调\"></a>2. 感知某个 Lifecycle 的发生并自动执行回调 </h3><p> 上面提了，<code>PublishSubject</code>不仅能发送消息，还能接受自己的消息。基于这个特点，我们便可以监听每一个 LifecycleEvent。如下图：<br><img src=\"http://upload-images.jianshu.io/upload_images/281665-0f2d95662cd053f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>这里的参数 Observable 是我们希望被回调的函数，IContextLifecycle 是指定的 Lifecycle。即当指定的 Lifecycle Event 发生时，会自动 subscribe 提供的 Observable。</p>\n<p>基于这个功能，便可以实现上面场景一和场景二里的 <code>@AutoLifecycleEvent</code> 注解了，即把 <code>@AutoLifecycleEvent</code> 标注的函数包装成一个 Observable，通过这个 <code>executeOn</code> 来注册函数的执行生命周期即可。</p>\n<h3 id=\"3- 监听 Lifecycle 并取消网络请求结果\"><a href=\"#3- 监听 Lifecycle 并取消网络请求结果\" class=\"headerlink\" title=\"3. 监听 Lifecycle 并取消网络请求结果\"></a>3. 监听 Lifecycle 并取消网络请求结果 </h3><p> 在场景三里，我们为网络请求的 <code>Observable</code> 提供了一个 <a href=\"http://reactivex.io/RxJava/javadoc/rx/Observable.Transformer.html\" target=\"_blank\" rel=\"external\"><code>Transformer</code></a>，它能在监听到某个 Lifecycle 发生时，停止数据流的向下流动。该<code>Transformer</code> 的核心实现是：<br><img src=\"http://upload-images.jianshu.io/upload_images/281665-3de275bde3f6a0a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>可以看出，当指定的 Lifecycle 一旦发生，我们网络请求 Observable 就会停止向下传递数据。</p>\n<h3 id=\"4- 支持自定义 Lifecycle，支持 Activity-Fragment-DialogFrament 等\"><a href=\"#4- 支持自定义 Lifecycle，支持 Activity-Fragment-DialogFrament 等\" class=\"headerlink\" title=\"4. 支持自定义 Lifecycle，支持 Activity/Fragment/DialogFrament 等\"></a>4. 支持自定义 Lifecycle，支持 Activity/Fragment/DialogFrament 等 </h3><p> 可以看出，<code>AutoLifecycle</code>除了支持常规的生命周期，还能支持自定义的特殊生命周期，比如 View Inflate 前。</p>\n<p>另外，上面都是以 Activity 为例，不过显然这套框架可以灵活扩展，不局限于 Activity，还能适用于 Fragment、DialogFrament 等。</p>\n<h2 id=\"源码\"><a href=\"# 源码\" class=\"headerlink\" title=\"源码\"></a>源码 </h2><p> 对源码感兴趣的欢迎进入我的【小专栏 <a href=\"https://xiaozhuanlan.com/wingjay】或者\" target=\"_blank\" rel=\"external\">https://xiaozhuanlan.com/wingjay】或者</a> 【付费群 <a href=\"http://www.jianshu.com/p/655af849aaf6】\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/655af849aaf6】</a></p>\n<h2 id=\"总结\"><a href=\"# 总结\" class=\"headerlink\" title=\"总结\"></a>总结 </h2><p><code>Lifecycle-Aware</code> 思想是 Google 官方提出来的概念：赋予普通类自动感知生命周期的能力。而本文也是基于这个思想，提供了一些具体实践和优化的思路，读者同学可以根据自己的情况做更多的改进和尝试。</p>\n<p>——————<br>wingjay<br>谢谢。</p>\n<blockquote>\n<p>欢迎加入【阿里求职付费群】：</p>\n<ol>\n<li>及时推送集团内最新岗位空缺信息</li>\n<li>定期分享针对阿里的最新 Android 面试题及相关面试经验</li>\n<li>长期提供阿里集团内各岗位的内推。<br>详情：<a href=\"http://www.jianshu.com/p/655af849aaf6\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/655af849aaf6</a></li>\n</ol>\n</blockquote>\n<h2 id=\"参考\"><a href=\"# 参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://developer.android.com/topic/libraries/architecture/lifecycle.html\" target=\"_blank\" rel=\"external\">https://developer.android.com/topic/libraries/architecture/lifecycle.html</a><br><a href=\"https://www.atatech.org/articles/63098\" target=\"_blank\" rel=\"external\">https://www.atatech.org/articles/63098</a><br><a href=\"https://github.com/trello/RxLifecycle\" target=\"_blank\" rel=\"external\">https://github.com/trello/RxLifecycle</a><br><a href=\"http://reactivex.io/RxJava/javadoc/rx/subjects/PublishSubject.html\" target=\"_blank\" rel=\"external\">http://reactivex.io/RxJava/javadoc/rx/subjects/PublishSubject.html</a><br><a href=\"http://reactivex.io/RxJava/javadoc/rx/Observable.Transformer.html\" target=\"_blank\" rel=\"external\">http://reactivex.io/RxJava/javadoc/rx/Observable.Transformer.html</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>在 Android 开发中，我们都很熟悉 Activity 的 Lifecycle，并且会在特定的 Lifecycle 下执行特定的操作。当然，我们清楚 Lifecycle 本身是带有 Android 特质的，那尝试设想下，如果<code>普通的 Java Class 也能自动感知\n Lifecycle 呢</code>？咋一听这个想法似乎背后意义不大，但在实际探索中，我们发现这个特性能为我们达成一些之前未考虑到或者不易实现的优化。</p>\n<p>本文分享下我们基于这个思想所开发的框架：<code>AutoLifecycle</code> 及其带来的一些有意思的实践。</p>","more":"<ul>\n<li>优化一：当Activity进入onDestroy时，自动取消网络请求返回</li>\n<li>优化二：自动将网络请求时机提前到View渲染之前，提高页面打开速度</li>\n<li>优化三：MVP改进，让Presenter和View自动bind/unBind</li>\n</ul>\n<p>注：下文提到的<code>Lifecycle-Aware</code>就是这里指代的<code>让普通 Java Class 自动获取 Lifecycle</code>。</p>\n<h2 id=\"实践及优化\"><a href=\"#实践及优化\" class=\"headerlink\" title=\"实践及优化\"></a>实践及优化</h2><h3 id=\"优化一：当Activity进入onDestroy时，自动取消网络请求返回\"><a href=\"#优化一：当Activity进入onDestroy时，自动取消网络请求返回\" class=\"headerlink\" title=\"优化一：当Activity进入onDestroy时，自动取消网络请求返回\"></a>优化一：当Activity进入onDestroy时，自动取消网络请求返回</h3><p>在网络请求时，相信大家都有一个经验：在每个网络结果回来时，我们做的第一件事不是显示数据，而是写个if-else判断Activity还在不在。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">mTopApiObservable</div><div class=\"line\">  ...</div><div class=\"line\">  .subscribe(<span class=\"keyword\">new</span> Subscriber&lt;Object&gt;() &#123;</div><div class=\"line\">\t  <span class=\"meta\">@Override</span></div><div class=\"line\">\t  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(Object data)</span> </span>&#123;</div><div class=\"line\">\t  \t<span class=\"keyword\">if</span>(activity == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span>; <span class=\"comment\">// 判断Activity是否还在，不在就不去显示数据</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tdisplay(data); <span class=\"comment\">// 显示数据</span></div><div class=\"line\">\t  &#125;</div><div class=\"line\">\t  ...</div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure></p>\n<p>由于网络请求都是异步的，所以不得不做这样的判断，来防止不可预测的空指针问题或内存泄漏问题。</p>\n<p>既然你总是担心<code>Activity</code>还在不在，那么如果我们通过<code>Lifecycle-Aware让每个网络请求能自动感知Activity的onDestroy事件</code>，<br>并在<code>onDestroy</code>时，自动把网络请求结果<code>取消掉不再返回</code>，那就能够消除这个担忧了。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">mTopApiObservable</div><div class=\"line\">  ...</div><div class=\"line\">  .compose(bindUntilEvent(ActivityLifecycle.DESTROY)) <span class=\"comment\">// 绑定Activity的onDestroy事件</span></div><div class=\"line\">  .subscribe(<span class=\"keyword\">new</span> Subscriber&lt;Object&gt;() &#123;</div><div class=\"line\">\t  <span class=\"meta\">@Override</span></div><div class=\"line\">\t  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(Object data)</span> </span>&#123;</div><div class=\"line\">\t\tdisplay(data); <span class=\"comment\">// 直接去显示数据</span></div><div class=\"line\">\t  &#125;</div><div class=\"line\">\t  ...</div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure></p>\n<p>其中最关键的就是<code>compose(bindUntilEvent(ActivityLifecycle.DESTROY))</code>这句，它能达到的效果是：一旦<code>Activity</code>发生<code>onDestroy</code>时，<code>Observer</code>的数据就会停止向<code>Subscriber</code>里流动。从而保证<code>onNext</code>无需担心<code>Activity</code>已<code>Destroy</code>这种情况。</p>\n<p><strong>在上面网络请求的实践里，你还可以根据自己的情况把<code>Destroy</code>换成<code>Stop</code>/<code>Pause</code>等，而且可以看出，这种自动取消机制可适用于任何<code>Observable</code>，不仅仅是网络请求。</strong></p>\n<h3 id=\"优化二：自动将网络请求提前到View-Inflate之前，加速页面渲染\"><a href=\"#优化二：自动将网络请求提前到View-Inflate之前，加速页面渲染\" class=\"headerlink\" title=\"优化二：自动将网络请求提前到View Inflate之前，加速页面渲染\"></a>优化二：自动将网络请求提前到View Inflate之前，加速页面渲染</h3><p>先说下这项优化的原理。<br>通常，我们会在<code>Activity</code>的<code>onCreate</code>里依次执行下面的代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">    setContentView(R.layout.XXX);   <span class=\"comment\">// Inflate View</span></div><div class=\"line\">    findViewByIds();                <span class=\"comment\">// 初始化View</span></div><div class=\"line\">    presenter.loadDataFromServer(); <span class=\"comment\">// 发起网络请求</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>即在<code>Inflate View</code>和<code>初始化View</code>之后，才发起网络请求去加载数据。</p>\n<p>而实际上，网络请求是不占用主线程的，如果能在<code>Inflate View</code>之前就在其他线程发起网络请求，可以把整个页面显示耗时缩短<code>100ms-200ms</code>。</p>\n<blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/281665-dbf719e2d9a88946.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"LoadBeforeInflate优化效果\"></p>\n</blockquote>\n<p>现在有了<code>AutoLifecycle</code>框架，我们就可以很轻松实现：让Presenter自动监听<code>Inflate View</code>这个生命周期，在那时发起网络请求即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NewPresenter</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NewPresenter</span><span class=\"params\">(IView iView)</span> </span>&#123;</div><div class=\"line\">        ...</div><div class=\"line\">\t\t<span class=\"comment\">// 向AutoLifecycle注册</span></div><div class=\"line\">        AutoLifecycle.getInstance().init(<span class=\"keyword\">this</span>); </div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// 当Activity Inflate View前自动回调</span></div><div class=\"line\">    <span class=\"meta\">@AutoLifecycleEvent</span>(activity = ActivityLifecycle.PRE_INFLATE)</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">onHostPreInflate</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">         loadDataFromServer(); <span class=\"comment\">// 发起网络请求</span></div><div class=\"line\">    &#125;</div><div class=\"line\">\t...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>此时，我们的Activity也不用手动调用<code>presenter.loadDataFromServer();</code>了，因为Presenter内会在感知到<code>Inflate View</code>事件时自动发起网络请求。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">    setContentView(R.layout.XXX);</div><div class=\"line\">    findViewByIds();</div><div class=\"line\">    <span class=\"comment\">// 无需手动启动网络请求</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>经过测试，在保证单个网络请求耗时相同的情况下，页面从<code>onCreate</code>到<code>显示数据</code>的渲染耗时可以从<code>550ms</code>缩短到<code>367ms</code>，也就是<code>30%-40%</code>的优化，效果是非常不错的，而且代码也更加简洁清晰。</p>\n<blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/281665-3d050c819f7c158e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n</blockquote>\n<p>通过简单的注册<code>AutoLifecycle</code>，<code>Presenter</code>能够自动感知到所有<code>Lifecycle</code>，甚至包括自定义的特殊<code>Lifecycle</code>，如下图：<br><img src=\"http://upload-images.jianshu.io/upload_images/281665-3c00d59f5cacebcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"LifecycleAwarePresenter\"></p>\n<h3 id=\"优化三：MVP改进，让Presenter和View自动bind-unBind\"><a href=\"#优化三：MVP改进，让Presenter和View自动bind-unBind\" class=\"headerlink\" title=\"优化三：MVP改进，让Presenter和View自动bind/unBind\"></a>优化三：MVP改进，让Presenter和View自动bind/unBind</h3><p>第一项优化比较直接，可以先让大家形成一个直观印象。<br>我们项目是采用MVP项目，对于<code>Presenter</code>的使用存在一段固定代码，即在<code>onCreate</code>时调用<code>bindView()</code>，在<code>onDestroy</code>时调用<code>unBindView()</code>。如下图：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OldActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseActivity</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    BasePresenter mPresenter = <span class=\"keyword\">new</span> BasePresenter();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">\t\tmPresenter.bindView(<span class=\"keyword\">this</span>); <span class=\"comment\">// onCreate时手动bind Presenter 和 IView</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        mPresenter.unbindView(); <span class=\"comment\">// onDestroy时手动unBindView</span></div><div class=\"line\">        <span class=\"keyword\">super</span>.onDestroy();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>那么，既然我们现在能<code>让一个普通类自动感知Lifecycle</code>，那其实也就能让<code>Presenter</code>在感知到<code>onCreate</code>时<code>自动bindView</code>，在感知到<code>onDestroy</code>时<code>自动unBindView</code>。<br>改进后的代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NewActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseActivity</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    NewPresenter mPresenter;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">        mPresenter = <span class=\"keyword\">new</span> NewPresenter(<span class=\"keyword\">this</span>); <span class=\"comment\">// 只需要创建即可</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NewPresenter</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> IView mIView;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NewPresenter</span><span class=\"params\">(IView iView)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.mIView = iView;</div><div class=\"line\">\t\t<span class=\"comment\">// 向AutoLifecycle注册即可获得Lifecycle回调</span></div><div class=\"line\">        AutoLifecycle.getInstance().init(<span class=\"keyword\">this</span>); </div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// 当Activity进入onCreate后自动调用</span></div><div class=\"line\">    <span class=\"meta\">@AutoLifecycleEvent</span>(activity = ActivityLifecycle.CREATE)</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">onHostCreate</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        bindView(mIView); </div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// 当Activity进入onDestroy后自动调用</span></div><div class=\"line\">    <span class=\"meta\">@AutoLifecycleEvent</span>(activity = ActivityLifecycle.DESTROY)</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">onHostDestroy</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        unBindView();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其实，在大家的平常开发中，还会存在许多类似<code>Presenter</code>的类：<code>需要在某个特定的Lifecycle下执行一些动作</code>。这时就可以基于<code>Lifecycle-Aware</code>来让这个普通类自动去执行，而不是去每个<code>Activity/Fragment</code>里写一遍，提高类的内聚性。</p>\n<h2 id=\"AutoLifecycle的核心原理\"><a href=\"#AutoLifecycle的核心原理\" class=\"headerlink\" title=\"AutoLifecycle的核心原理\"></a>AutoLifecycle的核心原理</h2><p>(TL;DR)<br>下面介绍下<code>AutoLifecycle</code>的关键实现部分，感兴趣的读者可以参考。</p>\n<h3 id=\"1-让Activity对外发送Lifecycle事件\"><a href=\"#1-让Activity对外发送Lifecycle事件\" class=\"headerlink\" title=\"1. 让Activity对外发送Lifecycle事件\"></a>1. 让Activity对外发送Lifecycle事件</h3><p>使用过<code>RxJava</code>的同学知道里面有一个<a href=\"http://reactivex.io/RxJava/javadoc/rx/subjects/PublishSubject.html\" target=\"_blank\" rel=\"external\"><code>PublishSubject</code></a>，基于观察者模式，主动发送并接受消息。这里我们用<code>PublishSubject</code>来发送Lifecycle事件。见如下：<br><img src=\"http://upload-images.jianshu.io/upload_images/281665-2deba2e78165c91a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><strong>这里的Lifecycle事件可以自己定义，比如前面提到的<code>PRE_INFLATE</code>事件，是在setContentView之前发送</strong>，类似：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/281665-f7c747443273ebe4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h3 id=\"2-感知某个Lifecycle的发生并自动执行回调\"><a href=\"#2-感知某个Lifecycle的发生并自动执行回调\" class=\"headerlink\" title=\"2. 感知某个Lifecycle的发生并自动执行回调\"></a>2. 感知某个Lifecycle的发生并自动执行回调</h3><p>上面提了，<code>PublishSubject</code>不仅能发送消息，还能接受自己的消息。基于这个特点，我们便可以监听每一个LifecycleEvent。如下图：<br><img src=\"http://upload-images.jianshu.io/upload_images/281665-0f2d95662cd053f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>这里的参数Observable是我们希望被回调的函数，IContextLifecycle是指定的Lifecycle。即当指定的Lifecycle Event发生时，会自动subscribe提供的Observable。</p>\n<p>基于这个功能，便可以实现上面场景一和场景二里的<code>@AutoLifecycleEvent</code>注解了，即把<code>@AutoLifecycleEvent</code>标注的函数包装成一个Observable，通过这个<code>executeOn</code>来注册函数的执行生命周期即可。</p>\n<h3 id=\"3-监听Lifecycle并取消网络请求结果\"><a href=\"#3-监听Lifecycle并取消网络请求结果\" class=\"headerlink\" title=\"3. 监听Lifecycle并取消网络请求结果\"></a>3. 监听Lifecycle并取消网络请求结果</h3><p>在场景三里，我们为网络请求的<code>Observable</code>提供了一个<a href=\"http://reactivex.io/RxJava/javadoc/rx/Observable.Transformer.html\" target=\"_blank\" rel=\"external\"><code>Transformer</code></a>，它能在监听到某个Lifecycle发生时，停止数据流的向下流动。该<code>Transformer</code>的核心实现是：<br><img src=\"http://upload-images.jianshu.io/upload_images/281665-3de275bde3f6a0a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>可以看出，当指定的Lifecycle一旦发生，我们网络请求Observable就会停止向下传递数据。</p>\n<h3 id=\"4-支持自定义Lifecycle，支持Activity-Fragment-DialogFrament等\"><a href=\"#4-支持自定义Lifecycle，支持Activity-Fragment-DialogFrament等\" class=\"headerlink\" title=\"4. 支持自定义Lifecycle，支持Activity/Fragment/DialogFrament等\"></a>4. 支持自定义Lifecycle，支持Activity/Fragment/DialogFrament等</h3><p>可以看出，<code>AutoLifecycle</code>除了支持常规的生命周期，还能支持自定义的特殊生命周期，比如View Inflate前。</p>\n<p>另外，上面都是以Activity为例，不过显然这套框架可以灵活扩展，不局限于Activity，还能适用于Fragment、DialogFrament等。</p>\n<h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><p>对源码感兴趣的欢迎进入我的【小专栏 <a href=\"https://xiaozhuanlan.com/wingjay】或者\" target=\"_blank\" rel=\"external\">https://xiaozhuanlan.com/wingjay】或者</a> 【付费群 <a href=\"http://www.jianshu.com/p/655af849aaf6】\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/655af849aaf6】</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><code>Lifecycle-Aware</code>思想是Google官方提出来的概念：赋予普通类自动感知生命周期的能力。而本文也是基于这个思想，提供了一些具体实践和优化的思路，读者同学可以根据自己的情况做更多的改进和尝试。</p>\n<p>——————<br>wingjay<br>谢谢。</p>\n<blockquote>\n<p>欢迎加入【阿里求职付费群】：</p>\n<ol>\n<li>及时推送集团内最新岗位空缺信息</li>\n<li>定期分享针对阿里的最新Android面试题及相关面试经验</li>\n<li>长期提供阿里集团内各岗位的内推。<br>详情：<a href=\"http://www.jianshu.com/p/655af849aaf6\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/655af849aaf6</a></li>\n</ol>\n</blockquote>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://developer.android.com/topic/libraries/architecture/lifecycle.html\" target=\"_blank\" rel=\"external\">https://developer.android.com/topic/libraries/architecture/lifecycle.html</a><br><a href=\"https://www.atatech.org/articles/63098\" target=\"_blank\" rel=\"external\">https://www.atatech.org/articles/63098</a><br><a href=\"https://github.com/trello/RxLifecycle\" target=\"_blank\" rel=\"external\">https://github.com/trello/RxLifecycle</a><br><a href=\"http://reactivex.io/RxJava/javadoc/rx/subjects/PublishSubject.html\" target=\"_blank\" rel=\"external\">http://reactivex.io/RxJava/javadoc/rx/subjects/PublishSubject.html</a><br><a href=\"http://reactivex.io/RxJava/javadoc/rx/Observable.Transformer.html\" target=\"_blank\" rel=\"external\">http://reactivex.io/RxJava/javadoc/rx/Observable.Transformer.html</a></p>","sticky":0},{"title":"谈谈移动应用的安全性实践","date":"2016-08-30T13:39:01.000Z","commentIssueId":13,"_content":">虽然没有完美的安全性，但我们所做的每一步都能加大被攻击的难度。\n\n<!-- more -->\n\n本文将从用户注册流程出发，介绍下个人实践中在提高数据安全性方面采用的一些策略方法，供读者参考。下文将从 `Android` 和 `服务端` 两部分来进行讲解。\n\n![](http://upload-images.jianshu.io/upload_images/281665-29572b7461c3d279.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n### 从注册说起\n\n用户第一次打开app时便会进入注册页面。然后客户端会要求用户输入用户名、密码并传递给服务端去创建一个新的user。此时通过明文传递用户名密码便是一个安全性隐患。或者说，如果有人监听注册API，那么很快就可以窃取到很多用户的账户信息，而且可以偷偷利用这些账户信息随时获取甚至更改用户数据。\n\n这对于任何一家企业而言都是非常可怕的。\n\n\n\n### 全站Https\n\n因此，为了应对数据明文传输隐患这个问题，我们可以<u>采用[Https](https://en.wikipedia.org/wiki/HTTPS)方式通信</u>。在Android端推荐[Square](http://square.github.io/)家的[OkHttp3](https://github.com/square/okhttp)作为网络层，为应用层提供Https服务。\n\n下面先对Https的基本工作原理进行下介绍。\n\n1. 首先，客户端去请求服务端的数字证书，这个证书包含了一个公钥。该证书购买后存储于我们自己服务器上。\n2. 当服务端收到客户端请求后，会把这个数字证书回传给客户端，由于是公钥，所以不害怕被窃取。\n3. 客户端收到数字证书后，先去`验证`证书的真实性。如果验证通过，就会从里面取出一个`公钥`。\n4. 客户端本地生成一个`随机数`，作为未来的`会话私钥`，利用前面的公钥进行`加密`。\n5. 客户端把`加密后会话私钥`回传给服务端，在这个过程中，即使`加密后的会话私钥`被窃取也不用担心，因为中间人并没有`解密私钥`，所以读不出里面的`会话私钥`。\n6. 服务端接收到`加密会话私钥`后，利用从CA购买证书时获得的`解密私钥`进行解密读出`真实会话私钥`。至此，客户端与服务端同时拥有了一个只有它们二者知道的`会话私钥`，非对称加密连接建立完成。\n7. 一旦客户端和服务端连接建立起来后，未来的数据通信都利用这个`会话私钥`进行对称加密传输数据。\n\n采用了https后，我们所有网络传输的数据都由明文变成了密文，即使中间有人能够监听到数据包，也不能轻易获取user的帐户密码信息。\n\n听起来，安全性问题基本解决了。\n\n然而实际上，在步骤3用户需要去验证数字证书时，如果<u>这个验证过程被欺骗了呢</u>？\n\n试想这样一种场景，如果在最开始，攻击者就拦截掉客户端与服务端的通信。当客户端在请求证书时，攻击者回传一个他自己的`假证书`，而且攻击者已经通过其他手段欺骗用户在手机上`信任`了这个`假证书`，那么当客户端接收到证书并去验证时，是**<u>可以通过的</u>**。\n\n这也就意味着，一旦客户端遭受这样的攻击，未来客户端都会与一个`虚假的中间人`通信，而且中间人也可以拿着客户端传来的信息去与我们的服务端通信，而这个过程`客户端和我们服务端完全不知道中间人的存在`，这是很大的安全隐患。\n\n\n\n### SSL Pinning\n\n为了防止客户端被虚假证书欺骗，我们采取的方式是<u>把我们自己的公钥直接绑定给每个客户端</u>，当客户端收到证书后，<u>与绑定的公钥进行验证</u>，从而防止`虚假证书`的入侵。\n\n在Android端，我们利用`OkHttp3`提供的`CertificatePinner`实现`证书绑定`\n\n```java\nOkHttpClient client = new OkHttpClient.Builder()\n  .certificatePinner(\n        new CertificatePinner.Builder().add(\"your_host\", \"your_public_key\").build())\n        .build();\n```\n\n至此，我们可以利用更为安全的https协议来传输用户名和密码来继续上面的注册流程。\n\n\n\n### Token机制\n\n回到注册流程，当服务端拿到用户名密码后，会去创建一个新的user，同时我们会<u>基于用户相关信息</u>生成一个`Token`并回传给客户端。客户端在接收到`Token`后需要在本地进行存储。另外，由于每个http请求都是无状态的，因此未来客户端如果想把`user_id`等信息传递给服务端时，就必须通过`Token`来传递，才能识别出某个请求的来源。\n\n那么，我们应该如何在Android和服务端的代码里具体实现Token的`传递`、`解析`及`有效性验证机制`呢？\n\n**1. 首先在Android端，为了把`Token`信息存入到所有请求的header里供服务端使用，我们采用了`okhttp3`提供的`interceptor接口`来。**\n\n```java\nOkHttpClient client = new OkHttpClient.Builder()\n       .addInterceptor(new Interceptor() {\n         @Override\n         public Response intercept(Chain chain) throws IOException {\n           Request request = chain.request();\n           Request.Builder newRequestBuilder = request.newBuilder();\n           String token = getAuthToken();\n           if (!TextUtils.isEmpty(token)) {\n             newRequestBuilder.addHeader(\"Authorization\", token);\n           }\n\n           Request newRequest = newRequestBuilder.build();\n           return chain.proceed(newRequest);\n         }\n       })\n       .build();\n```\n\n**2. 然后在服务端，我们需要`解析`客户端传递过来的Token信息并进行`校验`。这里可以创建一个`python`的`decorator`方法：**\n\n```python\ndef mobile_request(func):\n   @functools.wraps(func)\n   def wrapped(*args, **kwargs):\n       kwargs = kwargs if kwargs or {}\n   \tif request.headers.get('Authorization'):\n   \t\tencrypted_token = request.headers.get('Authorization')\n   \t\tisValid, user_id = check_token(encrypted_token) //解析并验证token有效性\n   \t\tif not isValid:\n   \t\t\tabort(498) //token无效，返回498状态码\n   \t\tuser = get_user_by_id(user_id)\n   \t\tif not user:\n   \t\t\tabort(1001) //找不到user，自定义601状态码\n\t\t\tkwargs['user_id'] = user_id //成功解析出user_id\n   \treturn func(**kwargs)\n   return wrapped\t\n```\n\n```py\n@app.route(\"/www/index\")\n@mobile_request // 使用decorator包装方法\ndef get_user(**kwargs):\n\tuser_id = kwargs['user_id'] // 取出decorator中封装好的user_id\n\treturn db.get_user(user_id) // 利用user_id进行逻辑处理\n```\n\n**3. 最后，请求结果返回到客户端，如果通过监测状态码发现返回结果是与Token相关的`error/异常`，则表示`Token失效`，此时我们让用户强制重新登录，生成新Token。这一步仍然可以在上面的`interceptor`里进行。**\n\n```java\nOkHttpClient client = new OkHttpClient.Builder()\n       .addInterceptor(new Interceptor() {\n         @Override\n         public Response intercept(Chain chain) throws IOException {\n           ... //put token into newRequest\n           Response response = chain.proceed(newRequest); // 获取服务端返回结果\n           switch(response.code()) {\n             case ResponseCode.USER_NOT_FOUND: // 自定义状态码: 1001 找不到user\n             \teventBus.post(new UserNotFoundEvent()); // 强制logout\n             \tbreak;\n             case ResponseCode.TOKEN_EXPIRED: // 498 token失效\n             \teventBus.post(new TokenExpiredEvent()); // 强制logout\n             \tbreak;\n             default:\n             \tbreak;\n           }\n           return response;\n         }\n       })\n       .build();\n```\n\n至此，我们完成了Android端和服务端的Token传递、解析和失效处理。\n\n因此，在完善了Token的管理机制后，我们未来的http请求中只要带上这个Token，就可以畅通无阻地去服务端做与自身user相关的各种操作了。\n\n那么，既然Token像家里门禁卡一样，<u>只要拥有就能进入我们服务端并获取这个特定user的所有数据</u>。那也就意味着，<u>一旦攻击者窃取了某个user的Token</u>，那在Token失效前，攻击者随时可以利用这个Token获取这个user的一切信息。\n\n遇到Token被盗，该怎么办呢？\n\n\n\n### 调整Token过期时间\n\n针对Token被盗这种威胁，我们可以缩短Token的过期时间的方法。这样即使一个Token泄漏了，在一段时间后，这个Token也会自动失效。当然这也做会需要用户频繁登录获取新Token；而且失效前的这段时间内，攻击者仍然是可以直接连上服务端随意获取数据的。\n\n\n\n### Request签名\n\n这种方法也是OAuth推荐的[一种方法](https://oauth.net/core/1.0/#signing_process)，其原理是<u>在客户端和服务端统一好某种加密方法和一个密钥</u>，这个密钥同时存储在客户端和服务端。每次客户端准备发起一个请求时，利用这种加密算法和密钥，针对<u>该请求的API和参数</u>进行计算得到一个数，称之为这个`Request的签名`，然后我们把这个`签名`放入到Request中。当服务端接收到Request后，就可以利用相同的加密算法和密钥来验证其中签名的真实性。\n\n```java\nOkHttpClient client = new OkHttpClient.Builder()\n        .addInterceptor(new Interceptor() {\n          @Override\n          public Response intercept(Chain chain) throws IOException {\n            Request request = chain.request();\n            String sign = RequestSignUtil.sign(request);\n            HttpUrl url = request.url().newBuilder()\n        \t\t.addQueryParameter(\"request_sign\", sign)\n        \t\t.build();\n            Request newRequest = request.newBuilder().url(url).build();\n            return chain.proceed(newRequest);\n          }\n        })\n        .build();\n```\n\n通过对每一个Request签名，可以确保服务端接收到的所有Request都来自我们自己的客户端。即使有人得到了Token想伪造Request，他也不知道如何计算Request签名，从而减小了Token被盗的危害。\n\n当然，每种安全方法都有漏洞，Request签名的方法意味着我们必须在客户端保存好加密算法和密钥，可以通过代码混淆、密钥存储到.so文件等方法来提高破解难度，这里就不再细述了。\n\n\n\n### 小结\n\n上文中，从注册流程开始，介绍了我们在数据安全性方面采取的一些策略和相关实现代码，希望能对读者有帮助。\n\n最后，笔者认为虽然没有完美的安全性，但我们所做的每一步都能加大被攻击的难度。\n\n","source":"_posts/谈谈移动应用的安全性实践.md","raw":"title: 谈谈移动应用的安全性实践\ndate: 2016-08-30 21:39:01\ncategories:\n  - Android\n  - 安全\ntags: Android\ncommentIssueId: 13\n---\n>虽然没有完美的安全性，但我们所做的每一步都能加大被攻击的难度。\n\n<!-- more -->\n\n本文将从用户注册流程出发，介绍下个人实践中在提高数据安全性方面采用的一些策略方法，供读者参考。下文将从 `Android` 和 `服务端` 两部分来进行讲解。\n\n![](http://upload-images.jianshu.io/upload_images/281665-29572b7461c3d279.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n### 从注册说起\n\n用户第一次打开app时便会进入注册页面。然后客户端会要求用户输入用户名、密码并传递给服务端去创建一个新的user。此时通过明文传递用户名密码便是一个安全性隐患。或者说，如果有人监听注册API，那么很快就可以窃取到很多用户的账户信息，而且可以偷偷利用这些账户信息随时获取甚至更改用户数据。\n\n这对于任何一家企业而言都是非常可怕的。\n\n\n\n### 全站Https\n\n因此，为了应对数据明文传输隐患这个问题，我们可以<u>采用[Https](https://en.wikipedia.org/wiki/HTTPS)方式通信</u>。在Android端推荐[Square](http://square.github.io/)家的[OkHttp3](https://github.com/square/okhttp)作为网络层，为应用层提供Https服务。\n\n下面先对Https的基本工作原理进行下介绍。\n\n1. 首先，客户端去请求服务端的数字证书，这个证书包含了一个公钥。该证书购买后存储于我们自己服务器上。\n2. 当服务端收到客户端请求后，会把这个数字证书回传给客户端，由于是公钥，所以不害怕被窃取。\n3. 客户端收到数字证书后，先去`验证`证书的真实性。如果验证通过，就会从里面取出一个`公钥`。\n4. 客户端本地生成一个`随机数`，作为未来的`会话私钥`，利用前面的公钥进行`加密`。\n5. 客户端把`加密后会话私钥`回传给服务端，在这个过程中，即使`加密后的会话私钥`被窃取也不用担心，因为中间人并没有`解密私钥`，所以读不出里面的`会话私钥`。\n6. 服务端接收到`加密会话私钥`后，利用从CA购买证书时获得的`解密私钥`进行解密读出`真实会话私钥`。至此，客户端与服务端同时拥有了一个只有它们二者知道的`会话私钥`，非对称加密连接建立完成。\n7. 一旦客户端和服务端连接建立起来后，未来的数据通信都利用这个`会话私钥`进行对称加密传输数据。\n\n采用了https后，我们所有网络传输的数据都由明文变成了密文，即使中间有人能够监听到数据包，也不能轻易获取user的帐户密码信息。\n\n听起来，安全性问题基本解决了。\n\n然而实际上，在步骤3用户需要去验证数字证书时，如果<u>这个验证过程被欺骗了呢</u>？\n\n试想这样一种场景，如果在最开始，攻击者就拦截掉客户端与服务端的通信。当客户端在请求证书时，攻击者回传一个他自己的`假证书`，而且攻击者已经通过其他手段欺骗用户在手机上`信任`了这个`假证书`，那么当客户端接收到证书并去验证时，是**<u>可以通过的</u>**。\n\n这也就意味着，一旦客户端遭受这样的攻击，未来客户端都会与一个`虚假的中间人`通信，而且中间人也可以拿着客户端传来的信息去与我们的服务端通信，而这个过程`客户端和我们服务端完全不知道中间人的存在`，这是很大的安全隐患。\n\n\n\n### SSL Pinning\n\n为了防止客户端被虚假证书欺骗，我们采取的方式是<u>把我们自己的公钥直接绑定给每个客户端</u>，当客户端收到证书后，<u>与绑定的公钥进行验证</u>，从而防止`虚假证书`的入侵。\n\n在Android端，我们利用`OkHttp3`提供的`CertificatePinner`实现`证书绑定`\n\n```java\nOkHttpClient client = new OkHttpClient.Builder()\n  .certificatePinner(\n        new CertificatePinner.Builder().add(\"your_host\", \"your_public_key\").build())\n        .build();\n```\n\n至此，我们可以利用更为安全的https协议来传输用户名和密码来继续上面的注册流程。\n\n\n\n### Token机制\n\n回到注册流程，当服务端拿到用户名密码后，会去创建一个新的user，同时我们会<u>基于用户相关信息</u>生成一个`Token`并回传给客户端。客户端在接收到`Token`后需要在本地进行存储。另外，由于每个http请求都是无状态的，因此未来客户端如果想把`user_id`等信息传递给服务端时，就必须通过`Token`来传递，才能识别出某个请求的来源。\n\n那么，我们应该如何在Android和服务端的代码里具体实现Token的`传递`、`解析`及`有效性验证机制`呢？\n\n**1. 首先在Android端，为了把`Token`信息存入到所有请求的header里供服务端使用，我们采用了`okhttp3`提供的`interceptor接口`来。**\n\n```java\nOkHttpClient client = new OkHttpClient.Builder()\n       .addInterceptor(new Interceptor() {\n         @Override\n         public Response intercept(Chain chain) throws IOException {\n           Request request = chain.request();\n           Request.Builder newRequestBuilder = request.newBuilder();\n           String token = getAuthToken();\n           if (!TextUtils.isEmpty(token)) {\n             newRequestBuilder.addHeader(\"Authorization\", token);\n           }\n\n           Request newRequest = newRequestBuilder.build();\n           return chain.proceed(newRequest);\n         }\n       })\n       .build();\n```\n\n**2. 然后在服务端，我们需要`解析`客户端传递过来的Token信息并进行`校验`。这里可以创建一个`python`的`decorator`方法：**\n\n```python\ndef mobile_request(func):\n   @functools.wraps(func)\n   def wrapped(*args, **kwargs):\n       kwargs = kwargs if kwargs or {}\n   \tif request.headers.get('Authorization'):\n   \t\tencrypted_token = request.headers.get('Authorization')\n   \t\tisValid, user_id = check_token(encrypted_token) //解析并验证token有效性\n   \t\tif not isValid:\n   \t\t\tabort(498) //token无效，返回498状态码\n   \t\tuser = get_user_by_id(user_id)\n   \t\tif not user:\n   \t\t\tabort(1001) //找不到user，自定义601状态码\n\t\t\tkwargs['user_id'] = user_id //成功解析出user_id\n   \treturn func(**kwargs)\n   return wrapped\t\n```\n\n```py\n@app.route(\"/www/index\")\n@mobile_request // 使用decorator包装方法\ndef get_user(**kwargs):\n\tuser_id = kwargs['user_id'] // 取出decorator中封装好的user_id\n\treturn db.get_user(user_id) // 利用user_id进行逻辑处理\n```\n\n**3. 最后，请求结果返回到客户端，如果通过监测状态码发现返回结果是与Token相关的`error/异常`，则表示`Token失效`，此时我们让用户强制重新登录，生成新Token。这一步仍然可以在上面的`interceptor`里进行。**\n\n```java\nOkHttpClient client = new OkHttpClient.Builder()\n       .addInterceptor(new Interceptor() {\n         @Override\n         public Response intercept(Chain chain) throws IOException {\n           ... //put token into newRequest\n           Response response = chain.proceed(newRequest); // 获取服务端返回结果\n           switch(response.code()) {\n             case ResponseCode.USER_NOT_FOUND: // 自定义状态码: 1001 找不到user\n             \teventBus.post(new UserNotFoundEvent()); // 强制logout\n             \tbreak;\n             case ResponseCode.TOKEN_EXPIRED: // 498 token失效\n             \teventBus.post(new TokenExpiredEvent()); // 强制logout\n             \tbreak;\n             default:\n             \tbreak;\n           }\n           return response;\n         }\n       })\n       .build();\n```\n\n至此，我们完成了Android端和服务端的Token传递、解析和失效处理。\n\n因此，在完善了Token的管理机制后，我们未来的http请求中只要带上这个Token，就可以畅通无阻地去服务端做与自身user相关的各种操作了。\n\n那么，既然Token像家里门禁卡一样，<u>只要拥有就能进入我们服务端并获取这个特定user的所有数据</u>。那也就意味着，<u>一旦攻击者窃取了某个user的Token</u>，那在Token失效前，攻击者随时可以利用这个Token获取这个user的一切信息。\n\n遇到Token被盗，该怎么办呢？\n\n\n\n### 调整Token过期时间\n\n针对Token被盗这种威胁，我们可以缩短Token的过期时间的方法。这样即使一个Token泄漏了，在一段时间后，这个Token也会自动失效。当然这也做会需要用户频繁登录获取新Token；而且失效前的这段时间内，攻击者仍然是可以直接连上服务端随意获取数据的。\n\n\n\n### Request签名\n\n这种方法也是OAuth推荐的[一种方法](https://oauth.net/core/1.0/#signing_process)，其原理是<u>在客户端和服务端统一好某种加密方法和一个密钥</u>，这个密钥同时存储在客户端和服务端。每次客户端准备发起一个请求时，利用这种加密算法和密钥，针对<u>该请求的API和参数</u>进行计算得到一个数，称之为这个`Request的签名`，然后我们把这个`签名`放入到Request中。当服务端接收到Request后，就可以利用相同的加密算法和密钥来验证其中签名的真实性。\n\n```java\nOkHttpClient client = new OkHttpClient.Builder()\n        .addInterceptor(new Interceptor() {\n          @Override\n          public Response intercept(Chain chain) throws IOException {\n            Request request = chain.request();\n            String sign = RequestSignUtil.sign(request);\n            HttpUrl url = request.url().newBuilder()\n        \t\t.addQueryParameter(\"request_sign\", sign)\n        \t\t.build();\n            Request newRequest = request.newBuilder().url(url).build();\n            return chain.proceed(newRequest);\n          }\n        })\n        .build();\n```\n\n通过对每一个Request签名，可以确保服务端接收到的所有Request都来自我们自己的客户端。即使有人得到了Token想伪造Request，他也不知道如何计算Request签名，从而减小了Token被盗的危害。\n\n当然，每种安全方法都有漏洞，Request签名的方法意味着我们必须在客户端保存好加密算法和密钥，可以通过代码混淆、密钥存储到.so文件等方法来提高破解难度，这里就不再细述了。\n\n\n\n### 小结\n\n上文中，从注册流程开始，介绍了我们在数据安全性方面采取的一些策略和相关实现代码，希望能对读者有帮助。\n\n最后，笔者认为虽然没有完美的安全性，但我们所做的每一步都能加大被攻击的难度。\n\n","slug":"谈谈移动应用的安全性实践","published":1,"updated":"2018-11-26T06:56:27.489Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplsib003f3dn8mz6zbflj","content":"<blockquote>\n<p>虽然没有完美的安全性，但我们所做的每一步都能加大被攻击的难度。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>本文将从用户注册流程出发，介绍下个人实践中在提高数据安全性方面采用的一些策略方法，供读者参考。下文将从 <code>Android</code> 和 <code>服务端</code> 两部分来进行讲解。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/281665-29572b7461c3d279.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h3 id=\"从注册说起\"><a href=\"# 从注册说起\" class=\"headerlink\" title=\"从注册说起\"></a>从注册说起 </h3><p> 用户第一次打开 app 时便会进入注册页面。然后客户端会要求用户输入用户名、密码并传递给服务端去创建一个新的 user。此时通过明文传递用户名密码便是一个安全性隐患。或者说，如果有人监听注册 API，那么很快就可以窃取到很多用户的账户信息，而且可以偷偷利用这些账户信息随时获取甚至更改用户数据。</p>\n<p>这对于任何一家企业而言都是非常可怕的。</p>\n<h3 id=\"全站 Https\"><a href=\"# 全站 Https\" class=\"headerlink\" title=\"全站 Https\"></a>全站 Https</h3><p>因此，为了应对数据明文传输隐患这个问题，我们可以 <u> 采用 <a href=\"https://en.wikipedia.org/wiki/HTTPS\" target=\"_blank\" rel=\"external\">Https</a> 方式通信 </u>。在 Android 端推荐<a href=\"http://square.github.io/\" target=\"_blank\" rel=\"external\">Square</a> 家的 <a href=\"https://github.com/square/okhttp\" target=\"_blank\" rel=\"external\">OkHttp3</a> 作为网络层，为应用层提供 Https 服务。</p>\n<p>下面先对 Https 的基本工作原理进行下介绍。</p>\n<ol>\n<li>首先，客户端去请求服务端的数字证书，这个证书包含了一个公钥。该证书购买后存储于我们自己服务器上。</li>\n<li>当服务端收到客户端请求后，会把这个数字证书回传给客户端，由于是公钥，所以不害怕被窃取。</li>\n<li>客户端收到数字证书后，先去 <code> 验证 </code> 证书的真实性。如果验证通过，就会从里面取出一个 <code> 公钥</code>。</li>\n<li>客户端本地生成一个 <code> 随机数 </code>，作为未来的<code> 会话私钥 </code>，利用前面的公钥进行<code> 加密</code>。</li>\n<li>客户端把 <code> 加密后会话私钥 </code> 回传给服务端，在这个过程中，即使 <code> 加密后的会话私钥 </code> 被窃取也不用担心，因为中间人并没有 <code> 解密私钥 </code>，所以读不出里面的<code> 会话私钥</code>。</li>\n<li>服务端接收到 <code> 加密会话私钥 </code> 后，利用从 CA 购买证书时获得的 <code> 解密私钥 </code> 进行解密读出 <code> 真实会话私钥 </code>。至此，客户端与服务端同时拥有了一个只有它们二者知道的<code> 会话私钥</code>，非对称加密连接建立完成。</li>\n<li>一旦客户端和服务端连接建立起来后，未来的数据通信都利用这个 <code> 会话私钥 </code> 进行对称加密传输数据。</li>\n</ol>\n<p>采用了 https 后，我们所有网络传输的数据都由明文变成了密文，即使中间有人能够监听到数据包，也不能轻易获取 user 的帐户密码信息。</p>\n<p>听起来，安全性问题基本解决了。</p>\n<p>然而实际上，在步骤 3 用户需要去验证数字证书时，如果 <u> 这个验证过程被欺骗了呢</u>？</p>\n<p>试想这样一种场景，如果在最开始，攻击者就拦截掉客户端与服务端的通信。当客户端在请求证书时，攻击者回传一个他自己的 <code> 假证书 </code>，而且攻击者已经通过其他手段欺骗用户在手机上<code> 信任 </code> 了这个 <code> 假证书 </code>，那么当客户端接收到证书并去验证时，是<strong><u> 可以通过的</u></strong>。</p>\n<p>这也就意味着，一旦客户端遭受这样的攻击，未来客户端都会与一个 <code> 虚假的中间人 </code> 通信，而且中间人也可以拿着客户端传来的信息去与我们的服务端通信，而这个过程 <code> 客户端和我们服务端完全不知道中间人的存在</code>，这是很大的安全隐患。</p>\n<h3 id=\"SSL-Pinning\"><a href=\"#SSL-Pinning\" class=\"headerlink\" title=\"SSL Pinning\"></a>SSL Pinning</h3><p>为了防止客户端被虚假证书欺骗，我们采取的方式是 <u> 把我们自己的公钥直接绑定给每个客户端 </u>，当客户端收到证书后，<u> 与绑定的公钥进行验证 </u>，从而防止<code> 虚假证书 </code> 的入侵。</p>\n<p>在 Android 端，我们利用 <code>OkHttp3</code> 提供的 <code>CertificatePinner</code> 实现 <code> 证书绑定</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">OkHttpClient client = <span class=\"keyword\">new</span> OkHttpClient.Builder()</div><div class=\"line\">  .certificatePinner(</div><div class=\"line\">        <span class=\"keyword\">new</span> CertificatePinner.Builder().add(<span class=\"string\">\"your_host\"</span>, <span class=\"string\">\"your_public_key\"</span>).build())</div><div class=\"line\">        .build();</div></pre></td></tr></table></figure>\n<p>至此，我们可以利用更为安全的 https 协议来传输用户名和密码来继续上面的注册流程。</p>\n<h3 id=\"Token 机制\"><a href=\"#Token 机制\" class=\"headerlink\" title=\"Token 机制\"></a>Token 机制 </h3><p> 回到注册流程，当服务端拿到用户名密码后，会去创建一个新的 user，同时我们会 <u> 基于用户相关信息 </u> 生成一个 <code>Token</code> 并回传给客户端。客户端在接收到 <code>Token</code> 后需要在本地进行存储。另外，由于每个 http 请求都是无状态的，因此未来客户端如果想把 <code>user_id</code> 等信息传递给服务端时，就必须通过 <code>Token</code> 来传递，才能识别出某个请求的来源。</p>\n<p>那么，我们应该如何在 Android 和服务端的代码里具体实现 Token 的 <code> 传递 </code>、<code> 解析 </code> 及<code>有效性验证机制 </code> 呢？</p>\n<p><strong>1. 首先在 Android 端，为了把 <code>Token</code> 信息存入到所有请求的 header 里供服务端使用，我们采用了 <code>okhttp3</code> 提供的 <code>interceptor 接口</code> 来。</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">OkHttpClient client = <span class=\"keyword\">new</span> OkHttpClient.Builder()</div><div class=\"line\">       .addInterceptor(<span class=\"keyword\">new</span> Interceptor() &#123;</div><div class=\"line\">         <span class=\"meta\">@Override</span></div><div class=\"line\">         <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">           Request request = chain.request();</div><div class=\"line\">           Request.Builder newRequestBuilder = request.newBuilder();</div><div class=\"line\">           String token = getAuthToken();</div><div class=\"line\">           <span class=\"keyword\">if</span> (!TextUtils.isEmpty(token)) &#123;</div><div class=\"line\">             newRequestBuilder.addHeader(<span class=\"string\">\"Authorization\"</span>, token);</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           Request newRequest = newRequestBuilder.build();</div><div class=\"line\">           <span class=\"keyword\">return</span> chain.proceed(newRequest);</div><div class=\"line\">         &#125;</div><div class=\"line\">       &#125;)</div><div class=\"line\">       .build();</div></pre></td></tr></table></figure>\n<p><strong>2. 然后在服务端，我们需要 <code> 解析 </code> 客户端传递过来的 Token 信息并进行 <code> 校验 </code>。这里可以创建一个<code>python</code> 的<code>decorator</code>方法：</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mobile_request</span><span class=\"params\">(func)</span>:</span></div><div class=\"line\"><span class=\"meta\">   @functools.wraps(func)</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapped</span><span class=\"params\">(*args, **kwargs)</span>:</span></div><div class=\"line\">       kwargs = kwargs <span class=\"keyword\">if</span> kwargs <span class=\"keyword\">or</span> &#123;&#125;</div><div class=\"line\">   \t<span class=\"keyword\">if</span> request.headers.get(<span class=\"string\">'Authorization'</span>):</div><div class=\"line\">   \t\tencrypted_token = request.headers.get(<span class=\"string\">'Authorization'</span>)</div><div class=\"line\">   \t\tisValid, user_id = check_token(encrypted_token) // 解析并验证 token 有效性 </div><div class=\"line\">   \t\t<span class=\"keyword\">if</span> <span class=\"keyword\">not</span> isValid:</div><div class=\"line\">   \t\t\tabort(<span class=\"number\">498</span>) //token 无效，返回<span class=\"number\">498</span> 状态码 </div><div class=\"line\">   \t\tuser = get_user_by_id(user_id)</div><div class=\"line\">   \t\t<span class=\"keyword\">if</span> <span class=\"keyword\">not</span> user:</div><div class=\"line\">   \t\t\tabort(<span class=\"number\">1001</span>) // 找不到 user，自定义<span class=\"number\">601</span> 状态码</div><div class=\"line\">\t\t\tkwargs[<span class=\"string\">'user_id'</span>] = user_id // 成功解析出 user_id</div><div class=\"line\">   \t<span class=\"keyword\">return</span> func(**kwargs)</div><div class=\"line\">   <span class=\"keyword\">return</span> wrapped</div></pre></td></tr></table></figure>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@app.route(\"/www/index\")</span></div><div class=\"line\"><span class=\"meta\">@mobile_request // 使用 decorator 包装方法</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_user</span><span class=\"params\">(**kwargs)</span>:</span></div><div class=\"line\">\tuser_id = kwargs[<span class=\"string\">'user_id'</span>] // 取出 decorator 中封装好的 user_id</div><div class=\"line\">\t<span class=\"keyword\">return</span> db.get_user(user_id) // 利用 user_id 进行逻辑处理</div></pre></td></tr></table></figure>\n<p><strong>3. 最后，请求结果返回到客户端，如果通过监测状态码发现返回结果是与 Token 相关的 <code>error/ 异常</code>，则表示<code>Token 失效</code>，此时我们让用户强制重新登录，生成新 Token。这一步仍然可以在上面的<code>interceptor</code> 里进行。</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">OkHttpClient client = <span class=\"keyword\">new</span> OkHttpClient.Builder()</div><div class=\"line\">       .addInterceptor(<span class=\"keyword\">new</span> Interceptor() &#123;</div><div class=\"line\">         <span class=\"meta\">@Override</span></div><div class=\"line\">         <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">           ... <span class=\"comment\">//put token into newRequest</span></div><div class=\"line\">           Response response = chain.proceed(newRequest); <span class=\"comment\">// 获取服务端返回结果</span></div><div class=\"line\">           <span class=\"keyword\">switch</span>(response.code()) &#123;</div><div class=\"line\">             <span class=\"keyword\">case</span> ResponseCode.USER_NOT_FOUND: <span class=\"comment\">// 自定义状态码: 1001 找不到 user</span></div><div class=\"line\">             \teventBus.post(<span class=\"keyword\">new</span> UserNotFoundEvent()); <span class=\"comment\">// 强制 logout</span></div><div class=\"line\">             \t<span class=\"keyword\">break</span>;</div><div class=\"line\">             <span class=\"keyword\">case</span> ResponseCode.TOKEN_EXPIRED: <span class=\"comment\">// 498 token 失效</span></div><div class=\"line\">             \teventBus.post(<span class=\"keyword\">new</span> TokenExpiredEvent()); <span class=\"comment\">// 强制 logout</span></div><div class=\"line\">             \t<span class=\"keyword\">break</span>;</div><div class=\"line\">             <span class=\"keyword\">default</span>:</div><div class=\"line\">             \t<span class=\"keyword\">break</span>;</div><div class=\"line\">           &#125;</div><div class=\"line\">           <span class=\"keyword\">return</span> response;</div><div class=\"line\">         &#125;</div><div class=\"line\">       &#125;)</div><div class=\"line\">       .build();</div></pre></td></tr></table></figure>\n<p>至此，我们完成了 Android 端和服务端的 Token 传递、解析和失效处理。</p>\n<p>因此，在完善了 Token 的管理机制后，我们未来的 http 请求中只要带上这个 Token，就可以畅通无阻地去服务端做与自身 user 相关的各种操作了。</p>\n<p>那么，既然 Token 像家里门禁卡一样，<u>只要拥有就能进入我们服务端并获取这个特定 user 的所有数据 </u>。那也就意味着，<u> 一旦攻击者窃取了某个 user 的 Token</u>，那在 Token 失效前，攻击者随时可以利用这个 Token 获取这个 user 的一切信息。</p>\n<p>遇到 Token 被盗，该怎么办呢？</p>\n<h3 id=\"调整 Token 过期时间\"><a href=\"# 调整 Token 过期时间\" class=\"headerlink\" title=\"调整 Token 过期时间\"></a>调整 Token 过期时间 </h3><p> 针对 Token 被盗这种威胁，我们可以缩短 Token 的过期时间的方法。这样即使一个 Token 泄漏了，在一段时间后，这个 Token 也会自动失效。当然这也做会需要用户频繁登录获取新 Token；而且失效前的这段时间内，攻击者仍然是可以直接连上服务端随意获取数据的。</p>\n<h3 id=\"Request 签名\"><a href=\"#Request 签名\" class=\"headerlink\" title=\"Request 签名\"></a>Request 签名 </h3><p> 这种方法也是 OAuth 推荐的 <a href=\"https://oauth.net/core/1.0/#signing_process\" target=\"_blank\" rel=\"external\"> 一种方法 </a>，其原理是<u> 在客户端和服务端统一好某种加密方法和一个密钥 </u>，这个密钥同时存储在客户端和服务端。每次客户端准备发起一个请求时，利用这种加密算法和密钥，针对<u> 该请求的 API 和参数 </u> 进行计算得到一个数，称之为这个 <code>Request 的签名</code>，然后我们把这个<code> 签名 </code> 放入到 Request 中。当服务端接收到 Request 后，就可以利用相同的加密算法和密钥来验证其中签名的真实性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">OkHttpClient client = <span class=\"keyword\">new</span> OkHttpClient.Builder()</div><div class=\"line\">        .addInterceptor(<span class=\"keyword\">new</span> Interceptor() &#123;</div><div class=\"line\">          <span class=\"meta\">@Override</span></div><div class=\"line\">          <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">            Request request = chain.request();</div><div class=\"line\">            String sign = RequestSignUtil.sign(request);</div><div class=\"line\">            HttpUrl url = request.url().newBuilder()</div><div class=\"line\">        \t\t.addQueryParameter(<span class=\"string\">\"request_sign\"</span>, sign)</div><div class=\"line\">        \t\t.build();</div><div class=\"line\">            Request newRequest = request.newBuilder().url(url).build();</div><div class=\"line\">            <span class=\"keyword\">return</span> chain.proceed(newRequest);</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;)</div><div class=\"line\">        .build();</div></pre></td></tr></table></figure>\n<p>通过对每一个 Request 签名，可以确保服务端接收到的所有 Request 都来自我们自己的客户端。即使有人得到了 Token 想伪造 Request，他也不知道如何计算 Request 签名，从而减小了 Token 被盗的危害。</p>\n<p>当然，每种安全方法都有漏洞，Request 签名的方法意味着我们必须在客户端保存好加密算法和密钥，可以通过代码混淆、密钥存储到.so 文件等方法来提高破解难度，这里就不再细述了。</p>\n<h3 id=\"小结\"><a href=\"# 小结\" class=\"headerlink\" title=\"小结\"></a>小结 </h3><p> 上文中，从注册流程开始，介绍了我们在数据安全性方面采取的一些策略和相关实现代码，希望能对读者有帮助。</p>\n<p>最后，笔者认为虽然没有完美的安全性，但我们所做的每一步都能加大被攻击的难度。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>虽然没有完美的安全性，但我们所做的每一步都能加大被攻击的难度。</p>\n</blockquote>","more":"<p>本文将从用户注册流程出发，介绍下个人实践中在提高数据安全性方面采用的一些策略方法，供读者参考。下文将从 <code>Android</code> 和 <code>服务端</code> 两部分来进行讲解。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/281665-29572b7461c3d279.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h3 id=\"从注册说起\"><a href=\"#从注册说起\" class=\"headerlink\" title=\"从注册说起\"></a>从注册说起</h3><p>用户第一次打开app时便会进入注册页面。然后客户端会要求用户输入用户名、密码并传递给服务端去创建一个新的user。此时通过明文传递用户名密码便是一个安全性隐患。或者说，如果有人监听注册API，那么很快就可以窃取到很多用户的账户信息，而且可以偷偷利用这些账户信息随时获取甚至更改用户数据。</p>\n<p>这对于任何一家企业而言都是非常可怕的。</p>\n<h3 id=\"全站Https\"><a href=\"#全站Https\" class=\"headerlink\" title=\"全站Https\"></a>全站Https</h3><p>因此，为了应对数据明文传输隐患这个问题，我们可以<u>采用<a href=\"https://en.wikipedia.org/wiki/HTTPS\" target=\"_blank\" rel=\"external\">Https</a>方式通信</u>。在Android端推荐<a href=\"http://square.github.io/\" target=\"_blank\" rel=\"external\">Square</a>家的<a href=\"https://github.com/square/okhttp\" target=\"_blank\" rel=\"external\">OkHttp3</a>作为网络层，为应用层提供Https服务。</p>\n<p>下面先对Https的基本工作原理进行下介绍。</p>\n<ol>\n<li>首先，客户端去请求服务端的数字证书，这个证书包含了一个公钥。该证书购买后存储于我们自己服务器上。</li>\n<li>当服务端收到客户端请求后，会把这个数字证书回传给客户端，由于是公钥，所以不害怕被窃取。</li>\n<li>客户端收到数字证书后，先去<code>验证</code>证书的真实性。如果验证通过，就会从里面取出一个<code>公钥</code>。</li>\n<li>客户端本地生成一个<code>随机数</code>，作为未来的<code>会话私钥</code>，利用前面的公钥进行<code>加密</code>。</li>\n<li>客户端把<code>加密后会话私钥</code>回传给服务端，在这个过程中，即使<code>加密后的会话私钥</code>被窃取也不用担心，因为中间人并没有<code>解密私钥</code>，所以读不出里面的<code>会话私钥</code>。</li>\n<li>服务端接收到<code>加密会话私钥</code>后，利用从CA购买证书时获得的<code>解密私钥</code>进行解密读出<code>真实会话私钥</code>。至此，客户端与服务端同时拥有了一个只有它们二者知道的<code>会话私钥</code>，非对称加密连接建立完成。</li>\n<li>一旦客户端和服务端连接建立起来后，未来的数据通信都利用这个<code>会话私钥</code>进行对称加密传输数据。</li>\n</ol>\n<p>采用了https后，我们所有网络传输的数据都由明文变成了密文，即使中间有人能够监听到数据包，也不能轻易获取user的帐户密码信息。</p>\n<p>听起来，安全性问题基本解决了。</p>\n<p>然而实际上，在步骤3用户需要去验证数字证书时，如果<u>这个验证过程被欺骗了呢</u>？</p>\n<p>试想这样一种场景，如果在最开始，攻击者就拦截掉客户端与服务端的通信。当客户端在请求证书时，攻击者回传一个他自己的<code>假证书</code>，而且攻击者已经通过其他手段欺骗用户在手机上<code>信任</code>了这个<code>假证书</code>，那么当客户端接收到证书并去验证时，是<strong><u>可以通过的</u></strong>。</p>\n<p>这也就意味着，一旦客户端遭受这样的攻击，未来客户端都会与一个<code>虚假的中间人</code>通信，而且中间人也可以拿着客户端传来的信息去与我们的服务端通信，而这个过程<code>客户端和我们服务端完全不知道中间人的存在</code>，这是很大的安全隐患。</p>\n<h3 id=\"SSL-Pinning\"><a href=\"#SSL-Pinning\" class=\"headerlink\" title=\"SSL Pinning\"></a>SSL Pinning</h3><p>为了防止客户端被虚假证书欺骗，我们采取的方式是<u>把我们自己的公钥直接绑定给每个客户端</u>，当客户端收到证书后，<u>与绑定的公钥进行验证</u>，从而防止<code>虚假证书</code>的入侵。</p>\n<p>在Android端，我们利用<code>OkHttp3</code>提供的<code>CertificatePinner</code>实现<code>证书绑定</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">OkHttpClient client = <span class=\"keyword\">new</span> OkHttpClient.Builder()</div><div class=\"line\">  .certificatePinner(</div><div class=\"line\">        <span class=\"keyword\">new</span> CertificatePinner.Builder().add(<span class=\"string\">\"your_host\"</span>, <span class=\"string\">\"your_public_key\"</span>).build())</div><div class=\"line\">        .build();</div></pre></td></tr></table></figure>\n<p>至此，我们可以利用更为安全的https协议来传输用户名和密码来继续上面的注册流程。</p>\n<h3 id=\"Token机制\"><a href=\"#Token机制\" class=\"headerlink\" title=\"Token机制\"></a>Token机制</h3><p>回到注册流程，当服务端拿到用户名密码后，会去创建一个新的user，同时我们会<u>基于用户相关信息</u>生成一个<code>Token</code>并回传给客户端。客户端在接收到<code>Token</code>后需要在本地进行存储。另外，由于每个http请求都是无状态的，因此未来客户端如果想把<code>user_id</code>等信息传递给服务端时，就必须通过<code>Token</code>来传递，才能识别出某个请求的来源。</p>\n<p>那么，我们应该如何在Android和服务端的代码里具体实现Token的<code>传递</code>、<code>解析</code>及<code>有效性验证机制</code>呢？</p>\n<p><strong>1. 首先在Android端，为了把<code>Token</code>信息存入到所有请求的header里供服务端使用，我们采用了<code>okhttp3</code>提供的<code>interceptor接口</code>来。</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">OkHttpClient client = <span class=\"keyword\">new</span> OkHttpClient.Builder()</div><div class=\"line\">       .addInterceptor(<span class=\"keyword\">new</span> Interceptor() &#123;</div><div class=\"line\">         <span class=\"meta\">@Override</span></div><div class=\"line\">         <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">           Request request = chain.request();</div><div class=\"line\">           Request.Builder newRequestBuilder = request.newBuilder();</div><div class=\"line\">           String token = getAuthToken();</div><div class=\"line\">           <span class=\"keyword\">if</span> (!TextUtils.isEmpty(token)) &#123;</div><div class=\"line\">             newRequestBuilder.addHeader(<span class=\"string\">\"Authorization\"</span>, token);</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           Request newRequest = newRequestBuilder.build();</div><div class=\"line\">           <span class=\"keyword\">return</span> chain.proceed(newRequest);</div><div class=\"line\">         &#125;</div><div class=\"line\">       &#125;)</div><div class=\"line\">       .build();</div></pre></td></tr></table></figure>\n<p><strong>2. 然后在服务端，我们需要<code>解析</code>客户端传递过来的Token信息并进行<code>校验</code>。这里可以创建一个<code>python</code>的<code>decorator</code>方法：</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mobile_request</span><span class=\"params\">(func)</span>:</span></div><div class=\"line\"><span class=\"meta\">   @functools.wraps(func)</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapped</span><span class=\"params\">(*args, **kwargs)</span>:</span></div><div class=\"line\">       kwargs = kwargs <span class=\"keyword\">if</span> kwargs <span class=\"keyword\">or</span> &#123;&#125;</div><div class=\"line\">   \t<span class=\"keyword\">if</span> request.headers.get(<span class=\"string\">'Authorization'</span>):</div><div class=\"line\">   \t\tencrypted_token = request.headers.get(<span class=\"string\">'Authorization'</span>)</div><div class=\"line\">   \t\tisValid, user_id = check_token(encrypted_token) //解析并验证token有效性</div><div class=\"line\">   \t\t<span class=\"keyword\">if</span> <span class=\"keyword\">not</span> isValid:</div><div class=\"line\">   \t\t\tabort(<span class=\"number\">498</span>) //token无效，返回<span class=\"number\">498</span>状态码</div><div class=\"line\">   \t\tuser = get_user_by_id(user_id)</div><div class=\"line\">   \t\t<span class=\"keyword\">if</span> <span class=\"keyword\">not</span> user:</div><div class=\"line\">   \t\t\tabort(<span class=\"number\">1001</span>) //找不到user，自定义<span class=\"number\">601</span>状态码</div><div class=\"line\">\t\t\tkwargs[<span class=\"string\">'user_id'</span>] = user_id //成功解析出user_id</div><div class=\"line\">   \t<span class=\"keyword\">return</span> func(**kwargs)</div><div class=\"line\">   <span class=\"keyword\">return</span> wrapped</div></pre></td></tr></table></figure>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@app.route(\"/www/index\")</span></div><div class=\"line\"><span class=\"meta\">@mobile_request // 使用decorator包装方法</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_user</span><span class=\"params\">(**kwargs)</span>:</span></div><div class=\"line\">\tuser_id = kwargs[<span class=\"string\">'user_id'</span>] // 取出decorator中封装好的user_id</div><div class=\"line\">\t<span class=\"keyword\">return</span> db.get_user(user_id) // 利用user_id进行逻辑处理</div></pre></td></tr></table></figure>\n<p><strong>3. 最后，请求结果返回到客户端，如果通过监测状态码发现返回结果是与Token相关的<code>error/异常</code>，则表示<code>Token失效</code>，此时我们让用户强制重新登录，生成新Token。这一步仍然可以在上面的<code>interceptor</code>里进行。</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">OkHttpClient client = <span class=\"keyword\">new</span> OkHttpClient.Builder()</div><div class=\"line\">       .addInterceptor(<span class=\"keyword\">new</span> Interceptor() &#123;</div><div class=\"line\">         <span class=\"meta\">@Override</span></div><div class=\"line\">         <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">           ... <span class=\"comment\">//put token into newRequest</span></div><div class=\"line\">           Response response = chain.proceed(newRequest); <span class=\"comment\">// 获取服务端返回结果</span></div><div class=\"line\">           <span class=\"keyword\">switch</span>(response.code()) &#123;</div><div class=\"line\">             <span class=\"keyword\">case</span> ResponseCode.USER_NOT_FOUND: <span class=\"comment\">// 自定义状态码: 1001 找不到user</span></div><div class=\"line\">             \teventBus.post(<span class=\"keyword\">new</span> UserNotFoundEvent()); <span class=\"comment\">// 强制logout</span></div><div class=\"line\">             \t<span class=\"keyword\">break</span>;</div><div class=\"line\">             <span class=\"keyword\">case</span> ResponseCode.TOKEN_EXPIRED: <span class=\"comment\">// 498 token失效</span></div><div class=\"line\">             \teventBus.post(<span class=\"keyword\">new</span> TokenExpiredEvent()); <span class=\"comment\">// 强制logout</span></div><div class=\"line\">             \t<span class=\"keyword\">break</span>;</div><div class=\"line\">             <span class=\"keyword\">default</span>:</div><div class=\"line\">             \t<span class=\"keyword\">break</span>;</div><div class=\"line\">           &#125;</div><div class=\"line\">           <span class=\"keyword\">return</span> response;</div><div class=\"line\">         &#125;</div><div class=\"line\">       &#125;)</div><div class=\"line\">       .build();</div></pre></td></tr></table></figure>\n<p>至此，我们完成了Android端和服务端的Token传递、解析和失效处理。</p>\n<p>因此，在完善了Token的管理机制后，我们未来的http请求中只要带上这个Token，就可以畅通无阻地去服务端做与自身user相关的各种操作了。</p>\n<p>那么，既然Token像家里门禁卡一样，<u>只要拥有就能进入我们服务端并获取这个特定user的所有数据</u>。那也就意味着，<u>一旦攻击者窃取了某个user的Token</u>，那在Token失效前，攻击者随时可以利用这个Token获取这个user的一切信息。</p>\n<p>遇到Token被盗，该怎么办呢？</p>\n<h3 id=\"调整Token过期时间\"><a href=\"#调整Token过期时间\" class=\"headerlink\" title=\"调整Token过期时间\"></a>调整Token过期时间</h3><p>针对Token被盗这种威胁，我们可以缩短Token的过期时间的方法。这样即使一个Token泄漏了，在一段时间后，这个Token也会自动失效。当然这也做会需要用户频繁登录获取新Token；而且失效前的这段时间内，攻击者仍然是可以直接连上服务端随意获取数据的。</p>\n<h3 id=\"Request签名\"><a href=\"#Request签名\" class=\"headerlink\" title=\"Request签名\"></a>Request签名</h3><p>这种方法也是OAuth推荐的<a href=\"https://oauth.net/core/1.0/#signing_process\" target=\"_blank\" rel=\"external\">一种方法</a>，其原理是<u>在客户端和服务端统一好某种加密方法和一个密钥</u>，这个密钥同时存储在客户端和服务端。每次客户端准备发起一个请求时，利用这种加密算法和密钥，针对<u>该请求的API和参数</u>进行计算得到一个数，称之为这个<code>Request的签名</code>，然后我们把这个<code>签名</code>放入到Request中。当服务端接收到Request后，就可以利用相同的加密算法和密钥来验证其中签名的真实性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">OkHttpClient client = <span class=\"keyword\">new</span> OkHttpClient.Builder()</div><div class=\"line\">        .addInterceptor(<span class=\"keyword\">new</span> Interceptor() &#123;</div><div class=\"line\">          <span class=\"meta\">@Override</span></div><div class=\"line\">          <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">            Request request = chain.request();</div><div class=\"line\">            String sign = RequestSignUtil.sign(request);</div><div class=\"line\">            HttpUrl url = request.url().newBuilder()</div><div class=\"line\">        \t\t.addQueryParameter(<span class=\"string\">\"request_sign\"</span>, sign)</div><div class=\"line\">        \t\t.build();</div><div class=\"line\">            Request newRequest = request.newBuilder().url(url).build();</div><div class=\"line\">            <span class=\"keyword\">return</span> chain.proceed(newRequest);</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;)</div><div class=\"line\">        .build();</div></pre></td></tr></table></figure>\n<p>通过对每一个Request签名，可以确保服务端接收到的所有Request都来自我们自己的客户端。即使有人得到了Token想伪造Request，他也不知道如何计算Request签名，从而减小了Token被盗的危害。</p>\n<p>当然，每种安全方法都有漏洞，Request签名的方法意味着我们必须在客户端保存好加密算法和密钥，可以通过代码混淆、密钥存储到.so文件等方法来提高破解难度，这里就不再细述了。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>上文中，从注册流程开始，介绍了我们在数据安全性方面采取的一些策略和相关实现代码，希望能对读者有帮助。</p>\n<p>最后，笔者认为虽然没有完美的安全性，但我们所做的每一步都能加大被攻击的难度。</p>","sticky":0},{"title":"Android 架构之长连接技术","date":"2018-12-05T07:43:15.000Z","commentIssueId":32,"_content":"\n上一篇文章[《Android 架构之网络框架（上）》](https://xiaozhuanlan.com/topic/6982074351)中，我们谈过了网络框架OkHttp、网络加速方案如HttpDNS、数据压缩与序列化等技术点。本文我们结合[腾讯Mars框架](https://github.com/Tencent/mars)和[美团Shark体系](https://tech.meituan.com/Shark_SDK.html)等业内主流长连接方案，谈一谈长连接技术的各个方面。\n\n本文会包括下面的技术点：\n- 长连接与Http短连接、Keep-Alive傻傻分不清\n- 你为什么需要长连接\n- 长连接何时会断开\n- 如何建立稳定长连接\n- Mars智能心跳机制\n- 长连接数据协议及加密\n- 长连接通道建设及容灾\n\n<!-- more -->\n\n除了大家常用的Http短连接，大型App几乎都会搭建一套完整的`TCP长连接`网络通道。我们先来看下`美团Shark长连接`的线上数据：\n![](https://diycode.b0.upaiyun.com/photo/2018/4b0801aef3c69c00d38d1cc688bf13ba.png)\n![](https://diycode.b0.upaiyun.com/photo/2018/e8055c916f15c34aa03f6d230235841b.png)\n> 图片来源 《[美团点评移动网络优化实践](https://tech.meituan.com/Shark_SDK.html)》\n\n上面两张图片对比了长/短连接的成功率和网络延时数据，这两个是网络模块最重要的衡量指标。可以看出，无论是成功率，还是网络延时，长连接都明显优于短连接。\n\n另外，大家都知道微信的消息收发非常即时，这便归功于背后稳定高可用的长连接系统。实际上，微信除了消息收发，其他的小数据通信都是通过长连接来实现的。\n\n下面我们来讲解一些长连接的一些核心技术点。\n\n## I. 长连接与Http短连接、Keep-Alive傻傻分不清\n\n为防止大家对于长连接和短连接混淆，这里先简单说明下几点区别。\n\n### 长连接 vs Http短连接\n这两者分别对应的是`TCP协议层`的`长连接`和`短连接`。\n\n大家都知道，TCP会通过三次握手，建立与服务端的连接，然后传递数据，只不过`短连接`在数据传输完后，会主动关闭连接，而`长连接`会继续保持这条连接，后续的数据读写继续使用这条连接。\n\n### 长连接 vs Http的`Keep-Alive`\n上一篇文章中提到了`连接复用`，通过Http1.1的`Keep Alive`字段，我们可以让一条Http连接保持不被立即关闭。有些同学这时就疑惑了，是不是长连接就是`Keep Alive`呢？\n\n其实不是的。长连接我们也叫`TCP长连接`，它是架设在TCP协议上的，而上面说的`Keep Alive`是Http协议的内容，连协议都不同，两者自然不是一个东西。\n\n开启了`Keep Alive`是Http连接，我们也称之为`持久连接`，和长连接并不同。感兴趣可参考此文：[《TCP 进阶》](https://halfrost.com/advance_tcp/)。\n\n### TCP的`Keep-Alive` vs Http的`Keep-Alive`\n提到`Keep Alive`，有些同学就会问了，TCP协议里也有一个`Keep Alive`，它和Http协议里的`Keep Alive`有什么区别吗？\n\n二者的用处并不同。Http协议在完成一个请求后，服务器会自动关闭连接。这时，可以在请求里带上一个`Keep Alive`给服务器，告诉`服务器不要立即关闭连接`，我还想继续复用这条连接；而对TCP协议层而言，是不会自动断开的，但这也带来了一个问题，万一由于某些外部原因导致连接断开，那我如何知道连接已失效呢？TCP会在2个小时间隔后，自动发送一个`Keep Alive`数据包给服务端，探测一下服务器是否还在响应。它的功能类似心跳包，只是间隔太长，不适合做真正的心跳包。\n\n![](https://diycode.b0.upaiyun.com/photo/2018/a24b4b22bdeeb950ab05af01086a44e2.png)\n\n## II. 你为什么需要长连接\n那么，相比Http短连接，长连接技术能带来什么好处呢？\n#### 1. 不同域名的请求可以复用同一个长连接通道\n以前我们不同域名的请求，需要做对应的DNS请求，然后建立对应的Http连接。上篇文章里说的`Http连接池`在不同域名下不可复用，需要重新建立连接。这些都是一些资源开销，但是如果通过长连接通道，那域名只是这个请求里的一个字段，可以直接复用同一条长连接通道。\n#### 2. 不依赖DNS，无DNS耗时和劫持等问题\n上文中我们提到了`HttpDNS`，虽然它比系统DNS更优，但终归还是要做DNS操作。而长连接都是IP直接连接，因此没有DNS相关的开销和耗时。\n#### 3. 如果有大量网络请求，可以明显减少网络延时，节省带宽\n对于大型App而言，存在繁多密集的网络请求，这中间就会存在非常多次的Http断开和重新连接，浪费了很多时间和带宽。而通过长连接通道的话，则没有这部分耗时，直接传输二进制数据即可，节省了每次连接里Header之类的带宽开销。\n#### 4. 服务端主动Push数据到客户端\n对于上面提到的微信消息接收等场景，如果需要客户端主动去轮询，则会频繁发起请求，对于服务器会产生很大的负载压力，浪费带宽流量。而通过长连接，服务端可以主动把消息下发给客户端，做到最高实时性，且节省流量。\n\n![](https://diycode.b0.upaiyun.com/photo/2018/9d3fe531208dfad25637fff33b358972.jpeg)\n## III. 长连接何时会断开？\n正常而言，长连接是不会断开的。大家可以自己试一试，两个socket建立连接，只要网络不变、一切正常，那么这两个socket可以一直互相传送数据，不会断开。\n\n但是，在移动网络下，网络状态复杂多变，比如网络线路被切断、服务器宕机等，都会导致长连接中断。除了这些线路异常外，我们需要关注下面几个长连接断开原因：\n#### 1. 长连接所在进程被杀\n这个很容易理解，如果我们的App切换到后台，那么系统随时可能将我们的App杀掉，这时长连接自然也就随之断开。\n#### 2. 用户切换网络\n比如手机网络断开，或者发生Wi-Fi和蜂窝数据切换，这时会导致手机IP地址变更。而我们知道，TCP连接是基于IP + Port的，一旦IP变更，TCP连接自然也就失效了，或者说长连接也就相当于断开了。\n#### 3. 系统休眠等导致NAT超时\n这里对NAT简单解释下，方便有的同学不太了解。当手机连接上网络时，网关会给我们分配一个IP地址，这个其实是内网IP，此时还未真正连接上公网，也连接不上服务器；如果想要连接公网，需要运营商将我们的内网IP映射成一个公网IP，有了公网IP，服务器就能与我们建立连接了。NAT指的就是这个映射过程。\n\n也就是说，运营商会给每台设备分配一个公网IP，类似一张通信证。不过，随着连接网络的设备不断增多，网关负载也会不断加大，这时，运营商就会对一些不太活跃的设备进行公网IP回收了，如果下次这个设备需要连网，那就重新分配一个IP即可。\n\n看似没问题，但实际上，如果我们的App在一段时间不活跃，发生了NAT超时，便会导致我们的公网IP失效，长连接也随之失效了。\n#### 4. DHCP 租期\nDHCP 租期过期，如果没有及时续约，同样会导致IP地址失效。\n\n综合而言，长连接在正常情况下是不会断开的，但是，一旦手机的IP地址失效，这时就不得不重新建立连接了。\n\n## IV. 如何建立稳定长连接？\n上面我们提到了多种长连接断开的原因，那我们应该如何进行优化，尽可能保证长连接不断开，或者及时断开了，也要尽快重连呢？\n#### 1. Mars长连接独立进程\n为了减少进程被杀的几率，在Mars的[Demo代码](https://github.com/Tencent/mars/blob/master/samples/android/marsSampleChat/app/src/main/java/com/tencent/mars/sample/SampleApplicaton.java)里我们可以看到，它将长连接逻辑单独提取到了一个独立的进程里。这个进程只做网络交互，消耗的内存等资源自然较少，从而减少了被系统回收的概率。\n![](https://diycode.b0.upaiyun.com/photo/2018/02ee70621e61e774ca31203025592d71.png)\n> 图片来自[《Android版微信后台保活实战分享(进程保活篇)》](http://www.52im.net/thread-210-1-1.html)\n\n#### 2. 长连接进程复活\n进程被杀难以避免，不过可以通过AlarmReceiver、 ConnectReceiver、BootReceiver，达到进程的及时唤醒。\n\n当然，进程保活是一个比较大的话题，而且不恰当的进程保活也会对系统体验造成危害。这里就不深究了。\n\n#### 3. 心跳机制\n对于心跳包很多人误以为只是用来定期告诉服务端我们的状态，实际并非如此。\n\n上面我们提到了 NAT 超时，即如果App一段时间内不活跃，会导致运营商那里删除我们的公网IP映射关系，这会导致我们的TCP长连接断开。因此，我们需要通过心跳机制来保证App的活跃度，防止发生 NAT 超时。\n\n#### 4. 断开重连\n在线上运行时，长连接很有可能会由于网络切换之类的原因断开。这时，我们需要`尽快发现`长连接断开，并`立即重连`。一般有下面几种做法：\n- 创建Receiver，监控网络状态，如果网络发生切换则立即重连；\n- 监控服务端心跳包回包，如果连续5次没有收到回包，则认为长连接已经失效；\n- 设置心跳包超时限制，如果超过时间还没有收到心跳回包，则重连，这种方式比较耗电；\n- 等socket IO异常抛出，不过耗时太长，需要15s左右才能发现。\n\n![](https://diycode.b0.upaiyun.com/photo/2018/5a11a944950af332e46829a071bf8cc6.png)\n\n## V. Mars智能心跳机制\n### 1. 固定心跳机制\n上面我们说了，心跳机制主要是为了防止 NAT 超时，外网IP地址失效。因此，一般的做法就是在NAT失效前，保证有心跳包发出。或者说，客户端应当以略小于NAT超时时间的间隔来发送心跳包。\n\n![NAT超时时间](https://diycode.b0.upaiyun.com/photo/2018/3f79b7910c7d811c43344652a30ef63b.png)\n\n早期的微信的心跳是4.5分钟发送一次心跳，可以不错的运行。\n\n### 2. Mars智能心跳策略\n在尽量不影响用户收消息及时性的前提下，根据网络类型自适应的找出保活信令TCP连接的尽可能大的心跳间隔，从而达到减少安卓微信因心跳引起的空中信道资源消耗，减少心跳Server的负载，以及减少部分因心跳引起的耗电。\n\n##### 自适应心跳\n因此，在固定心跳机制下，微信又研究了一套动态计算心跳的方案，动态的探测最大的NAT超时时间，然后选定合适的心跳间隔区间去发送心跳包。这里说一下大致思路：\n\n首先，如果心跳间隔越久，产生的负载和消耗也会越小。因此微信采用了`自适应心跳`：当找到一个有效心跳间隔后，我们主动去加大这个间隔，然后测试是否能成功，如果不能，则使用比上一次成功间隔稍短的时间作为间隔；否则继续加大间隔，直到找到可用的有效间隔。\n\n那么，如何判断一个心跳间隔有效呢？微信采用的方案是使用固定短心跳直到满足三次连续短心跳成功，则认为这个间隔有效。\n\n探测过程大致为：60秒短心跳，连续发3次后开始探测，90，120，150，180，210，240，270\n\n##### 前后台策略\n另外，考虑到App在前后台对于长连接的需求是不同的。因此当微信在前台活跃态时，采用了`固定心跳`机制；在前台熄屏态或者后台活跃态（进入后台10分钟内）时，先用几次最小心跳维持长连接，然后进入`自适应心跳`机制；在后台稳定态（超过10分钟），则采用自适应心跳计算出来的最大心跳作为固定值。\n\n如果在运行过程中，发生了心跳失败，则进行重连。同时将心跳间隔调整为断线前间隔减去20s，重新走自适应心跳；如果连续5次均失败，则以初始心跳180s继续测试。\n\n##### Alarm对齐策略\n对于Android系统而言，为了减少频繁唤醒系统导致的电量损耗，提供了`Alarm对齐唤醒`机制：把一定时间段内的多次Alarm唤醒合并成一次，减少系统被唤醒次数，增加待机时间。\n\n而我们的心跳包就是需要在定时结束后自动触发一次心跳包的发送，因此，在Mars里面的心跳时间也是按照Alarm对齐时间来做心跳间隔，减少电量损耗。\n\n##### 其他\n对于微信心跳策略感兴趣的话可以阅读文末的参考文献，代码可以参考[smart_heartbeat](https://github.com/Tencent/mars/blob/master/mars/stn/src/smart_heartbeat.cc)。\n\n## VI. 长连接数据协议及加密\n长连接传递的是二进制数据，前后端可以自行协商每个字节要存放的内容即可。当然，也可以考虑采用一些通用协议：比如SMTP、ProtoBuf等序列化方案。\n\n参考文章：[《一个基于TCP/WebSockets的超级精简的长连接消息协议》](https://www.jianshu.com/p/42bfb79b0d39?utm_campaign=studygolang.com&utm_medium=studygolang.com&utm_source=studygolang.com).\n\n另外，在数据加密方面，可以结合非对称加密算法RSA和对称加密算法AES来对数据进行加密传输。\n\n这一点不是本文的重点，不做过多赘述。\n\n## VII. 长连接通道建设及容灾\n上面讲了长连接的优势，那我们该如何搭建整个长连接通道呢？这里我们以美团的长连接通道为例子进行说明，各大厂的方案也是类似的。\n![美团长连通道](https://diycode.b0.upaiyun.com/photo/2018/5e97a86e0a4286a4398510ed77c38b1a.png)\n上面是一个简图，大体流程如下：\n\n1. 客户端与代理长连服务器建立长连接，代理服务器可全国多地部署，在建立长连时可以选择最近的服务器IP就近接入；\n2. 长连接建立好后，客户端对要发送的二进制数据进行加密并传输；\n3. 代理服务器收到后，可以通过内部专线或普通Http请求来访问业务服务器；\n4. 如果长连接出现问题导致不可用，为保障客户端运行，需要立即降级成普通Http短连或者UDP通道。\n\n\n## 小结\n本文结合了国内大厂如腾讯、美团等长连接框架，针对长连接这个技术点做了完整的介绍和剖析，如有不对或疑问，欢迎留言。\n\n---\n谢谢。\nwingjay\n\n---\n### 《亿级Android架构》小专栏介绍\n业务的快速增长离不开稳定可靠的架构。[《亿级Android架构》](https://xiaozhuanlan.com/AndroidArch)小专栏会基于作者实际工作经验，结合国内大厂如阿里、腾讯、美团等基础架构现状，尝试谈谈如何设计一套好的架构来支持业务从0到1，甚至到亿，希望与大家多多探讨。\n\n本专栏主要内容：\n1. 当前大厂有哪些Android架构；\n2. 这些架构能解决什么问题；\n3. 这些架构的原理是什么；\n4. 学习这些架构对我们自身的意义。\n\n**[《亿级Android架构》](https://xiaozhuanlan.com/AndroidArch)小专栏文章列表：**\n\n[《亿级 Android 架构》专栏随谈》](https://xiaozhuanlan.com/topic/1934527806)\n\n[《Android 架构之网络连接与加速》](https://xiaozhuanlan.com/topic/6982074351)\n\n[《Android 架构之长连接技术》](https://xiaozhuanlan.com/topic/3758142906)\n\n[《Android 架构之高可用移动网络连接》](https://xiaozhuanlan.com/topic/2130768549)\n\n[《Android 架构之网络安全演进》](https://xiaozhuanlan.com/topic/8159302674)\n\n[《Android 架构之高性能移动端日志系统》](https://xiaozhuanlan.com/topic/2694081375)\n\n---\n \n## 参考：\n[《移动端IM实践：实现Android版微信的智能心跳机制》](http://www.52im.net/thread-120-1-1.html)\n[《Android端消息推送总结：实现原理、心跳保活、遇到的问题等》](http://www.52im.net/thread-341-1-1.html)\n[《美团点评移动网络优化实践](https://tech.meituan.com/Shark_SDK.html)\n[《Android版微信后台保活实战分享(网络保活篇)》](http://www.52im.net/thread-209-1-1.html)\n[《移动 APP 网络优化概述》](https://blog.cnbang.net/tech/3531/)\n[《高效 保活长连接：手把手教你实现 自适应的心跳保活机制》](https://blog.csdn.net/carson_ho/article/details/79522975)\n[《一种Android端IM智能心跳算法的设计与实现探讨》](http://www.52im.net/thread-783-1-1.html)\n[《HTTP长连接说明》](https://cloud.tencent.com/document/product/214/4149)\n[《TCP 进阶》](https://halfrost.com/advance_tcp/)\n","source":"_posts/Android-架构之长连接技术.md","raw":"title: Android架构之长连接技术\ndate: 2018-12-05 15:43:15\npermalink: android-arch-long-link\ncategories:\n  - Android\n  - 亿级Android架构\ntags:\n\t- Android\n\t- 架构\n\t- 长连接\n\t- 网络\ncommentIssueId: 32\n---\n\n上一篇文章[《Android 架构之网络框架（上）》](https://xiaozhuanlan.com/topic/6982074351)中，我们谈过了网络框架OkHttp、网络加速方案如HttpDNS、数据压缩与序列化等技术点。本文我们结合[腾讯Mars框架](https://github.com/Tencent/mars)和[美团Shark体系](https://tech.meituan.com/Shark_SDK.html)等业内主流长连接方案，谈一谈长连接技术的各个方面。\n\n本文会包括下面的技术点：\n- 长连接与Http短连接、Keep-Alive傻傻分不清\n- 你为什么需要长连接\n- 长连接何时会断开\n- 如何建立稳定长连接\n- Mars智能心跳机制\n- 长连接数据协议及加密\n- 长连接通道建设及容灾\n\n<!-- more -->\n\n除了大家常用的Http短连接，大型App几乎都会搭建一套完整的`TCP长连接`网络通道。我们先来看下`美团Shark长连接`的线上数据：\n![](https://diycode.b0.upaiyun.com/photo/2018/4b0801aef3c69c00d38d1cc688bf13ba.png)\n![](https://diycode.b0.upaiyun.com/photo/2018/e8055c916f15c34aa03f6d230235841b.png)\n> 图片来源 《[美团点评移动网络优化实践](https://tech.meituan.com/Shark_SDK.html)》\n\n上面两张图片对比了长/短连接的成功率和网络延时数据，这两个是网络模块最重要的衡量指标。可以看出，无论是成功率，还是网络延时，长连接都明显优于短连接。\n\n另外，大家都知道微信的消息收发非常即时，这便归功于背后稳定高可用的长连接系统。实际上，微信除了消息收发，其他的小数据通信都是通过长连接来实现的。\n\n下面我们来讲解一些长连接的一些核心技术点。\n\n## I. 长连接与Http短连接、Keep-Alive傻傻分不清\n\n为防止大家对于长连接和短连接混淆，这里先简单说明下几点区别。\n\n### 长连接 vs Http短连接\n这两者分别对应的是`TCP协议层`的`长连接`和`短连接`。\n\n大家都知道，TCP会通过三次握手，建立与服务端的连接，然后传递数据，只不过`短连接`在数据传输完后，会主动关闭连接，而`长连接`会继续保持这条连接，后续的数据读写继续使用这条连接。\n\n### 长连接 vs Http的`Keep-Alive`\n上一篇文章中提到了`连接复用`，通过Http1.1的`Keep Alive`字段，我们可以让一条Http连接保持不被立即关闭。有些同学这时就疑惑了，是不是长连接就是`Keep Alive`呢？\n\n其实不是的。长连接我们也叫`TCP长连接`，它是架设在TCP协议上的，而上面说的`Keep Alive`是Http协议的内容，连协议都不同，两者自然不是一个东西。\n\n开启了`Keep Alive`是Http连接，我们也称之为`持久连接`，和长连接并不同。感兴趣可参考此文：[《TCP 进阶》](https://halfrost.com/advance_tcp/)。\n\n### TCP的`Keep-Alive` vs Http的`Keep-Alive`\n提到`Keep Alive`，有些同学就会问了，TCP协议里也有一个`Keep Alive`，它和Http协议里的`Keep Alive`有什么区别吗？\n\n二者的用处并不同。Http协议在完成一个请求后，服务器会自动关闭连接。这时，可以在请求里带上一个`Keep Alive`给服务器，告诉`服务器不要立即关闭连接`，我还想继续复用这条连接；而对TCP协议层而言，是不会自动断开的，但这也带来了一个问题，万一由于某些外部原因导致连接断开，那我如何知道连接已失效呢？TCP会在2个小时间隔后，自动发送一个`Keep Alive`数据包给服务端，探测一下服务器是否还在响应。它的功能类似心跳包，只是间隔太长，不适合做真正的心跳包。\n\n![](https://diycode.b0.upaiyun.com/photo/2018/a24b4b22bdeeb950ab05af01086a44e2.png)\n\n## II. 你为什么需要长连接\n那么，相比Http短连接，长连接技术能带来什么好处呢？\n#### 1. 不同域名的请求可以复用同一个长连接通道\n以前我们不同域名的请求，需要做对应的DNS请求，然后建立对应的Http连接。上篇文章里说的`Http连接池`在不同域名下不可复用，需要重新建立连接。这些都是一些资源开销，但是如果通过长连接通道，那域名只是这个请求里的一个字段，可以直接复用同一条长连接通道。\n#### 2. 不依赖DNS，无DNS耗时和劫持等问题\n上文中我们提到了`HttpDNS`，虽然它比系统DNS更优，但终归还是要做DNS操作。而长连接都是IP直接连接，因此没有DNS相关的开销和耗时。\n#### 3. 如果有大量网络请求，可以明显减少网络延时，节省带宽\n对于大型App而言，存在繁多密集的网络请求，这中间就会存在非常多次的Http断开和重新连接，浪费了很多时间和带宽。而通过长连接通道的话，则没有这部分耗时，直接传输二进制数据即可，节省了每次连接里Header之类的带宽开销。\n#### 4. 服务端主动Push数据到客户端\n对于上面提到的微信消息接收等场景，如果需要客户端主动去轮询，则会频繁发起请求，对于服务器会产生很大的负载压力，浪费带宽流量。而通过长连接，服务端可以主动把消息下发给客户端，做到最高实时性，且节省流量。\n\n![](https://diycode.b0.upaiyun.com/photo/2018/9d3fe531208dfad25637fff33b358972.jpeg)\n## III. 长连接何时会断开？\n正常而言，长连接是不会断开的。大家可以自己试一试，两个socket建立连接，只要网络不变、一切正常，那么这两个socket可以一直互相传送数据，不会断开。\n\n但是，在移动网络下，网络状态复杂多变，比如网络线路被切断、服务器宕机等，都会导致长连接中断。除了这些线路异常外，我们需要关注下面几个长连接断开原因：\n#### 1. 长连接所在进程被杀\n这个很容易理解，如果我们的App切换到后台，那么系统随时可能将我们的App杀掉，这时长连接自然也就随之断开。\n#### 2. 用户切换网络\n比如手机网络断开，或者发生Wi-Fi和蜂窝数据切换，这时会导致手机IP地址变更。而我们知道，TCP连接是基于IP + Port的，一旦IP变更，TCP连接自然也就失效了，或者说长连接也就相当于断开了。\n#### 3. 系统休眠等导致NAT超时\n这里对NAT简单解释下，方便有的同学不太了解。当手机连接上网络时，网关会给我们分配一个IP地址，这个其实是内网IP，此时还未真正连接上公网，也连接不上服务器；如果想要连接公网，需要运营商将我们的内网IP映射成一个公网IP，有了公网IP，服务器就能与我们建立连接了。NAT指的就是这个映射过程。\n\n也就是说，运营商会给每台设备分配一个公网IP，类似一张通信证。不过，随着连接网络的设备不断增多，网关负载也会不断加大，这时，运营商就会对一些不太活跃的设备进行公网IP回收了，如果下次这个设备需要连网，那就重新分配一个IP即可。\n\n看似没问题，但实际上，如果我们的App在一段时间不活跃，发生了NAT超时，便会导致我们的公网IP失效，长连接也随之失效了。\n#### 4. DHCP 租期\nDHCP 租期过期，如果没有及时续约，同样会导致IP地址失效。\n\n综合而言，长连接在正常情况下是不会断开的，但是，一旦手机的IP地址失效，这时就不得不重新建立连接了。\n\n## IV. 如何建立稳定长连接？\n上面我们提到了多种长连接断开的原因，那我们应该如何进行优化，尽可能保证长连接不断开，或者及时断开了，也要尽快重连呢？\n#### 1. Mars长连接独立进程\n为了减少进程被杀的几率，在Mars的[Demo代码](https://github.com/Tencent/mars/blob/master/samples/android/marsSampleChat/app/src/main/java/com/tencent/mars/sample/SampleApplicaton.java)里我们可以看到，它将长连接逻辑单独提取到了一个独立的进程里。这个进程只做网络交互，消耗的内存等资源自然较少，从而减少了被系统回收的概率。\n![](https://diycode.b0.upaiyun.com/photo/2018/02ee70621e61e774ca31203025592d71.png)\n> 图片来自[《Android版微信后台保活实战分享(进程保活篇)》](http://www.52im.net/thread-210-1-1.html)\n\n#### 2. 长连接进程复活\n进程被杀难以避免，不过可以通过AlarmReceiver、 ConnectReceiver、BootReceiver，达到进程的及时唤醒。\n\n当然，进程保活是一个比较大的话题，而且不恰当的进程保活也会对系统体验造成危害。这里就不深究了。\n\n#### 3. 心跳机制\n对于心跳包很多人误以为只是用来定期告诉服务端我们的状态，实际并非如此。\n\n上面我们提到了 NAT 超时，即如果App一段时间内不活跃，会导致运营商那里删除我们的公网IP映射关系，这会导致我们的TCP长连接断开。因此，我们需要通过心跳机制来保证App的活跃度，防止发生 NAT 超时。\n\n#### 4. 断开重连\n在线上运行时，长连接很有可能会由于网络切换之类的原因断开。这时，我们需要`尽快发现`长连接断开，并`立即重连`。一般有下面几种做法：\n- 创建Receiver，监控网络状态，如果网络发生切换则立即重连；\n- 监控服务端心跳包回包，如果连续5次没有收到回包，则认为长连接已经失效；\n- 设置心跳包超时限制，如果超过时间还没有收到心跳回包，则重连，这种方式比较耗电；\n- 等socket IO异常抛出，不过耗时太长，需要15s左右才能发现。\n\n![](https://diycode.b0.upaiyun.com/photo/2018/5a11a944950af332e46829a071bf8cc6.png)\n\n## V. Mars智能心跳机制\n### 1. 固定心跳机制\n上面我们说了，心跳机制主要是为了防止 NAT 超时，外网IP地址失效。因此，一般的做法就是在NAT失效前，保证有心跳包发出。或者说，客户端应当以略小于NAT超时时间的间隔来发送心跳包。\n\n![NAT超时时间](https://diycode.b0.upaiyun.com/photo/2018/3f79b7910c7d811c43344652a30ef63b.png)\n\n早期的微信的心跳是4.5分钟发送一次心跳，可以不错的运行。\n\n### 2. Mars智能心跳策略\n在尽量不影响用户收消息及时性的前提下，根据网络类型自适应的找出保活信令TCP连接的尽可能大的心跳间隔，从而达到减少安卓微信因心跳引起的空中信道资源消耗，减少心跳Server的负载，以及减少部分因心跳引起的耗电。\n\n##### 自适应心跳\n因此，在固定心跳机制下，微信又研究了一套动态计算心跳的方案，动态的探测最大的NAT超时时间，然后选定合适的心跳间隔区间去发送心跳包。这里说一下大致思路：\n\n首先，如果心跳间隔越久，产生的负载和消耗也会越小。因此微信采用了`自适应心跳`：当找到一个有效心跳间隔后，我们主动去加大这个间隔，然后测试是否能成功，如果不能，则使用比上一次成功间隔稍短的时间作为间隔；否则继续加大间隔，直到找到可用的有效间隔。\n\n那么，如何判断一个心跳间隔有效呢？微信采用的方案是使用固定短心跳直到满足三次连续短心跳成功，则认为这个间隔有效。\n\n探测过程大致为：60秒短心跳，连续发3次后开始探测，90，120，150，180，210，240，270\n\n##### 前后台策略\n另外，考虑到App在前后台对于长连接的需求是不同的。因此当微信在前台活跃态时，采用了`固定心跳`机制；在前台熄屏态或者后台活跃态（进入后台10分钟内）时，先用几次最小心跳维持长连接，然后进入`自适应心跳`机制；在后台稳定态（超过10分钟），则采用自适应心跳计算出来的最大心跳作为固定值。\n\n如果在运行过程中，发生了心跳失败，则进行重连。同时将心跳间隔调整为断线前间隔减去20s，重新走自适应心跳；如果连续5次均失败，则以初始心跳180s继续测试。\n\n##### Alarm对齐策略\n对于Android系统而言，为了减少频繁唤醒系统导致的电量损耗，提供了`Alarm对齐唤醒`机制：把一定时间段内的多次Alarm唤醒合并成一次，减少系统被唤醒次数，增加待机时间。\n\n而我们的心跳包就是需要在定时结束后自动触发一次心跳包的发送，因此，在Mars里面的心跳时间也是按照Alarm对齐时间来做心跳间隔，减少电量损耗。\n\n##### 其他\n对于微信心跳策略感兴趣的话可以阅读文末的参考文献，代码可以参考[smart_heartbeat](https://github.com/Tencent/mars/blob/master/mars/stn/src/smart_heartbeat.cc)。\n\n## VI. 长连接数据协议及加密\n长连接传递的是二进制数据，前后端可以自行协商每个字节要存放的内容即可。当然，也可以考虑采用一些通用协议：比如SMTP、ProtoBuf等序列化方案。\n\n参考文章：[《一个基于TCP/WebSockets的超级精简的长连接消息协议》](https://www.jianshu.com/p/42bfb79b0d39?utm_campaign=studygolang.com&utm_medium=studygolang.com&utm_source=studygolang.com).\n\n另外，在数据加密方面，可以结合非对称加密算法RSA和对称加密算法AES来对数据进行加密传输。\n\n这一点不是本文的重点，不做过多赘述。\n\n## VII. 长连接通道建设及容灾\n上面讲了长连接的优势，那我们该如何搭建整个长连接通道呢？这里我们以美团的长连接通道为例子进行说明，各大厂的方案也是类似的。\n![美团长连通道](https://diycode.b0.upaiyun.com/photo/2018/5e97a86e0a4286a4398510ed77c38b1a.png)\n上面是一个简图，大体流程如下：\n\n1. 客户端与代理长连服务器建立长连接，代理服务器可全国多地部署，在建立长连时可以选择最近的服务器IP就近接入；\n2. 长连接建立好后，客户端对要发送的二进制数据进行加密并传输；\n3. 代理服务器收到后，可以通过内部专线或普通Http请求来访问业务服务器；\n4. 如果长连接出现问题导致不可用，为保障客户端运行，需要立即降级成普通Http短连或者UDP通道。\n\n\n## 小结\n本文结合了国内大厂如腾讯、美团等长连接框架，针对长连接这个技术点做了完整的介绍和剖析，如有不对或疑问，欢迎留言。\n\n---\n谢谢。\nwingjay\n\n---\n### 《亿级Android架构》小专栏介绍\n业务的快速增长离不开稳定可靠的架构。[《亿级Android架构》](https://xiaozhuanlan.com/AndroidArch)小专栏会基于作者实际工作经验，结合国内大厂如阿里、腾讯、美团等基础架构现状，尝试谈谈如何设计一套好的架构来支持业务从0到1，甚至到亿，希望与大家多多探讨。\n\n本专栏主要内容：\n1. 当前大厂有哪些Android架构；\n2. 这些架构能解决什么问题；\n3. 这些架构的原理是什么；\n4. 学习这些架构对我们自身的意义。\n\n**[《亿级Android架构》](https://xiaozhuanlan.com/AndroidArch)小专栏文章列表：**\n\n[《亿级 Android 架构》专栏随谈》](https://xiaozhuanlan.com/topic/1934527806)\n\n[《Android 架构之网络连接与加速》](https://xiaozhuanlan.com/topic/6982074351)\n\n[《Android 架构之长连接技术》](https://xiaozhuanlan.com/topic/3758142906)\n\n[《Android 架构之高可用移动网络连接》](https://xiaozhuanlan.com/topic/2130768549)\n\n[《Android 架构之网络安全演进》](https://xiaozhuanlan.com/topic/8159302674)\n\n[《Android 架构之高性能移动端日志系统》](https://xiaozhuanlan.com/topic/2694081375)\n\n---\n \n## 参考：\n[《移动端IM实践：实现Android版微信的智能心跳机制》](http://www.52im.net/thread-120-1-1.html)\n[《Android端消息推送总结：实现原理、心跳保活、遇到的问题等》](http://www.52im.net/thread-341-1-1.html)\n[《美团点评移动网络优化实践](https://tech.meituan.com/Shark_SDK.html)\n[《Android版微信后台保活实战分享(网络保活篇)》](http://www.52im.net/thread-209-1-1.html)\n[《移动 APP 网络优化概述》](https://blog.cnbang.net/tech/3531/)\n[《高效 保活长连接：手把手教你实现 自适应的心跳保活机制》](https://blog.csdn.net/carson_ho/article/details/79522975)\n[《一种Android端IM智能心跳算法的设计与实现探讨》](http://www.52im.net/thread-783-1-1.html)\n[《HTTP长连接说明》](https://cloud.tencent.com/document/product/214/4149)\n[《TCP 进阶》](https://halfrost.com/advance_tcp/)\n","slug":"android-arch-long-link","published":1,"updated":"2019-01-16T03:42:50.850Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplsji005g3dn8vpi8szl4","content":"<p>上一篇文章 <a href=\"https://xiaozhuanlan.com/topic/6982074351\" target=\"_blank\" rel=\"external\">《Android 架构之网络框架（上）》</a> 中，我们谈过了网络框架 OkHttp、网络加速方案如 HttpDNS、数据压缩与序列化等技术点。本文我们结合 <a href=\"https://github.com/Tencent/mars\" target=\"_blank\" rel=\"external\"> 腾讯 Mars 框架 </a> 和<a href=\"https://tech.meituan.com/Shark_SDK.html\" target=\"_blank\" rel=\"external\">美团 Shark 体系 </a> 等业内主流长连接方案，谈一谈长连接技术的各个方面。</p>\n<p>本文会包括下面的技术点：</p>\n<ul>\n<li>长连接与 Http 短连接、Keep-Alive 傻傻分不清</li>\n<li>你为什么需要长连接</li>\n<li>长连接何时会断开</li>\n<li>如何建立稳定长连接</li>\n<li>Mars 智能心跳机制</li>\n<li>长连接数据协议及加密</li>\n<li>长连接通道建设及容灾</li>\n</ul>\n<a id=\"more\"></a>\n<p>除了大家常用的 Http 短连接，大型 App 几乎都会搭建一套完整的 <code>TCP 长连接</code> 网络通道。我们先来看下 <code> 美团 Shark 长连接 </code> 的线上数据：<br><img src=\"https://diycode.b0.upaiyun.com/photo/2018/4b0801aef3c69c00d38d1cc688bf13ba.png\" alt=\"\"><br><img src=\"https://diycode.b0.upaiyun.com/photo/2018/e8055c916f15c34aa03f6d230235841b.png\"alt=\"\"></p>\n<blockquote>\n<p>图片来源 《<a href=\"https://tech.meituan.com/Shark_SDK.html\" target=\"_blank\" rel=\"external\">美团点评移动网络优化实践</a>》</p>\n</blockquote>\n<p>上面两张图片对比了长 / 短连接的成功率和网络延时数据，这两个是网络模块最重要的衡量指标。可以看出，无论是成功率，还是网络延时，长连接都明显优于短连接。</p>\n<p>另外，大家都知道微信的消息收发非常即时，这便归功于背后稳定高可用的长连接系统。实际上，微信除了消息收发，其他的小数据通信都是通过长连接来实现的。</p>\n<p>下面我们来讲解一些长连接的一些核心技术点。</p>\n<h2 id=\"I- 长连接与 Http 短连接、Keep-Alive 傻傻分不清\"><a href=\"#I- 长连接与 Http 短连接、Keep-Alive 傻傻分不清\" class=\"headerlink\" title=\"I. 长连接与 Http 短连接、Keep-Alive 傻傻分不清\"></a>I. 长连接与 Http 短连接、Keep-Alive 傻傻分不清 </h2><p> 为防止大家对于长连接和短连接混淆，这里先简单说明下几点区别。</p>\n<h3 id=\"长连接 -vs-Http 短连接\"><a href=\"# 长连接 -vs-Http 短连接\" class=\"headerlink\" title=\"长连接 vs Http 短连接\"></a>长连接 vs Http 短连接 </h3><p> 这两者分别对应的是 <code>TCP 协议层</code> 的<code>长连接 </code> 和<code>短连接</code>。</p>\n<p>大家都知道，TCP 会通过三次握手，建立与服务端的连接，然后传递数据，只不过 <code> 短连接 </code> 在数据传输完后，会主动关闭连接，而 <code> 长连接 </code> 会继续保持这条连接，后续的数据读写继续使用这条连接。</p>\n<h3 id=\"长连接 -vs-Http 的 Keep-Alive\"><a href=\"# 长连接 -vs-Http 的 Keep-Alive\" class=\"headerlink\" title=\"长连接 vs Http 的 Keep-Alive\"></a>长连接 vs Http 的 <code>Keep-Alive</code></h3><p> 上一篇文章中提到了 <code> 连接复用 </code>，通过 Http1.1 的<code>Keep Alive</code> 字段，我们可以让一条 Http 连接保持不被立即关闭。有些同学这时就疑惑了，是不是长连接就是 <code>Keep Alive</code> 呢？</p>\n<p>其实不是的。长连接我们也叫 <code>TCP 长连接</code>，它是架设在 TCP 协议上的，而上面说的<code>Keep Alive</code> 是 Http 协议的内容，连协议都不同，两者自然不是一个东西。</p>\n<p>开启了 <code>Keep Alive</code> 是 Http 连接，我们也称之为 <code> 持久连接</code>，和长连接并不同。感兴趣可参考此文：<a href=\"https://halfrost.com/advance_tcp/\" target=\"_blank\" rel=\"external\">《TCP 进阶》</a>。</p>\n<h3 id=\"TCP 的 Keep-Alive-vs-Http 的 Keep-Alive\"><a href=\"#TCP 的 Keep-Alive-vs-Http 的 Keep-Alive\" class=\"headerlink\" title=\"TCP 的 Keep-Alive vs Http 的 Keep-Alive\"></a>TCP 的 <code>Keep-Alive</code> vs Http 的<code>Keep-Alive</code></h3><p> 提到 <code>Keep Alive</code>，有些同学就会问了，TCP 协议里也有一个<code>Keep Alive</code>，它和 Http 协议里的<code>Keep Alive</code> 有什么区别吗？</p>\n<p>二者的用处并不同。Http 协议在完成一个请求后，服务器会自动关闭连接。这时，可以在请求里带上一个 <code>Keep Alive</code> 给服务器，告诉 <code> 服务器不要立即关闭连接 </code>，我还想继续复用这条连接；而对 TCP 协议层而言，是不会自动断开的，但这也带来了一个问题，万一由于某些外部原因导致连接断开，那我如何知道连接已失效呢？TCP 会在 2 个小时间隔后，自动发送一个<code>Keep Alive</code> 数据包给服务端，探测一下服务器是否还在响应。它的功能类似心跳包，只是间隔太长，不适合做真正的心跳包。</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/a24b4b22bdeeb950ab05af01086a44e2.png\" alt=\"\"></p>\n<h2 id=\"II- 你为什么需要长连接\"><a href=\"#II- 你为什么需要长连接\" class=\"headerlink\" title=\"II. 你为什么需要长连接\"></a>II. 你为什么需要长连接 </h2><p> 那么，相比 Http 短连接，长连接技术能带来什么好处呢？</p>\n<h4 id=\"1- 不同域名的请求可以复用同一个长连接通道\"><a href=\"#1- 不同域名的请求可以复用同一个长连接通道\" class=\"headerlink\" title=\"1. 不同域名的请求可以复用同一个长连接通道\"></a>1. 不同域名的请求可以复用同一个长连接通道 </h4><p> 以前我们不同域名的请求，需要做对应的 DNS 请求，然后建立对应的 Http 连接。上篇文章里说的 <code>Http 连接池</code> 在不同域名下不可复用，需要重新建立连接。这些都是一些资源开销，但是如果通过长连接通道，那域名只是这个请求里的一个字段，可以直接复用同一条长连接通道。</p>\n<h4 id=\"2- 不依赖 DNS，无 DNS 耗时和劫持等问题\"><a href=\"#2- 不依赖 DNS，无 DNS 耗时和劫持等问题\" class=\"headerlink\" title=\"2. 不依赖 DNS，无 DNS 耗时和劫持等问题\"></a>2. 不依赖 DNS，无 DNS 耗时和劫持等问题 </h4><p> 上文中我们提到了<code>HttpDNS</code>，虽然它比系统 DNS 更优，但终归还是要做 DNS 操作。而长连接都是 IP 直接连接，因此没有 DNS 相关的开销和耗时。</p>\n<h4 id=\"3- 如果有大量网络请求，可以明显减少网络延时，节省带宽\"><a href=\"#3- 如果有大量网络请求，可以明显减少网络延时，节省带宽\" class=\"headerlink\" title=\"3. 如果有大量网络请求，可以明显减少网络延时，节省带宽\"></a>3. 如果有大量网络请求，可以明显减少网络延时，节省带宽 </h4><p> 对于大型 App 而言，存在繁多密集的网络请求，这中间就会存在非常多次的 Http 断开和重新连接，浪费了很多时间和带宽。而通过长连接通道的话，则没有这部分耗时，直接传输二进制数据即可，节省了每次连接里 Header 之类的带宽开销。</p>\n<h4 id=\"4- 服务端主动 Push 数据到客户端\"><a href=\"#4- 服务端主动 Push 数据到客户端\" class=\"headerlink\" title=\"4. 服务端主动 Push 数据到客户端\"></a>4. 服务端主动 Push 数据到客户端 </h4><p> 对于上面提到的微信消息接收等场景，如果需要客户端主动去轮询，则会频繁发起请求，对于服务器会产生很大的负载压力，浪费带宽流量。而通过长连接，服务端可以主动把消息下发给客户端，做到最高实时性，且节省流量。</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/9d3fe531208dfad25637fff33b358972.jpeg\" alt=\"\"></p>\n<h2 id=\"III- 长连接何时会断开？\"><a href=\"#III- 长连接何时会断开？\" class=\"headerlink\" title=\"III. 长连接何时会断开？\"></a>III. 长连接何时会断开？</h2><p>正常而言，长连接是不会断开的。大家可以自己试一试，两个 socket 建立连接，只要网络不变、一切正常，那么这两个 socket 可以一直互相传送数据，不会断开。</p>\n<p>但是，在移动网络下，网络状态复杂多变，比如网络线路被切断、服务器宕机等，都会导致长连接中断。除了这些线路异常外，我们需要关注下面几个长连接断开原因：</p>\n<h4 id=\"1- 长连接所在进程被杀\"><a href=\"#1- 长连接所在进程被杀\" class=\"headerlink\" title=\"1. 长连接所在进程被杀\"></a>1. 长连接所在进程被杀 </h4><p> 这个很容易理解，如果我们的 App 切换到后台，那么系统随时可能将我们的 App 杀掉，这时长连接自然也就随之断开。</p>\n<h4 id=\"2- 用户切换网络\"><a href=\"#2- 用户切换网络\" class=\"headerlink\" title=\"2. 用户切换网络\"></a>2. 用户切换网络 </h4><p> 比如手机网络断开，或者发生 Wi-Fi 和蜂窝数据切换，这时会导致手机 IP 地址变更。而我们知道，TCP 连接是基于 IP + Port 的，一旦 IP 变更，TCP 连接自然也就失效了，或者说长连接也就相当于断开了。</p>\n<h4 id=\"3- 系统休眠等导致 NAT 超时\"><a href=\"#3- 系统休眠等导致 NAT 超时\" class=\"headerlink\" title=\"3. 系统休眠等导致 NAT 超时\"></a>3. 系统休眠等导致 NAT 超时 </h4><p> 这里对 NAT 简单解释下，方便有的同学不太了解。当手机连接上网络时，网关会给我们分配一个 IP 地址，这个其实是内网 IP，此时还未真正连接上公网，也连接不上服务器；如果想要连接公网，需要运营商将我们的内网 IP 映射成一个公网 IP，有了公网 IP，服务器就能与我们建立连接了。NAT 指的就是这个映射过程。</p>\n<p>也就是说，运营商会给每台设备分配一个公网 IP，类似一张通信证。不过，随着连接网络的设备不断增多，网关负载也会不断加大，这时，运营商就会对一些不太活跃的设备进行公网 IP 回收了，如果下次这个设备需要连网，那就重新分配一个 IP 即可。</p>\n<p>看似没问题，但实际上，如果我们的 App 在一段时间不活跃，发生了 NAT 超时，便会导致我们的公网 IP 失效，长连接也随之失效了。</p>\n<h4 id=\"4-DHCP- 租期\"><a href=\"#4-DHCP- 租期\" class=\"headerlink\" title=\"4. DHCP 租期\"></a>4. DHCP 租期</h4><p>DHCP 租期过期，如果没有及时续约，同样会导致 IP 地址失效。</p>\n<p>综合而言，长连接在正常情况下是不会断开的，但是，一旦手机的 IP 地址失效，这时就不得不重新建立连接了。</p>\n<h2 id=\"IV- 如何建立稳定长连接？\"><a href=\"#IV- 如何建立稳定长连接？\" class=\"headerlink\" title=\"IV. 如何建立稳定长连接？\"></a>IV. 如何建立稳定长连接？</h2><p>上面我们提到了多种长连接断开的原因，那我们应该如何进行优化，尽可能保证长连接不断开，或者及时断开了，也要尽快重连呢？</p>\n<h4 id=\"1-Mars 长连接独立进程\"><a href=\"#1-Mars 长连接独立进程\" class=\"headerlink\" title=\"1. Mars 长连接独立进程\"></a>1. Mars 长连接独立进程 </h4><p> 为了减少进程被杀的几率，在 Mars 的 <a href=\"https://github.com/Tencent/mars/blob/master/samples/android/marsSampleChat/app/src/main/java/com/tencent/mars/sample/SampleApplicaton.java\" target=\"_blank\" rel=\"external\">Demo 代码</a> 里我们可以看到，它将长连接逻辑单独提取到了一个独立的进程里。这个进程只做网络交互，消耗的内存等资源自然较少，从而减少了被系统回收的概率。<br><img src=\"https://diycode.b0.upaiyun.com/photo/2018/02ee70621e61e774ca31203025592d71.png\" alt=\"\"></p>\n<blockquote>\n<p>图片来自<a href=\"http://www.52im.net/thread-210-1-1.html\" target=\"_blank\" rel=\"external\">《Android 版微信后台保活实战分享(进程保活篇)》</a></p>\n</blockquote>\n<h4 id=\"2- 长连接进程复活\"><a href=\"#2- 长连接进程复活\" class=\"headerlink\" title=\"2. 长连接进程复活\"></a>2. 长连接进程复活 </h4><p> 进程被杀难以避免，不过可以通过 AlarmReceiver、 ConnectReceiver、BootReceiver，达到进程的及时唤醒。</p>\n<p>当然，进程保活是一个比较大的话题，而且不恰当的进程保活也会对系统体验造成危害。这里就不深究了。</p>\n<h4 id=\"3- 心跳机制\"><a href=\"#3- 心跳机制\" class=\"headerlink\" title=\"3. 心跳机制\"></a>3. 心跳机制 </h4><p> 对于心跳包很多人误以为只是用来定期告诉服务端我们的状态，实际并非如此。</p>\n<p>上面我们提到了 NAT 超时，即如果 App 一段时间内不活跃，会导致运营商那里删除我们的公网 IP 映射关系，这会导致我们的 TCP 长连接断开。因此，我们需要通过心跳机制来保证 App 的活跃度，防止发生 NAT 超时。</p>\n<h4 id=\"4- 断开重连\"><a href=\"#4- 断开重连\" class=\"headerlink\" title=\"4. 断开重连\"></a>4. 断开重连 </h4><p> 在线上运行时，长连接很有可能会由于网络切换之类的原因断开。这时，我们需要 <code> 尽快发现 </code> 长连接断开，并 <code> 立即重连</code>。一般有下面几种做法：</p>\n<ul>\n<li>创建 Receiver，监控网络状态，如果网络发生切换则立即重连；</li>\n<li>监控服务端心跳包回包，如果连续 5 次没有收到回包，则认为长连接已经失效；</li>\n<li>设置心跳包超时限制，如果超过时间还没有收到心跳回包，则重连，这种方式比较耗电；</li>\n<li>等 socket IO 异常抛出，不过耗时太长，需要 15s 左右才能发现。</li>\n</ul>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/5a11a944950af332e46829a071bf8cc6.png\" alt=\"\"></p>\n<h2 id=\"V-Mars 智能心跳机制\"><a href=\"#V-Mars 智能心跳机制\" class=\"headerlink\" title=\"V. Mars 智能心跳机制\"></a>V. Mars 智能心跳机制 </h2><h3 id=\"1- 固定心跳机制\"><a href=\"#1- 固定心跳机制\" class=\"headerlink\" title=\"1. 固定心跳机制\"></a>1. 固定心跳机制</h3><p> 上面我们说了，心跳机制主要是为了防止 NAT 超时，外网 IP 地址失效。因此，一般的做法就是在 NAT 失效前，保证有心跳包发出。或者说，客户端应当以略小于 NAT 超时时间的间隔来发送心跳包。</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/3f79b7910c7d811c43344652a30ef63b.png\" alt=\"NAT 超时时间\"></p>\n<p>早期的微信的心跳是 4.5 分钟发送一次心跳，可以不错的运行。</p>\n<h3 id=\"2-Mars 智能心跳策略\"><a href=\"#2-Mars 智能心跳策略\" class=\"headerlink\" title=\"2. Mars 智能心跳策略\"></a>2. Mars 智能心跳策略 </h3><p> 在尽量不影响用户收消息及时性的前提下，根据网络类型自适应的找出保活信令 TCP 连接的尽可能大的心跳间隔，从而达到减少安卓微信因心跳引起的空中信道资源消耗，减少心跳 Server 的负载，以及减少部分因心跳引起的耗电。</p>\n<h5 id=\"自适应心跳\"><a href=\"# 自适应心跳\" class=\"headerlink\" title=\"自适应心跳\"></a>自适应心跳 </h5><p> 因此，在固定心跳机制下，微信又研究了一套动态计算心跳的方案，动态的探测最大的 NAT 超时时间，然后选定合适的心跳间隔区间去发送心跳包。这里说一下大致思路：</p>\n<p>首先，如果心跳间隔越久，产生的负载和消耗也会越小。因此微信采用了 <code> 自适应心跳</code>：当找到一个有效心跳间隔后，我们主动去加大这个间隔，然后测试是否能成功，如果不能，则使用比上一次成功间隔稍短的时间作为间隔；否则继续加大间隔，直到找到可用的有效间隔。</p>\n<p>那么，如何判断一个心跳间隔有效呢？微信采用的方案是使用固定短心跳直到满足三次连续短心跳成功，则认为这个间隔有效。</p>\n<p>探测过程大致为：60 秒短心跳，连续发 3 次后开始探测，90，120，150，180，210，240，270</p>\n<h5 id=\"前后台策略\"><a href=\"# 前后台策略\" class=\"headerlink\" title=\"前后台策略\"></a>前后台策略 </h5><p> 另外，考虑到 App 在前后台对于长连接的需求是不同的。因此当微信在前台活跃态时，采用了 <code> 固定心跳 </code> 机制；在前台熄屏态或者后台活跃态（进入后台 10 分钟内）时，先用几次最小心跳维持长连接，然后进入 <code> 自适应心跳 </code> 机制；在后台稳定态（超过 10 分钟），则采用自适应心跳计算出来的最大心跳作为固定值。</p>\n<p>如果在运行过程中，发生了心跳失败，则进行重连。同时将心跳间隔调整为断线前间隔减去 20s，重新走自适应心跳；如果连续 5 次均失败，则以初始心跳 180s 继续测试。</p>\n<h5 id=\"Alarm 对齐策略\"><a href=\"#Alarm 对齐策略\" class=\"headerlink\" title=\"Alarm 对齐策略\"></a>Alarm 对齐策略 </h5><p> 对于 Android 系统而言，为了减少频繁唤醒系统导致的电量损耗，提供了 <code>Alarm 对齐唤醒</code> 机制：把一定时间段内的多次 Alarm 唤醒合并成一次，减少系统被唤醒次数，增加待机时间。</p>\n<p>而我们的心跳包就是需要在定时结束后自动触发一次心跳包的发送，因此，在 Mars 里面的心跳时间也是按照 Alarm 对齐时间来做心跳间隔，减少电量损耗。</p>\n<h5 id=\"其他\"><a href=\"# 其他\" class=\"headerlink\" title=\"其他\"></a>其他 </h5><p> 对于微信心跳策略感兴趣的话可以阅读文末的参考文献，代码可以参考<a href=\"https://github.com/Tencent/mars/blob/master/mars/stn/src/smart_heartbeat.cc\" target=\"_blank\" rel=\"external\">smart_heartbeat</a>。</p>\n<h2 id=\"VI- 长连接数据协议及加密\"><a href=\"#VI- 长连接数据协议及加密\" class=\"headerlink\" title=\"VI. 长连接数据协议及加密\"></a>VI. 长连接数据协议及加密 </h2><p> 长连接传递的是二进制数据，前后端可以自行协商每个字节要存放的内容即可。当然，也可以考虑采用一些通用协议：比如 SMTP、ProtoBuf 等序列化方案。</p>\n<p>参考文章：<a href=\"https://www.jianshu.com/p/42bfb79b0d39?utm_campaign=studygolang.com&amp;utm_medium=studygolang.com&amp;utm_source=studygolang.com\" target=\"_blank\" rel=\"external\">《一个基于 TCP/WebSockets 的超级精简的长连接消息协议》</a>.</p>\n<p>另外，在数据加密方面，可以结合非对称加密算法 RSA 和对称加密算法 AES 来对数据进行加密传输。</p>\n<p>这一点不是本文的重点，不做过多赘述。</p>\n<h2 id=\"VII- 长连接通道建设及容灾\"><a href=\"#VII- 长连接通道建设及容灾\" class=\"headerlink\" title=\"VII. 长连接通道建设及容灾\"></a>VII. 长连接通道建设及容灾 </h2><p> 上面讲了长连接的优势，那我们该如何搭建整个长连接通道呢？这里我们以美团的长连接通道为例子进行说明，各大厂的方案也是类似的。<br><img src=\"https://diycode.b0.upaiyun.com/photo/2018/5e97a86e0a4286a4398510ed77c38b1a.png\" alt=\"美团长连通道\"><br>上面是一个简图，大体流程如下：</p>\n<ol>\n<li>客户端与代理长连服务器建立长连接，代理服务器可全国多地部署，在建立长连时可以选择最近的服务器 IP 就近接入；</li>\n<li>长连接建立好后，客户端对要发送的二进制数据进行加密并传输；</li>\n<li>代理服务器收到后，可以通过内部专线或普通 Http 请求来访问业务服务器；</li>\n<li>如果长连接出现问题导致不可用，为保障客户端运行，需要立即降级成普通 Http 短连或者 UDP 通道。</li>\n</ol>\n<h2 id=\"小结\"><a href=\"# 小结\" class=\"headerlink\" title=\"小结\"></a>小结 </h2><p> 本文结合了国内大厂如腾讯、美团等长连接框架，针对长连接这个技术点做了完整的介绍和剖析，如有不对或疑问，欢迎留言。</p>\n<hr>\n<p>谢谢。<br>wingjay</p>\n<hr>\n<h3 id=\"《亿级 Android 架构》小专栏介绍\"><a href=\"#《亿级 Android 架构》小专栏介绍\" class=\"headerlink\" title=\"《亿级 Android 架构》小专栏介绍\"></a>《亿级 Android 架构》小专栏介绍 </h3><p> 业务的快速增长离不开稳定可靠的架构。<a href=\"https://xiaozhuanlan.com/AndroidArch\" target=\"_blank\" rel=\"external\">《亿级 Android 架构》</a>小专栏会基于作者实际工作经验，结合国内大厂如阿里、腾讯、美团等基础架构现状，尝试谈谈如何设计一套好的架构来支持业务从 0 到 1，甚至到亿，希望与大家多多探讨。</p>\n<p>本专栏主要内容：</p>\n<ol>\n<li>当前大厂有哪些 Android 架构；</li>\n<li>这些架构能解决什么问题；</li>\n<li>这些架构的原理是什么；</li>\n<li>学习这些架构对我们自身的意义。</li>\n</ol>\n<p><strong><a href=\"https://xiaozhuanlan.com/AndroidArch\" target=\"_blank\" rel=\"external\">《亿级 Android 架构》</a>小专栏文章列表：</strong></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/1934527806\" target=\"_blank\" rel=\"external\">《亿级 Android 架构》专栏随谈》</a></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/6982074351\" target=\"_blank\" rel=\"external\">《Android 架构之网络连接与加速》</a></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/3758142906\" target=\"_blank\" rel=\"external\">《Android 架构之长连接技术》</a></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/2130768549\" target=\"_blank\" rel=\"external\">《Android 架构之高可用移动网络连接》</a></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/8159302674\" target=\"_blank\" rel=\"external\">《Android 架构之网络安全演进》</a></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/2694081375\" target=\"_blank\" rel=\"external\">《Android 架构之高性能移动端日志系统》</a></p>\n<hr>\n<h2 id=\"参考：\"><a href=\"# 参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h2><p><a href=\"http://www.52im.net/thread-120-1-1.html\" target=\"_blank\" rel=\"external\">《移动端 IM 实践：实现 Android 版微信的智能心跳机制》</a><br><a href=\"http://www.52im.net/thread-341-1-1.html\" target=\"_blank\" rel=\"external\">《Android 端消息推送总结：实现原理、心跳保活、遇到的问题等》</a><br><a href=\"https://tech.meituan.com/Shark_SDK.html\" target=\"_blank\" rel=\"external\">《美团点评移动网络优化实践</a><br><a href=\"http://www.52im.net/thread-209-1-1.html\" target=\"_blank\" rel=\"external\">《Android 版微信后台保活实战分享(网络保活篇)》</a><br><a href=\"https://blog.cnbang.net/tech/3531/\" target=\"_blank\" rel=\"external\">《移动 APP 网络优化概述》</a><br><a href=\"https://blog.csdn.net/carson_ho/article/details/79522975\" target=\"_blank\" rel=\"external\">《高效 保活长连接：手把手教你实现 自适应的心跳保活机制》</a><br><a href=\"http://www.52im.net/thread-783-1-1.html\" target=\"_blank\" rel=\"external\">《一种 Android 端 IM 智能心跳算法的设计与实现探讨》</a><br><a href=\"https://cloud.tencent.com/document/product/214/4149\" target=\"_blank\" rel=\"external\">《HTTP 长连接说明》</a><br><a href=\"https://halfrost.com/advance_tcp/\" target=\"_blank\" rel=\"external\">《TCP 进阶》</a></p>\n","site":{"data":{}},"excerpt":"<p>上一篇文章<a href=\"https://xiaozhuanlan.com/topic/6982074351\" target=\"_blank\" rel=\"external\">《Android 架构之网络框架（上）》</a>中，我们谈过了网络框架OkHttp、网络加速方案如HttpDNS、数据压缩与序列化等技术点。本文我们结合<a href=\"https://github.com/Tencent/mars\" target=\"_blank\" rel=\"external\">腾讯Mars框架</a>和<a href=\"https://tech.meituan.com/Shark_SDK.html\" target=\"_blank\" rel=\"external\">美团Shark体系</a>等业内主流长连接方案，谈一谈长连接技术的各个方面。</p>\n<p>本文会包括下面的技术点：</p>\n<ul>\n<li>长连接与Http短连接、Keep-Alive傻傻分不清</li>\n<li>你为什么需要长连接</li>\n<li>长连接何时会断开</li>\n<li>如何建立稳定长连接</li>\n<li>Mars智能心跳机制</li>\n<li>长连接数据协议及加密</li>\n<li>长连接通道建设及容灾</li>\n</ul>","more":"<p>除了大家常用的Http短连接，大型App几乎都会搭建一套完整的<code>TCP长连接</code>网络通道。我们先来看下<code>美团Shark长连接</code>的线上数据：<br><img src=\"https://diycode.b0.upaiyun.com/photo/2018/4b0801aef3c69c00d38d1cc688bf13ba.png\" alt=\"\"><br><img src=\"https://diycode.b0.upaiyun.com/photo/2018/e8055c916f15c34aa03f6d230235841b.png\" alt=\"\"></p>\n<blockquote>\n<p>图片来源 《<a href=\"https://tech.meituan.com/Shark_SDK.html\" target=\"_blank\" rel=\"external\">美团点评移动网络优化实践</a>》</p>\n</blockquote>\n<p>上面两张图片对比了长/短连接的成功率和网络延时数据，这两个是网络模块最重要的衡量指标。可以看出，无论是成功率，还是网络延时，长连接都明显优于短连接。</p>\n<p>另外，大家都知道微信的消息收发非常即时，这便归功于背后稳定高可用的长连接系统。实际上，微信除了消息收发，其他的小数据通信都是通过长连接来实现的。</p>\n<p>下面我们来讲解一些长连接的一些核心技术点。</p>\n<h2 id=\"I-长连接与Http短连接、Keep-Alive傻傻分不清\"><a href=\"#I-长连接与Http短连接、Keep-Alive傻傻分不清\" class=\"headerlink\" title=\"I. 长连接与Http短连接、Keep-Alive傻傻分不清\"></a>I. 长连接与Http短连接、Keep-Alive傻傻分不清</h2><p>为防止大家对于长连接和短连接混淆，这里先简单说明下几点区别。</p>\n<h3 id=\"长连接-vs-Http短连接\"><a href=\"#长连接-vs-Http短连接\" class=\"headerlink\" title=\"长连接 vs Http短连接\"></a>长连接 vs Http短连接</h3><p>这两者分别对应的是<code>TCP协议层</code>的<code>长连接</code>和<code>短连接</code>。</p>\n<p>大家都知道，TCP会通过三次握手，建立与服务端的连接，然后传递数据，只不过<code>短连接</code>在数据传输完后，会主动关闭连接，而<code>长连接</code>会继续保持这条连接，后续的数据读写继续使用这条连接。</p>\n<h3 id=\"长连接-vs-Http的Keep-Alive\"><a href=\"#长连接-vs-Http的Keep-Alive\" class=\"headerlink\" title=\"长连接 vs Http的Keep-Alive\"></a>长连接 vs Http的<code>Keep-Alive</code></h3><p>上一篇文章中提到了<code>连接复用</code>，通过Http1.1的<code>Keep Alive</code>字段，我们可以让一条Http连接保持不被立即关闭。有些同学这时就疑惑了，是不是长连接就是<code>Keep Alive</code>呢？</p>\n<p>其实不是的。长连接我们也叫<code>TCP长连接</code>，它是架设在TCP协议上的，而上面说的<code>Keep Alive</code>是Http协议的内容，连协议都不同，两者自然不是一个东西。</p>\n<p>开启了<code>Keep Alive</code>是Http连接，我们也称之为<code>持久连接</code>，和长连接并不同。感兴趣可参考此文：<a href=\"https://halfrost.com/advance_tcp/\" target=\"_blank\" rel=\"external\">《TCP 进阶》</a>。</p>\n<h3 id=\"TCP的Keep-Alive-vs-Http的Keep-Alive\"><a href=\"#TCP的Keep-Alive-vs-Http的Keep-Alive\" class=\"headerlink\" title=\"TCP的Keep-Alive vs Http的Keep-Alive\"></a>TCP的<code>Keep-Alive</code> vs Http的<code>Keep-Alive</code></h3><p>提到<code>Keep Alive</code>，有些同学就会问了，TCP协议里也有一个<code>Keep Alive</code>，它和Http协议里的<code>Keep Alive</code>有什么区别吗？</p>\n<p>二者的用处并不同。Http协议在完成一个请求后，服务器会自动关闭连接。这时，可以在请求里带上一个<code>Keep Alive</code>给服务器，告诉<code>服务器不要立即关闭连接</code>，我还想继续复用这条连接；而对TCP协议层而言，是不会自动断开的，但这也带来了一个问题，万一由于某些外部原因导致连接断开，那我如何知道连接已失效呢？TCP会在2个小时间隔后，自动发送一个<code>Keep Alive</code>数据包给服务端，探测一下服务器是否还在响应。它的功能类似心跳包，只是间隔太长，不适合做真正的心跳包。</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/a24b4b22bdeeb950ab05af01086a44e2.png\" alt=\"\"></p>\n<h2 id=\"II-你为什么需要长连接\"><a href=\"#II-你为什么需要长连接\" class=\"headerlink\" title=\"II. 你为什么需要长连接\"></a>II. 你为什么需要长连接</h2><p>那么，相比Http短连接，长连接技术能带来什么好处呢？</p>\n<h4 id=\"1-不同域名的请求可以复用同一个长连接通道\"><a href=\"#1-不同域名的请求可以复用同一个长连接通道\" class=\"headerlink\" title=\"1. 不同域名的请求可以复用同一个长连接通道\"></a>1. 不同域名的请求可以复用同一个长连接通道</h4><p>以前我们不同域名的请求，需要做对应的DNS请求，然后建立对应的Http连接。上篇文章里说的<code>Http连接池</code>在不同域名下不可复用，需要重新建立连接。这些都是一些资源开销，但是如果通过长连接通道，那域名只是这个请求里的一个字段，可以直接复用同一条长连接通道。</p>\n<h4 id=\"2-不依赖DNS，无DNS耗时和劫持等问题\"><a href=\"#2-不依赖DNS，无DNS耗时和劫持等问题\" class=\"headerlink\" title=\"2. 不依赖DNS，无DNS耗时和劫持等问题\"></a>2. 不依赖DNS，无DNS耗时和劫持等问题</h4><p>上文中我们提到了<code>HttpDNS</code>，虽然它比系统DNS更优，但终归还是要做DNS操作。而长连接都是IP直接连接，因此没有DNS相关的开销和耗时。</p>\n<h4 id=\"3-如果有大量网络请求，可以明显减少网络延时，节省带宽\"><a href=\"#3-如果有大量网络请求，可以明显减少网络延时，节省带宽\" class=\"headerlink\" title=\"3. 如果有大量网络请求，可以明显减少网络延时，节省带宽\"></a>3. 如果有大量网络请求，可以明显减少网络延时，节省带宽</h4><p>对于大型App而言，存在繁多密集的网络请求，这中间就会存在非常多次的Http断开和重新连接，浪费了很多时间和带宽。而通过长连接通道的话，则没有这部分耗时，直接传输二进制数据即可，节省了每次连接里Header之类的带宽开销。</p>\n<h4 id=\"4-服务端主动Push数据到客户端\"><a href=\"#4-服务端主动Push数据到客户端\" class=\"headerlink\" title=\"4. 服务端主动Push数据到客户端\"></a>4. 服务端主动Push数据到客户端</h4><p>对于上面提到的微信消息接收等场景，如果需要客户端主动去轮询，则会频繁发起请求，对于服务器会产生很大的负载压力，浪费带宽流量。而通过长连接，服务端可以主动把消息下发给客户端，做到最高实时性，且节省流量。</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/9d3fe531208dfad25637fff33b358972.jpeg\" alt=\"\"></p>\n<h2 id=\"III-长连接何时会断开？\"><a href=\"#III-长连接何时会断开？\" class=\"headerlink\" title=\"III. 长连接何时会断开？\"></a>III. 长连接何时会断开？</h2><p>正常而言，长连接是不会断开的。大家可以自己试一试，两个socket建立连接，只要网络不变、一切正常，那么这两个socket可以一直互相传送数据，不会断开。</p>\n<p>但是，在移动网络下，网络状态复杂多变，比如网络线路被切断、服务器宕机等，都会导致长连接中断。除了这些线路异常外，我们需要关注下面几个长连接断开原因：</p>\n<h4 id=\"1-长连接所在进程被杀\"><a href=\"#1-长连接所在进程被杀\" class=\"headerlink\" title=\"1. 长连接所在进程被杀\"></a>1. 长连接所在进程被杀</h4><p>这个很容易理解，如果我们的App切换到后台，那么系统随时可能将我们的App杀掉，这时长连接自然也就随之断开。</p>\n<h4 id=\"2-用户切换网络\"><a href=\"#2-用户切换网络\" class=\"headerlink\" title=\"2. 用户切换网络\"></a>2. 用户切换网络</h4><p>比如手机网络断开，或者发生Wi-Fi和蜂窝数据切换，这时会导致手机IP地址变更。而我们知道，TCP连接是基于IP + Port的，一旦IP变更，TCP连接自然也就失效了，或者说长连接也就相当于断开了。</p>\n<h4 id=\"3-系统休眠等导致NAT超时\"><a href=\"#3-系统休眠等导致NAT超时\" class=\"headerlink\" title=\"3. 系统休眠等导致NAT超时\"></a>3. 系统休眠等导致NAT超时</h4><p>这里对NAT简单解释下，方便有的同学不太了解。当手机连接上网络时，网关会给我们分配一个IP地址，这个其实是内网IP，此时还未真正连接上公网，也连接不上服务器；如果想要连接公网，需要运营商将我们的内网IP映射成一个公网IP，有了公网IP，服务器就能与我们建立连接了。NAT指的就是这个映射过程。</p>\n<p>也就是说，运营商会给每台设备分配一个公网IP，类似一张通信证。不过，随着连接网络的设备不断增多，网关负载也会不断加大，这时，运营商就会对一些不太活跃的设备进行公网IP回收了，如果下次这个设备需要连网，那就重新分配一个IP即可。</p>\n<p>看似没问题，但实际上，如果我们的App在一段时间不活跃，发生了NAT超时，便会导致我们的公网IP失效，长连接也随之失效了。</p>\n<h4 id=\"4-DHCP-租期\"><a href=\"#4-DHCP-租期\" class=\"headerlink\" title=\"4. DHCP 租期\"></a>4. DHCP 租期</h4><p>DHCP 租期过期，如果没有及时续约，同样会导致IP地址失效。</p>\n<p>综合而言，长连接在正常情况下是不会断开的，但是，一旦手机的IP地址失效，这时就不得不重新建立连接了。</p>\n<h2 id=\"IV-如何建立稳定长连接？\"><a href=\"#IV-如何建立稳定长连接？\" class=\"headerlink\" title=\"IV. 如何建立稳定长连接？\"></a>IV. 如何建立稳定长连接？</h2><p>上面我们提到了多种长连接断开的原因，那我们应该如何进行优化，尽可能保证长连接不断开，或者及时断开了，也要尽快重连呢？</p>\n<h4 id=\"1-Mars长连接独立进程\"><a href=\"#1-Mars长连接独立进程\" class=\"headerlink\" title=\"1. Mars长连接独立进程\"></a>1. Mars长连接独立进程</h4><p>为了减少进程被杀的几率，在Mars的<a href=\"https://github.com/Tencent/mars/blob/master/samples/android/marsSampleChat/app/src/main/java/com/tencent/mars/sample/SampleApplicaton.java\" target=\"_blank\" rel=\"external\">Demo代码</a>里我们可以看到，它将长连接逻辑单独提取到了一个独立的进程里。这个进程只做网络交互，消耗的内存等资源自然较少，从而减少了被系统回收的概率。<br><img src=\"https://diycode.b0.upaiyun.com/photo/2018/02ee70621e61e774ca31203025592d71.png\" alt=\"\"></p>\n<blockquote>\n<p>图片来自<a href=\"http://www.52im.net/thread-210-1-1.html\" target=\"_blank\" rel=\"external\">《Android版微信后台保活实战分享(进程保活篇)》</a></p>\n</blockquote>\n<h4 id=\"2-长连接进程复活\"><a href=\"#2-长连接进程复活\" class=\"headerlink\" title=\"2. 长连接进程复活\"></a>2. 长连接进程复活</h4><p>进程被杀难以避免，不过可以通过AlarmReceiver、 ConnectReceiver、BootReceiver，达到进程的及时唤醒。</p>\n<p>当然，进程保活是一个比较大的话题，而且不恰当的进程保活也会对系统体验造成危害。这里就不深究了。</p>\n<h4 id=\"3-心跳机制\"><a href=\"#3-心跳机制\" class=\"headerlink\" title=\"3. 心跳机制\"></a>3. 心跳机制</h4><p>对于心跳包很多人误以为只是用来定期告诉服务端我们的状态，实际并非如此。</p>\n<p>上面我们提到了 NAT 超时，即如果App一段时间内不活跃，会导致运营商那里删除我们的公网IP映射关系，这会导致我们的TCP长连接断开。因此，我们需要通过心跳机制来保证App的活跃度，防止发生 NAT 超时。</p>\n<h4 id=\"4-断开重连\"><a href=\"#4-断开重连\" class=\"headerlink\" title=\"4. 断开重连\"></a>4. 断开重连</h4><p>在线上运行时，长连接很有可能会由于网络切换之类的原因断开。这时，我们需要<code>尽快发现</code>长连接断开，并<code>立即重连</code>。一般有下面几种做法：</p>\n<ul>\n<li>创建Receiver，监控网络状态，如果网络发生切换则立即重连；</li>\n<li>监控服务端心跳包回包，如果连续5次没有收到回包，则认为长连接已经失效；</li>\n<li>设置心跳包超时限制，如果超过时间还没有收到心跳回包，则重连，这种方式比较耗电；</li>\n<li>等socket IO异常抛出，不过耗时太长，需要15s左右才能发现。</li>\n</ul>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/5a11a944950af332e46829a071bf8cc6.png\" alt=\"\"></p>\n<h2 id=\"V-Mars智能心跳机制\"><a href=\"#V-Mars智能心跳机制\" class=\"headerlink\" title=\"V. Mars智能心跳机制\"></a>V. Mars智能心跳机制</h2><h3 id=\"1-固定心跳机制\"><a href=\"#1-固定心跳机制\" class=\"headerlink\" title=\"1. 固定心跳机制\"></a>1. 固定心跳机制</h3><p>上面我们说了，心跳机制主要是为了防止 NAT 超时，外网IP地址失效。因此，一般的做法就是在NAT失效前，保证有心跳包发出。或者说，客户端应当以略小于NAT超时时间的间隔来发送心跳包。</p>\n<p><img src=\"https://diycode.b0.upaiyun.com/photo/2018/3f79b7910c7d811c43344652a30ef63b.png\" alt=\"NAT超时时间\"></p>\n<p>早期的微信的心跳是4.5分钟发送一次心跳，可以不错的运行。</p>\n<h3 id=\"2-Mars智能心跳策略\"><a href=\"#2-Mars智能心跳策略\" class=\"headerlink\" title=\"2. Mars智能心跳策略\"></a>2. Mars智能心跳策略</h3><p>在尽量不影响用户收消息及时性的前提下，根据网络类型自适应的找出保活信令TCP连接的尽可能大的心跳间隔，从而达到减少安卓微信因心跳引起的空中信道资源消耗，减少心跳Server的负载，以及减少部分因心跳引起的耗电。</p>\n<h5 id=\"自适应心跳\"><a href=\"#自适应心跳\" class=\"headerlink\" title=\"自适应心跳\"></a>自适应心跳</h5><p>因此，在固定心跳机制下，微信又研究了一套动态计算心跳的方案，动态的探测最大的NAT超时时间，然后选定合适的心跳间隔区间去发送心跳包。这里说一下大致思路：</p>\n<p>首先，如果心跳间隔越久，产生的负载和消耗也会越小。因此微信采用了<code>自适应心跳</code>：当找到一个有效心跳间隔后，我们主动去加大这个间隔，然后测试是否能成功，如果不能，则使用比上一次成功间隔稍短的时间作为间隔；否则继续加大间隔，直到找到可用的有效间隔。</p>\n<p>那么，如何判断一个心跳间隔有效呢？微信采用的方案是使用固定短心跳直到满足三次连续短心跳成功，则认为这个间隔有效。</p>\n<p>探测过程大致为：60秒短心跳，连续发3次后开始探测，90，120，150，180，210，240，270</p>\n<h5 id=\"前后台策略\"><a href=\"#前后台策略\" class=\"headerlink\" title=\"前后台策略\"></a>前后台策略</h5><p>另外，考虑到App在前后台对于长连接的需求是不同的。因此当微信在前台活跃态时，采用了<code>固定心跳</code>机制；在前台熄屏态或者后台活跃态（进入后台10分钟内）时，先用几次最小心跳维持长连接，然后进入<code>自适应心跳</code>机制；在后台稳定态（超过10分钟），则采用自适应心跳计算出来的最大心跳作为固定值。</p>\n<p>如果在运行过程中，发生了心跳失败，则进行重连。同时将心跳间隔调整为断线前间隔减去20s，重新走自适应心跳；如果连续5次均失败，则以初始心跳180s继续测试。</p>\n<h5 id=\"Alarm对齐策略\"><a href=\"#Alarm对齐策略\" class=\"headerlink\" title=\"Alarm对齐策略\"></a>Alarm对齐策略</h5><p>对于Android系统而言，为了减少频繁唤醒系统导致的电量损耗，提供了<code>Alarm对齐唤醒</code>机制：把一定时间段内的多次Alarm唤醒合并成一次，减少系统被唤醒次数，增加待机时间。</p>\n<p>而我们的心跳包就是需要在定时结束后自动触发一次心跳包的发送，因此，在Mars里面的心跳时间也是按照Alarm对齐时间来做心跳间隔，减少电量损耗。</p>\n<h5 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h5><p>对于微信心跳策略感兴趣的话可以阅读文末的参考文献，代码可以参考<a href=\"https://github.com/Tencent/mars/blob/master/mars/stn/src/smart_heartbeat.cc\" target=\"_blank\" rel=\"external\">smart_heartbeat</a>。</p>\n<h2 id=\"VI-长连接数据协议及加密\"><a href=\"#VI-长连接数据协议及加密\" class=\"headerlink\" title=\"VI. 长连接数据协议及加密\"></a>VI. 长连接数据协议及加密</h2><p>长连接传递的是二进制数据，前后端可以自行协商每个字节要存放的内容即可。当然，也可以考虑采用一些通用协议：比如SMTP、ProtoBuf等序列化方案。</p>\n<p>参考文章：<a href=\"https://www.jianshu.com/p/42bfb79b0d39?utm_campaign=studygolang.com&amp;utm_medium=studygolang.com&amp;utm_source=studygolang.com\" target=\"_blank\" rel=\"external\">《一个基于TCP/WebSockets的超级精简的长连接消息协议》</a>.</p>\n<p>另外，在数据加密方面，可以结合非对称加密算法RSA和对称加密算法AES来对数据进行加密传输。</p>\n<p>这一点不是本文的重点，不做过多赘述。</p>\n<h2 id=\"VII-长连接通道建设及容灾\"><a href=\"#VII-长连接通道建设及容灾\" class=\"headerlink\" title=\"VII. 长连接通道建设及容灾\"></a>VII. 长连接通道建设及容灾</h2><p>上面讲了长连接的优势，那我们该如何搭建整个长连接通道呢？这里我们以美团的长连接通道为例子进行说明，各大厂的方案也是类似的。<br><img src=\"https://diycode.b0.upaiyun.com/photo/2018/5e97a86e0a4286a4398510ed77c38b1a.png\" alt=\"美团长连通道\"><br>上面是一个简图，大体流程如下：</p>\n<ol>\n<li>客户端与代理长连服务器建立长连接，代理服务器可全国多地部署，在建立长连时可以选择最近的服务器IP就近接入；</li>\n<li>长连接建立好后，客户端对要发送的二进制数据进行加密并传输；</li>\n<li>代理服务器收到后，可以通过内部专线或普通Http请求来访问业务服务器；</li>\n<li>如果长连接出现问题导致不可用，为保障客户端运行，需要立即降级成普通Http短连或者UDP通道。</li>\n</ol>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>本文结合了国内大厂如腾讯、美团等长连接框架，针对长连接这个技术点做了完整的介绍和剖析，如有不对或疑问，欢迎留言。</p>\n<hr>\n<p>谢谢。<br>wingjay</p>\n<hr>\n<h3 id=\"《亿级Android架构》小专栏介绍\"><a href=\"#《亿级Android架构》小专栏介绍\" class=\"headerlink\" title=\"《亿级Android架构》小专栏介绍\"></a>《亿级Android架构》小专栏介绍</h3><p>业务的快速增长离不开稳定可靠的架构。<a href=\"https://xiaozhuanlan.com/AndroidArch\" target=\"_blank\" rel=\"external\">《亿级Android架构》</a>小专栏会基于作者实际工作经验，结合国内大厂如阿里、腾讯、美团等基础架构现状，尝试谈谈如何设计一套好的架构来支持业务从0到1，甚至到亿，希望与大家多多探讨。</p>\n<p>本专栏主要内容：</p>\n<ol>\n<li>当前大厂有哪些Android架构；</li>\n<li>这些架构能解决什么问题；</li>\n<li>这些架构的原理是什么；</li>\n<li>学习这些架构对我们自身的意义。</li>\n</ol>\n<p><strong><a href=\"https://xiaozhuanlan.com/AndroidArch\" target=\"_blank\" rel=\"external\">《亿级Android架构》</a>小专栏文章列表：</strong></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/1934527806\" target=\"_blank\" rel=\"external\">《亿级 Android 架构》专栏随谈》</a></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/6982074351\" target=\"_blank\" rel=\"external\">《Android 架构之网络连接与加速》</a></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/3758142906\" target=\"_blank\" rel=\"external\">《Android 架构之长连接技术》</a></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/2130768549\" target=\"_blank\" rel=\"external\">《Android 架构之高可用移动网络连接》</a></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/8159302674\" target=\"_blank\" rel=\"external\">《Android 架构之网络安全演进》</a></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/2694081375\" target=\"_blank\" rel=\"external\">《Android 架构之高性能移动端日志系统》</a></p>\n<hr>\n<h2 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h2><p><a href=\"http://www.52im.net/thread-120-1-1.html\" target=\"_blank\" rel=\"external\">《移动端IM实践：实现Android版微信的智能心跳机制》</a><br><a href=\"http://www.52im.net/thread-341-1-1.html\" target=\"_blank\" rel=\"external\">《Android端消息推送总结：实现原理、心跳保活、遇到的问题等》</a><br><a href=\"https://tech.meituan.com/Shark_SDK.html\" target=\"_blank\" rel=\"external\">《美团点评移动网络优化实践</a><br><a href=\"http://www.52im.net/thread-209-1-1.html\" target=\"_blank\" rel=\"external\">《Android版微信后台保活实战分享(网络保活篇)》</a><br><a href=\"https://blog.cnbang.net/tech/3531/\" target=\"_blank\" rel=\"external\">《移动 APP 网络优化概述》</a><br><a href=\"https://blog.csdn.net/carson_ho/article/details/79522975\" target=\"_blank\" rel=\"external\">《高效 保活长连接：手把手教你实现 自适应的心跳保活机制》</a><br><a href=\"http://www.52im.net/thread-783-1-1.html\" target=\"_blank\" rel=\"external\">《一种Android端IM智能心跳算法的设计与实现探讨》</a><br><a href=\"https://cloud.tencent.com/document/product/214/4149\" target=\"_blank\" rel=\"external\">《HTTP长连接说明》</a><br><a href=\"https://halfrost.com/advance_tcp/\" target=\"_blank\" rel=\"external\">《TCP 进阶》</a></p>","sticky":0},{"title":"带你学开源项目：LeakCanary- 如何检测 Activity 是否泄漏","date":"2017-05-14T11:29:33.000Z","commentIssueId":3,"_content":">OOM 是 Android 开发中常见的问题，而内存泄漏往往是罪魁祸首。\n\n>为了简单方便的检测内存泄漏，Square 开源了 [`LeakCanary`](https://github.com/square/leakcanary)，它可以实时监测 Activity 是否发生了泄漏，一旦发现就会自动弹出提示及相关的泄漏信息供分析。\n\n>本文的目的是试图通过分析 `LeakCanary` 源码来探讨它的 Activity 泄漏检测机制。\n\n<!-- more -->\n\n## `LeakCanary` 使用方式\n为了将 `LeakCanary` 引入到我们的项目里，我们只需要做以下两步：\n```\ndependencies {\n debugCompile 'com.squareup.leakcanary:leakcanary-android:1.5.1'\n releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.5.1'\n testCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.5.1'\n}\n\npublic class ExampleApplication extends Application {\n  @Override public void onCreate() {\n    super.onCreate();\n    if (LeakCanary.isInAnalyzerProcess(this)) {\n      // This process is dedicated to LeakCanary for heap analysis.\n      // You should not init your app in this process.\n      return;\n    }\n    LeakCanary.install(this);\n  }\n}\n```\n\n可以看出，最关键的就是 `LeakCanary.install(this);` 这么一句话，正式开启了 `LeakCanary` 的大门，未来它就会自动帮我们检测内存泄漏，并在发生泄漏是弹出通知信息。\n\n##  从 `LeakCanary.install(this);` 开始\n下面我们来看下它做了些什么？\n```\n  public static RefWatcher install(Application application) {\n    return install(application, DisplayLeakService.class,\n        AndroidExcludedRefs.createAppDefaults().build());\n  }\n\n  public static RefWatcher install(Application application,\n      Class<? extends AbstractAnalysisResultService> listenerServiceClass,\n      ExcludedRefs excludedRefs) {\n    if (isInAnalyzerProcess(application)) {\n      return RefWatcher.DISABLED;\n    }\n    enableDisplayLeakActivity(application);\n    HeapDump.Listener heapDumpListener =\n        new ServiceHeapDumpListener(application, listenerServiceClass);\n    RefWatcher refWatcher = androidWatcher(application, heapDumpListener, excludedRefs);\n    ActivityRefWatcher.installOnIcsPlus(application, refWatcher);\n    return refWatcher;\n  }\n```\n\n首先，我们先看最重要的部分，就是：\n```\nRefWatcher refWatcher = androidWatcher(application, heapDumpListener, excludedRefs);\nActivityRefWatcher.installOnIcsPlus(application, refWatcher);\t\n```\n先生成了一个 `RefWatcher`，这个东西非常关键，从名字可以看出，它是用来 `watch Reference` 的，也就是用来一个监控引用的工具。然后再把 `refWatcher` 和我们自己提供的 `application` 传入到 `ActivityRefWatcher.installOnIcsPlus(application, refWatcher);` 这句里面，继续看。\n\n```\npublic static void installOnIcsPlus(Application application, RefWatcher refWatcher) {\n    ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher);\n    activityRefWatcher.watchActivities();\n}\n```\n\n创建了一个 `ActivityRefWatcher`，大家应该能感受到，这个东西就是用来监控我们的 `Activity` 泄漏状况的，它调用`watchActivities()` 方法，就可以开始进行监控了。下面就是它监控的核心原理：\n\n```\npublic void watchActivities() {\n  application.registerActivityLifecycleCallbacks(lifecycleCallbacks);\n}\n```\n\n它向 `application` 里注册了一个 `ActivitylifecycleCallbacks` 的回调函数，可以用来监听 `Application` 整个生命周期所有 `Activity` 的 lifecycle 事件。再看下这个 `lifecycleCallbacks` 是什么？\n```\n  private final Application.ActivityLifecycleCallbacks lifecycleCallbacks =\n      new Application.ActivityLifecycleCallbacks() {\n        @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) {\n        }\n\n        @Override public void onActivityStarted(Activity activity) {\n        }\n\n        @Override public void onActivityResumed(Activity activity) {\n        }\n\n        @Override public void onActivityPaused(Activity activity) {\n        }\n\n        @Override public void onActivityStopped(Activity activity) {\n        }\n\n        @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) {\n        }\n\n        @Override public void onActivityDestroyed(Activity activity) {\n          ActivityRefWatcher.this.onActivityDestroyed(activity);\n        }\n      };\n```\n\n原来它只监听了所有 `Activity` 的 `onActivityDestroyed` 事件，当 `Activity` 被 `Destory` 时，调用 `ActivityRefWatcher.this.onActivityDestroyed(activity);` 函数。\n\n猜测下，正常情况下，当一个这个函数应该 `activity` 被 `Destory` 时，那这个 `activity` 对象应该变成 null 才是正确的。如果没有变成null，那么就意味着发生了内存泄漏。\n\n因此我们向，这个函数 `ActivityRefWatcher.this.onActivityDestroyed(activity);` 应该是用来监听 `activity` 对象是否变成了 null。继续看。\n\n```\n  void onActivityDestroyed(Activity activity) {\n    refWatcher.watch(activity);\n  }\n  RefWatcher refWatcher = androidWatcher(application, heapDumpListener, excludedRefs);\n```\n\n可以看出，这个函数把目标 `activity` 对象传给了 `RefWatcher`，让它去监控这个 `activity` 是否被正常回收了，若未被回收，则意味着发生了内存泄漏。\n\n## RefWatcher 如何监控 activity 是否被正常回收呢？\n我们先来看看这个 `RefWatcher` 究竟是个什么东西？\n```\n  public static RefWatcher androidWatcher(Context context, HeapDump.Listener heapDumpListener,\n      ExcludedRefs excludedRefs) {\n    AndroidHeapDumper heapDumper = new AndroidHeapDumper(context, leakDirectoryProvider);\n    heapDumper.cleanup();\n\n    int watchDelayMillis = 5000;\n    AndroidWatchExecutor executor = new AndroidWatchExecutor(watchDelayMillis);\n\n    return new RefWatcher(executor, debuggerControl, GcTrigger.DEFAULT, heapDumper,\n        heapDumpListener, excludedRefs);\n  }\n```\n\n这里面涉及到两个新的对象：`AndroidHeapDumper` 和 `AndroidWatchExecutor`，前者用来 dump 堆内存状态的，后者则是用来 watch 一个引用的监听器。具体原理后面再看。总之，这里已经生成好了一个 `RefWatcher` 对象了。\n\n现在再看上面 `onActivityDestroyed(Activity activity)` 里调用的 `refWatcher.watch(activity);`，下面来看下这个最为核心的 `watch(activity)` 方法，了解它是如何监控 `activity` 是否被回收的。\n\n```\n  private final Set<String> retainedKeys;\n  public void watch(Object activity, String referenceName) {\n    String key = UUID.randomUUID().toString();\n    retainedKeys.add(key);\n\n    final KeyedWeakReference reference =\n        new KeyedWeakReference(activity, key, referenceName, queue);\n\n    watchExecutor.execute(new Runnable() {\n      @Override public void run() {\n        ensureGone(reference, watchStartNanoTime);\n      }\n    });\n  }\n\n  final class KeyedWeakReference extends WeakReference<Object> {\n    public final String key;\n    public final String name;\n  }\n```\n可以看到，它首先把我们传入的 `activity` 包装成了一个 `KeyedWeakReference`（可以暂时看成一个普通的 WeakReference），然后 `watchExecutor` 会去执行一个 Runnable，这个 Runnable 会调用 `ensureGone(reference, watchStartNanoTime)` 函数。\n\n看这个函数之前猜测下，我们知道 `watch` 函数本身就是用来监听 `activity` 是否被正常回收，这就涉及到两个问题：\n\n1. 何时去检查它是否回收？\n2. 如何有效地检查它真的被回收？\n\n所以我们觉得 `ensureGone` 函数本身要做的事正如它的名字，就是确保 `reference` 被回收掉了，否则就意味着内存泄漏。\n\n#### 核心函数：ensureGone(reference) 检测回收 \n下面来看这个函数实现：\n```\n  void ensureGone(KeyedWeakReference reference, long watchStartNanoTime) {\n    removeWeaklyReachableReferences();\n    if (gone(reference) || debuggerControl.isDebuggerAttached()) {\n      return;\n    }\n    gcTrigger.runGc();\n    removeWeaklyReachableReferences();\n    if (!gone(reference)) {\n      File heapDumpFile = heapDumper.dumpHeap();\n      heapdumpListener.analyze(\n          new HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs, watchDurationMs,\n              gcDurationMs, heapDumpDurationMs));\n    }\n  }\n\n  private boolean gone(KeyedWeakReference reference) {\n    return !retainedKeys.contains(reference.key);\n  }\n\n  private void removeWeaklyReachableReferences() {\n    KeyedWeakReference ref;\n    while ((ref = (KeyedWeakReference) queue.poll()) != null) {\n      retainedKeys.remove(ref.key);\n    }\n  }\n```\n\n这里先来解释下 `WeakReference` 和 `ReferenceQueue` 的工作原理。\n\n1. 弱引用 WeakReference\n被强引用的对象就算发生 OOM 也永远不会被垃圾回收机回收；被弱引用的对象，只要被垃圾回收器发现就会立即被回收；被软引用的对象，具备内存敏感性，只有内存不足时才会被回收，常用来做内存敏感缓存器；虚引用则任意时刻都可能被回收，使用较少。\n2. 引用队列 ReferenceQueue\n我们常用一个 `WeakReference<Activity> reference = new WeakReference(activity);`，这里我们创建了一个 `reference` 来弱引用到某个 `activity`，当这个 `activity` 被垃圾回收器回收后，这个 `reference` 会被放入内部的 `ReferenceQueue` 中。也就是说，从队列 `ReferenceQueue` 取出来的所有 `reference`，它们指向的真实对象都已经成功被回收了。\n\n然后再回到上面的代码。\n\n在一个 activity 传给 RefWatcher 时会创建一个唯一的 key 对应这个 activity，该key存入一个集合 `retainedKeys` 中。也就是说，所有我们想要观测的 `activity` 对应的唯一 key 都会被放入 `retainedKeys` 集合中。\n\n基于我们对 `ReferenceQueue` 的了解，只要把队列中所有的 reference 取出来，并把对应 retainedKeys 里的key移除，剩下的 key 对应的对象都没有被回收。\n\n1. ensureGone 首先调用 `removeWeaklyReachableReferences` 把已被回收的对象的 key 从 retainedKeys 移除，剩下的 key 都是未被回收的对象；\n2. if (gone(reference)) 用来判断某个 reference 的key是否仍在 retainedKeys 里，若不在，表示已回收，否则继续；\n3. gcTrigger.runGc(); 手动出发 GC，立即把所有 WeakReference 引用的对象回收；\n4. removeWeaklyReachableReferences(); 再次清理 retainedKeys，如果该 reference 还在 retainedKeys里 (if (!gone(reference)))，表示泄漏；\n5. 利用 heapDumper 把内存情况 dump 成文件，并调用 heapdumpListener 进行内存分析，进一步确认是否发生内存泄漏。\n6. 如果确认发生内存泄漏，调用 `DisplayLeakService` 发送通知。\n\n至此，核心的内存泄漏检测机制便看完了。\n\n## 内存泄漏检测小结\n从上面我们大概了解了内存泄漏检测机制，大概是以下几个步骤：\n1. 利用 `application.registerActivityLifecycleCallbacks(lifecycleCallbacks)` 来监听整个生命周期内的 Activity `onDestoryed` 事件;\n2. 当某个 `Activity` 被 destory 后，将它传给 RefWatcher 去做观测，确保其后续会被正常回收；\n3. RefWatcher 首先把 `Activity` 使用 KeyedWeakReference 引用起来，并使用一个 ReferenceQueue 来记录该 KeyedWeakReference 指向的对象是否已被回收；\n4. `AndroidWatchExecutor` 会在 5s 后，开始检查这个弱引用内的 `Activity` 是否被正常回收。判断条件是：若 `Activity` 被正常回收，那么引用它的 KeyedWeakReference 会被自动放入 ReferenceQueue 中。\n5. 判断方式是：先看 `Activity` 对应的 `KeyedWeakReference` 是否已经放入 `ReferenceQueue` 中；如果没有，则手动GC：`gcTrigger.runGc();`；然后再一次判断 `ReferenceQueue` 是否已经含有对应的 `KeyedWeakReference`。若还未被回收，则认为可能发生内存泄漏。\n6. 利用 HeapAnalyzer 对 dump 的内存情况进行分析并进一步确认，若确定发生泄漏，则利用 `DisplayLeakService` 发送通知。\n\n## 探讨一些关于 `LeakCanary` 有趣的问题\n在学习了 `LeakCanary` 的源码之后，我想再提几个有趣的问题做些探讨。\n\n### `LeakCanary` 项目目录结构为什么这样分？\n下面是整个 `LeakCanary` 的项目结构：\n![](/img/leakcanary/project.png)\n\n对于开发者而言，只需要使用到 `LeakCanary.install(this);` 这一句即可。那整个项目为什么要分成这么多个 module 呢？\n\n实际上，这里面每一个 module 都有自己的角色。\n\n- `leakcanary-watcher`: 这是一个通用的内存检测器，对外提供一个 RefWatcher#watch(Object watchedReference)，可以看出，它不仅能够检测 `Activity`，还能监测任意常规的 Java Object 的泄漏情况。\n\n- `leakcanary-android`: 这个 module 是与 `Android` 世界的接入点，用来专门监测 `Activity` 的泄漏情况，内部使用了 application#registerActivityLifecycleCallbacks 方法来监听 onDestory 事件，然后利用 `leakcanary-watcher` 来进行弱引用＋手动 GC 机制进行监控。\n\n- `leakcanary-analyzer`: 这个 module 提供了 `HeapAnalyzer`，用来对 dump 出来的内存进行分析并返回内存分析结果 `AnalysisResult`，内部包含了泄漏发生的路径等信息供开发者寻找定位。\n\n- `leakcanary-android-no-op`: 这个 module 是专门给 release 的版本用的，内部只提供了两个完全空白的类 `LeakCanary` 和 `RefWatcher`，这两个类不会做任何内存泄漏相关的分析。为什么？因为 `LeakCanary` 本身会由于不断 gc 影响到 app 本身的运行，而且主要用于开发阶段的内存泄漏检测。因此对于 release 则可以 disable 所有泄漏分析。\n\n- `leakcanary-sample`: 这个很简单，就是提供了一个用法 sample。\n\n### 当 Activity 被 destory 后，LeakCanary 多久后会去进行检查其是否泄漏呢？\n在源码中可以看到，LeakCanary 并不会在 destory 后立即去检查，而是让一个 `AndroidWatchExecutor` 去进行检查。它会做什么呢？\n```\n  @Override public void execute(final Runnable command) {\n    if (isOnMainThread()) {\n      executeDelayedAfterIdleUnsafe(command);\n    } else {\n      mainHandler.post(new Runnable() {\n        @Override public void run() {\n          executeDelayedAfterIdleUnsafe(command);\n        }\n      });\n    }\n  }\n\n  void executeDelayedAfterIdleUnsafe(final Runnable runnable) {\n    // This needs to be called from the main thread.\n    Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {\n      @Override public boolean queueIdle() {\n        backgroundHandler.postDelayed(runnable, delayMillis);\n        return false;\n      }\n    });\n  }\n```\n\n可以看到，它首先会向主线程的 MessageQueue 添加一个 `IdleHandler`。\n\n什么是 `IdleHandler`？我们知道 Looper 会不断从 MessageQueue 里取出 Message 并执行。当没有新的 Message 执行时，Looper 进入 Idle 状态时，就会取出 `IdleHandler` 来执行。\n\n换句话说，`IdleHandler`就是`优先级别较低的 Message`，只有当 Looper 没有消息要处理时才得到处理。而且，内部的 `queueIdle()` 方法若返回 `true`，表示该任务一直存活，每次 Looper 进入 Idle 时就执行；反正，如果返回 `false`，则表示只会执行一次，执行完后丢弃。\n\n那么，这件优先级较低的任务是什么呢？`backgroundHandler.postDelayed(runnable, delayMillis);`，runnable 就是之前 `ensureGone()`。\n\n也就是说，当主线程空闲了，没事做了，开始向后台线程发送一个延时消息，告诉后台线程，5s(delayMillis)后开始检查 `Activity` 是否被回收了。\n\n所以，当 `Activity` 发生 `destory` 后，首先要等到主线程空闲，然后再延时 5s(delayMillis)，才开始执行泄漏检查。\n\n##### 知识点：\n1. 如何创建一个优先级低的主线程任务，它只会在主线程空闲时才执行，不会影响到app的性能？\n```\nLooper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {\n      @Override public boolean queueIdle() {\n        // do task\n        return false; // only once\n      }\n    });\n```\n2. 如何快速创建一个主／子线程handler？\n```\n//主线程handler\nmainHandler = new Handler(Looper.getMainLooper());\n\n//子线程handler\nHandlerThread handlerThread = new HandlerThread(“子线程任务”);\nhandlerThread.start();\nHandler backgroundHandler = new Handler(handlerThread.getLooper());\n```\n3. 如何快速判断当前是否运行在主线程？\n```\nLooper.getMainLooper().getThread() == Thread.currentThread();\n```\n\n### System.gc() 可以触发立即 gc 吗？如果不行那怎么才能触发即时 gc 呢？\n在 LeakCanary 里，需要立即触发 gc，并在之后立即判断弱引用是否被回收。这意味着该 gc 必须能够立即同步执行。\n\n常用的触发 gc 方法是 `System.gc()`，那它能达到我们的要求吗？\n\n我们来看下其实现方式：\n```\n    /**\n     * Indicates to the VM that it would be a good time to run the\n     * garbage collector. Note that this is a hint only. There is no guarantee\n     * that the garbage collector will actually be run.\n     */\n    public static void gc() {\n        boolean shouldRunGC;\n        synchronized(lock) {\n            shouldRunGC = justRanFinalization;\n            if (shouldRunGC) {\n                justRanFinalization = false;\n            } else {\n                runGC = true;\n            }\n        }\n        if (shouldRunGC) {\n            Runtime.getRuntime().gc();\n        }\n    }\n```\n\n注释里清楚说了，`System.gc()`只是建议垃圾回收器来执行回收，但是`不能保证真的去回收`。从代码也能看出，必须先判断 `shouldRunGC` 才能决定是否真的要 gc。\n\n##### 知识点：\n那要怎么实现 即时 GC 呢？\n\n`LeakCanary` 参考了一段 [AOSP 的代码](https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/java/lang/ref/FinalizationTester.java)\n```\n// System.gc() does not garbage collect every time. Runtime.gc() is\n// more likely to perfom a gc.\nRuntime.getRuntime().gc();\nenqueueReferences();\nSystem.runFinalization();\npublic static void enqueueReferences() {\n    /*\n     * Hack. We don't have a programmatic way to wait for the reference queue\n     * daemon to move references to the appropriate queues.\n     */\n    try {\n        Thread.sleep(100);\n    } catch (InterruptedException e) {\n        throw new AssertionError();\n    }\n}\n```\n\n### 可以怎样来改造 LeakCanary 呢？\n##### 忽略某些已知泄漏的类或Activity\nLeakCanary 提供了 ExcludedRefs 类，可以向里面添加某些主动忽略的类。比如已知 Android 源代码里有某些内存泄漏，不属于我们 App 的泄漏，那么就可以 exclude 掉。\n\n另外，如果不想监控某些特殊的 Activity，那么可以在 `onActivityDestroyed(Activity activity)` 里，过滤掉特殊的 Activity，只对其它 Activity 调用 `refWatcher.watch(activity)` 监控。\n\n##### 把内存泄漏数据上传至服务器\n在 LeakCanary 提供了 `AbstractAnalysisResultService`，它是一个 intentService，接收到的 intent 内包含了 `HeapDump` 数据和 `AnalysisResult` 结果，我们只要继承这个类，实现自己的 `listenerServiceClass`，就可以将堆数据和分析结果上传到我们自己的服务器上。\n\n## 小结\n本文通过源代码分析了 LeakCanary 的原理，并提出了一些有趣的问题，学习了一些实用的知识点。希望对读者有所启发，欢迎与我讨论。\n\n之后会继续挑选优质开源项目进行分析，欢迎提意见。\n\n谢谢。\n\nwingjay\n\nhttp://wingjay.com\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n\n\n\n\n","source":"_posts/带你学开源项目：LeakCanary-如何检测-Activity-发生泄漏.md","raw":"title: 带你学开源项目：LeakCanary-如何检测 Activity 是否泄漏\ndate: 2017-05-14 19:29:33\npermalink: dig_into_leakcanary\ncategories:\n  - Android\n  - 带你学开源项目\ntags:\n    - Android\n    - 带你学开源项目\n    - 内存泄漏\n    - 性能优化\ncommentIssueId: 3    \n---\n>OOM 是 Android 开发中常见的问题，而内存泄漏往往是罪魁祸首。\n\n>为了简单方便的检测内存泄漏，Square 开源了 [`LeakCanary`](https://github.com/square/leakcanary)，它可以实时监测 Activity 是否发生了泄漏，一旦发现就会自动弹出提示及相关的泄漏信息供分析。\n\n>本文的目的是试图通过分析 `LeakCanary` 源码来探讨它的 Activity 泄漏检测机制。\n\n<!-- more -->\n\n## `LeakCanary` 使用方式\n为了将 `LeakCanary` 引入到我们的项目里，我们只需要做以下两步：\n```\ndependencies {\n debugCompile 'com.squareup.leakcanary:leakcanary-android:1.5.1'\n releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.5.1'\n testCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.5.1'\n}\n\npublic class ExampleApplication extends Application {\n  @Override public void onCreate() {\n    super.onCreate();\n    if (LeakCanary.isInAnalyzerProcess(this)) {\n      // This process is dedicated to LeakCanary for heap analysis.\n      // You should not init your app in this process.\n      return;\n    }\n    LeakCanary.install(this);\n  }\n}\n```\n\n可以看出，最关键的就是 `LeakCanary.install(this);` 这么一句话，正式开启了 `LeakCanary` 的大门，未来它就会自动帮我们检测内存泄漏，并在发生泄漏是弹出通知信息。\n\n##  从 `LeakCanary.install(this);` 开始\n下面我们来看下它做了些什么？\n```\n  public static RefWatcher install(Application application) {\n    return install(application, DisplayLeakService.class,\n        AndroidExcludedRefs.createAppDefaults().build());\n  }\n\n  public static RefWatcher install(Application application,\n      Class<? extends AbstractAnalysisResultService> listenerServiceClass,\n      ExcludedRefs excludedRefs) {\n    if (isInAnalyzerProcess(application)) {\n      return RefWatcher.DISABLED;\n    }\n    enableDisplayLeakActivity(application);\n    HeapDump.Listener heapDumpListener =\n        new ServiceHeapDumpListener(application, listenerServiceClass);\n    RefWatcher refWatcher = androidWatcher(application, heapDumpListener, excludedRefs);\n    ActivityRefWatcher.installOnIcsPlus(application, refWatcher);\n    return refWatcher;\n  }\n```\n\n首先，我们先看最重要的部分，就是：\n```\nRefWatcher refWatcher = androidWatcher(application, heapDumpListener, excludedRefs);\nActivityRefWatcher.installOnIcsPlus(application, refWatcher);\t\n```\n先生成了一个 `RefWatcher`，这个东西非常关键，从名字可以看出，它是用来 `watch Reference` 的，也就是用来一个监控引用的工具。然后再把 `refWatcher` 和我们自己提供的 `application` 传入到 `ActivityRefWatcher.installOnIcsPlus(application, refWatcher);` 这句里面，继续看。\n\n```\npublic static void installOnIcsPlus(Application application, RefWatcher refWatcher) {\n    ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher);\n    activityRefWatcher.watchActivities();\n}\n```\n\n创建了一个 `ActivityRefWatcher`，大家应该能感受到，这个东西就是用来监控我们的 `Activity` 泄漏状况的，它调用`watchActivities()` 方法，就可以开始进行监控了。下面就是它监控的核心原理：\n\n```\npublic void watchActivities() {\n  application.registerActivityLifecycleCallbacks(lifecycleCallbacks);\n}\n```\n\n它向 `application` 里注册了一个 `ActivitylifecycleCallbacks` 的回调函数，可以用来监听 `Application` 整个生命周期所有 `Activity` 的 lifecycle 事件。再看下这个 `lifecycleCallbacks` 是什么？\n```\n  private final Application.ActivityLifecycleCallbacks lifecycleCallbacks =\n      new Application.ActivityLifecycleCallbacks() {\n        @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) {\n        }\n\n        @Override public void onActivityStarted(Activity activity) {\n        }\n\n        @Override public void onActivityResumed(Activity activity) {\n        }\n\n        @Override public void onActivityPaused(Activity activity) {\n        }\n\n        @Override public void onActivityStopped(Activity activity) {\n        }\n\n        @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) {\n        }\n\n        @Override public void onActivityDestroyed(Activity activity) {\n          ActivityRefWatcher.this.onActivityDestroyed(activity);\n        }\n      };\n```\n\n原来它只监听了所有 `Activity` 的 `onActivityDestroyed` 事件，当 `Activity` 被 `Destory` 时，调用 `ActivityRefWatcher.this.onActivityDestroyed(activity);` 函数。\n\n猜测下，正常情况下，当一个这个函数应该 `activity` 被 `Destory` 时，那这个 `activity` 对象应该变成 null 才是正确的。如果没有变成null，那么就意味着发生了内存泄漏。\n\n因此我们向，这个函数 `ActivityRefWatcher.this.onActivityDestroyed(activity);` 应该是用来监听 `activity` 对象是否变成了 null。继续看。\n\n```\n  void onActivityDestroyed(Activity activity) {\n    refWatcher.watch(activity);\n  }\n  RefWatcher refWatcher = androidWatcher(application, heapDumpListener, excludedRefs);\n```\n\n可以看出，这个函数把目标 `activity` 对象传给了 `RefWatcher`，让它去监控这个 `activity` 是否被正常回收了，若未被回收，则意味着发生了内存泄漏。\n\n## RefWatcher 如何监控 activity 是否被正常回收呢？\n我们先来看看这个 `RefWatcher` 究竟是个什么东西？\n```\n  public static RefWatcher androidWatcher(Context context, HeapDump.Listener heapDumpListener,\n      ExcludedRefs excludedRefs) {\n    AndroidHeapDumper heapDumper = new AndroidHeapDumper(context, leakDirectoryProvider);\n    heapDumper.cleanup();\n\n    int watchDelayMillis = 5000;\n    AndroidWatchExecutor executor = new AndroidWatchExecutor(watchDelayMillis);\n\n    return new RefWatcher(executor, debuggerControl, GcTrigger.DEFAULT, heapDumper,\n        heapDumpListener, excludedRefs);\n  }\n```\n\n这里面涉及到两个新的对象：`AndroidHeapDumper` 和 `AndroidWatchExecutor`，前者用来 dump 堆内存状态的，后者则是用来 watch 一个引用的监听器。具体原理后面再看。总之，这里已经生成好了一个 `RefWatcher` 对象了。\n\n现在再看上面 `onActivityDestroyed(Activity activity)` 里调用的 `refWatcher.watch(activity);`，下面来看下这个最为核心的 `watch(activity)` 方法，了解它是如何监控 `activity` 是否被回收的。\n\n```\n  private final Set<String> retainedKeys;\n  public void watch(Object activity, String referenceName) {\n    String key = UUID.randomUUID().toString();\n    retainedKeys.add(key);\n\n    final KeyedWeakReference reference =\n        new KeyedWeakReference(activity, key, referenceName, queue);\n\n    watchExecutor.execute(new Runnable() {\n      @Override public void run() {\n        ensureGone(reference, watchStartNanoTime);\n      }\n    });\n  }\n\n  final class KeyedWeakReference extends WeakReference<Object> {\n    public final String key;\n    public final String name;\n  }\n```\n可以看到，它首先把我们传入的 `activity` 包装成了一个 `KeyedWeakReference`（可以暂时看成一个普通的 WeakReference），然后 `watchExecutor` 会去执行一个 Runnable，这个 Runnable 会调用 `ensureGone(reference, watchStartNanoTime)` 函数。\n\n看这个函数之前猜测下，我们知道 `watch` 函数本身就是用来监听 `activity` 是否被正常回收，这就涉及到两个问题：\n\n1. 何时去检查它是否回收？\n2. 如何有效地检查它真的被回收？\n\n所以我们觉得 `ensureGone` 函数本身要做的事正如它的名字，就是确保 `reference` 被回收掉了，否则就意味着内存泄漏。\n\n#### 核心函数：ensureGone(reference) 检测回收 \n下面来看这个函数实现：\n```\n  void ensureGone(KeyedWeakReference reference, long watchStartNanoTime) {\n    removeWeaklyReachableReferences();\n    if (gone(reference) || debuggerControl.isDebuggerAttached()) {\n      return;\n    }\n    gcTrigger.runGc();\n    removeWeaklyReachableReferences();\n    if (!gone(reference)) {\n      File heapDumpFile = heapDumper.dumpHeap();\n      heapdumpListener.analyze(\n          new HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs, watchDurationMs,\n              gcDurationMs, heapDumpDurationMs));\n    }\n  }\n\n  private boolean gone(KeyedWeakReference reference) {\n    return !retainedKeys.contains(reference.key);\n  }\n\n  private void removeWeaklyReachableReferences() {\n    KeyedWeakReference ref;\n    while ((ref = (KeyedWeakReference) queue.poll()) != null) {\n      retainedKeys.remove(ref.key);\n    }\n  }\n```\n\n这里先来解释下 `WeakReference` 和 `ReferenceQueue` 的工作原理。\n\n1. 弱引用 WeakReference\n被强引用的对象就算发生 OOM 也永远不会被垃圾回收机回收；被弱引用的对象，只要被垃圾回收器发现就会立即被回收；被软引用的对象，具备内存敏感性，只有内存不足时才会被回收，常用来做内存敏感缓存器；虚引用则任意时刻都可能被回收，使用较少。\n2. 引用队列 ReferenceQueue\n我们常用一个 `WeakReference<Activity> reference = new WeakReference(activity);`，这里我们创建了一个 `reference` 来弱引用到某个 `activity`，当这个 `activity` 被垃圾回收器回收后，这个 `reference` 会被放入内部的 `ReferenceQueue` 中。也就是说，从队列 `ReferenceQueue` 取出来的所有 `reference`，它们指向的真实对象都已经成功被回收了。\n\n然后再回到上面的代码。\n\n在一个 activity 传给 RefWatcher 时会创建一个唯一的 key 对应这个 activity，该key存入一个集合 `retainedKeys` 中。也就是说，所有我们想要观测的 `activity` 对应的唯一 key 都会被放入 `retainedKeys` 集合中。\n\n基于我们对 `ReferenceQueue` 的了解，只要把队列中所有的 reference 取出来，并把对应 retainedKeys 里的key移除，剩下的 key 对应的对象都没有被回收。\n\n1. ensureGone 首先调用 `removeWeaklyReachableReferences` 把已被回收的对象的 key 从 retainedKeys 移除，剩下的 key 都是未被回收的对象；\n2. if (gone(reference)) 用来判断某个 reference 的key是否仍在 retainedKeys 里，若不在，表示已回收，否则继续；\n3. gcTrigger.runGc(); 手动出发 GC，立即把所有 WeakReference 引用的对象回收；\n4. removeWeaklyReachableReferences(); 再次清理 retainedKeys，如果该 reference 还在 retainedKeys里 (if (!gone(reference)))，表示泄漏；\n5. 利用 heapDumper 把内存情况 dump 成文件，并调用 heapdumpListener 进行内存分析，进一步确认是否发生内存泄漏。\n6. 如果确认发生内存泄漏，调用 `DisplayLeakService` 发送通知。\n\n至此，核心的内存泄漏检测机制便看完了。\n\n## 内存泄漏检测小结\n从上面我们大概了解了内存泄漏检测机制，大概是以下几个步骤：\n1. 利用 `application.registerActivityLifecycleCallbacks(lifecycleCallbacks)` 来监听整个生命周期内的 Activity `onDestoryed` 事件;\n2. 当某个 `Activity` 被 destory 后，将它传给 RefWatcher 去做观测，确保其后续会被正常回收；\n3. RefWatcher 首先把 `Activity` 使用 KeyedWeakReference 引用起来，并使用一个 ReferenceQueue 来记录该 KeyedWeakReference 指向的对象是否已被回收；\n4. `AndroidWatchExecutor` 会在 5s 后，开始检查这个弱引用内的 `Activity` 是否被正常回收。判断条件是：若 `Activity` 被正常回收，那么引用它的 KeyedWeakReference 会被自动放入 ReferenceQueue 中。\n5. 判断方式是：先看 `Activity` 对应的 `KeyedWeakReference` 是否已经放入 `ReferenceQueue` 中；如果没有，则手动GC：`gcTrigger.runGc();`；然后再一次判断 `ReferenceQueue` 是否已经含有对应的 `KeyedWeakReference`。若还未被回收，则认为可能发生内存泄漏。\n6. 利用 HeapAnalyzer 对 dump 的内存情况进行分析并进一步确认，若确定发生泄漏，则利用 `DisplayLeakService` 发送通知。\n\n## 探讨一些关于 `LeakCanary` 有趣的问题\n在学习了 `LeakCanary` 的源码之后，我想再提几个有趣的问题做些探讨。\n\n### `LeakCanary` 项目目录结构为什么这样分？\n下面是整个 `LeakCanary` 的项目结构：\n![](/img/leakcanary/project.png)\n\n对于开发者而言，只需要使用到 `LeakCanary.install(this);` 这一句即可。那整个项目为什么要分成这么多个 module 呢？\n\n实际上，这里面每一个 module 都有自己的角色。\n\n- `leakcanary-watcher`: 这是一个通用的内存检测器，对外提供一个 RefWatcher#watch(Object watchedReference)，可以看出，它不仅能够检测 `Activity`，还能监测任意常规的 Java Object 的泄漏情况。\n\n- `leakcanary-android`: 这个 module 是与 `Android` 世界的接入点，用来专门监测 `Activity` 的泄漏情况，内部使用了 application#registerActivityLifecycleCallbacks 方法来监听 onDestory 事件，然后利用 `leakcanary-watcher` 来进行弱引用＋手动 GC 机制进行监控。\n\n- `leakcanary-analyzer`: 这个 module 提供了 `HeapAnalyzer`，用来对 dump 出来的内存进行分析并返回内存分析结果 `AnalysisResult`，内部包含了泄漏发生的路径等信息供开发者寻找定位。\n\n- `leakcanary-android-no-op`: 这个 module 是专门给 release 的版本用的，内部只提供了两个完全空白的类 `LeakCanary` 和 `RefWatcher`，这两个类不会做任何内存泄漏相关的分析。为什么？因为 `LeakCanary` 本身会由于不断 gc 影响到 app 本身的运行，而且主要用于开发阶段的内存泄漏检测。因此对于 release 则可以 disable 所有泄漏分析。\n\n- `leakcanary-sample`: 这个很简单，就是提供了一个用法 sample。\n\n### 当 Activity 被 destory 后，LeakCanary 多久后会去进行检查其是否泄漏呢？\n在源码中可以看到，LeakCanary 并不会在 destory 后立即去检查，而是让一个 `AndroidWatchExecutor` 去进行检查。它会做什么呢？\n```\n  @Override public void execute(final Runnable command) {\n    if (isOnMainThread()) {\n      executeDelayedAfterIdleUnsafe(command);\n    } else {\n      mainHandler.post(new Runnable() {\n        @Override public void run() {\n          executeDelayedAfterIdleUnsafe(command);\n        }\n      });\n    }\n  }\n\n  void executeDelayedAfterIdleUnsafe(final Runnable runnable) {\n    // This needs to be called from the main thread.\n    Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {\n      @Override public boolean queueIdle() {\n        backgroundHandler.postDelayed(runnable, delayMillis);\n        return false;\n      }\n    });\n  }\n```\n\n可以看到，它首先会向主线程的 MessageQueue 添加一个 `IdleHandler`。\n\n什么是 `IdleHandler`？我们知道 Looper 会不断从 MessageQueue 里取出 Message 并执行。当没有新的 Message 执行时，Looper 进入 Idle 状态时，就会取出 `IdleHandler` 来执行。\n\n换句话说，`IdleHandler`就是`优先级别较低的 Message`，只有当 Looper 没有消息要处理时才得到处理。而且，内部的 `queueIdle()` 方法若返回 `true`，表示该任务一直存活，每次 Looper 进入 Idle 时就执行；反正，如果返回 `false`，则表示只会执行一次，执行完后丢弃。\n\n那么，这件优先级较低的任务是什么呢？`backgroundHandler.postDelayed(runnable, delayMillis);`，runnable 就是之前 `ensureGone()`。\n\n也就是说，当主线程空闲了，没事做了，开始向后台线程发送一个延时消息，告诉后台线程，5s(delayMillis)后开始检查 `Activity` 是否被回收了。\n\n所以，当 `Activity` 发生 `destory` 后，首先要等到主线程空闲，然后再延时 5s(delayMillis)，才开始执行泄漏检查。\n\n##### 知识点：\n1. 如何创建一个优先级低的主线程任务，它只会在主线程空闲时才执行，不会影响到app的性能？\n```\nLooper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {\n      @Override public boolean queueIdle() {\n        // do task\n        return false; // only once\n      }\n    });\n```\n2. 如何快速创建一个主／子线程handler？\n```\n//主线程handler\nmainHandler = new Handler(Looper.getMainLooper());\n\n//子线程handler\nHandlerThread handlerThread = new HandlerThread(“子线程任务”);\nhandlerThread.start();\nHandler backgroundHandler = new Handler(handlerThread.getLooper());\n```\n3. 如何快速判断当前是否运行在主线程？\n```\nLooper.getMainLooper().getThread() == Thread.currentThread();\n```\n\n### System.gc() 可以触发立即 gc 吗？如果不行那怎么才能触发即时 gc 呢？\n在 LeakCanary 里，需要立即触发 gc，并在之后立即判断弱引用是否被回收。这意味着该 gc 必须能够立即同步执行。\n\n常用的触发 gc 方法是 `System.gc()`，那它能达到我们的要求吗？\n\n我们来看下其实现方式：\n```\n    /**\n     * Indicates to the VM that it would be a good time to run the\n     * garbage collector. Note that this is a hint only. There is no guarantee\n     * that the garbage collector will actually be run.\n     */\n    public static void gc() {\n        boolean shouldRunGC;\n        synchronized(lock) {\n            shouldRunGC = justRanFinalization;\n            if (shouldRunGC) {\n                justRanFinalization = false;\n            } else {\n                runGC = true;\n            }\n        }\n        if (shouldRunGC) {\n            Runtime.getRuntime().gc();\n        }\n    }\n```\n\n注释里清楚说了，`System.gc()`只是建议垃圾回收器来执行回收，但是`不能保证真的去回收`。从代码也能看出，必须先判断 `shouldRunGC` 才能决定是否真的要 gc。\n\n##### 知识点：\n那要怎么实现 即时 GC 呢？\n\n`LeakCanary` 参考了一段 [AOSP 的代码](https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/java/lang/ref/FinalizationTester.java)\n```\n// System.gc() does not garbage collect every time. Runtime.gc() is\n// more likely to perfom a gc.\nRuntime.getRuntime().gc();\nenqueueReferences();\nSystem.runFinalization();\npublic static void enqueueReferences() {\n    /*\n     * Hack. We don't have a programmatic way to wait for the reference queue\n     * daemon to move references to the appropriate queues.\n     */\n    try {\n        Thread.sleep(100);\n    } catch (InterruptedException e) {\n        throw new AssertionError();\n    }\n}\n```\n\n### 可以怎样来改造 LeakCanary 呢？\n##### 忽略某些已知泄漏的类或Activity\nLeakCanary 提供了 ExcludedRefs 类，可以向里面添加某些主动忽略的类。比如已知 Android 源代码里有某些内存泄漏，不属于我们 App 的泄漏，那么就可以 exclude 掉。\n\n另外，如果不想监控某些特殊的 Activity，那么可以在 `onActivityDestroyed(Activity activity)` 里，过滤掉特殊的 Activity，只对其它 Activity 调用 `refWatcher.watch(activity)` 监控。\n\n##### 把内存泄漏数据上传至服务器\n在 LeakCanary 提供了 `AbstractAnalysisResultService`，它是一个 intentService，接收到的 intent 内包含了 `HeapDump` 数据和 `AnalysisResult` 结果，我们只要继承这个类，实现自己的 `listenerServiceClass`，就可以将堆数据和分析结果上传到我们自己的服务器上。\n\n## 小结\n本文通过源代码分析了 LeakCanary 的原理，并提出了一些有趣的问题，学习了一些实用的知识点。希望对读者有所启发，欢迎与我讨论。\n\n之后会继续挑选优质开源项目进行分析，欢迎提意见。\n\n谢谢。\n\nwingjay\n\nhttp://wingjay.com\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n\n\n\n\n","slug":"dig_into_leakcanary","published":1,"updated":"2018-11-26T06:56:27.485Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplsjj005h3dn8k9jmrw62","content":"<blockquote>\n<p>OOM 是 Android 开发中常见的问题，而内存泄漏往往是罪魁祸首。</p>\n<p>为了简单方便的检测内存泄漏，Square 开源了 <a href=\"https://github.com/square/leakcanary\" target=\"_blank\" rel=\"external\"><code>LeakCanary</code></a>，它可以实时监测 Activity 是否发生了泄漏，一旦发现就会自动弹出提示及相关的泄漏信息供分析。</p>\n<p>本文的目的是试图通过分析 <code>LeakCanary</code> 源码来探讨它的 Activity 泄漏检测机制。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"LeakCanary- 使用方式\"><a href=\"#LeakCanary- 使用方式\" class=\"headerlink\" title=\"LeakCanary 使用方式\"></a><code>LeakCanary</code> 使用方式 </h2><p> 为了将 <code>LeakCanary</code> 引入到我们的项目里，我们只需要做以下两步：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">dependencies &#123;</div><div class=\"line\"> debugCompile &apos;com.squareup.leakcanary:leakcanary-android:1.5.1&apos;</div><div class=\"line\"> releaseCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5.1&apos;</div><div class=\"line\"> testCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5.1&apos;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public class ExampleApplication extends Application &#123;</div><div class=\"line\">  @Override public void onCreate() &#123;</div><div class=\"line\">    super.onCreate();</div><div class=\"line\">    if (LeakCanary.isInAnalyzerProcess(this)) &#123;</div><div class=\"line\">      // This process is dedicated to LeakCanary for heap analysis.</div><div class=\"line\">      // You should not init your app in this process.</div><div class=\"line\">      return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    LeakCanary.install(this);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看出，最关键的就是 <code>LeakCanary.install(this);</code> 这么一句话，正式开启了 <code>LeakCanary</code> 的大门，未来它就会自动帮我们检测内存泄漏，并在发生泄漏是弹出通知信息。</p>\n<h2 id=\"从 -LeakCanary-install-this- 开始\"><a href=\"# 从 -LeakCanary-install-this- 开始\" class=\"headerlink\" title=\"从 LeakCanary.install(this); 开始\"></a>从 <code>LeakCanary.install(this);</code> 开始 </h2><p> 下面我们来看下它做了些什么？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static RefWatcher install(Application application) &#123;</div><div class=\"line\">  return install(application, DisplayLeakService.class,</div><div class=\"line\">      AndroidExcludedRefs.createAppDefaults().build());</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public static RefWatcher install(Application application,</div><div class=\"line\">    Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass,</div><div class=\"line\">    ExcludedRefs excludedRefs) &#123;</div><div class=\"line\">  if (isInAnalyzerProcess(application)) &#123;</div><div class=\"line\">    return RefWatcher.DISABLED;</div><div class=\"line\">  &#125;</div><div class=\"line\">  enableDisplayLeakActivity(application);</div><div class=\"line\">  HeapDump.Listener heapDumpListener =</div><div class=\"line\">      new ServiceHeapDumpListener(application, listenerServiceClass);</div><div class=\"line\">  RefWatcher refWatcher = androidWatcher(application, heapDumpListener, excludedRefs);</div><div class=\"line\">  ActivityRefWatcher.installOnIcsPlus(application, refWatcher);</div><div class=\"line\">  return refWatcher;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>首先，我们先看最重要的部分，就是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">RefWatcher refWatcher = androidWatcher(application, heapDumpListener, excludedRefs);</div><div class=\"line\">ActivityRefWatcher.installOnIcsPlus(application, refWatcher);</div></pre></td></tr></table></figure></p>\n<p>先生成了一个 <code>RefWatcher</code>，这个东西非常关键，从名字可以看出，它是用来 <code>watch Reference</code> 的，也就是用来一个监控引用的工具。然后再把 <code>refWatcher</code> 和我们自己提供的 <code>application</code> 传入到 <code>ActivityRefWatcher.installOnIcsPlus(application, refWatcher);</code> 这句里面，继续看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static void installOnIcsPlus(Application application, RefWatcher refWatcher) &#123;</div><div class=\"line\">    ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher);</div><div class=\"line\">    activityRefWatcher.watchActivities();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>创建了一个 <code>ActivityRefWatcher</code>，大家应该能感受到，这个东西就是用来监控我们的 <code>Activity</code> 泄漏状况的，它调用<code>watchActivities()</code> 方法，就可以开始进行监控了。下面就是它监控的核心原理：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void watchActivities() &#123;</div><div class=\"line\">  application.registerActivityLifecycleCallbacks(lifecycleCallbacks);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>它向 <code>application</code> 里注册了一个 <code>ActivitylifecycleCallbacks</code> 的回调函数，可以用来监听 <code>Application</code> 整个生命周期所有 <code>Activity</code> 的 lifecycle 事件。再看下这个 <code>lifecycleCallbacks</code> 是什么？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">private final Application.ActivityLifecycleCallbacks lifecycleCallbacks =</div><div class=\"line\">    new Application.ActivityLifecycleCallbacks() &#123;</div><div class=\"line\">      @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) &#123;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      @Override public void onActivityStarted(Activity activity) &#123;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      @Override public void onActivityResumed(Activity activity) &#123;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      @Override public void onActivityPaused(Activity activity) &#123;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      @Override public void onActivityStopped(Activity activity) &#123;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) &#123;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      @Override public void onActivityDestroyed(Activity activity) &#123;</div><div class=\"line\">        ActivityRefWatcher.this.onActivityDestroyed(activity);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure></p>\n<p>原来它只监听了所有 <code>Activity</code> 的 <code>onActivityDestroyed</code> 事件，当 <code>Activity</code> 被 <code>Destory</code> 时，调用 <code>ActivityRefWatcher.this.onActivityDestroyed(activity);</code> 函数。</p>\n<p>猜测下，正常情况下，当一个这个函数应该 <code>activity</code> 被 <code>Destory</code> 时，那这个 <code>activity</code> 对象应该变成 null 才是正确的。如果没有变成 null，那么就意味着发生了内存泄漏。</p>\n<p>因此我们向，这个函数 <code>ActivityRefWatcher.this.onActivityDestroyed(activity);</code> 应该是用来监听 <code>activity</code> 对象是否变成了 null。继续看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">void onActivityDestroyed(Activity activity) &#123;</div><div class=\"line\">  refWatcher.watch(activity);</div><div class=\"line\">&#125;</div><div class=\"line\">RefWatcher refWatcher = androidWatcher(application, heapDumpListener, excludedRefs);</div></pre></td></tr></table></figure>\n<p>可以看出，这个函数把目标 <code>activity</code> 对象传给了 <code>RefWatcher</code>，让它去监控这个 <code>activity</code> 是否被正常回收了，若未被回收，则意味着发生了内存泄漏。</p>\n<h2 id=\"RefWatcher- 如何监控 -activity- 是否被正常回收呢？\"><a href=\"#RefWatcher- 如何监控 -activity- 是否被正常回收呢？\" class=\"headerlink\" title=\"RefWatcher 如何监控 activity 是否被正常回收呢？\"></a>RefWatcher 如何监控 activity 是否被正常回收呢？</h2><p>我们先来看看这个 <code>RefWatcher</code> 究竟是个什么东西？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static RefWatcher androidWatcher(Context context, HeapDump.Listener heapDumpListener,</div><div class=\"line\">    ExcludedRefs excludedRefs) &#123;</div><div class=\"line\">  AndroidHeapDumper heapDumper = new AndroidHeapDumper(context, leakDirectoryProvider);</div><div class=\"line\">  heapDumper.cleanup();</div><div class=\"line\"></div><div class=\"line\">  int watchDelayMillis = 5000;</div><div class=\"line\">  AndroidWatchExecutor executor = new AndroidWatchExecutor(watchDelayMillis);</div><div class=\"line\"></div><div class=\"line\">  return new RefWatcher(executor, debuggerControl, GcTrigger.DEFAULT, heapDumper,</div><div class=\"line\">      heapDumpListener, excludedRefs);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里面涉及到两个新的对象：<code>AndroidHeapDumper</code> 和 <code>AndroidWatchExecutor</code>，前者用来 dump 堆内存状态的，后者则是用来 watch 一个引用的监听器。具体原理后面再看。总之，这里已经生成好了一个 <code>RefWatcher</code> 对象了。</p>\n<p>现在再看上面 <code>onActivityDestroyed(Activity activity)</code> 里调用的 <code>refWatcher.watch(activity);</code>，下面来看下这个最为核心的 <code>watch(activity)</code> 方法，了解它是如何监控 <code>activity</code> 是否被回收的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">private final Set&lt;String&gt; retainedKeys;</div><div class=\"line\">public void watch(Object activity, String referenceName) &#123;</div><div class=\"line\">  String key = UUID.randomUUID().toString();</div><div class=\"line\">  retainedKeys.add(key);</div><div class=\"line\"></div><div class=\"line\">  final KeyedWeakReference reference =</div><div class=\"line\">      new KeyedWeakReference(activity, key, referenceName, queue);</div><div class=\"line\"></div><div class=\"line\">  watchExecutor.execute(new Runnable() &#123;</div><div class=\"line\">    @Override public void run() &#123;</div><div class=\"line\">      ensureGone(reference, watchStartNanoTime);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">final class KeyedWeakReference extends WeakReference&lt;Object&gt; &#123;</div><div class=\"line\">  public final String key;</div><div class=\"line\">  public final String name;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，它首先把我们传入的 <code>activity</code> 包装成了一个 <code>KeyedWeakReference</code>（可以暂时看成一个普通的 WeakReference），然后 <code>watchExecutor</code> 会去执行一个 Runnable，这个 Runnable 会调用 <code>ensureGone(reference, watchStartNanoTime)</code> 函数。</p>\n<p>看这个函数之前猜测下，我们知道 <code>watch</code> 函数本身就是用来监听 <code>activity</code> 是否被正常回收，这就涉及到两个问题：</p>\n<ol>\n<li>何时去检查它是否回收？</li>\n<li>如何有效地检查它真的被回收？</li>\n</ol>\n<p>所以我们觉得 <code>ensureGone</code> 函数本身要做的事正如它的名字，就是确保 <code>reference</code> 被回收掉了，否则就意味着内存泄漏。</p>\n<h4 id=\"核心函数：ensureGone-reference- 检测回收\"><a href=\"# 核心函数：ensureGone-reference- 检测回收\" class=\"headerlink\" title=\"核心函数：ensureGone(reference) 检测回收\"></a>核心函数：ensureGone(reference) 检测回收 </h4><p> 下面来看这个函数实现：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">void ensureGone(KeyedWeakReference reference, long watchStartNanoTime) &#123;</div><div class=\"line\">  removeWeaklyReachableReferences();</div><div class=\"line\">  if (gone(reference) || debuggerControl.isDebuggerAttached()) &#123;</div><div class=\"line\">    return;</div><div class=\"line\">  &#125;</div><div class=\"line\">  gcTrigger.runGc();</div><div class=\"line\">  removeWeaklyReachableReferences();</div><div class=\"line\">  if (!gone(reference)) &#123;</div><div class=\"line\">    File heapDumpFile = heapDumper.dumpHeap();</div><div class=\"line\">    heapdumpListener.analyze(</div><div class=\"line\">        new HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs, watchDurationMs,</div><div class=\"line\">            gcDurationMs, heapDumpDurationMs));</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">private boolean gone(KeyedWeakReference reference) &#123;</div><div class=\"line\">  return !retainedKeys.contains(reference.key);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">private void removeWeaklyReachableReferences() &#123;</div><div class=\"line\">  KeyedWeakReference ref;</div><div class=\"line\">  while ((ref = (KeyedWeakReference) queue.poll()) != null) &#123;</div><div class=\"line\">    retainedKeys.remove(ref.key);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里先来解释下 <code>WeakReference</code> 和 <code>ReferenceQueue</code> 的工作原理。</p>\n<ol>\n<li>弱引用 WeakReference<br>被强引用的对象就算发生 OOM 也永远不会被垃圾回收机回收；被弱引用的对象，只要被垃圾回收器发现就会立即被回收；被软引用的对象，具备内存敏感性，只有内存不足时才会被回收，常用来做内存敏感缓存器；虚引用则任意时刻都可能被回收，使用较少。</li>\n<li>引用队列 ReferenceQueue<br>我们常用一个 <code>WeakReference&lt;Activity&gt; reference = new WeakReference(activity);</code>，这里我们创建了一个 <code>reference</code> 来弱引用到某个 <code>activity</code>，当这个 <code>activity</code> 被垃圾回收器回收后，这个 <code>reference</code> 会被放入内部的 <code>ReferenceQueue</code> 中。也就是说，从队列 <code>ReferenceQueue</code> 取出来的所有 <code>reference</code>，它们指向的真实对象都已经成功被回收了。</li>\n</ol>\n<p>然后再回到上面的代码。</p>\n<p>在一个 activity 传给 RefWatcher 时会创建一个唯一的 key 对应这个 activity，该 key 存入一个集合 <code>retainedKeys</code> 中。也就是说，所有我们想要观测的 <code>activity</code> 对应的唯一 key 都会被放入 <code>retainedKeys</code> 集合中。</p>\n<p>基于我们对 <code>ReferenceQueue</code> 的了解，只要把队列中所有的 reference 取出来，并把对应 retainedKeys 里的 key 移除，剩下的 key 对应的对象都没有被回收。</p>\n<ol>\n<li>ensureGone 首先调用 <code>removeWeaklyReachableReferences</code> 把已被回收的对象的 key 从 retainedKeys 移除，剩下的 key 都是未被回收的对象；</li>\n<li>if (gone(reference)) 用来判断某个 reference 的 key 是否仍在 retainedKeys 里，若不在，表示已回收，否则继续；</li>\n<li>gcTrigger.runGc(); 手动出发 GC，立即把所有 WeakReference 引用的对象回收；</li>\n<li>removeWeaklyReachableReferences(); 再次清理 retainedKeys，如果该 reference 还在 retainedKeys 里 (if (!gone(reference)))，表示泄漏；</li>\n<li>利用 heapDumper 把内存情况 dump 成文件，并调用 heapdumpListener 进行内存分析，进一步确认是否发生内存泄漏。</li>\n<li>如果确认发生内存泄漏，调用 <code>DisplayLeakService</code> 发送通知。</li>\n</ol>\n<p>至此，核心的内存泄漏检测机制便看完了。</p>\n<h2 id=\"内存泄漏检测小结\"><a href=\"# 内存泄漏检测小结\" class=\"headerlink\" title=\"内存泄漏检测小结\"></a>内存泄漏检测小结 </h2><p> 从上面我们大概了解了内存泄漏检测机制，大概是以下几个步骤：</p>\n<ol>\n<li>利用 <code>application.registerActivityLifecycleCallbacks(lifecycleCallbacks)</code> 来监听整个生命周期内的 Activity <code>onDestoryed</code> 事件;</li>\n<li>当某个 <code>Activity</code> 被 destory 后，将它传给 RefWatcher 去做观测，确保其后续会被正常回收；</li>\n<li>RefWatcher 首先把 <code>Activity</code> 使用 KeyedWeakReference 引用起来，并使用一个 ReferenceQueue 来记录该 KeyedWeakReference 指向的对象是否已被回收；</li>\n<li><code>AndroidWatchExecutor</code> 会在 5s 后，开始检查这个弱引用内的 <code>Activity</code> 是否被正常回收。判断条件是：若 <code>Activity</code> 被正常回收，那么引用它的 KeyedWeakReference 会被自动放入 ReferenceQueue 中。</li>\n<li>判断方式是：先看 <code>Activity</code> 对应的 <code>KeyedWeakReference</code> 是否已经放入 <code>ReferenceQueue</code> 中；如果没有，则手动 GC：<code>gcTrigger.runGc();</code>；然后再一次判断 <code>ReferenceQueue</code> 是否已经含有对应的 <code>KeyedWeakReference</code>。若还未被回收，则认为可能发生内存泄漏。</li>\n<li>利用 HeapAnalyzer 对 dump 的内存情况进行分析并进一步确认，若确定发生泄漏，则利用 <code>DisplayLeakService</code> 发送通知。</li>\n</ol>\n<h2 id=\"探讨一些关于 -LeakCanary- 有趣的问题\"><a href=\"# 探讨一些关于 -LeakCanary- 有趣的问题\" class=\"headerlink\" title=\"探讨一些关于 LeakCanary 有趣的问题\"></a>探讨一些关于 <code>LeakCanary</code> 有趣的问题 </h2><p> 在学习了 <code>LeakCanary</code> 的源码之后，我想再提几个有趣的问题做些探讨。</p>\n<h3 id=\"LeakCanary- 项目目录结构为什么这样分？\"><a href=\"#LeakCanary- 项目目录结构为什么这样分？\" class=\"headerlink\" title=\"LeakCanary 项目目录结构为什么这样分？\"></a><code>LeakCanary</code> 项目目录结构为什么这样分？</h3><p>下面是整个 <code>LeakCanary</code> 的项目结构：<br><img src=\"/img/leakcanary/project.png\" alt=\"\"></p>\n<p>对于开发者而言，只需要使用到 <code>LeakCanary.install(this);</code> 这一句即可。那整个项目为什么要分成这么多个 module 呢？</p>\n<p>实际上，这里面每一个 module 都有自己的角色。</p>\n<ul>\n<li><p><code>leakcanary-watcher</code>: 这是一个通用的内存检测器，对外提供一个 RefWatcher#watch(Object watchedReference)，可以看出，它不仅能够检测 <code>Activity</code>，还能监测任意常规的 Java Object 的泄漏情况。</p>\n</li>\n<li><p><code>leakcanary-android</code>: 这个 module 是与 <code>Android</code> 世界的接入点，用来专门监测 <code>Activity</code> 的泄漏情况，内部使用了 application#registerActivityLifecycleCallbacks 方法来监听 onDestory 事件，然后利用 <code>leakcanary-watcher</code> 来进行弱引用＋手动 GC 机制进行监控。</p>\n</li>\n<li><p><code>leakcanary-analyzer</code>: 这个 module 提供了 <code>HeapAnalyzer</code>，用来对 dump 出来的内存进行分析并返回内存分析结果 <code>AnalysisResult</code>，内部包含了泄漏发生的路径等信息供开发者寻找定位。</p>\n</li>\n<li><p><code>leakcanary-android-no-op</code>: 这个 module 是专门给 release 的版本用的，内部只提供了两个完全空白的类 <code>LeakCanary</code> 和 <code>RefWatcher</code>，这两个类不会做任何内存泄漏相关的分析。为什么？因为 <code>LeakCanary</code> 本身会由于不断 gc 影响到 app 本身的运行，而且主要用于开发阶段的内存泄漏检测。因此对于 release 则可以 disable 所有泄漏分析。</p>\n</li>\n<li><p><code>leakcanary-sample</code>: 这个很简单，就是提供了一个用法 sample。</p>\n</li>\n</ul>\n<h3 id=\"当 -Activity- 被 -destory- 后，LeakCanary- 多久后会去进行检查其是否泄漏呢？\"><a href=\"# 当 -Activity- 被 -destory- 后，LeakCanary- 多久后会去进行检查其是否泄漏呢？\" class=\"headerlink\" title=\"当 Activity 被 destory 后，LeakCanary 多久后会去进行检查其是否泄漏呢？\"></a>当 Activity 被 destory 后，LeakCanary 多久后会去进行检查其是否泄漏呢？</h3><p>在源码中可以看到，LeakCanary 并不会在 destory 后立即去检查，而是让一个 <code>AndroidWatchExecutor</code> 去进行检查。它会做什么呢？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override public void execute(final Runnable command) &#123;</div><div class=\"line\">  if (isOnMainThread()) &#123;</div><div class=\"line\">    executeDelayedAfterIdleUnsafe(command);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    mainHandler.post(new Runnable() &#123;</div><div class=\"line\">      @Override public void run() &#123;</div><div class=\"line\">        executeDelayedAfterIdleUnsafe(command);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">void executeDelayedAfterIdleUnsafe(final Runnable runnable) &#123;</div><div class=\"line\">  // This needs to be called from the main thread.</div><div class=\"line\">  Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() &#123;</div><div class=\"line\">    @Override public boolean queueIdle() &#123;</div><div class=\"line\">      backgroundHandler.postDelayed(runnable, delayMillis);</div><div class=\"line\">      return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到，它首先会向主线程的 MessageQueue 添加一个 <code>IdleHandler</code>。</p>\n<p>什么是 <code>IdleHandler</code>？我们知道 Looper 会不断从 MessageQueue 里取出 Message 并执行。当没有新的 Message 执行时，Looper 进入 Idle 状态时，就会取出 <code>IdleHandler</code> 来执行。</p>\n<p>换句话说，<code>IdleHandler</code>就是 <code> 优先级别较低的 Message</code>，只有当 Looper 没有消息要处理时才得到处理。而且，内部的 <code>queueIdle()</code> 方法若返回 <code>true</code>，表示该任务一直存活，每次 Looper 进入 Idle 时就执行；反正，如果返回 <code>false</code>，则表示只会执行一次，执行完后丢弃。</p>\n<p>那么，这件优先级较低的任务是什么呢？<code>backgroundHandler.postDelayed(runnable, delayMillis);</code>，runnable 就是之前 <code>ensureGone()</code>。</p>\n<p>也就是说，当主线程空闲了，没事做了，开始向后台线程发送一个延时消息，告诉后台线程，5s(delayMillis)后开始检查 <code>Activity</code> 是否被回收了。</p>\n<p>所以，当 <code>Activity</code> 发生 <code>destory</code> 后，首先要等到主线程空闲，然后再延时 5s(delayMillis)，才开始执行泄漏检查。</p>\n<h5 id=\"知识点：\"><a href=\"# 知识点：\" class=\"headerlink\" title=\"知识点：\"></a>知识点：</h5><ol>\n<li><p>如何创建一个优先级低的主线程任务，它只会在主线程空闲时才执行，不会影响到 app 的性能？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() &#123;</div><div class=\"line\">      @Override public boolean queueIdle() &#123;</div><div class=\"line\">        // do task</div><div class=\"line\">        return false; // only once</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p>如何快速创建一个主／子线程 handler？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 主线程 handler</div><div class=\"line\">mainHandler = new Handler(Looper.getMainLooper());</div><div class=\"line\"></div><div class=\"line\">// 子线程 handler</div><div class=\"line\">HandlerThread handlerThread = new HandlerThread(“子线程任务”);</div><div class=\"line\">handlerThread.start();</div><div class=\"line\">Handler backgroundHandler = new Handler(handlerThread.getLooper());</div></pre></td></tr></table></figure>\n</li>\n<li><p>如何快速判断当前是否运行在主线程？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Looper.getMainLooper().getThread() == Thread.currentThread();</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"System-gc- 可以触发立即 -gc- 吗？如果不行那怎么才能触发即时 -gc- 呢？\"><a href=\"#System-gc- 可以触发立即 -gc- 吗？如果不行那怎么才能触发即时 -gc- 呢？\" class=\"headerlink\" title=\"System.gc() 可以触发立即 gc 吗？如果不行那怎么才能触发即时 gc 呢？\"></a>System.gc() 可以触发立即 gc 吗？如果不行那怎么才能触发即时 gc 呢？</h3><p>在 LeakCanary 里，需要立即触发 gc，并在之后立即判断弱引用是否被回收。这意味着该 gc 必须能够立即同步执行。</p>\n<p>常用的触发 gc 方法是 <code>System.gc()</code>，那它能达到我们的要求吗？</p>\n<p>我们来看下其实现方式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Indicates to the VM that it would be a good time to run the</div><div class=\"line\"> * garbage collector. Note that this is a hint only. There is no guarantee</div><div class=\"line\"> * that the garbage collector will actually be run.</div><div class=\"line\"> */</div><div class=\"line\">public static void gc() &#123;</div><div class=\"line\">    boolean shouldRunGC;</div><div class=\"line\">    synchronized(lock) &#123;</div><div class=\"line\">        shouldRunGC = justRanFinalization;</div><div class=\"line\">        if (shouldRunGC) &#123;</div><div class=\"line\">            justRanFinalization = false;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            runGC = true;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (shouldRunGC) &#123;</div><div class=\"line\">        Runtime.getRuntime().gc();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注释里清楚说了，<code>System.gc()</code>只是建议垃圾回收器来执行回收，但是 <code> 不能保证真的去回收</code>。从代码也能看出，必须先判断 <code>shouldRunGC</code> 才能决定是否真的要 gc。</p>\n<h5 id=\"知识点：-1\"><a href=\"# 知识点：-1\" class=\"headerlink\" title=\"知识点：\"></a>知识点：</h5><p>那要怎么实现 即时 GC 呢？</p>\n<p><code>LeakCanary</code> 参考了一段 <a href=\"https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/java/lang/ref/FinalizationTester.java\" target=\"_blank\" rel=\"external\">AOSP 的代码</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">// System.gc() does not garbage collect every time. Runtime.gc() is</div><div class=\"line\">// more likely to perfom a gc.</div><div class=\"line\">Runtime.getRuntime().gc();</div><div class=\"line\">enqueueReferences();</div><div class=\"line\">System.runFinalization();</div><div class=\"line\">public static void enqueueReferences() &#123;</div><div class=\"line\">    /*</div><div class=\"line\">     * Hack. We don&apos;t have a programmatic way to wait for the reference queue</div><div class=\"line\">     * daemon to move references to the appropriate queues.</div><div class=\"line\">     */</div><div class=\"line\">    try &#123;</div><div class=\"line\">        Thread.sleep(100);</div><div class=\"line\">    &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">        throw new AssertionError();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"可以怎样来改造 -LeakCanary- 呢？\"><a href=\"# 可以怎样来改造 -LeakCanary- 呢？\" class=\"headerlink\" title=\"可以怎样来改造 LeakCanary 呢？\"></a>可以怎样来改造 LeakCanary 呢？</h3><h5 id=\"忽略某些已知泄漏的类或 Activity\"><a href=\"# 忽略某些已知泄漏的类或 Activity\" class=\"headerlink\" title=\"忽略某些已知泄漏的类或 Activity\"></a>忽略某些已知泄漏的类或 Activity</h5><p>LeakCanary 提供了 ExcludedRefs 类，可以向里面添加某些主动忽略的类。比如已知 Android 源代码里有某些内存泄漏，不属于我们 App 的泄漏，那么就可以 exclude 掉。</p>\n<p>另外，如果不想监控某些特殊的 Activity，那么可以在 <code>onActivityDestroyed(Activity activity)</code> 里，过滤掉特殊的 Activity，只对其它 Activity 调用 <code>refWatcher.watch(activity)</code> 监控。</p>\n<h5 id=\"把内存泄漏数据上传至服务器\"><a href=\"# 把内存泄漏数据上传至服务器\" class=\"headerlink\" title=\"把内存泄漏数据上传至服务器\"></a>把内存泄漏数据上传至服务器 </h5><p> 在 LeakCanary 提供了 <code>AbstractAnalysisResultService</code>，它是一个 intentService，接收到的 intent 内包含了 <code>HeapDump</code> 数据和 <code>AnalysisResult</code> 结果，我们只要继承这个类，实现自己的 <code>listenerServiceClass</code>，就可以将堆数据和分析结果上传到我们自己的服务器上。</p>\n<h2 id=\"小结\"><a href=\"# 小结\" class=\"headerlink\" title=\"小结\"></a>小结 </h2><p> 本文通过源代码分析了 LeakCanary 的原理，并提出了一些有趣的问题，学习了一些实用的知识点。希望对读者有所启发，欢迎与我讨论。</p>\n<p>之后会继续挑选优质开源项目进行分析，欢迎提意见。</p>\n<p>谢谢。</p>\n<p>wingjay</p>\n<p><a href=\"http://wingjay.com\">http://wingjay.com</a></p>\n<p><img src=\"https://avatars0.githubusercontent.com/u/9619875?v=3&amp;s=460\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>OOM 是 Android 开发中常见的问题，而内存泄漏往往是罪魁祸首。</p>\n<p>为了简单方便的检测内存泄漏，Square 开源了 <a href=\"https://github.com/square/leakcanary\" target=\"_blank\" rel=\"external\"><code>LeakCanary</code></a>，它可以实时监测 Activity 是否发生了泄漏，一旦发现就会自动弹出提示及相关的泄漏信息供分析。</p>\n<p>本文的目的是试图通过分析 <code>LeakCanary</code> 源码来探讨它的 Activity 泄漏检测机制。</p>\n</blockquote>","more":"<h2 id=\"LeakCanary-使用方式\"><a href=\"#LeakCanary-使用方式\" class=\"headerlink\" title=\"LeakCanary 使用方式\"></a><code>LeakCanary</code> 使用方式</h2><p>为了将 <code>LeakCanary</code> 引入到我们的项目里，我们只需要做以下两步：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">dependencies &#123;</div><div class=\"line\"> debugCompile &apos;com.squareup.leakcanary:leakcanary-android:1.5.1&apos;</div><div class=\"line\"> releaseCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5.1&apos;</div><div class=\"line\"> testCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5.1&apos;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public class ExampleApplication extends Application &#123;</div><div class=\"line\">  @Override public void onCreate() &#123;</div><div class=\"line\">    super.onCreate();</div><div class=\"line\">    if (LeakCanary.isInAnalyzerProcess(this)) &#123;</div><div class=\"line\">      // This process is dedicated to LeakCanary for heap analysis.</div><div class=\"line\">      // You should not init your app in this process.</div><div class=\"line\">      return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    LeakCanary.install(this);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看出，最关键的就是 <code>LeakCanary.install(this);</code> 这么一句话，正式开启了 <code>LeakCanary</code> 的大门，未来它就会自动帮我们检测内存泄漏，并在发生泄漏是弹出通知信息。</p>\n<h2 id=\"从-LeakCanary-install-this-开始\"><a href=\"#从-LeakCanary-install-this-开始\" class=\"headerlink\" title=\"从 LeakCanary.install(this); 开始\"></a>从 <code>LeakCanary.install(this);</code> 开始</h2><p>下面我们来看下它做了些什么？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static RefWatcher install(Application application) &#123;</div><div class=\"line\">  return install(application, DisplayLeakService.class,</div><div class=\"line\">      AndroidExcludedRefs.createAppDefaults().build());</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public static RefWatcher install(Application application,</div><div class=\"line\">    Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass,</div><div class=\"line\">    ExcludedRefs excludedRefs) &#123;</div><div class=\"line\">  if (isInAnalyzerProcess(application)) &#123;</div><div class=\"line\">    return RefWatcher.DISABLED;</div><div class=\"line\">  &#125;</div><div class=\"line\">  enableDisplayLeakActivity(application);</div><div class=\"line\">  HeapDump.Listener heapDumpListener =</div><div class=\"line\">      new ServiceHeapDumpListener(application, listenerServiceClass);</div><div class=\"line\">  RefWatcher refWatcher = androidWatcher(application, heapDumpListener, excludedRefs);</div><div class=\"line\">  ActivityRefWatcher.installOnIcsPlus(application, refWatcher);</div><div class=\"line\">  return refWatcher;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>首先，我们先看最重要的部分，就是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">RefWatcher refWatcher = androidWatcher(application, heapDumpListener, excludedRefs);</div><div class=\"line\">ActivityRefWatcher.installOnIcsPlus(application, refWatcher);</div></pre></td></tr></table></figure></p>\n<p>先生成了一个 <code>RefWatcher</code>，这个东西非常关键，从名字可以看出，它是用来 <code>watch Reference</code> 的，也就是用来一个监控引用的工具。然后再把 <code>refWatcher</code> 和我们自己提供的 <code>application</code> 传入到 <code>ActivityRefWatcher.installOnIcsPlus(application, refWatcher);</code> 这句里面，继续看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static void installOnIcsPlus(Application application, RefWatcher refWatcher) &#123;</div><div class=\"line\">    ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher);</div><div class=\"line\">    activityRefWatcher.watchActivities();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>创建了一个 <code>ActivityRefWatcher</code>，大家应该能感受到，这个东西就是用来监控我们的 <code>Activity</code> 泄漏状况的，它调用<code>watchActivities()</code> 方法，就可以开始进行监控了。下面就是它监控的核心原理：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void watchActivities() &#123;</div><div class=\"line\">  application.registerActivityLifecycleCallbacks(lifecycleCallbacks);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>它向 <code>application</code> 里注册了一个 <code>ActivitylifecycleCallbacks</code> 的回调函数，可以用来监听 <code>Application</code> 整个生命周期所有 <code>Activity</code> 的 lifecycle 事件。再看下这个 <code>lifecycleCallbacks</code> 是什么？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">private final Application.ActivityLifecycleCallbacks lifecycleCallbacks =</div><div class=\"line\">    new Application.ActivityLifecycleCallbacks() &#123;</div><div class=\"line\">      @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) &#123;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      @Override public void onActivityStarted(Activity activity) &#123;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      @Override public void onActivityResumed(Activity activity) &#123;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      @Override public void onActivityPaused(Activity activity) &#123;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      @Override public void onActivityStopped(Activity activity) &#123;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) &#123;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      @Override public void onActivityDestroyed(Activity activity) &#123;</div><div class=\"line\">        ActivityRefWatcher.this.onActivityDestroyed(activity);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure></p>\n<p>原来它只监听了所有 <code>Activity</code> 的 <code>onActivityDestroyed</code> 事件，当 <code>Activity</code> 被 <code>Destory</code> 时，调用 <code>ActivityRefWatcher.this.onActivityDestroyed(activity);</code> 函数。</p>\n<p>猜测下，正常情况下，当一个这个函数应该 <code>activity</code> 被 <code>Destory</code> 时，那这个 <code>activity</code> 对象应该变成 null 才是正确的。如果没有变成null，那么就意味着发生了内存泄漏。</p>\n<p>因此我们向，这个函数 <code>ActivityRefWatcher.this.onActivityDestroyed(activity);</code> 应该是用来监听 <code>activity</code> 对象是否变成了 null。继续看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">void onActivityDestroyed(Activity activity) &#123;</div><div class=\"line\">  refWatcher.watch(activity);</div><div class=\"line\">&#125;</div><div class=\"line\">RefWatcher refWatcher = androidWatcher(application, heapDumpListener, excludedRefs);</div></pre></td></tr></table></figure>\n<p>可以看出，这个函数把目标 <code>activity</code> 对象传给了 <code>RefWatcher</code>，让它去监控这个 <code>activity</code> 是否被正常回收了，若未被回收，则意味着发生了内存泄漏。</p>\n<h2 id=\"RefWatcher-如何监控-activity-是否被正常回收呢？\"><a href=\"#RefWatcher-如何监控-activity-是否被正常回收呢？\" class=\"headerlink\" title=\"RefWatcher 如何监控 activity 是否被正常回收呢？\"></a>RefWatcher 如何监控 activity 是否被正常回收呢？</h2><p>我们先来看看这个 <code>RefWatcher</code> 究竟是个什么东西？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static RefWatcher androidWatcher(Context context, HeapDump.Listener heapDumpListener,</div><div class=\"line\">    ExcludedRefs excludedRefs) &#123;</div><div class=\"line\">  AndroidHeapDumper heapDumper = new AndroidHeapDumper(context, leakDirectoryProvider);</div><div class=\"line\">  heapDumper.cleanup();</div><div class=\"line\"></div><div class=\"line\">  int watchDelayMillis = 5000;</div><div class=\"line\">  AndroidWatchExecutor executor = new AndroidWatchExecutor(watchDelayMillis);</div><div class=\"line\"></div><div class=\"line\">  return new RefWatcher(executor, debuggerControl, GcTrigger.DEFAULT, heapDumper,</div><div class=\"line\">      heapDumpListener, excludedRefs);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里面涉及到两个新的对象：<code>AndroidHeapDumper</code> 和 <code>AndroidWatchExecutor</code>，前者用来 dump 堆内存状态的，后者则是用来 watch 一个引用的监听器。具体原理后面再看。总之，这里已经生成好了一个 <code>RefWatcher</code> 对象了。</p>\n<p>现在再看上面 <code>onActivityDestroyed(Activity activity)</code> 里调用的 <code>refWatcher.watch(activity);</code>，下面来看下这个最为核心的 <code>watch(activity)</code> 方法，了解它是如何监控 <code>activity</code> 是否被回收的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">private final Set&lt;String&gt; retainedKeys;</div><div class=\"line\">public void watch(Object activity, String referenceName) &#123;</div><div class=\"line\">  String key = UUID.randomUUID().toString();</div><div class=\"line\">  retainedKeys.add(key);</div><div class=\"line\"></div><div class=\"line\">  final KeyedWeakReference reference =</div><div class=\"line\">      new KeyedWeakReference(activity, key, referenceName, queue);</div><div class=\"line\"></div><div class=\"line\">  watchExecutor.execute(new Runnable() &#123;</div><div class=\"line\">    @Override public void run() &#123;</div><div class=\"line\">      ensureGone(reference, watchStartNanoTime);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">final class KeyedWeakReference extends WeakReference&lt;Object&gt; &#123;</div><div class=\"line\">  public final String key;</div><div class=\"line\">  public final String name;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，它首先把我们传入的 <code>activity</code> 包装成了一个 <code>KeyedWeakReference</code>（可以暂时看成一个普通的 WeakReference），然后 <code>watchExecutor</code> 会去执行一个 Runnable，这个 Runnable 会调用 <code>ensureGone(reference, watchStartNanoTime)</code> 函数。</p>\n<p>看这个函数之前猜测下，我们知道 <code>watch</code> 函数本身就是用来监听 <code>activity</code> 是否被正常回收，这就涉及到两个问题：</p>\n<ol>\n<li>何时去检查它是否回收？</li>\n<li>如何有效地检查它真的被回收？</li>\n</ol>\n<p>所以我们觉得 <code>ensureGone</code> 函数本身要做的事正如它的名字，就是确保 <code>reference</code> 被回收掉了，否则就意味着内存泄漏。</p>\n<h4 id=\"核心函数：ensureGone-reference-检测回收\"><a href=\"#核心函数：ensureGone-reference-检测回收\" class=\"headerlink\" title=\"核心函数：ensureGone(reference) 检测回收\"></a>核心函数：ensureGone(reference) 检测回收</h4><p>下面来看这个函数实现：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">void ensureGone(KeyedWeakReference reference, long watchStartNanoTime) &#123;</div><div class=\"line\">  removeWeaklyReachableReferences();</div><div class=\"line\">  if (gone(reference) || debuggerControl.isDebuggerAttached()) &#123;</div><div class=\"line\">    return;</div><div class=\"line\">  &#125;</div><div class=\"line\">  gcTrigger.runGc();</div><div class=\"line\">  removeWeaklyReachableReferences();</div><div class=\"line\">  if (!gone(reference)) &#123;</div><div class=\"line\">    File heapDumpFile = heapDumper.dumpHeap();</div><div class=\"line\">    heapdumpListener.analyze(</div><div class=\"line\">        new HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs, watchDurationMs,</div><div class=\"line\">            gcDurationMs, heapDumpDurationMs));</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">private boolean gone(KeyedWeakReference reference) &#123;</div><div class=\"line\">  return !retainedKeys.contains(reference.key);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">private void removeWeaklyReachableReferences() &#123;</div><div class=\"line\">  KeyedWeakReference ref;</div><div class=\"line\">  while ((ref = (KeyedWeakReference) queue.poll()) != null) &#123;</div><div class=\"line\">    retainedKeys.remove(ref.key);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里先来解释下 <code>WeakReference</code> 和 <code>ReferenceQueue</code> 的工作原理。</p>\n<ol>\n<li>弱引用 WeakReference<br>被强引用的对象就算发生 OOM 也永远不会被垃圾回收机回收；被弱引用的对象，只要被垃圾回收器发现就会立即被回收；被软引用的对象，具备内存敏感性，只有内存不足时才会被回收，常用来做内存敏感缓存器；虚引用则任意时刻都可能被回收，使用较少。</li>\n<li>引用队列 ReferenceQueue<br>我们常用一个 <code>WeakReference&lt;Activity&gt; reference = new WeakReference(activity);</code>，这里我们创建了一个 <code>reference</code> 来弱引用到某个 <code>activity</code>，当这个 <code>activity</code> 被垃圾回收器回收后，这个 <code>reference</code> 会被放入内部的 <code>ReferenceQueue</code> 中。也就是说，从队列 <code>ReferenceQueue</code> 取出来的所有 <code>reference</code>，它们指向的真实对象都已经成功被回收了。</li>\n</ol>\n<p>然后再回到上面的代码。</p>\n<p>在一个 activity 传给 RefWatcher 时会创建一个唯一的 key 对应这个 activity，该key存入一个集合 <code>retainedKeys</code> 中。也就是说，所有我们想要观测的 <code>activity</code> 对应的唯一 key 都会被放入 <code>retainedKeys</code> 集合中。</p>\n<p>基于我们对 <code>ReferenceQueue</code> 的了解，只要把队列中所有的 reference 取出来，并把对应 retainedKeys 里的key移除，剩下的 key 对应的对象都没有被回收。</p>\n<ol>\n<li>ensureGone 首先调用 <code>removeWeaklyReachableReferences</code> 把已被回收的对象的 key 从 retainedKeys 移除，剩下的 key 都是未被回收的对象；</li>\n<li>if (gone(reference)) 用来判断某个 reference 的key是否仍在 retainedKeys 里，若不在，表示已回收，否则继续；</li>\n<li>gcTrigger.runGc(); 手动出发 GC，立即把所有 WeakReference 引用的对象回收；</li>\n<li>removeWeaklyReachableReferences(); 再次清理 retainedKeys，如果该 reference 还在 retainedKeys里 (if (!gone(reference)))，表示泄漏；</li>\n<li>利用 heapDumper 把内存情况 dump 成文件，并调用 heapdumpListener 进行内存分析，进一步确认是否发生内存泄漏。</li>\n<li>如果确认发生内存泄漏，调用 <code>DisplayLeakService</code> 发送通知。</li>\n</ol>\n<p>至此，核心的内存泄漏检测机制便看完了。</p>\n<h2 id=\"内存泄漏检测小结\"><a href=\"#内存泄漏检测小结\" class=\"headerlink\" title=\"内存泄漏检测小结\"></a>内存泄漏检测小结</h2><p>从上面我们大概了解了内存泄漏检测机制，大概是以下几个步骤：</p>\n<ol>\n<li>利用 <code>application.registerActivityLifecycleCallbacks(lifecycleCallbacks)</code> 来监听整个生命周期内的 Activity <code>onDestoryed</code> 事件;</li>\n<li>当某个 <code>Activity</code> 被 destory 后，将它传给 RefWatcher 去做观测，确保其后续会被正常回收；</li>\n<li>RefWatcher 首先把 <code>Activity</code> 使用 KeyedWeakReference 引用起来，并使用一个 ReferenceQueue 来记录该 KeyedWeakReference 指向的对象是否已被回收；</li>\n<li><code>AndroidWatchExecutor</code> 会在 5s 后，开始检查这个弱引用内的 <code>Activity</code> 是否被正常回收。判断条件是：若 <code>Activity</code> 被正常回收，那么引用它的 KeyedWeakReference 会被自动放入 ReferenceQueue 中。</li>\n<li>判断方式是：先看 <code>Activity</code> 对应的 <code>KeyedWeakReference</code> 是否已经放入 <code>ReferenceQueue</code> 中；如果没有，则手动GC：<code>gcTrigger.runGc();</code>；然后再一次判断 <code>ReferenceQueue</code> 是否已经含有对应的 <code>KeyedWeakReference</code>。若还未被回收，则认为可能发生内存泄漏。</li>\n<li>利用 HeapAnalyzer 对 dump 的内存情况进行分析并进一步确认，若确定发生泄漏，则利用 <code>DisplayLeakService</code> 发送通知。</li>\n</ol>\n<h2 id=\"探讨一些关于-LeakCanary-有趣的问题\"><a href=\"#探讨一些关于-LeakCanary-有趣的问题\" class=\"headerlink\" title=\"探讨一些关于 LeakCanary 有趣的问题\"></a>探讨一些关于 <code>LeakCanary</code> 有趣的问题</h2><p>在学习了 <code>LeakCanary</code> 的源码之后，我想再提几个有趣的问题做些探讨。</p>\n<h3 id=\"LeakCanary-项目目录结构为什么这样分？\"><a href=\"#LeakCanary-项目目录结构为什么这样分？\" class=\"headerlink\" title=\"LeakCanary 项目目录结构为什么这样分？\"></a><code>LeakCanary</code> 项目目录结构为什么这样分？</h3><p>下面是整个 <code>LeakCanary</code> 的项目结构：<br><img src=\"/img/leakcanary/project.png\" alt=\"\"></p>\n<p>对于开发者而言，只需要使用到 <code>LeakCanary.install(this);</code> 这一句即可。那整个项目为什么要分成这么多个 module 呢？</p>\n<p>实际上，这里面每一个 module 都有自己的角色。</p>\n<ul>\n<li><p><code>leakcanary-watcher</code>: 这是一个通用的内存检测器，对外提供一个 RefWatcher#watch(Object watchedReference)，可以看出，它不仅能够检测 <code>Activity</code>，还能监测任意常规的 Java Object 的泄漏情况。</p>\n</li>\n<li><p><code>leakcanary-android</code>: 这个 module 是与 <code>Android</code> 世界的接入点，用来专门监测 <code>Activity</code> 的泄漏情况，内部使用了 application#registerActivityLifecycleCallbacks 方法来监听 onDestory 事件，然后利用 <code>leakcanary-watcher</code> 来进行弱引用＋手动 GC 机制进行监控。</p>\n</li>\n<li><p><code>leakcanary-analyzer</code>: 这个 module 提供了 <code>HeapAnalyzer</code>，用来对 dump 出来的内存进行分析并返回内存分析结果 <code>AnalysisResult</code>，内部包含了泄漏发生的路径等信息供开发者寻找定位。</p>\n</li>\n<li><p><code>leakcanary-android-no-op</code>: 这个 module 是专门给 release 的版本用的，内部只提供了两个完全空白的类 <code>LeakCanary</code> 和 <code>RefWatcher</code>，这两个类不会做任何内存泄漏相关的分析。为什么？因为 <code>LeakCanary</code> 本身会由于不断 gc 影响到 app 本身的运行，而且主要用于开发阶段的内存泄漏检测。因此对于 release 则可以 disable 所有泄漏分析。</p>\n</li>\n<li><p><code>leakcanary-sample</code>: 这个很简单，就是提供了一个用法 sample。</p>\n</li>\n</ul>\n<h3 id=\"当-Activity-被-destory-后，LeakCanary-多久后会去进行检查其是否泄漏呢？\"><a href=\"#当-Activity-被-destory-后，LeakCanary-多久后会去进行检查其是否泄漏呢？\" class=\"headerlink\" title=\"当 Activity 被 destory 后，LeakCanary 多久后会去进行检查其是否泄漏呢？\"></a>当 Activity 被 destory 后，LeakCanary 多久后会去进行检查其是否泄漏呢？</h3><p>在源码中可以看到，LeakCanary 并不会在 destory 后立即去检查，而是让一个 <code>AndroidWatchExecutor</code> 去进行检查。它会做什么呢？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override public void execute(final Runnable command) &#123;</div><div class=\"line\">  if (isOnMainThread()) &#123;</div><div class=\"line\">    executeDelayedAfterIdleUnsafe(command);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    mainHandler.post(new Runnable() &#123;</div><div class=\"line\">      @Override public void run() &#123;</div><div class=\"line\">        executeDelayedAfterIdleUnsafe(command);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">void executeDelayedAfterIdleUnsafe(final Runnable runnable) &#123;</div><div class=\"line\">  // This needs to be called from the main thread.</div><div class=\"line\">  Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() &#123;</div><div class=\"line\">    @Override public boolean queueIdle() &#123;</div><div class=\"line\">      backgroundHandler.postDelayed(runnable, delayMillis);</div><div class=\"line\">      return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到，它首先会向主线程的 MessageQueue 添加一个 <code>IdleHandler</code>。</p>\n<p>什么是 <code>IdleHandler</code>？我们知道 Looper 会不断从 MessageQueue 里取出 Message 并执行。当没有新的 Message 执行时，Looper 进入 Idle 状态时，就会取出 <code>IdleHandler</code> 来执行。</p>\n<p>换句话说，<code>IdleHandler</code>就是<code>优先级别较低的 Message</code>，只有当 Looper 没有消息要处理时才得到处理。而且，内部的 <code>queueIdle()</code> 方法若返回 <code>true</code>，表示该任务一直存活，每次 Looper 进入 Idle 时就执行；反正，如果返回 <code>false</code>，则表示只会执行一次，执行完后丢弃。</p>\n<p>那么，这件优先级较低的任务是什么呢？<code>backgroundHandler.postDelayed(runnable, delayMillis);</code>，runnable 就是之前 <code>ensureGone()</code>。</p>\n<p>也就是说，当主线程空闲了，没事做了，开始向后台线程发送一个延时消息，告诉后台线程，5s(delayMillis)后开始检查 <code>Activity</code> 是否被回收了。</p>\n<p>所以，当 <code>Activity</code> 发生 <code>destory</code> 后，首先要等到主线程空闲，然后再延时 5s(delayMillis)，才开始执行泄漏检查。</p>\n<h5 id=\"知识点：\"><a href=\"#知识点：\" class=\"headerlink\" title=\"知识点：\"></a>知识点：</h5><ol>\n<li><p>如何创建一个优先级低的主线程任务，它只会在主线程空闲时才执行，不会影响到app的性能？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() &#123;</div><div class=\"line\">      @Override public boolean queueIdle() &#123;</div><div class=\"line\">        // do task</div><div class=\"line\">        return false; // only once</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p>如何快速创建一个主／子线程handler？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">//主线程handler</div><div class=\"line\">mainHandler = new Handler(Looper.getMainLooper());</div><div class=\"line\"></div><div class=\"line\">//子线程handler</div><div class=\"line\">HandlerThread handlerThread = new HandlerThread(“子线程任务”);</div><div class=\"line\">handlerThread.start();</div><div class=\"line\">Handler backgroundHandler = new Handler(handlerThread.getLooper());</div></pre></td></tr></table></figure>\n</li>\n<li><p>如何快速判断当前是否运行在主线程？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Looper.getMainLooper().getThread() == Thread.currentThread();</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"System-gc-可以触发立即-gc-吗？如果不行那怎么才能触发即时-gc-呢？\"><a href=\"#System-gc-可以触发立即-gc-吗？如果不行那怎么才能触发即时-gc-呢？\" class=\"headerlink\" title=\"System.gc() 可以触发立即 gc 吗？如果不行那怎么才能触发即时 gc 呢？\"></a>System.gc() 可以触发立即 gc 吗？如果不行那怎么才能触发即时 gc 呢？</h3><p>在 LeakCanary 里，需要立即触发 gc，并在之后立即判断弱引用是否被回收。这意味着该 gc 必须能够立即同步执行。</p>\n<p>常用的触发 gc 方法是 <code>System.gc()</code>，那它能达到我们的要求吗？</p>\n<p>我们来看下其实现方式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Indicates to the VM that it would be a good time to run the</div><div class=\"line\"> * garbage collector. Note that this is a hint only. There is no guarantee</div><div class=\"line\"> * that the garbage collector will actually be run.</div><div class=\"line\"> */</div><div class=\"line\">public static void gc() &#123;</div><div class=\"line\">    boolean shouldRunGC;</div><div class=\"line\">    synchronized(lock) &#123;</div><div class=\"line\">        shouldRunGC = justRanFinalization;</div><div class=\"line\">        if (shouldRunGC) &#123;</div><div class=\"line\">            justRanFinalization = false;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            runGC = true;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (shouldRunGC) &#123;</div><div class=\"line\">        Runtime.getRuntime().gc();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注释里清楚说了，<code>System.gc()</code>只是建议垃圾回收器来执行回收，但是<code>不能保证真的去回收</code>。从代码也能看出，必须先判断 <code>shouldRunGC</code> 才能决定是否真的要 gc。</p>\n<h5 id=\"知识点：-1\"><a href=\"#知识点：-1\" class=\"headerlink\" title=\"知识点：\"></a>知识点：</h5><p>那要怎么实现 即时 GC 呢？</p>\n<p><code>LeakCanary</code> 参考了一段 <a href=\"https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/java/lang/ref/FinalizationTester.java\" target=\"_blank\" rel=\"external\">AOSP 的代码</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">// System.gc() does not garbage collect every time. Runtime.gc() is</div><div class=\"line\">// more likely to perfom a gc.</div><div class=\"line\">Runtime.getRuntime().gc();</div><div class=\"line\">enqueueReferences();</div><div class=\"line\">System.runFinalization();</div><div class=\"line\">public static void enqueueReferences() &#123;</div><div class=\"line\">    /*</div><div class=\"line\">     * Hack. We don&apos;t have a programmatic way to wait for the reference queue</div><div class=\"line\">     * daemon to move references to the appropriate queues.</div><div class=\"line\">     */</div><div class=\"line\">    try &#123;</div><div class=\"line\">        Thread.sleep(100);</div><div class=\"line\">    &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">        throw new AssertionError();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"可以怎样来改造-LeakCanary-呢？\"><a href=\"#可以怎样来改造-LeakCanary-呢？\" class=\"headerlink\" title=\"可以怎样来改造 LeakCanary 呢？\"></a>可以怎样来改造 LeakCanary 呢？</h3><h5 id=\"忽略某些已知泄漏的类或Activity\"><a href=\"#忽略某些已知泄漏的类或Activity\" class=\"headerlink\" title=\"忽略某些已知泄漏的类或Activity\"></a>忽略某些已知泄漏的类或Activity</h5><p>LeakCanary 提供了 ExcludedRefs 类，可以向里面添加某些主动忽略的类。比如已知 Android 源代码里有某些内存泄漏，不属于我们 App 的泄漏，那么就可以 exclude 掉。</p>\n<p>另外，如果不想监控某些特殊的 Activity，那么可以在 <code>onActivityDestroyed(Activity activity)</code> 里，过滤掉特殊的 Activity，只对其它 Activity 调用 <code>refWatcher.watch(activity)</code> 监控。</p>\n<h5 id=\"把内存泄漏数据上传至服务器\"><a href=\"#把内存泄漏数据上传至服务器\" class=\"headerlink\" title=\"把内存泄漏数据上传至服务器\"></a>把内存泄漏数据上传至服务器</h5><p>在 LeakCanary 提供了 <code>AbstractAnalysisResultService</code>，它是一个 intentService，接收到的 intent 内包含了 <code>HeapDump</code> 数据和 <code>AnalysisResult</code> 结果，我们只要继承这个类，实现自己的 <code>listenerServiceClass</code>，就可以将堆数据和分析结果上传到我们自己的服务器上。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>本文通过源代码分析了 LeakCanary 的原理，并提出了一些有趣的问题，学习了一些实用的知识点。希望对读者有所启发，欢迎与我讨论。</p>\n<p>之后会继续挑选优质开源项目进行分析，欢迎提意见。</p>\n<p>谢谢。</p>\n<p>wingjay</p>\n<p><a href=\"http://wingjay.com\">http://wingjay.com</a></p>\n<p><img src=\"https://avatars0.githubusercontent.com/u/9619875?v=3&amp;s=460\" alt=\"\"></p>","sticky":0},{"title":"带你学开源项目：OkHttp-- 自己动手实现 okhttp","date":"2016-07-21T06:54:33.000Z","commentIssueId":14,"_content":"> 私以为，阅读开源项目是与世界级技术大牛直接对话的最好方式。\n此次来分享下 OkHttp 源码的分析。\n\n<!-- more -->\n\n## 一、开源项目 OkHttp\n在Android、Java开发领域中，相信大家都听过或者在使用Square家大名鼎鼎的网络请求库——[OkHttp](https://github.com/square/okhttp)——https://github.com/square/okhttp ，当前多数著名的开源项目如 [Fresco](https://github.com/facebook/fresco)、[Glide](https://github.com/bumptech/glide)、 [Picasso](https://github.com/square/picasso)、 [Retrofit](https://github.com/square/retrofit)都在使用OkHttp，这足以说明其质量，而且该项目仍处在[不断维护中](https://github.com/square/okhttp/commits/master)。\n\n\n## 二、问题\n在分析okhttp源码之前，我想先提出一个问题，如果我们自己来设计一个网络请求库，这个库应该长什么样子？大致是什么结构呢？\n\n下面我和大家一起来构建一个网络请求库，并在其中融入okhttp中核心的设计思想，希望借此让读者感受并学习到okhttp中的精华之处，而非仅限于了解其实现。\n\n笔者相信，如果你能耐心阅读完本篇，不仅能对http协议有进一步理解，更能够学习到世界级项目的思维精华，提高自身思维方式。\n\n## 三、思考\n首先，我们假设要构建的的网络请求库叫做`WingjayHttpClient`，那么，作为一个网络请求库，它最基本功能是什么呢？\n\n在我看来应该是：接收用户的请求 -> 发出请求 -> 接收响应结果并返回给用户。\n\n那么从使用者角度而言，需要做的事是：\n\n1. 创建一个`Request`：在里面设置好目标URL；请求method如GET/POST等；一些header如Host、User-Agent等；如果你在POST上传一个表单，那么还需要body。\n2. 将创建好的`Request`传递给`WingjayHttpClient`。\n3. `WingjayHttpClient`去执行`Request`，并把返回结果封装成一个`Response`给用户。而一个`Response`里应该包括statusCode如200，一些header如content-type等，可能还有body\n\n到此即为一次完整请求的雏形。那么下面我们来具体实现这三步。\n\n## 四、雏形实现\n下面我们先来实现一个httpClient的雏形，只具备最基本的功能。\n\n#### 1. 创建`Request`类\n首先，我们要建立一个`Request`类，利用`Request`类用户可以把自己需要的参数传入进去，基本形式如下：\n```\nclass Request {\n\tString url;\n\tString method;\n\tHeaders headers;\n\tBody requestBody;\n\n\tpublic Request(String url, String method, @Nullable Headers headers, @Nullable Body body) {\n\t\tthis.url = url;\n\t\t...\n\t}\n}\n```\n#### 2. 将`Request`对象传递给`WingjayHttpClient`\n我们可以设计`WingjayHttpClient`如下：\n```\nclass WingjayHttpClient {\n\tpublic Response sendRequest(Request request) {\n\t\treturn executeRequest(request);\n\t}\n}\n```\n#### 3. 执行`Request`，并把返回结果封装成一个`Response`返回\n```\nclass WingjayHttpClient {\n\t...\n\tprivate Response executeRequest(Request request) {\n\t\t//使用socket来进行访问\n\t\tSocket socket = new Socket(request.getUrl(), 80);\n\t\tResponseData data = socket.connect().getResponseData();\n\t\treturn new Response(data);\n\t}\n\t...\n}\n\nclass Response {\n\tint statusCode;\n\tHeaders headers;\n\tBody responseBody\n\t...\n}\n```\n\n## 五、功能扩展\n利用上面的雏形，可以得到其使用方法如下：\n```\nRequest request = new Request(\"http://wingjay.com\");\nWingjayHttpClient client = new WingjayHttpClient();\nResponse response = client.sendRequest(request);\nhandle(response);\n```\n\n然而，上面的雏形是远远不能胜任常规的应用需求的，因此，下面再来对它添加一些常用的功能模块。\n\n#### 1. 重新把简陋的user Request组装成一个规范的http request\n一般的request中，往往用户只会指定一个URL和method，这个简单的user request是不足以成为一个http request，我们还需要为它添加一些header，如Content-Length, Transfer-Encoding, User-Agent, Host, Connection, 和 Content-Type，如果这个request使用了cookie，那我们还要将cookie添加到这个request中。\n\n我们可以扩展上面的`sendRequest(request)`方法：\n```\n[class WingjayHttpClient]\n\npublic Response sendRequest(Request userRequest) {\n    Request httpRequest = expandHeaders(userRequest);\n    return executeRequest(httpRequest);\n}\n\nprivate Request expandHeaders(Request userRequest) {\n    if (userRequest.header(\"Connection\") == null) {\n      requestBuilder.header(\"Connection\", \"Keep-Alive\");\n    }\n    \n    if (userRequest.header(\"User-Agent\") == null) {\n      requestBuilder.header(\"User-Agent\", Version.userAgent());\n    }\n    ...\n}\t\n```\n\n#### 2. 支持自动重定向\n有时我们请求的URL已经被移走了，此时server会返回301状态码和一个重定向的新URL，此时我们要能够支持自动访问新URL而不是向用户报错。\n\n对于重定向这里有一个测试性URL：http://www.publicobject.com/helloworld.txt ，通过访问并抓包，可以看到如下信息：\n\n![](http://upload-images.jianshu.io/upload_images/281665-62df4e64fd04dc24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n因此，我们在接收到Response后要根据status_code是否为重定向，如果是，则要从Response Header里解析出新的URL－`Location`并自动请求新URL。那么，我们可以继续改写`sendRequest(request)`方法：\n```java\n[class WingjayHttpClient]\n\nprivate boolean allowRedirect = true;\n// user can set redirect status when building WingjayHttpClient\npublic void setAllowRedirect(boolean allowRedirect) {\n\tthis.allowRedirect = allowRedirect;\n}\n\npublic Response sendRequest(Request userRequest) {\n\t\tRequest httpRequest = expandHeaders(userRequest);\n\t\tResponse response = executeRequest(httpRequest);\n\t\tswitch (response.statusCode()) {\n\t\t\t// 300: multi choice; 301: moven permanently; \n\t\t\t// 302: moved temporarily; 303: see other; \n\t\t\t// 307: redirect temporarily; 308: redirect permanently\n\t\t\tcase 300:\n\t\t\tcase 301:\n\t\t\tcase 302:\n\t\t\tcase 303:\n\t\t\tcase 307:\n\t\t\tcase 308:\n\t\t\t\treturn handleRedirect(response);\n\t\t\tdefault:\n\t\t\t\treturn response;\n\t\t}\n\t\t\n}\n// the max times of followup request\nprivate static final int MAX_FOLLOW_UPS = 20;\nprivate int followupCount = 0;\n\nprivate Response handleRedirect(Response response) {\n\t// Does the WingjayHttpClient allow redirect?\n\tif (!client.allowRedirect()) {\n\t\treturn null;\n\t}\n\n\t// Get the redirecting url\n\tString nextUrl = response.header(\"Location\");\n\n\t// Construct a redirecting request\n\tRequest followup = new Request(nextUrl);\n\n\t// check the max followupCount\n\tif (++followupCount > MAX_FOLLOW_UPS) {\n\t\tthrow new Exception(\"Too many follow-up requests: \" + followUpCount);\n\t}\n\n\t// not reach the max followup times, send followup request then.\n\treturn sendRequest(followup);\n}\n```\n利用上面的代码，我们通过获取原始`userRequest`的返回结果，判断结果是否为重定向，并做出自动followup处理。\n\n> 一些常用的状态码\n100~199：指示信息，表示请求已接收，继续处理\n200~299：请求成功，表示请求已被成功接收、理解、接受\n300~399：重定向，要完成请求必须进行更进一步的操作\n400~499：客户端错误，请求有语法错误或请求无法实现\n500~599：服务器端错误，服务器未能实现合法的请求\n\n#### 3. 支持重试机制\n所谓重试，和重定向非常类似，即通过判断`Response`状态，如果连接服务器失败等，那么可以尝试获取一个新的路径进行重新连接，大致的实现和重定向非常类似，此不赘述。\n\n#### 4. Request & Response 拦截机制\n这是非常核心的部分。\n\n通过上面的重新组装`request`和重定向机制，我们可以感受的，一个`request`从user创建出来后，会经过层层处理后，才真正发出去，而一个`response`，也会经过各种处理，最终返回给用户。\n\n笔者认为这和网络协议栈非常相似，用户在应用层发出简单的数据，然后经过传输层、网络层等，层层封装后真正把请求从物理层发出去，当请求结果回来后又层层解析，最终把最直接的结果返回给用户使用。\n\n最重要的是，每一层都是抽象的，互不相关的！\n\n因此在我们设计时，也可以借鉴这个思想，通过设置`拦截器Interceptor`，每个拦截器会做两件事情：\n\n1. 接收上一层拦截器封装后的request，然后自身对这个request进行处理，例如添加一些header，处理后向下传递；\n2. 接收下一层拦截器传递回来的response，然后自身对response进行处理，例如判断返回的statusCode，然后进一步处理。\n\n那么，我们可以为拦截器定义一个抽象接口，然后去实现具体的拦截器。\n```java\ninterface Interceptor {\n\tResponse intercept(Request request);\n}\n```\n大家可以看下上面这个拦截器设计是否有问题？\n\n![](http://upload-images.jianshu.io/upload_images/281665-00ec5b478499a386.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们想象这个拦截器能够接收一个request，进行拦截处理，并返回结果。\n\n但实际上，它无法返回结果，而且它在处理request后，并不能继续向下传递，因为它并不知道下一个`Interceptor`在哪里，也就无法继续向下传递。\n\n那么，如何解决才能把所有`Interceptor`串在一起，并能够依次传递下去。\n```java\npublic interface Interceptor {\n  Response intercept(Chain chain);\n\n  interface Chain {\n    Request request();\n\n    Response proceed(Request request);\n  }\n}\n```\n使用方法如下：假如我们现在有三个`Interceptor`需要依次拦截：\n```java\n// Build a full stack of interceptors.\nList<Interceptor> interceptors = new ArrayList<>();\ninterceptors.add(new MyInterceptor1());\ninterceptors.add(new MyInterceptor2());\ninterceptors.add(new MyInterceptor3());\n\nInterceptor.Chain chain = new RealInterceptorChain(\n        interceptors, 0, originalRequest);\nchain.proceed(originalRequest);        \n```\n里面的`RealInterceptorChain`的基本思想是：我们把所有`interceptors`传进去，然后`chain`去依次把`request`传入到每一个`interceptors`进行拦截即可。\n\n通过下面的示意图可以明确看出拦截流程：\n\n![](http://upload-images.jianshu.io/upload_images/281665-aa94adfc49da4e40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n其中，`RetryAndFollowupInterceptor`是用来做自动重试和自动重定向的拦截器；`BridgeInterceptor`是用来扩展`request`的`header`的拦截器。这两个拦截器存在于`okhttp`里，实际上在`okhttp`里还有好几个拦截器，这里暂时不做深入分析。\n\n![](http://upload-images.jianshu.io/upload_images/281665-1b58154250ce74d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n1. `CacheInterceptor`\n这是用来拦截请求并提供缓存的，当request进入这一层，它会自动去检查缓存，如果有，就直接返回缓存结果；否则的话才将request继续向下传递。而且，当下层把response返回到这一层，它会根据需求进行缓存处理；\n\n2. `ConnectInterceptor`\n这一层是用来与目标服务器建立连接\n\n3. `CallServerInterceptor`\n这一层位于最底层，直接向服务器发出请求，并接收服务器返回的response，并向上层层传递。\n\n上面几个都是okhttp自带的，也就是说需要在`WingjayHttpClient`自己实现的。除了这几个功能性的拦截器，我们还要支持用户`自定义拦截器`，主要有以下两种（见图中非虚线框蓝色字部分）：\n\n1. `interceptors`\n这里的拦截器是拦截用户最原始的request。\n\n2. `NetworkInterceptor`\n这是最底层的request拦截器。\n\n如何区分这两个呢？举个例子，我创建两个`LoggingInterceptor`，分别放在`interceptors`层和`NetworkInterceptor`层，然后访问一个会重定向的`URL_1`，当访问完`URL_1`后会再去访问重定向后的新地址`URL_2`。对于这个过程，`interceptors`层的拦截器只会拦截到`URL_1`的request，而在`NetworkInterceptor`层的拦截器则会同时拦截到`URL_1`和`URL_2`两个request。具体原因可以看上面的图。\n\n#### 5. 同步、异步 Request池管理机制\n这是非常核心的部分。\n\n通过上面的工作，我们修改`WingjayHttpClient`后得到了下面的样子：\n```java\nclass WingjayHttpClient {\n\tpublic Response sendRequest(Request userRequest) {\n\t\tRequest httpRequest = expandHeaders(userRequest);\n\t\tResponse response = executeRequest(httpRequest);\n\t\tswitch (response.statusCode()) {\n\t\t\t// 300: multi choice; 301: moven permanently; \n\t\t\t// 302: moved temporarily; 303: see other; \n\t\t\t// 307: redirect temporarily; 308: redirect permanently\n\t\t\tcase 300:\n\t\t\tcase 301:\n\t\t\tcase 302:\n\t\t\tcase 303:\n\t\t\tcase 307:\n\t\t\tcase 308:\n\t\t\t\treturn handleRedirect(response);\n\t\t\tdefault:\n\t\t\t\treturn response;\n\t\t}\n\t}\n\n\tprivate Request expandHeaders(Request userRequest) {...}\n\tprivate Response executeRequest(Request httpRequest) {...}\n\tprivate Response handleRedirect(Response response) {...}\n}\n```\n也就是说，`WingjayHttpClient`现在能够`同步`地处理单个`Request`了。\n\n然而，在实际应用中，一个`WingjayHttpClient`可能会被用于同时处理几十个用户request，而且这些request里还分成了`同步`和`异步`两种不同的请求方式，所以我们显然不能简单把一个request直接塞给`WingjayHttpClient`。\n\n我们知道，一个request除了上面定义的http协议相关的内容，还应该要设置其处理方式`同步`和`异步`。那这些信息应该存在哪里呢？两种选择：\n\n1. 直接放入`Request`\n从理论上来讲是可以的，但是却违背了初衷。我们最开始是希望用`Request`来构造符合http协议的一个请求，里面应该包含的是请求目标网址URL，请求端口，请求方法等等信息，而http协议是不关心这个request是同步还是异步之类的信息\n\n2. 创建一个类，专门来管理`Request`的状态\n这是更为合适的，我们可以更好的拆分职责。\n\n因此，这里选择创建两个类`SyncCall`和`AsyncCall`，用来区分`同步`和`异步`。\n```java\nclass SyncCall {\n\tprivate Request userRequest;\n\n\tpublic SyncCall(Request userRequest) {\n\t\tthis.userRequest = userRequest;\n\t}\n}\n\nclass AsyncCall {\n\tprivate Request userRequest;\n\tprivate Callback callback;\n\n\tpublic AsyncCall(Request userRequest, Callback callback) {\n\t\tthis.userRequest = userRequest;\n\t\tthis.callback = callback;\n\t}\n\n\tinterface Callback {\n\t\tvoid onFailure(Call call, IOException e);\n\t\tvoid onResponse(Call call, Response response) throws IOException;\n\t}\n}\n```\n基于上面两个类，我们的使用场景如下：\n```java\nWingjayHttpClient client = new WingjayHttpClient();\n// Sync\nRequest syncRequest = new Request(\"http://wingjay.com\");\nSyncCall syncCall = new SyncCall(request);\nResponse response = client.sendSyncCall(syncCall);\nhandle(response);\n\n// Async\nAsyncCall asyncCall = new AsyncCall(request, new CallBack() {\n\t  @Override\n      public void onFailure(Call call, IOException e) {}\n\n      @Override\n      public void onResponse(Call call, Response response) throws IOException {\n        handle(response);\n      }\n});\nclient.equeueAsyncCall(asyncCall);\n```\n从上面的代码可以看到，`WingjayHttpClient`的职责发生了变化：以前是**response = client.sendRequest(request);**，而现在变成了\n```java\nresponse = client.sendSyncCall(syncCall);\n\nclient.equeueAsyncCall(asyncCall);\n```\n\n那么，我们也需要对`WingjayHttpClient`进行改造，基本思路是在内部添加`请求池`来对所有request进行管理。那么这个`请求池`我们怎么来设计呢？有两个方法：\n\n1. 直接在`WingjayHttpClient`内部创建几个容器\n同样，从理论上而言是可行的。当用户把(a)syncCall传给client后，client自动把call存入对应的容器进行管理。\n\n2. 创建一个独立的类进行管理\n显然这样可以更好的分配职责。我们把`WingjayHttpClient`的职责定义为，接收一个call，内部进行处理后返回结果。这就是`WingjayHttpClient`的任务，那么具体如何去管理这些request的执行顺序和生命周期，自然不需要由它来管。\n\n因此，我们创建一个新的类：`Dispatcher`，这个类的作用是：\n\n1. 存储外界不断传入的`SyncCall`和`AsyncCall`，如果用户想取消则可以遍历所有的call进行cancel操作;\n2. 对于`SyncCall`，由于它是即时运行的，因此`Dispatcher`只需要在`SyncCall`运行前存储进来，在运行结束后移除即可；\n3. 对于`AsyncCall`，`Dispatcher`首先启动一个ExecutorService，不断取出`AsyncCall`去进行执行，然后，我们设置最多执行的request数量为64，如果已经有64个request在执行中，那么就将这个asyncCall存入等待区。\n\n根据设计可以得到`Dispatcher`构造：\n```java\nclass Dispatcher {\n\t// sync call\n\tprivate final Deque<SyncCall> runningSyncCalls = new ArrayDeque<>();\n\t// async call\n\tprivate int maxRequests = 64;\n\tprivate final Deque<AsyncCall> waitingAsyncCalls = new ArrayDeque<>();\n\tprivate final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();\n\tprivate ExecutorService executorService;\n\n\t// begin execute Sync call\n\tpublic void startSyncCall(SyncCall syncCall) {\n\t\trunningSyncCalls.add(syncCall);\n\t}\n\t// finish Sync call\n\tpublic void finishSyncCall(SyncCall syncCall) {\n\t\trunningSyncCalls.remove(syncCall);\n\t}\n\n\t// enqueue a new AsyncCall\n\tpublic void enqueue(AsyncCall asyncCall) {\n\t\tif (runningAsyncCalls.size() < 64) {\n\t\t\t// run directly\n\t\t\trunningAsyncCalls.add(asyncCall);\n\t\t\texecutorService.execute(asyncCall);\n\t\t} else {\n\t\t\treadyAsyncCalls.add(asyncCall);\n\t\t}\n\t}\n\t// finish a AsyncCall\n\tpublic void finishAsyncCall(AsyncCall asyncCall) {\n\t\trunningAsyncCalls.remove(asyncCall);\n\t}\n}\n```\n有了这个`Dispatcher`，那我们就可以去修改`WingjayHttpClient`以实现\n```java\nresponse = client.sendSyncCall(syncCall);\n\nclient.equeueAsyncCall(asyncCall);\n```\n这两个方法了。具体实现如下\n```java\n[class WingjayHttpClient]\n\n\tprivate Dispatcher dispatcher;\n\n\tpublic Response sendSyncCall(SyncCall syncCall) {\n\t\ttry {\n\t\t\t// store syncCall into dispatcher;\n\t\t\tdispatcher.startSyncCall(syncCall);\n\t\t\t// execute\n\t\t\treturn sendRequest(syncCall.getRequest());\n\t\t} finally {\n\t\t\t// remove syncCall from dispatcher\n\t\t\tdispatcher.finishSyncCall(syncCall);\n\t\t}\n\t}\n\n\tpublic void equeueAsyncCall(AsyncCall asyncCall) {\n\t\t// store asyncCall into dispatcher;\n\t\tdispatcher.enqueue(asyncCall);\n\t\t// it will be removed when this asyncCall be executed\n\t}\n```\n\n基于以上，我们能够很好的处理`同步`和`异步`两种请求，使用场景如下：\n```java\nWingjayHttpClient client = new WingjayHttpClient();\n// Sync\nRequest syncRequest = new Request(\"http://wingjay.com\");\nSyncCall syncCall = new SyncCall(request);\nResponse response = client.sendSyncCall(syncCall);\nhandle(response);\n\n// Async\nAsyncCall asyncCall = new AsyncCall(request, new CallBack() {\n\t  @Override\n      public void onFailure(Call call, IOException e) {}\n\n      @Override\n      public void onResponse(Call call, Response response) throws IOException {\n        handle(response);\n      }\n});\nclient.equeueAsyncCall(asyncCall);\n```\n\n## 六、总结\n到此，我们基本把`okhttp`里核心的机制都讲解了一遍，相信读者对于okhttp的整体结构和核心机制都有了较为详细的了解。\n\n如果有问题欢迎联系我。\n\n谢谢！\n\nwingjay\n\n\n\n\n\n欢迎各位关注\n[我的Github](https://github.com/wingjay): <https://github.com/wingjay> \n和\n[我的简书](http://www.jianshu.com/users/da333fd63fe5/latest_articles): <http://www.jianshu.com/users/da333fd63fe5/latest_articles>\n和\n[微博 iam_wingjay](http://weibo.com/u/1625892654): <http://weibo.com/u/1625892654>\n如果有问题，可以给我留言或发邮件<mailto:yinjiesh@126.com>\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/带你学开源项目：OkHttp-自己动手实现okhttp.md","raw":"title: 带你学开源项目：OkHttp--自己动手实现okhttp\ndate: 2016-07-21 14:54:33\ncategories:\n  - Android\n  - 带你学开源项目\ntags:\n    - Android\n    - 带你学开源项目\ncommentIssueId: 14    \n---\n> 私以为，阅读开源项目是与世界级技术大牛直接对话的最好方式。\n此次来分享下 OkHttp 源码的分析。\n\n<!-- more -->\n\n## 一、开源项目 OkHttp\n在Android、Java开发领域中，相信大家都听过或者在使用Square家大名鼎鼎的网络请求库——[OkHttp](https://github.com/square/okhttp)——https://github.com/square/okhttp ，当前多数著名的开源项目如 [Fresco](https://github.com/facebook/fresco)、[Glide](https://github.com/bumptech/glide)、 [Picasso](https://github.com/square/picasso)、 [Retrofit](https://github.com/square/retrofit)都在使用OkHttp，这足以说明其质量，而且该项目仍处在[不断维护中](https://github.com/square/okhttp/commits/master)。\n\n\n## 二、问题\n在分析okhttp源码之前，我想先提出一个问题，如果我们自己来设计一个网络请求库，这个库应该长什么样子？大致是什么结构呢？\n\n下面我和大家一起来构建一个网络请求库，并在其中融入okhttp中核心的设计思想，希望借此让读者感受并学习到okhttp中的精华之处，而非仅限于了解其实现。\n\n笔者相信，如果你能耐心阅读完本篇，不仅能对http协议有进一步理解，更能够学习到世界级项目的思维精华，提高自身思维方式。\n\n## 三、思考\n首先，我们假设要构建的的网络请求库叫做`WingjayHttpClient`，那么，作为一个网络请求库，它最基本功能是什么呢？\n\n在我看来应该是：接收用户的请求 -> 发出请求 -> 接收响应结果并返回给用户。\n\n那么从使用者角度而言，需要做的事是：\n\n1. 创建一个`Request`：在里面设置好目标URL；请求method如GET/POST等；一些header如Host、User-Agent等；如果你在POST上传一个表单，那么还需要body。\n2. 将创建好的`Request`传递给`WingjayHttpClient`。\n3. `WingjayHttpClient`去执行`Request`，并把返回结果封装成一个`Response`给用户。而一个`Response`里应该包括statusCode如200，一些header如content-type等，可能还有body\n\n到此即为一次完整请求的雏形。那么下面我们来具体实现这三步。\n\n## 四、雏形实现\n下面我们先来实现一个httpClient的雏形，只具备最基本的功能。\n\n#### 1. 创建`Request`类\n首先，我们要建立一个`Request`类，利用`Request`类用户可以把自己需要的参数传入进去，基本形式如下：\n```\nclass Request {\n\tString url;\n\tString method;\n\tHeaders headers;\n\tBody requestBody;\n\n\tpublic Request(String url, String method, @Nullable Headers headers, @Nullable Body body) {\n\t\tthis.url = url;\n\t\t...\n\t}\n}\n```\n#### 2. 将`Request`对象传递给`WingjayHttpClient`\n我们可以设计`WingjayHttpClient`如下：\n```\nclass WingjayHttpClient {\n\tpublic Response sendRequest(Request request) {\n\t\treturn executeRequest(request);\n\t}\n}\n```\n#### 3. 执行`Request`，并把返回结果封装成一个`Response`返回\n```\nclass WingjayHttpClient {\n\t...\n\tprivate Response executeRequest(Request request) {\n\t\t//使用socket来进行访问\n\t\tSocket socket = new Socket(request.getUrl(), 80);\n\t\tResponseData data = socket.connect().getResponseData();\n\t\treturn new Response(data);\n\t}\n\t...\n}\n\nclass Response {\n\tint statusCode;\n\tHeaders headers;\n\tBody responseBody\n\t...\n}\n```\n\n## 五、功能扩展\n利用上面的雏形，可以得到其使用方法如下：\n```\nRequest request = new Request(\"http://wingjay.com\");\nWingjayHttpClient client = new WingjayHttpClient();\nResponse response = client.sendRequest(request);\nhandle(response);\n```\n\n然而，上面的雏形是远远不能胜任常规的应用需求的，因此，下面再来对它添加一些常用的功能模块。\n\n#### 1. 重新把简陋的user Request组装成一个规范的http request\n一般的request中，往往用户只会指定一个URL和method，这个简单的user request是不足以成为一个http request，我们还需要为它添加一些header，如Content-Length, Transfer-Encoding, User-Agent, Host, Connection, 和 Content-Type，如果这个request使用了cookie，那我们还要将cookie添加到这个request中。\n\n我们可以扩展上面的`sendRequest(request)`方法：\n```\n[class WingjayHttpClient]\n\npublic Response sendRequest(Request userRequest) {\n    Request httpRequest = expandHeaders(userRequest);\n    return executeRequest(httpRequest);\n}\n\nprivate Request expandHeaders(Request userRequest) {\n    if (userRequest.header(\"Connection\") == null) {\n      requestBuilder.header(\"Connection\", \"Keep-Alive\");\n    }\n    \n    if (userRequest.header(\"User-Agent\") == null) {\n      requestBuilder.header(\"User-Agent\", Version.userAgent());\n    }\n    ...\n}\t\n```\n\n#### 2. 支持自动重定向\n有时我们请求的URL已经被移走了，此时server会返回301状态码和一个重定向的新URL，此时我们要能够支持自动访问新URL而不是向用户报错。\n\n对于重定向这里有一个测试性URL：http://www.publicobject.com/helloworld.txt ，通过访问并抓包，可以看到如下信息：\n\n![](http://upload-images.jianshu.io/upload_images/281665-62df4e64fd04dc24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n因此，我们在接收到Response后要根据status_code是否为重定向，如果是，则要从Response Header里解析出新的URL－`Location`并自动请求新URL。那么，我们可以继续改写`sendRequest(request)`方法：\n```java\n[class WingjayHttpClient]\n\nprivate boolean allowRedirect = true;\n// user can set redirect status when building WingjayHttpClient\npublic void setAllowRedirect(boolean allowRedirect) {\n\tthis.allowRedirect = allowRedirect;\n}\n\npublic Response sendRequest(Request userRequest) {\n\t\tRequest httpRequest = expandHeaders(userRequest);\n\t\tResponse response = executeRequest(httpRequest);\n\t\tswitch (response.statusCode()) {\n\t\t\t// 300: multi choice; 301: moven permanently; \n\t\t\t// 302: moved temporarily; 303: see other; \n\t\t\t// 307: redirect temporarily; 308: redirect permanently\n\t\t\tcase 300:\n\t\t\tcase 301:\n\t\t\tcase 302:\n\t\t\tcase 303:\n\t\t\tcase 307:\n\t\t\tcase 308:\n\t\t\t\treturn handleRedirect(response);\n\t\t\tdefault:\n\t\t\t\treturn response;\n\t\t}\n\t\t\n}\n// the max times of followup request\nprivate static final int MAX_FOLLOW_UPS = 20;\nprivate int followupCount = 0;\n\nprivate Response handleRedirect(Response response) {\n\t// Does the WingjayHttpClient allow redirect?\n\tif (!client.allowRedirect()) {\n\t\treturn null;\n\t}\n\n\t// Get the redirecting url\n\tString nextUrl = response.header(\"Location\");\n\n\t// Construct a redirecting request\n\tRequest followup = new Request(nextUrl);\n\n\t// check the max followupCount\n\tif (++followupCount > MAX_FOLLOW_UPS) {\n\t\tthrow new Exception(\"Too many follow-up requests: \" + followUpCount);\n\t}\n\n\t// not reach the max followup times, send followup request then.\n\treturn sendRequest(followup);\n}\n```\n利用上面的代码，我们通过获取原始`userRequest`的返回结果，判断结果是否为重定向，并做出自动followup处理。\n\n> 一些常用的状态码\n100~199：指示信息，表示请求已接收，继续处理\n200~299：请求成功，表示请求已被成功接收、理解、接受\n300~399：重定向，要完成请求必须进行更进一步的操作\n400~499：客户端错误，请求有语法错误或请求无法实现\n500~599：服务器端错误，服务器未能实现合法的请求\n\n#### 3. 支持重试机制\n所谓重试，和重定向非常类似，即通过判断`Response`状态，如果连接服务器失败等，那么可以尝试获取一个新的路径进行重新连接，大致的实现和重定向非常类似，此不赘述。\n\n#### 4. Request & Response 拦截机制\n这是非常核心的部分。\n\n通过上面的重新组装`request`和重定向机制，我们可以感受的，一个`request`从user创建出来后，会经过层层处理后，才真正发出去，而一个`response`，也会经过各种处理，最终返回给用户。\n\n笔者认为这和网络协议栈非常相似，用户在应用层发出简单的数据，然后经过传输层、网络层等，层层封装后真正把请求从物理层发出去，当请求结果回来后又层层解析，最终把最直接的结果返回给用户使用。\n\n最重要的是，每一层都是抽象的，互不相关的！\n\n因此在我们设计时，也可以借鉴这个思想，通过设置`拦截器Interceptor`，每个拦截器会做两件事情：\n\n1. 接收上一层拦截器封装后的request，然后自身对这个request进行处理，例如添加一些header，处理后向下传递；\n2. 接收下一层拦截器传递回来的response，然后自身对response进行处理，例如判断返回的statusCode，然后进一步处理。\n\n那么，我们可以为拦截器定义一个抽象接口，然后去实现具体的拦截器。\n```java\ninterface Interceptor {\n\tResponse intercept(Request request);\n}\n```\n大家可以看下上面这个拦截器设计是否有问题？\n\n![](http://upload-images.jianshu.io/upload_images/281665-00ec5b478499a386.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们想象这个拦截器能够接收一个request，进行拦截处理，并返回结果。\n\n但实际上，它无法返回结果，而且它在处理request后，并不能继续向下传递，因为它并不知道下一个`Interceptor`在哪里，也就无法继续向下传递。\n\n那么，如何解决才能把所有`Interceptor`串在一起，并能够依次传递下去。\n```java\npublic interface Interceptor {\n  Response intercept(Chain chain);\n\n  interface Chain {\n    Request request();\n\n    Response proceed(Request request);\n  }\n}\n```\n使用方法如下：假如我们现在有三个`Interceptor`需要依次拦截：\n```java\n// Build a full stack of interceptors.\nList<Interceptor> interceptors = new ArrayList<>();\ninterceptors.add(new MyInterceptor1());\ninterceptors.add(new MyInterceptor2());\ninterceptors.add(new MyInterceptor3());\n\nInterceptor.Chain chain = new RealInterceptorChain(\n        interceptors, 0, originalRequest);\nchain.proceed(originalRequest);        \n```\n里面的`RealInterceptorChain`的基本思想是：我们把所有`interceptors`传进去，然后`chain`去依次把`request`传入到每一个`interceptors`进行拦截即可。\n\n通过下面的示意图可以明确看出拦截流程：\n\n![](http://upload-images.jianshu.io/upload_images/281665-aa94adfc49da4e40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n其中，`RetryAndFollowupInterceptor`是用来做自动重试和自动重定向的拦截器；`BridgeInterceptor`是用来扩展`request`的`header`的拦截器。这两个拦截器存在于`okhttp`里，实际上在`okhttp`里还有好几个拦截器，这里暂时不做深入分析。\n\n![](http://upload-images.jianshu.io/upload_images/281665-1b58154250ce74d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n1. `CacheInterceptor`\n这是用来拦截请求并提供缓存的，当request进入这一层，它会自动去检查缓存，如果有，就直接返回缓存结果；否则的话才将request继续向下传递。而且，当下层把response返回到这一层，它会根据需求进行缓存处理；\n\n2. `ConnectInterceptor`\n这一层是用来与目标服务器建立连接\n\n3. `CallServerInterceptor`\n这一层位于最底层，直接向服务器发出请求，并接收服务器返回的response，并向上层层传递。\n\n上面几个都是okhttp自带的，也就是说需要在`WingjayHttpClient`自己实现的。除了这几个功能性的拦截器，我们还要支持用户`自定义拦截器`，主要有以下两种（见图中非虚线框蓝色字部分）：\n\n1. `interceptors`\n这里的拦截器是拦截用户最原始的request。\n\n2. `NetworkInterceptor`\n这是最底层的request拦截器。\n\n如何区分这两个呢？举个例子，我创建两个`LoggingInterceptor`，分别放在`interceptors`层和`NetworkInterceptor`层，然后访问一个会重定向的`URL_1`，当访问完`URL_1`后会再去访问重定向后的新地址`URL_2`。对于这个过程，`interceptors`层的拦截器只会拦截到`URL_1`的request，而在`NetworkInterceptor`层的拦截器则会同时拦截到`URL_1`和`URL_2`两个request。具体原因可以看上面的图。\n\n#### 5. 同步、异步 Request池管理机制\n这是非常核心的部分。\n\n通过上面的工作，我们修改`WingjayHttpClient`后得到了下面的样子：\n```java\nclass WingjayHttpClient {\n\tpublic Response sendRequest(Request userRequest) {\n\t\tRequest httpRequest = expandHeaders(userRequest);\n\t\tResponse response = executeRequest(httpRequest);\n\t\tswitch (response.statusCode()) {\n\t\t\t// 300: multi choice; 301: moven permanently; \n\t\t\t// 302: moved temporarily; 303: see other; \n\t\t\t// 307: redirect temporarily; 308: redirect permanently\n\t\t\tcase 300:\n\t\t\tcase 301:\n\t\t\tcase 302:\n\t\t\tcase 303:\n\t\t\tcase 307:\n\t\t\tcase 308:\n\t\t\t\treturn handleRedirect(response);\n\t\t\tdefault:\n\t\t\t\treturn response;\n\t\t}\n\t}\n\n\tprivate Request expandHeaders(Request userRequest) {...}\n\tprivate Response executeRequest(Request httpRequest) {...}\n\tprivate Response handleRedirect(Response response) {...}\n}\n```\n也就是说，`WingjayHttpClient`现在能够`同步`地处理单个`Request`了。\n\n然而，在实际应用中，一个`WingjayHttpClient`可能会被用于同时处理几十个用户request，而且这些request里还分成了`同步`和`异步`两种不同的请求方式，所以我们显然不能简单把一个request直接塞给`WingjayHttpClient`。\n\n我们知道，一个request除了上面定义的http协议相关的内容，还应该要设置其处理方式`同步`和`异步`。那这些信息应该存在哪里呢？两种选择：\n\n1. 直接放入`Request`\n从理论上来讲是可以的，但是却违背了初衷。我们最开始是希望用`Request`来构造符合http协议的一个请求，里面应该包含的是请求目标网址URL，请求端口，请求方法等等信息，而http协议是不关心这个request是同步还是异步之类的信息\n\n2. 创建一个类，专门来管理`Request`的状态\n这是更为合适的，我们可以更好的拆分职责。\n\n因此，这里选择创建两个类`SyncCall`和`AsyncCall`，用来区分`同步`和`异步`。\n```java\nclass SyncCall {\n\tprivate Request userRequest;\n\n\tpublic SyncCall(Request userRequest) {\n\t\tthis.userRequest = userRequest;\n\t}\n}\n\nclass AsyncCall {\n\tprivate Request userRequest;\n\tprivate Callback callback;\n\n\tpublic AsyncCall(Request userRequest, Callback callback) {\n\t\tthis.userRequest = userRequest;\n\t\tthis.callback = callback;\n\t}\n\n\tinterface Callback {\n\t\tvoid onFailure(Call call, IOException e);\n\t\tvoid onResponse(Call call, Response response) throws IOException;\n\t}\n}\n```\n基于上面两个类，我们的使用场景如下：\n```java\nWingjayHttpClient client = new WingjayHttpClient();\n// Sync\nRequest syncRequest = new Request(\"http://wingjay.com\");\nSyncCall syncCall = new SyncCall(request);\nResponse response = client.sendSyncCall(syncCall);\nhandle(response);\n\n// Async\nAsyncCall asyncCall = new AsyncCall(request, new CallBack() {\n\t  @Override\n      public void onFailure(Call call, IOException e) {}\n\n      @Override\n      public void onResponse(Call call, Response response) throws IOException {\n        handle(response);\n      }\n});\nclient.equeueAsyncCall(asyncCall);\n```\n从上面的代码可以看到，`WingjayHttpClient`的职责发生了变化：以前是**response = client.sendRequest(request);**，而现在变成了\n```java\nresponse = client.sendSyncCall(syncCall);\n\nclient.equeueAsyncCall(asyncCall);\n```\n\n那么，我们也需要对`WingjayHttpClient`进行改造，基本思路是在内部添加`请求池`来对所有request进行管理。那么这个`请求池`我们怎么来设计呢？有两个方法：\n\n1. 直接在`WingjayHttpClient`内部创建几个容器\n同样，从理论上而言是可行的。当用户把(a)syncCall传给client后，client自动把call存入对应的容器进行管理。\n\n2. 创建一个独立的类进行管理\n显然这样可以更好的分配职责。我们把`WingjayHttpClient`的职责定义为，接收一个call，内部进行处理后返回结果。这就是`WingjayHttpClient`的任务，那么具体如何去管理这些request的执行顺序和生命周期，自然不需要由它来管。\n\n因此，我们创建一个新的类：`Dispatcher`，这个类的作用是：\n\n1. 存储外界不断传入的`SyncCall`和`AsyncCall`，如果用户想取消则可以遍历所有的call进行cancel操作;\n2. 对于`SyncCall`，由于它是即时运行的，因此`Dispatcher`只需要在`SyncCall`运行前存储进来，在运行结束后移除即可；\n3. 对于`AsyncCall`，`Dispatcher`首先启动一个ExecutorService，不断取出`AsyncCall`去进行执行，然后，我们设置最多执行的request数量为64，如果已经有64个request在执行中，那么就将这个asyncCall存入等待区。\n\n根据设计可以得到`Dispatcher`构造：\n```java\nclass Dispatcher {\n\t// sync call\n\tprivate final Deque<SyncCall> runningSyncCalls = new ArrayDeque<>();\n\t// async call\n\tprivate int maxRequests = 64;\n\tprivate final Deque<AsyncCall> waitingAsyncCalls = new ArrayDeque<>();\n\tprivate final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();\n\tprivate ExecutorService executorService;\n\n\t// begin execute Sync call\n\tpublic void startSyncCall(SyncCall syncCall) {\n\t\trunningSyncCalls.add(syncCall);\n\t}\n\t// finish Sync call\n\tpublic void finishSyncCall(SyncCall syncCall) {\n\t\trunningSyncCalls.remove(syncCall);\n\t}\n\n\t// enqueue a new AsyncCall\n\tpublic void enqueue(AsyncCall asyncCall) {\n\t\tif (runningAsyncCalls.size() < 64) {\n\t\t\t// run directly\n\t\t\trunningAsyncCalls.add(asyncCall);\n\t\t\texecutorService.execute(asyncCall);\n\t\t} else {\n\t\t\treadyAsyncCalls.add(asyncCall);\n\t\t}\n\t}\n\t// finish a AsyncCall\n\tpublic void finishAsyncCall(AsyncCall asyncCall) {\n\t\trunningAsyncCalls.remove(asyncCall);\n\t}\n}\n```\n有了这个`Dispatcher`，那我们就可以去修改`WingjayHttpClient`以实现\n```java\nresponse = client.sendSyncCall(syncCall);\n\nclient.equeueAsyncCall(asyncCall);\n```\n这两个方法了。具体实现如下\n```java\n[class WingjayHttpClient]\n\n\tprivate Dispatcher dispatcher;\n\n\tpublic Response sendSyncCall(SyncCall syncCall) {\n\t\ttry {\n\t\t\t// store syncCall into dispatcher;\n\t\t\tdispatcher.startSyncCall(syncCall);\n\t\t\t// execute\n\t\t\treturn sendRequest(syncCall.getRequest());\n\t\t} finally {\n\t\t\t// remove syncCall from dispatcher\n\t\t\tdispatcher.finishSyncCall(syncCall);\n\t\t}\n\t}\n\n\tpublic void equeueAsyncCall(AsyncCall asyncCall) {\n\t\t// store asyncCall into dispatcher;\n\t\tdispatcher.enqueue(asyncCall);\n\t\t// it will be removed when this asyncCall be executed\n\t}\n```\n\n基于以上，我们能够很好的处理`同步`和`异步`两种请求，使用场景如下：\n```java\nWingjayHttpClient client = new WingjayHttpClient();\n// Sync\nRequest syncRequest = new Request(\"http://wingjay.com\");\nSyncCall syncCall = new SyncCall(request);\nResponse response = client.sendSyncCall(syncCall);\nhandle(response);\n\n// Async\nAsyncCall asyncCall = new AsyncCall(request, new CallBack() {\n\t  @Override\n      public void onFailure(Call call, IOException e) {}\n\n      @Override\n      public void onResponse(Call call, Response response) throws IOException {\n        handle(response);\n      }\n});\nclient.equeueAsyncCall(asyncCall);\n```\n\n## 六、总结\n到此，我们基本把`okhttp`里核心的机制都讲解了一遍，相信读者对于okhttp的整体结构和核心机制都有了较为详细的了解。\n\n如果有问题欢迎联系我。\n\n谢谢！\n\nwingjay\n\n\n\n\n\n欢迎各位关注\n[我的Github](https://github.com/wingjay): <https://github.com/wingjay> \n和\n[我的简书](http://www.jianshu.com/users/da333fd63fe5/latest_articles): <http://www.jianshu.com/users/da333fd63fe5/latest_articles>\n和\n[微博 iam_wingjay](http://weibo.com/u/1625892654): <http://weibo.com/u/1625892654>\n如果有问题，可以给我留言或发邮件<mailto:yinjiesh@126.com>\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"带你学开源项目：OkHttp-自己动手实现okhttp","published":1,"updated":"2018-11-26T06:56:27.485Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplsjk005j3dn8y4mxc76q","content":"<blockquote>\n<p>私以为，阅读开源项目是与世界级技术大牛直接对话的最好方式。<br>此次来分享下 OkHttp 源码的分析。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"一、开源项目 -OkHttp\"><a href=\"# 一、开源项目 -OkHttp\" class=\"headerlink\" title=\"一、开源项目 OkHttp\"></a>一、开源项目 OkHttp</h2><p>在 Android、Java 开发领域中，相信大家都听过或者在使用 Square 家大名鼎鼎的网络请求库——<a href=\"https://github.com/square/okhttp\" target=\"_blank\" rel=\"external\">OkHttp</a>——<a href=\"https://github.com/square/okhttp\" target=\"_blank\" rel=\"external\">https://github.com/square/okhttp</a> ，当前多数著名的开源项目如 <a href=\"https://github.com/facebook/fresco\" target=\"_blank\" rel=\"external\">Fresco</a>、<a href=\"https://github.com/bumptech/glide\" target=\"_blank\" rel=\"external\">Glide</a>、 <a href=\"https://github.com/square/picasso\" target=\"_blank\" rel=\"external\">Picasso</a>、 <a href=\"https://github.com/square/retrofit\" target=\"_blank\" rel=\"external\">Retrofit</a>都在使用 OkHttp，这足以说明其质量，而且该项目仍处在 <a href=\"https://github.com/square/okhttp/commits/master\" target=\"_blank\" rel=\"external\"> 不断维护中</a>。</p>\n<h2 id=\"二、问题\"><a href=\"# 二、问题\" class=\"headerlink\" title=\"二、问题\"></a>二、问题 </h2><p> 在分析 okhttp 源码之前，我想先提出一个问题，如果我们自己来设计一个网络请求库，这个库应该长什么样子？大致是什么结构呢？</p>\n<p>下面我和大家一起来构建一个网络请求库，并在其中融入 okhttp 中核心的设计思想，希望借此让读者感受并学习到 okhttp 中的精华之处，而非仅限于了解其实现。</p>\n<p>笔者相信，如果你能耐心阅读完本篇，不仅能对 http 协议有进一步理解，更能够学习到世界级项目的思维精华，提高自身思维方式。</p>\n<h2 id=\"三、思考\"><a href=\"# 三、思考\" class=\"headerlink\" title=\"三、思考\"></a>三、思考 </h2><p> 首先，我们假设要构建的的网络请求库叫做<code>WingjayHttpClient</code>，那么，作为一个网络请求库，它最基本功能是什么呢？</p>\n<p>在我看来应该是：接收用户的请求 -&gt; 发出请求 -&gt; 接收响应结果并返回给用户。</p>\n<p>那么从使用者角度而言，需要做的事是：</p>\n<ol>\n<li>创建一个<code>Request</code>：在里面设置好目标 URL；请求 method 如 GET/POST 等；一些 header 如 Host、User-Agent 等；如果你在 POST 上传一个表单，那么还需要 body。</li>\n<li>将创建好的 <code>Request</code> 传递给<code>WingjayHttpClient</code>。</li>\n<li><code>WingjayHttpClient</code>去执行 <code>Request</code>，并把返回结果封装成一个<code>Response</code> 给用户。而一个 <code>Response</code> 里应该包括 statusCode 如 200，一些 header 如 content-type 等，可能还有 body</li>\n</ol>\n<p>到此即为一次完整请求的雏形。那么下面我们来具体实现这三步。</p>\n<h2 id=\"四、雏形实现\"><a href=\"# 四、雏形实现\" class=\"headerlink\" title=\"四、雏形实现\"></a>四、雏形实现 </h2><p> 下面我们先来实现一个 httpClient 的雏形，只具备最基本的功能。</p>\n<h4 id=\"1- 创建 Request 类\"><a href=\"#1- 创建 Request 类\" class=\"headerlink\" title=\"1. 创建 Request 类\"></a>1. 创建 <code>Request</code> 类</h4><p>首先，我们要建立一个 <code>Request</code> 类，利用 <code>Request</code> 类用户可以把自己需要的参数传入进去，基本形式如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Request &#123;</div><div class=\"line\">\tString url;</div><div class=\"line\">\tString method;</div><div class=\"line\">\tHeaders headers;</div><div class=\"line\">\tBody requestBody;</div><div class=\"line\"></div><div class=\"line\">\tpublic Request(String url, String method, @Nullable Headers headers, @Nullable Body body) &#123;</div><div class=\"line\">\t\tthis.url = url;</div><div class=\"line\">\t\t...</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"2- 将 Request 对象传递给 WingjayHttpClient\"><a href=\"#2- 将 Request 对象传递给 WingjayHttpClient\" class=\"headerlink\" title=\"2. 将 Request 对象传递给 WingjayHttpClient\"></a>2. 将 <code>Request</code> 对象传递给 <code>WingjayHttpClient</code></h4><p> 我们可以设计 <code>WingjayHttpClient</code> 如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">class WingjayHttpClient &#123;</div><div class=\"line\">\tpublic Response sendRequest(Request request) &#123;</div><div class=\"line\">\t\treturn executeRequest(request);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"3- 执行 Request，并把返回结果封装成一个 Response 返回\"><a href=\"#3- 执行 Request，并把返回结果封装成一个 Response 返回\" class=\"headerlink\" title=\"3. 执行 Request，并把返回结果封装成一个 Response 返回\"></a>3. 执行 <code>Request</code>，并把返回结果封装成一个<code>Response</code> 返回</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">class WingjayHttpClient &#123;</div><div class=\"line\">\t...</div><div class=\"line\">\tprivate Response executeRequest(Request request) &#123;</div><div class=\"line\">\t\t// 使用 socket 来进行访问</div><div class=\"line\">\t\tSocket socket = new Socket(request.getUrl(), 80);</div><div class=\"line\">\t\tResponseData data = socket.connect().getResponseData();</div><div class=\"line\">\t\treturn new Response(data);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t...</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class Response &#123;</div><div class=\"line\">\tint statusCode;</div><div class=\"line\">\tHeaders headers;</div><div class=\"line\">\tBody responseBody</div><div class=\"line\">\t...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"五、功能扩展\"><a href=\"# 五、功能扩展\" class=\"headerlink\" title=\"五、功能扩展\"></a>五、功能扩展 </h2><p> 利用上面的雏形，可以得到其使用方法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Request request = new Request(&quot;http://wingjay.com&quot;);</div><div class=\"line\">WingjayHttpClient client = new WingjayHttpClient();</div><div class=\"line\">Response response = client.sendRequest(request);</div><div class=\"line\">handle(response);</div></pre></td></tr></table></figure></p>\n<p>然而，上面的雏形是远远不能胜任常规的应用需求的，因此，下面再来对它添加一些常用的功能模块。</p>\n<h4 id=\"1- 重新把简陋的 user-Request 组装成一个规范的 http-request\"><a href=\"#1- 重新把简陋的 user-Request 组装成一个规范的 http-request\" class=\"headerlink\" title=\"1. 重新把简陋的 user Request 组装成一个规范的 http request\"></a>1. 重新把简陋的 user Request 组装成一个规范的 http request</h4><p>一般的 request 中，往往用户只会指定一个 URL 和 method，这个简单的 user request 是不足以成为一个 http request，我们还需要为它添加一些 header，如 Content-Length, Transfer-Encoding, User-Agent, Host, Connection, 和 Content-Type，如果这个 request 使用了 cookie，那我们还要将 cookie 添加到这个 request 中。</p>\n<p>我们可以扩展上面的 <code>sendRequest(request)</code> 方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">[class WingjayHttpClient]</div><div class=\"line\"></div><div class=\"line\">public Response sendRequest(Request userRequest) &#123;</div><div class=\"line\">    Request httpRequest = expandHeaders(userRequest);</div><div class=\"line\">    return executeRequest(httpRequest);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">private Request expandHeaders(Request userRequest) &#123;</div><div class=\"line\">    if (userRequest.header(&quot;Connection&quot;) == null) &#123;</div><div class=\"line\">      requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    if (userRequest.header(&quot;User-Agent&quot;) == null) &#123;</div><div class=\"line\">      requestBuilder.header(&quot;User-Agent&quot;, Version.userAgent());</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"2- 支持自动重定向\"><a href=\"#2- 支持自动重定向\" class=\"headerlink\" title=\"2. 支持自动重定向\"></a>2. 支持自动重定向 </h4><p> 有时我们请求的 URL 已经被移走了，此时 server 会返回 301 状态码和一个重定向的新 URL，此时我们要能够支持自动访问新 URL 而不是向用户报错。</p>\n<p>对于重定向这里有一个测试性 URL：<a href=\"http://www.publicobject.com/helloworld.txt\" target=\"_blank\" rel=\"external\">http://www.publicobject.com/helloworld.txt</a> ，通过访问并抓包，可以看到如下信息：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/281665-62df4e64fd04dc24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>因此，我们在接收到 Response 后要根据 status_code 是否为重定向，如果是，则要从 Response Header 里解析出新的 URL－<code>Location</code>并自动请求新 URL。那么，我们可以继续改写 <code>sendRequest(request)</code> 方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\">[class WingjayHttpClient]</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> allowRedirect = <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"comment\">// user can set redirect status when building WingjayHttpClient</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAllowRedirect</span><span class=\"params\">(<span class=\"keyword\">boolean</span> allowRedirect)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.allowRedirect = allowRedirect;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">sendRequest</span><span class=\"params\">(Request userRequest)</span> </span>&#123;</div><div class=\"line\">\t\tRequest httpRequest = expandHeaders(userRequest);</div><div class=\"line\">\t\tResponse response = executeRequest(httpRequest);</div><div class=\"line\">\t\t<span class=\"keyword\">switch</span> (response.statusCode()) &#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">// 300: multi choice; 301: moven permanently; </span></div><div class=\"line\">\t\t\t<span class=\"comment\">// 302: moved temporarily; 303: see other; </span></div><div class=\"line\">\t\t\t<span class=\"comment\">// 307: redirect temporarily; 308: redirect permanently</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">300</span>:</div><div class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">301</span>:</div><div class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">302</span>:</div><div class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">303</span>:</div><div class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">307</span>:</div><div class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">308</span>:</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> handleRedirect(response);</div><div class=\"line\">\t\t\t<span class=\"keyword\">default</span>:</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> response;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// the max times of followup request</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_FOLLOW_UPS = <span class=\"number\">20</span>;</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> followupCount = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Response <span class=\"title\">handleRedirect</span><span class=\"params\">(Response response)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// Does the WingjayHttpClient allow redirect?</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> (!client.allowRedirect()) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// Get the redirecting url</span></div><div class=\"line\">\tString nextUrl = response.header(<span class=\"string\">\"Location\"</span>);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// Construct a redirecting request</span></div><div class=\"line\">\tRequest followup = <span class=\"keyword\">new</span> Request(nextUrl);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// check the max followupCount</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> (++followupCount &gt; MAX_FOLLOW_UPS) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">\"Too many follow-up requests:\"</span> + followUpCount);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// not reach the max followup times, send followup request then.</span></div><div class=\"line\">\t<span class=\"keyword\">return</span> sendRequest(followup);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>利用上面的代码，我们通过获取原始 <code>userRequest</code> 的返回结果，判断结果是否为重定向，并做出自动 followup 处理。</p>\n<blockquote>\n<p>一些常用的状态码<br>100~199：指示信息，表示请求已接收，继续处理<br>200~299：请求成功，表示请求已被成功接收、理解、接受<br>300~399：重定向，要完成请求必须进行更进一步的操作<br>400~499：客户端错误，请求有语法错误或请求无法实现<br>500~599：服务器端错误，服务器未能实现合法的请求</p>\n</blockquote>\n<h4 id=\"3- 支持重试机制\"><a href=\"#3- 支持重试机制\" class=\"headerlink\" title=\"3. 支持重试机制\"></a>3. 支持重试机制 </h4><p> 所谓重试，和重定向非常类似，即通过判断 <code>Response</code> 状态，如果连接服务器失败等，那么可以尝试获取一个新的路径进行重新连接，大致的实现和重定向非常类似，此不赘述。</p>\n<h4 id=\"4-Request-amp-Response- 拦截机制\"><a href=\"#4-Request-amp-Response- 拦截机制\" class=\"headerlink\" title=\"4. Request &amp; Response 拦截机制\"></a>4. Request &amp; Response 拦截机制 </h4><p> 这是非常核心的部分。</p>\n<p>通过上面的重新组装 <code>request</code> 和重定向机制，我们可以感受的，一个 <code>request</code> 从 user 创建出来后，会经过层层处理后，才真正发出去，而一个<code>response</code>，也会经过各种处理，最终返回给用户。</p>\n<p>笔者认为这和网络协议栈非常相似，用户在应用层发出简单的数据，然后经过传输层、网络层等，层层封装后真正把请求从物理层发出去，当请求结果回来后又层层解析，最终把最直接的结果返回给用户使用。</p>\n<p>最重要的是，每一层都是抽象的，互不相关的！</p>\n<p>因此在我们设计时，也可以借鉴这个思想，通过设置 <code> 拦截器 Interceptor</code>，每个拦截器会做两件事情：</p>\n<ol>\n<li>接收上一层拦截器封装后的 request，然后自身对这个 request 进行处理，例如添加一些 header，处理后向下传递；</li>\n<li>接收下一层拦截器传递回来的 response，然后自身对 response 进行处理，例如判断返回的 statusCode，然后进一步处理。</li>\n</ol>\n<p>那么，我们可以为拦截器定义一个抽象接口，然后去实现具体的拦截器。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Interceptor</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\">Response <span class=\"title\">intercept</span><span class=\"params\">(Request request)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>大家可以看下上面这个拦截器设计是否有问题？</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/281665-00ec5b478499a386.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>我们想象这个拦截器能够接收一个 request，进行拦截处理，并返回结果。</p>\n<p>但实际上，它无法返回结果，而且它在处理 request 后，并不能继续向下传递，因为它并不知道下一个 <code>Interceptor</code> 在哪里，也就无法继续向下传递。</p>\n<p>那么，如何解决才能把所有 <code>Interceptor</code> 串在一起，并能够依次传递下去。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Interceptor</span> </span>&#123;</div><div class=\"line\">  <span class=\"function\">Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span></span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Chain</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\">Request <span class=\"title\">request</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\">Response <span class=\"title\">proceed</span><span class=\"params\">(Request request)</span></span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用方法如下：假如我们现在有三个 <code>Interceptor</code> 需要依次拦截：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Build a full stack of interceptors.</span></div><div class=\"line\">List&lt;Interceptor&gt; interceptors = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">interceptors.add(<span class=\"keyword\">new</span> MyInterceptor1());</div><div class=\"line\">interceptors.add(<span class=\"keyword\">new</span> MyInterceptor2());</div><div class=\"line\">interceptors.add(<span class=\"keyword\">new</span> MyInterceptor3());</div><div class=\"line\"></div><div class=\"line\">Interceptor.Chain chain = <span class=\"keyword\">new</span> RealInterceptorChain(</div><div class=\"line\">        interceptors, <span class=\"number\">0</span>, originalRequest);</div><div class=\"line\">chain.proceed(originalRequest);</div></pre></td></tr></table></figure></p>\n<p>里面的 <code>RealInterceptorChain</code> 的基本思想是：我们把所有 <code>interceptors</code> 传进去，然后 <code>chain</code> 去依次把 <code>request</code> 传入到每一个 <code>interceptors</code> 进行拦截即可。</p>\n<p>通过下面的示意图可以明确看出拦截流程：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/281665-aa94adfc49da4e40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>其中，<code>RetryAndFollowupInterceptor</code>是用来做自动重试和自动重定向的拦截器；<code>BridgeInterceptor</code>是用来扩展 <code>request</code> 的<code>header</code>的拦截器。这两个拦截器存在于 <code>okhttp</code> 里，实际上在 <code>okhttp</code> 里还有好几个拦截器，这里暂时不做深入分析。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/281665-1b58154250ce74d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<ol>\n<li><p><code>CacheInterceptor</code><br>这是用来拦截请求并提供缓存的，当 request 进入这一层，它会自动去检查缓存，如果有，就直接返回缓存结果；否则的话才将 request 继续向下传递。而且，当下层把 response 返回到这一层，它会根据需求进行缓存处理；</p>\n</li>\n<li><p><code>ConnectInterceptor</code><br>这一层是用来与目标服务器建立连接</p>\n</li>\n<li><p><code>CallServerInterceptor</code><br>这一层位于最底层，直接向服务器发出请求，并接收服务器返回的 response，并向上层层传递。</p>\n</li>\n</ol>\n<p>上面几个都是 okhttp 自带的，也就是说需要在 <code>WingjayHttpClient</code> 自己实现的。除了这几个功能性的拦截器，我们还要支持用户 <code> 自定义拦截器</code>，主要有以下两种（见图中非虚线框蓝色字部分）：</p>\n<ol>\n<li><p><code>interceptors</code><br>这里的拦截器是拦截用户最原始的 request。</p>\n</li>\n<li><p><code>NetworkInterceptor</code><br>这是最底层的 request 拦截器。</p>\n</li>\n</ol>\n<p>如何区分这两个呢？举个例子，我创建两个 <code>LoggingInterceptor</code>，分别放在<code>interceptors</code> 层和 <code>NetworkInterceptor</code> 层，然后访问一个会重定向的 <code>URL_1</code>，当访问完<code>URL_1</code> 后会再去访问重定向后的新地址 <code>URL_2</code>。对于这个过程，<code>interceptors</code> 层的拦截器只会拦截到 <code>URL_1</code> 的 request，而在 <code>NetworkInterceptor</code> 层的拦截器则会同时拦截到 <code>URL_1</code> 和<code>URL_2</code>两个 request。具体原因可以看上面的图。</p>\n<h4 id=\"5- 同步、异步 -Request 池管理机制\"><a href=\"#5- 同步、异步 -Request 池管理机制\" class=\"headerlink\" title=\"5. 同步、异步 Request 池管理机制\"></a>5. 同步、异步 Request 池管理机制 </h4><p> 这是非常核心的部分。</p>\n<p>通过上面的工作，我们修改 <code>WingjayHttpClient</code> 后得到了下面的样子：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WingjayHttpClient</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">sendRequest</span><span class=\"params\">(Request userRequest)</span> </span>&#123;</div><div class=\"line\">\t\tRequest httpRequest = expandHeaders(userRequest);</div><div class=\"line\">\t\tResponse response = executeRequest(httpRequest);</div><div class=\"line\">\t\t<span class=\"keyword\">switch</span> (response.statusCode()) &#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">// 300: multi choice; 301: moven permanently; </span></div><div class=\"line\">\t\t\t<span class=\"comment\">// 302: moved temporarily; 303: see other; </span></div><div class=\"line\">\t\t\t<span class=\"comment\">// 307: redirect temporarily; 308: redirect permanently</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">300</span>:</div><div class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">301</span>:</div><div class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">302</span>:</div><div class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">303</span>:</div><div class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">307</span>:</div><div class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">308</span>:</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> handleRedirect(response);</div><div class=\"line\">\t\t\t<span class=\"keyword\">default</span>:</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> response;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> Request <span class=\"title\">expandHeaders</span><span class=\"params\">(Request userRequest)</span> </span>&#123;...&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> Response <span class=\"title\">executeRequest</span><span class=\"params\">(Request httpRequest)</span> </span>&#123;...&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> Response <span class=\"title\">handleRedirect</span><span class=\"params\">(Response response)</span> </span>&#123;...&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>也就是说，<code>WingjayHttpClient</code>现在能够 <code> 同步 </code> 地处理单个 <code>Request</code> 了。</p>\n<p>然而，在实际应用中，一个 <code>WingjayHttpClient</code> 可能会被用于同时处理几十个用户 request，而且这些 request 里还分成了 <code> 同步 </code> 和<code>异步 </code> 两种不同的请求方式，所以我们显然不能简单把一个 request 直接塞给<code>WingjayHttpClient</code>。</p>\n<p>我们知道，一个 request 除了上面定义的 http 协议相关的内容，还应该要设置其处理方式 <code> 同步 </code> 和<code>异步</code>。那这些信息应该存在哪里呢？两种选择：</p>\n<ol>\n<li><p>直接放入 <code>Request</code><br> 从理论上来讲是可以的，但是却违背了初衷。我们最开始是希望用 <code>Request</code> 来构造符合 http 协议的一个请求，里面应该包含的是请求目标网址 URL，请求端口，请求方法等等信息，而 http 协议是不关心这个 request 是同步还是异步之类的信息</p>\n</li>\n<li><p>创建一个类，专门来管理 <code>Request</code> 的状态 <br> 这是更为合适的，我们可以更好的拆分职责。</p>\n</li>\n</ol>\n<p>因此，这里选择创建两个类 <code>SyncCall</code> 和<code>AsyncCall</code>，用来区分 <code> 同步 </code> 和<code>异步</code>。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncCall</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> Request userRequest;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SyncCall</span><span class=\"params\">(Request userRequest)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.userRequest = userRequest;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AsyncCall</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> Request userRequest;</div><div class=\"line\">\t<span class=\"keyword\">private</span> Callback callback;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AsyncCall</span><span class=\"params\">(Request userRequest, Callback callback)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.userRequest = userRequest;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.callback = callback;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Callback</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call call, IOException e)</span></span>;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call call, Response response)</span> <span class=\"keyword\">throws</span> IOException</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>基于上面两个类，我们的使用场景如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">WingjayHttpClient client = <span class=\"keyword\">new</span> WingjayHttpClient();</div><div class=\"line\"><span class=\"comment\">// Sync</span></div><div class=\"line\">Request syncRequest = <span class=\"keyword\">new</span> Request(<span class=\"string\">\"http://wingjay.com\"</span>);</div><div class=\"line\">SyncCall syncCall = <span class=\"keyword\">new</span> SyncCall(request);</div><div class=\"line\">Response response = client.sendSyncCall(syncCall);</div><div class=\"line\">handle(response);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Async</span></div><div class=\"line\">AsyncCall asyncCall = <span class=\"keyword\">new</span> AsyncCall(request, <span class=\"keyword\">new</span> CallBack() &#123;</div><div class=\"line\">\t  <span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call call, IOException e)</span> </span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call call, Response response)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">        handle(response);</div><div class=\"line\">      &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\">client.equeueAsyncCall(asyncCall);</div></pre></td></tr></table></figure></p>\n<p>从上面的代码可以看到，<code>WingjayHttpClient</code>的职责发生了变化：以前是<strong>response = client.sendRequest(request);</strong>，而现在变成了<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">response = client.sendSyncCall(syncCall);</div><div class=\"line\"></div><div class=\"line\">client.equeueAsyncCall(asyncCall);</div></pre></td></tr></table></figure></p>\n<p>那么，我们也需要对 <code>WingjayHttpClient</code> 进行改造，基本思路是在内部添加 <code> 请求池 </code> 来对所有 request 进行管理。那么这个 <code> 请求池 </code> 我们怎么来设计呢？有两个方法：</p>\n<ol>\n<li><p>直接在 <code>WingjayHttpClient</code> 内部创建几个容器 <br> 同样，从理论上而言是可行的。当用户把(a)syncCall 传给 client 后，client 自动把 call 存入对应的容器进行管理。</p>\n</li>\n<li><p>创建一个独立的类进行管理 <br> 显然这样可以更好的分配职责。我们把 <code>WingjayHttpClient</code> 的职责定义为，接收一个 call，内部进行处理后返回结果。这就是 <code>WingjayHttpClient</code> 的任务，那么具体如何去管理这些 request 的执行顺序和生命周期，自然不需要由它来管。</p>\n</li>\n</ol>\n<p>因此，我们创建一个新的类：<code>Dispatcher</code>，这个类的作用是：</p>\n<ol>\n<li>存储外界不断传入的 <code>SyncCall</code> 和<code>AsyncCall</code>，如果用户想取消则可以遍历所有的 call 进行 cancel 操作;</li>\n<li>对于 <code>SyncCall</code>，由于它是即时运行的，因此<code>Dispatcher</code> 只需要在 <code>SyncCall</code> 运行前存储进来，在运行结束后移除即可；</li>\n<li>对于 <code>AsyncCall</code>，<code>Dispatcher</code> 首先启动一个 ExecutorService，不断取出 <code>AsyncCall</code> 去进行执行，然后，我们设置最多执行的 request 数量为 64，如果已经有 64 个 request 在执行中，那么就将这个 asyncCall 存入等待区。</li>\n</ol>\n<p>根据设计可以得到 <code>Dispatcher</code> 构造：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dispatcher</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// sync call</span></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Deque&lt;SyncCall&gt; runningSyncCalls = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</div><div class=\"line\">\t<span class=\"comment\">// async call</span></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxRequests = <span class=\"number\">64</span>;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Deque&lt;AsyncCall&gt; waitingAsyncCalls = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</div><div class=\"line\">\t<span class=\"keyword\">private</span> ExecutorService executorService;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// begin execute Sync call</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startSyncCall</span><span class=\"params\">(SyncCall syncCall)</span> </span>&#123;</div><div class=\"line\">\t\trunningSyncCalls.add(syncCall);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"comment\">// finish Sync call</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">finishSyncCall</span><span class=\"params\">(SyncCall syncCall)</span> </span>&#123;</div><div class=\"line\">\t\trunningSyncCalls.remove(syncCall);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// enqueue a new AsyncCall</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(AsyncCall asyncCall)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (runningAsyncCalls.size() &lt; <span class=\"number\">64</span>) &#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">// run directly</span></div><div class=\"line\">\t\t\trunningAsyncCalls.add(asyncCall);</div><div class=\"line\">\t\t\texecutorService.execute(asyncCall);</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t\treadyAsyncCalls.add(asyncCall);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"comment\">// finish a AsyncCall</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">finishAsyncCall</span><span class=\"params\">(AsyncCall asyncCall)</span> </span>&#123;</div><div class=\"line\">\t\trunningAsyncCalls.remove(asyncCall);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>有了这个 <code>Dispatcher</code>，那我们就可以去修改<code>WingjayHttpClient</code> 以实现<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">response = client.sendSyncCall(syncCall);</div><div class=\"line\"></div><div class=\"line\">client.equeueAsyncCall(asyncCall);</div></pre></td></tr></table></figure></p>\n<p>这两个方法了。具体实现如下<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">[class WingjayHttpClient]</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">private</span> Dispatcher dispatcher;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">sendSyncCall</span><span class=\"params\">(SyncCall syncCall)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">// store syncCall into dispatcher;</span></div><div class=\"line\">\t\t\tdispatcher.startSyncCall(syncCall);</div><div class=\"line\">\t\t\t<span class=\"comment\">// execute</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> sendRequest(syncCall.getRequest());</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">// remove syncCall from dispatcher</span></div><div class=\"line\">\t\t\tdispatcher.finishSyncCall(syncCall);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">equeueAsyncCall</span><span class=\"params\">(AsyncCall asyncCall)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// store asyncCall into dispatcher;</span></div><div class=\"line\">\t\tdispatcher.enqueue(asyncCall);</div><div class=\"line\">\t\t<span class=\"comment\">// it will be removed when this asyncCall be executed</span></div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure></p>\n<p>基于以上，我们能够很好的处理 <code> 同步 </code> 和<code>异步 </code> 两种请求，使用场景如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">WingjayHttpClient client = <span class=\"keyword\">new</span> WingjayHttpClient();</div><div class=\"line\"><span class=\"comment\">// Sync</span></div><div class=\"line\">Request syncRequest = <span class=\"keyword\">new</span> Request(<span class=\"string\">\"http://wingjay.com\"</span>);</div><div class=\"line\">SyncCall syncCall = <span class=\"keyword\">new</span> SyncCall(request);</div><div class=\"line\">Response response = client.sendSyncCall(syncCall);</div><div class=\"line\">handle(response);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Async</span></div><div class=\"line\">AsyncCall asyncCall = <span class=\"keyword\">new</span> AsyncCall(request, <span class=\"keyword\">new</span> CallBack() &#123;</div><div class=\"line\">\t  <span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call call, IOException e)</span> </span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call call, Response response)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">        handle(response);</div><div class=\"line\">      &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\">client.equeueAsyncCall(asyncCall);</div></pre></td></tr></table></figure></p>\n<h2 id=\"六、总结\"><a href=\"# 六、总结\" class=\"headerlink\" title=\"六、总结\"></a>六、总结 </h2><p> 到此，我们基本把 <code>okhttp</code> 里核心的机制都讲解了一遍，相信读者对于 okhttp 的整体结构和核心机制都有了较为详细的了解。</p>\n<p>如果有问题欢迎联系我。</p>\n<p>谢谢！</p>\n<p>wingjay</p>\n<p>欢迎各位关注 <br><a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\"> 我的 Github</a>: <a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\">https://github.com/wingjay</a><br>和 <br><a href=\"http://www.jianshu.com/users/da333fd63fe5/latest_articles\" target=\"_blank\" rel=\"external\"> 我的简书 </a>: <a href=\"http://www.jianshu.com/users/da333fd63fe5/latest_articles\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/users/da333fd63fe5/latest_articles</a><br> 和<br><a href=\"http://weibo.com/u/1625892654\" target=\"_blank\" rel=\"external\">微博 iam_wingjay</a>: <a href=\"http://weibo.com/u/1625892654\" target=\"_blank\" rel=\"external\">http://weibo.com/u/1625892654</a><br>如果有问题，可以给我留言或发邮件<a href=\"&#109;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#121;&#x69;&#110;&#106;&#105;&#x65;&#115;&#x68;&#64;&#49;&#x32;&#x36;&#46;&#99;&#111;&#x6d;\">&#121;&#x69;&#110;&#106;&#105;&#x65;&#115;&#x68;&#64;&#49;&#x32;&#x36;&#46;&#99;&#111;&#x6d;</a></p>\n<p><img src=\"https://avatars0.githubusercontent.com/u/9619875?v=3&amp;s=460\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>私以为，阅读开源项目是与世界级技术大牛直接对话的最好方式。<br>此次来分享下 OkHttp 源码的分析。</p>\n</blockquote>","more":"<h2 id=\"一、开源项目-OkHttp\"><a href=\"#一、开源项目-OkHttp\" class=\"headerlink\" title=\"一、开源项目 OkHttp\"></a>一、开源项目 OkHttp</h2><p>在Android、Java开发领域中，相信大家都听过或者在使用Square家大名鼎鼎的网络请求库——<a href=\"https://github.com/square/okhttp\" target=\"_blank\" rel=\"external\">OkHttp</a>——<a href=\"https://github.com/square/okhttp\" target=\"_blank\" rel=\"external\">https://github.com/square/okhttp</a> ，当前多数著名的开源项目如 <a href=\"https://github.com/facebook/fresco\" target=\"_blank\" rel=\"external\">Fresco</a>、<a href=\"https://github.com/bumptech/glide\" target=\"_blank\" rel=\"external\">Glide</a>、 <a href=\"https://github.com/square/picasso\" target=\"_blank\" rel=\"external\">Picasso</a>、 <a href=\"https://github.com/square/retrofit\" target=\"_blank\" rel=\"external\">Retrofit</a>都在使用OkHttp，这足以说明其质量，而且该项目仍处在<a href=\"https://github.com/square/okhttp/commits/master\" target=\"_blank\" rel=\"external\">不断维护中</a>。</p>\n<h2 id=\"二、问题\"><a href=\"#二、问题\" class=\"headerlink\" title=\"二、问题\"></a>二、问题</h2><p>在分析okhttp源码之前，我想先提出一个问题，如果我们自己来设计一个网络请求库，这个库应该长什么样子？大致是什么结构呢？</p>\n<p>下面我和大家一起来构建一个网络请求库，并在其中融入okhttp中核心的设计思想，希望借此让读者感受并学习到okhttp中的精华之处，而非仅限于了解其实现。</p>\n<p>笔者相信，如果你能耐心阅读完本篇，不仅能对http协议有进一步理解，更能够学习到世界级项目的思维精华，提高自身思维方式。</p>\n<h2 id=\"三、思考\"><a href=\"#三、思考\" class=\"headerlink\" title=\"三、思考\"></a>三、思考</h2><p>首先，我们假设要构建的的网络请求库叫做<code>WingjayHttpClient</code>，那么，作为一个网络请求库，它最基本功能是什么呢？</p>\n<p>在我看来应该是：接收用户的请求 -&gt; 发出请求 -&gt; 接收响应结果并返回给用户。</p>\n<p>那么从使用者角度而言，需要做的事是：</p>\n<ol>\n<li>创建一个<code>Request</code>：在里面设置好目标URL；请求method如GET/POST等；一些header如Host、User-Agent等；如果你在POST上传一个表单，那么还需要body。</li>\n<li>将创建好的<code>Request</code>传递给<code>WingjayHttpClient</code>。</li>\n<li><code>WingjayHttpClient</code>去执行<code>Request</code>，并把返回结果封装成一个<code>Response</code>给用户。而一个<code>Response</code>里应该包括statusCode如200，一些header如content-type等，可能还有body</li>\n</ol>\n<p>到此即为一次完整请求的雏形。那么下面我们来具体实现这三步。</p>\n<h2 id=\"四、雏形实现\"><a href=\"#四、雏形实现\" class=\"headerlink\" title=\"四、雏形实现\"></a>四、雏形实现</h2><p>下面我们先来实现一个httpClient的雏形，只具备最基本的功能。</p>\n<h4 id=\"1-创建Request类\"><a href=\"#1-创建Request类\" class=\"headerlink\" title=\"1. 创建Request类\"></a>1. 创建<code>Request</code>类</h4><p>首先，我们要建立一个<code>Request</code>类，利用<code>Request</code>类用户可以把自己需要的参数传入进去，基本形式如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Request &#123;</div><div class=\"line\">\tString url;</div><div class=\"line\">\tString method;</div><div class=\"line\">\tHeaders headers;</div><div class=\"line\">\tBody requestBody;</div><div class=\"line\"></div><div class=\"line\">\tpublic Request(String url, String method, @Nullable Headers headers, @Nullable Body body) &#123;</div><div class=\"line\">\t\tthis.url = url;</div><div class=\"line\">\t\t...</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"2-将Request对象传递给WingjayHttpClient\"><a href=\"#2-将Request对象传递给WingjayHttpClient\" class=\"headerlink\" title=\"2. 将Request对象传递给WingjayHttpClient\"></a>2. 将<code>Request</code>对象传递给<code>WingjayHttpClient</code></h4><p>我们可以设计<code>WingjayHttpClient</code>如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">class WingjayHttpClient &#123;</div><div class=\"line\">\tpublic Response sendRequest(Request request) &#123;</div><div class=\"line\">\t\treturn executeRequest(request);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"3-执行Request，并把返回结果封装成一个Response返回\"><a href=\"#3-执行Request，并把返回结果封装成一个Response返回\" class=\"headerlink\" title=\"3. 执行Request，并把返回结果封装成一个Response返回\"></a>3. 执行<code>Request</code>，并把返回结果封装成一个<code>Response</code>返回</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">class WingjayHttpClient &#123;</div><div class=\"line\">\t...</div><div class=\"line\">\tprivate Response executeRequest(Request request) &#123;</div><div class=\"line\">\t\t//使用socket来进行访问</div><div class=\"line\">\t\tSocket socket = new Socket(request.getUrl(), 80);</div><div class=\"line\">\t\tResponseData data = socket.connect().getResponseData();</div><div class=\"line\">\t\treturn new Response(data);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t...</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class Response &#123;</div><div class=\"line\">\tint statusCode;</div><div class=\"line\">\tHeaders headers;</div><div class=\"line\">\tBody responseBody</div><div class=\"line\">\t...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"五、功能扩展\"><a href=\"#五、功能扩展\" class=\"headerlink\" title=\"五、功能扩展\"></a>五、功能扩展</h2><p>利用上面的雏形，可以得到其使用方法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Request request = new Request(&quot;http://wingjay.com&quot;);</div><div class=\"line\">WingjayHttpClient client = new WingjayHttpClient();</div><div class=\"line\">Response response = client.sendRequest(request);</div><div class=\"line\">handle(response);</div></pre></td></tr></table></figure></p>\n<p>然而，上面的雏形是远远不能胜任常规的应用需求的，因此，下面再来对它添加一些常用的功能模块。</p>\n<h4 id=\"1-重新把简陋的user-Request组装成一个规范的http-request\"><a href=\"#1-重新把简陋的user-Request组装成一个规范的http-request\" class=\"headerlink\" title=\"1. 重新把简陋的user Request组装成一个规范的http request\"></a>1. 重新把简陋的user Request组装成一个规范的http request</h4><p>一般的request中，往往用户只会指定一个URL和method，这个简单的user request是不足以成为一个http request，我们还需要为它添加一些header，如Content-Length, Transfer-Encoding, User-Agent, Host, Connection, 和 Content-Type，如果这个request使用了cookie，那我们还要将cookie添加到这个request中。</p>\n<p>我们可以扩展上面的<code>sendRequest(request)</code>方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">[class WingjayHttpClient]</div><div class=\"line\"></div><div class=\"line\">public Response sendRequest(Request userRequest) &#123;</div><div class=\"line\">    Request httpRequest = expandHeaders(userRequest);</div><div class=\"line\">    return executeRequest(httpRequest);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">private Request expandHeaders(Request userRequest) &#123;</div><div class=\"line\">    if (userRequest.header(&quot;Connection&quot;) == null) &#123;</div><div class=\"line\">      requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    if (userRequest.header(&quot;User-Agent&quot;) == null) &#123;</div><div class=\"line\">      requestBuilder.header(&quot;User-Agent&quot;, Version.userAgent());</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"2-支持自动重定向\"><a href=\"#2-支持自动重定向\" class=\"headerlink\" title=\"2. 支持自动重定向\"></a>2. 支持自动重定向</h4><p>有时我们请求的URL已经被移走了，此时server会返回301状态码和一个重定向的新URL，此时我们要能够支持自动访问新URL而不是向用户报错。</p>\n<p>对于重定向这里有一个测试性URL：<a href=\"http://www.publicobject.com/helloworld.txt\" target=\"_blank\" rel=\"external\">http://www.publicobject.com/helloworld.txt</a> ，通过访问并抓包，可以看到如下信息：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/281665-62df4e64fd04dc24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>因此，我们在接收到Response后要根据status_code是否为重定向，如果是，则要从Response Header里解析出新的URL－<code>Location</code>并自动请求新URL。那么，我们可以继续改写<code>sendRequest(request)</code>方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\">[class WingjayHttpClient]</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> allowRedirect = <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"comment\">// user can set redirect status when building WingjayHttpClient</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAllowRedirect</span><span class=\"params\">(<span class=\"keyword\">boolean</span> allowRedirect)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.allowRedirect = allowRedirect;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">sendRequest</span><span class=\"params\">(Request userRequest)</span> </span>&#123;</div><div class=\"line\">\t\tRequest httpRequest = expandHeaders(userRequest);</div><div class=\"line\">\t\tResponse response = executeRequest(httpRequest);</div><div class=\"line\">\t\t<span class=\"keyword\">switch</span> (response.statusCode()) &#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">// 300: multi choice; 301: moven permanently; </span></div><div class=\"line\">\t\t\t<span class=\"comment\">// 302: moved temporarily; 303: see other; </span></div><div class=\"line\">\t\t\t<span class=\"comment\">// 307: redirect temporarily; 308: redirect permanently</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">300</span>:</div><div class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">301</span>:</div><div class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">302</span>:</div><div class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">303</span>:</div><div class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">307</span>:</div><div class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">308</span>:</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> handleRedirect(response);</div><div class=\"line\">\t\t\t<span class=\"keyword\">default</span>:</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> response;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// the max times of followup request</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_FOLLOW_UPS = <span class=\"number\">20</span>;</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> followupCount = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Response <span class=\"title\">handleRedirect</span><span class=\"params\">(Response response)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// Does the WingjayHttpClient allow redirect?</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> (!client.allowRedirect()) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// Get the redirecting url</span></div><div class=\"line\">\tString nextUrl = response.header(<span class=\"string\">\"Location\"</span>);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// Construct a redirecting request</span></div><div class=\"line\">\tRequest followup = <span class=\"keyword\">new</span> Request(nextUrl);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// check the max followupCount</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> (++followupCount &gt; MAX_FOLLOW_UPS) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">\"Too many follow-up requests: \"</span> + followUpCount);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// not reach the max followup times, send followup request then.</span></div><div class=\"line\">\t<span class=\"keyword\">return</span> sendRequest(followup);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>利用上面的代码，我们通过获取原始<code>userRequest</code>的返回结果，判断结果是否为重定向，并做出自动followup处理。</p>\n<blockquote>\n<p>一些常用的状态码<br>100~199：指示信息，表示请求已接收，继续处理<br>200~299：请求成功，表示请求已被成功接收、理解、接受<br>300~399：重定向，要完成请求必须进行更进一步的操作<br>400~499：客户端错误，请求有语法错误或请求无法实现<br>500~599：服务器端错误，服务器未能实现合法的请求</p>\n</blockquote>\n<h4 id=\"3-支持重试机制\"><a href=\"#3-支持重试机制\" class=\"headerlink\" title=\"3. 支持重试机制\"></a>3. 支持重试机制</h4><p>所谓重试，和重定向非常类似，即通过判断<code>Response</code>状态，如果连接服务器失败等，那么可以尝试获取一个新的路径进行重新连接，大致的实现和重定向非常类似，此不赘述。</p>\n<h4 id=\"4-Request-amp-Response-拦截机制\"><a href=\"#4-Request-amp-Response-拦截机制\" class=\"headerlink\" title=\"4. Request &amp; Response 拦截机制\"></a>4. Request &amp; Response 拦截机制</h4><p>这是非常核心的部分。</p>\n<p>通过上面的重新组装<code>request</code>和重定向机制，我们可以感受的，一个<code>request</code>从user创建出来后，会经过层层处理后，才真正发出去，而一个<code>response</code>，也会经过各种处理，最终返回给用户。</p>\n<p>笔者认为这和网络协议栈非常相似，用户在应用层发出简单的数据，然后经过传输层、网络层等，层层封装后真正把请求从物理层发出去，当请求结果回来后又层层解析，最终把最直接的结果返回给用户使用。</p>\n<p>最重要的是，每一层都是抽象的，互不相关的！</p>\n<p>因此在我们设计时，也可以借鉴这个思想，通过设置<code>拦截器Interceptor</code>，每个拦截器会做两件事情：</p>\n<ol>\n<li>接收上一层拦截器封装后的request，然后自身对这个request进行处理，例如添加一些header，处理后向下传递；</li>\n<li>接收下一层拦截器传递回来的response，然后自身对response进行处理，例如判断返回的statusCode，然后进一步处理。</li>\n</ol>\n<p>那么，我们可以为拦截器定义一个抽象接口，然后去实现具体的拦截器。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Interceptor</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\">Response <span class=\"title\">intercept</span><span class=\"params\">(Request request)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>大家可以看下上面这个拦截器设计是否有问题？</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/281665-00ec5b478499a386.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>我们想象这个拦截器能够接收一个request，进行拦截处理，并返回结果。</p>\n<p>但实际上，它无法返回结果，而且它在处理request后，并不能继续向下传递，因为它并不知道下一个<code>Interceptor</code>在哪里，也就无法继续向下传递。</p>\n<p>那么，如何解决才能把所有<code>Interceptor</code>串在一起，并能够依次传递下去。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Interceptor</span> </span>&#123;</div><div class=\"line\">  <span class=\"function\">Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span></span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Chain</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\">Request <span class=\"title\">request</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\">Response <span class=\"title\">proceed</span><span class=\"params\">(Request request)</span></span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用方法如下：假如我们现在有三个<code>Interceptor</code>需要依次拦截：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Build a full stack of interceptors.</span></div><div class=\"line\">List&lt;Interceptor&gt; interceptors = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">interceptors.add(<span class=\"keyword\">new</span> MyInterceptor1());</div><div class=\"line\">interceptors.add(<span class=\"keyword\">new</span> MyInterceptor2());</div><div class=\"line\">interceptors.add(<span class=\"keyword\">new</span> MyInterceptor3());</div><div class=\"line\"></div><div class=\"line\">Interceptor.Chain chain = <span class=\"keyword\">new</span> RealInterceptorChain(</div><div class=\"line\">        interceptors, <span class=\"number\">0</span>, originalRequest);</div><div class=\"line\">chain.proceed(originalRequest);</div></pre></td></tr></table></figure></p>\n<p>里面的<code>RealInterceptorChain</code>的基本思想是：我们把所有<code>interceptors</code>传进去，然后<code>chain</code>去依次把<code>request</code>传入到每一个<code>interceptors</code>进行拦截即可。</p>\n<p>通过下面的示意图可以明确看出拦截流程：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/281665-aa94adfc49da4e40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>其中，<code>RetryAndFollowupInterceptor</code>是用来做自动重试和自动重定向的拦截器；<code>BridgeInterceptor</code>是用来扩展<code>request</code>的<code>header</code>的拦截器。这两个拦截器存在于<code>okhttp</code>里，实际上在<code>okhttp</code>里还有好几个拦截器，这里暂时不做深入分析。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/281665-1b58154250ce74d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<ol>\n<li><p><code>CacheInterceptor</code><br>这是用来拦截请求并提供缓存的，当request进入这一层，它会自动去检查缓存，如果有，就直接返回缓存结果；否则的话才将request继续向下传递。而且，当下层把response返回到这一层，它会根据需求进行缓存处理；</p>\n</li>\n<li><p><code>ConnectInterceptor</code><br>这一层是用来与目标服务器建立连接</p>\n</li>\n<li><p><code>CallServerInterceptor</code><br>这一层位于最底层，直接向服务器发出请求，并接收服务器返回的response，并向上层层传递。</p>\n</li>\n</ol>\n<p>上面几个都是okhttp自带的，也就是说需要在<code>WingjayHttpClient</code>自己实现的。除了这几个功能性的拦截器，我们还要支持用户<code>自定义拦截器</code>，主要有以下两种（见图中非虚线框蓝色字部分）：</p>\n<ol>\n<li><p><code>interceptors</code><br>这里的拦截器是拦截用户最原始的request。</p>\n</li>\n<li><p><code>NetworkInterceptor</code><br>这是最底层的request拦截器。</p>\n</li>\n</ol>\n<p>如何区分这两个呢？举个例子，我创建两个<code>LoggingInterceptor</code>，分别放在<code>interceptors</code>层和<code>NetworkInterceptor</code>层，然后访问一个会重定向的<code>URL_1</code>，当访问完<code>URL_1</code>后会再去访问重定向后的新地址<code>URL_2</code>。对于这个过程，<code>interceptors</code>层的拦截器只会拦截到<code>URL_1</code>的request，而在<code>NetworkInterceptor</code>层的拦截器则会同时拦截到<code>URL_1</code>和<code>URL_2</code>两个request。具体原因可以看上面的图。</p>\n<h4 id=\"5-同步、异步-Request池管理机制\"><a href=\"#5-同步、异步-Request池管理机制\" class=\"headerlink\" title=\"5. 同步、异步 Request池管理机制\"></a>5. 同步、异步 Request池管理机制</h4><p>这是非常核心的部分。</p>\n<p>通过上面的工作，我们修改<code>WingjayHttpClient</code>后得到了下面的样子：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WingjayHttpClient</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">sendRequest</span><span class=\"params\">(Request userRequest)</span> </span>&#123;</div><div class=\"line\">\t\tRequest httpRequest = expandHeaders(userRequest);</div><div class=\"line\">\t\tResponse response = executeRequest(httpRequest);</div><div class=\"line\">\t\t<span class=\"keyword\">switch</span> (response.statusCode()) &#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">// 300: multi choice; 301: moven permanently; </span></div><div class=\"line\">\t\t\t<span class=\"comment\">// 302: moved temporarily; 303: see other; </span></div><div class=\"line\">\t\t\t<span class=\"comment\">// 307: redirect temporarily; 308: redirect permanently</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">300</span>:</div><div class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">301</span>:</div><div class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">302</span>:</div><div class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">303</span>:</div><div class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">307</span>:</div><div class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">308</span>:</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> handleRedirect(response);</div><div class=\"line\">\t\t\t<span class=\"keyword\">default</span>:</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> response;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> Request <span class=\"title\">expandHeaders</span><span class=\"params\">(Request userRequest)</span> </span>&#123;...&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> Response <span class=\"title\">executeRequest</span><span class=\"params\">(Request httpRequest)</span> </span>&#123;...&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> Response <span class=\"title\">handleRedirect</span><span class=\"params\">(Response response)</span> </span>&#123;...&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>也就是说，<code>WingjayHttpClient</code>现在能够<code>同步</code>地处理单个<code>Request</code>了。</p>\n<p>然而，在实际应用中，一个<code>WingjayHttpClient</code>可能会被用于同时处理几十个用户request，而且这些request里还分成了<code>同步</code>和<code>异步</code>两种不同的请求方式，所以我们显然不能简单把一个request直接塞给<code>WingjayHttpClient</code>。</p>\n<p>我们知道，一个request除了上面定义的http协议相关的内容，还应该要设置其处理方式<code>同步</code>和<code>异步</code>。那这些信息应该存在哪里呢？两种选择：</p>\n<ol>\n<li><p>直接放入<code>Request</code><br>从理论上来讲是可以的，但是却违背了初衷。我们最开始是希望用<code>Request</code>来构造符合http协议的一个请求，里面应该包含的是请求目标网址URL，请求端口，请求方法等等信息，而http协议是不关心这个request是同步还是异步之类的信息</p>\n</li>\n<li><p>创建一个类，专门来管理<code>Request</code>的状态<br>这是更为合适的，我们可以更好的拆分职责。</p>\n</li>\n</ol>\n<p>因此，这里选择创建两个类<code>SyncCall</code>和<code>AsyncCall</code>，用来区分<code>同步</code>和<code>异步</code>。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncCall</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> Request userRequest;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SyncCall</span><span class=\"params\">(Request userRequest)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.userRequest = userRequest;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AsyncCall</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> Request userRequest;</div><div class=\"line\">\t<span class=\"keyword\">private</span> Callback callback;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AsyncCall</span><span class=\"params\">(Request userRequest, Callback callback)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.userRequest = userRequest;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.callback = callback;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Callback</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call call, IOException e)</span></span>;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call call, Response response)</span> <span class=\"keyword\">throws</span> IOException</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>基于上面两个类，我们的使用场景如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">WingjayHttpClient client = <span class=\"keyword\">new</span> WingjayHttpClient();</div><div class=\"line\"><span class=\"comment\">// Sync</span></div><div class=\"line\">Request syncRequest = <span class=\"keyword\">new</span> Request(<span class=\"string\">\"http://wingjay.com\"</span>);</div><div class=\"line\">SyncCall syncCall = <span class=\"keyword\">new</span> SyncCall(request);</div><div class=\"line\">Response response = client.sendSyncCall(syncCall);</div><div class=\"line\">handle(response);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Async</span></div><div class=\"line\">AsyncCall asyncCall = <span class=\"keyword\">new</span> AsyncCall(request, <span class=\"keyword\">new</span> CallBack() &#123;</div><div class=\"line\">\t  <span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call call, IOException e)</span> </span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call call, Response response)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">        handle(response);</div><div class=\"line\">      &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\">client.equeueAsyncCall(asyncCall);</div></pre></td></tr></table></figure></p>\n<p>从上面的代码可以看到，<code>WingjayHttpClient</code>的职责发生了变化：以前是<strong>response = client.sendRequest(request);</strong>，而现在变成了<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">response = client.sendSyncCall(syncCall);</div><div class=\"line\"></div><div class=\"line\">client.equeueAsyncCall(asyncCall);</div></pre></td></tr></table></figure></p>\n<p>那么，我们也需要对<code>WingjayHttpClient</code>进行改造，基本思路是在内部添加<code>请求池</code>来对所有request进行管理。那么这个<code>请求池</code>我们怎么来设计呢？有两个方法：</p>\n<ol>\n<li><p>直接在<code>WingjayHttpClient</code>内部创建几个容器<br>同样，从理论上而言是可行的。当用户把(a)syncCall传给client后，client自动把call存入对应的容器进行管理。</p>\n</li>\n<li><p>创建一个独立的类进行管理<br>显然这样可以更好的分配职责。我们把<code>WingjayHttpClient</code>的职责定义为，接收一个call，内部进行处理后返回结果。这就是<code>WingjayHttpClient</code>的任务，那么具体如何去管理这些request的执行顺序和生命周期，自然不需要由它来管。</p>\n</li>\n</ol>\n<p>因此，我们创建一个新的类：<code>Dispatcher</code>，这个类的作用是：</p>\n<ol>\n<li>存储外界不断传入的<code>SyncCall</code>和<code>AsyncCall</code>，如果用户想取消则可以遍历所有的call进行cancel操作;</li>\n<li>对于<code>SyncCall</code>，由于它是即时运行的，因此<code>Dispatcher</code>只需要在<code>SyncCall</code>运行前存储进来，在运行结束后移除即可；</li>\n<li>对于<code>AsyncCall</code>，<code>Dispatcher</code>首先启动一个ExecutorService，不断取出<code>AsyncCall</code>去进行执行，然后，我们设置最多执行的request数量为64，如果已经有64个request在执行中，那么就将这个asyncCall存入等待区。</li>\n</ol>\n<p>根据设计可以得到<code>Dispatcher</code>构造：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dispatcher</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// sync call</span></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Deque&lt;SyncCall&gt; runningSyncCalls = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</div><div class=\"line\">\t<span class=\"comment\">// async call</span></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxRequests = <span class=\"number\">64</span>;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Deque&lt;AsyncCall&gt; waitingAsyncCalls = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</div><div class=\"line\">\t<span class=\"keyword\">private</span> ExecutorService executorService;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// begin execute Sync call</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startSyncCall</span><span class=\"params\">(SyncCall syncCall)</span> </span>&#123;</div><div class=\"line\">\t\trunningSyncCalls.add(syncCall);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"comment\">// finish Sync call</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">finishSyncCall</span><span class=\"params\">(SyncCall syncCall)</span> </span>&#123;</div><div class=\"line\">\t\trunningSyncCalls.remove(syncCall);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// enqueue a new AsyncCall</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(AsyncCall asyncCall)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (runningAsyncCalls.size() &lt; <span class=\"number\">64</span>) &#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">// run directly</span></div><div class=\"line\">\t\t\trunningAsyncCalls.add(asyncCall);</div><div class=\"line\">\t\t\texecutorService.execute(asyncCall);</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t\treadyAsyncCalls.add(asyncCall);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"comment\">// finish a AsyncCall</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">finishAsyncCall</span><span class=\"params\">(AsyncCall asyncCall)</span> </span>&#123;</div><div class=\"line\">\t\trunningAsyncCalls.remove(asyncCall);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>有了这个<code>Dispatcher</code>，那我们就可以去修改<code>WingjayHttpClient</code>以实现<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">response = client.sendSyncCall(syncCall);</div><div class=\"line\"></div><div class=\"line\">client.equeueAsyncCall(asyncCall);</div></pre></td></tr></table></figure></p>\n<p>这两个方法了。具体实现如下<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">[class WingjayHttpClient]</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">private</span> Dispatcher dispatcher;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">sendSyncCall</span><span class=\"params\">(SyncCall syncCall)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">// store syncCall into dispatcher;</span></div><div class=\"line\">\t\t\tdispatcher.startSyncCall(syncCall);</div><div class=\"line\">\t\t\t<span class=\"comment\">// execute</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> sendRequest(syncCall.getRequest());</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">// remove syncCall from dispatcher</span></div><div class=\"line\">\t\t\tdispatcher.finishSyncCall(syncCall);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">equeueAsyncCall</span><span class=\"params\">(AsyncCall asyncCall)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// store asyncCall into dispatcher;</span></div><div class=\"line\">\t\tdispatcher.enqueue(asyncCall);</div><div class=\"line\">\t\t<span class=\"comment\">// it will be removed when this asyncCall be executed</span></div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure></p>\n<p>基于以上，我们能够很好的处理<code>同步</code>和<code>异步</code>两种请求，使用场景如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">WingjayHttpClient client = <span class=\"keyword\">new</span> WingjayHttpClient();</div><div class=\"line\"><span class=\"comment\">// Sync</span></div><div class=\"line\">Request syncRequest = <span class=\"keyword\">new</span> Request(<span class=\"string\">\"http://wingjay.com\"</span>);</div><div class=\"line\">SyncCall syncCall = <span class=\"keyword\">new</span> SyncCall(request);</div><div class=\"line\">Response response = client.sendSyncCall(syncCall);</div><div class=\"line\">handle(response);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Async</span></div><div class=\"line\">AsyncCall asyncCall = <span class=\"keyword\">new</span> AsyncCall(request, <span class=\"keyword\">new</span> CallBack() &#123;</div><div class=\"line\">\t  <span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call call, IOException e)</span> </span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call call, Response response)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">        handle(response);</div><div class=\"line\">      &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\">client.equeueAsyncCall(asyncCall);</div></pre></td></tr></table></figure></p>\n<h2 id=\"六、总结\"><a href=\"#六、总结\" class=\"headerlink\" title=\"六、总结\"></a>六、总结</h2><p>到此，我们基本把<code>okhttp</code>里核心的机制都讲解了一遍，相信读者对于okhttp的整体结构和核心机制都有了较为详细的了解。</p>\n<p>如果有问题欢迎联系我。</p>\n<p>谢谢！</p>\n<p>wingjay</p>\n<p>欢迎各位关注<br><a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\">我的Github</a>: <a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\">https://github.com/wingjay</a><br>和<br><a href=\"http://www.jianshu.com/users/da333fd63fe5/latest_articles\" target=\"_blank\" rel=\"external\">我的简书</a>: <a href=\"http://www.jianshu.com/users/da333fd63fe5/latest_articles\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/users/da333fd63fe5/latest_articles</a><br>和<br><a href=\"http://weibo.com/u/1625892654\" target=\"_blank\" rel=\"external\">微博 iam_wingjay</a>: <a href=\"http://weibo.com/u/1625892654\" target=\"_blank\" rel=\"external\">http://weibo.com/u/1625892654</a><br>如果有问题，可以给我留言或发邮件<a href=\"&#109;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#121;&#x69;&#110;&#106;&#105;&#x65;&#115;&#x68;&#64;&#49;&#x32;&#x36;&#46;&#99;&#111;&#x6d;\">&#121;&#x69;&#110;&#106;&#105;&#x65;&#115;&#x68;&#64;&#49;&#x32;&#x36;&#46;&#99;&#111;&#x6d;</a></p>\n<p><img src=\"https://avatars0.githubusercontent.com/u/9619875?v=3&amp;s=460\" alt=\"\"></p>","sticky":0},{"title":"[干货] Glow Android 优化实践","date":"2016-11-02T11:58:15.000Z","commentIssueId":12,"_content":"\n> 分享下自己在实际工作中积累的技术经验。\n\n<!-- more -->\n\n了解 Glow 的朋友应该知道，我们主营四款 App，分别是Eve、Glow、Nuture和Baby。作为创业公司，我们的四款 App 都处于高速开发中，平均每个 Android App 由两人负责开发，包括 Android 和 Server 开发，在满足 PM 各种需求的同时，我们的session crash free率保持不低于 99.8%，其中两款 App 接近 100%。\n\n本文将对 Glow 当前 Android 对现有工具的探索及优化作出讲解，希望对读者有所启发。\n\n## 整体结构概览\n\n由于架构都是为了实际业务服务，因此在深入讲解前，需要先展示 Android 端的大体结构：\n\n ![Glow Android 整体结构](http://upload-images.jianshu.io/upload_images/281665-6a05f7e014dc6234.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们有四个 Android App，它们共用同一个 Community 社区，最底层是 Base-Library，存放公用的模块组件，如支付模块，Logging模块等等。\n\n下面，我将依次从以下几个方面进行讲解：\n\n- 网络层优化\n- 内存优化实践\n- 在App和Library中集成依赖注入\n- etc.\n\n\n\n\n## 网络层优化\n\n#### 1. Retrofit2 + OkHttp3 + RxJava\n\n上面这套结构是目前最为流行的网络层架构，可以帮我们写出简洁而稳定的网络请求代码，比起以前复杂的异步回调、主次线程切换等代码更为易用，而且能支持 `https` 请求。\n\n基本用法如下:\n\n```java\nUserApi userApi = retrofit.create(UserApi.class);  \n```\n\n```java\n@Get(\"/{id}\")\nObservable<User> getUser(@Path(\"id\") long id);\n```\n\n```java\nuserApi.getUser(1)\n  .subscribeOn(Schedulers.io())\n  .observeOn(AndroidSchedulers.mainThread())\n  .subscribe(new Action1<User>() {\n    @Override\n    public void call(User user) {\n\t\t// handle user\n    }\n  }, new Action1<Throwable>() {\n    @Override\n    public void call(Throwable throwable) {\n\t\t// handle throwable\n    }\n  });\n```\n\n这只是通用做法。下面我们要根据实际情况进行优化。\n\n#### 2. 封装线程切换代码\n\n上面的代码中可以看到，为了执行网络请求，我们会利用`RxJava`提供的`Schedulers`工具来方便切换线程。\n\n```java\n  .subscribeOn(Schedulers.io())\n  .observeOn(AndroidSchedulers.mainThread())\n```\n\n上面的代码的作用是：让网络请求进入 `io线程` 执行，并将返回结果转入 `UI线程` 去进行渲染。\n\n不过，我们 app 有非常多的网络请求，而且除了`网络请求`，其他的`数据库操作` 或者 `文件读写操作` 都需要一样的线程切换。因此，为了代码复用，我们利用 `RxJava` 提供的 `Transformer` 来进行封装。\n\n```java\n// RxUtil.java  \npublic static <T> Observable.Transformer<T, T> normalSchedulers() {\n  return new Observable.Transformer<T, T>() {\n    @Override\n    public Observable<T> call(Observable<T> source) {\n      return source.subscribeOn(Schedulers.io())\n        .observeOn(AndroidSchedulers.mainThread());\n    }\n  };\n}\n```\n\n然后，我们可以把网络请求代码转化为\n\n```java\nuserApi.getUser(1)\n  .compose(RxUtil.normalSchedulers())\n  .subscribe(...)\n```\n\n这虽然只是很简单的改进，但能让我们的代码更简洁，更不易出错。\n\n#### 3. 封装响应结果 JsonDataResponse\n\n我们 server 的所有返回结果都符合如下格式:\n\n```json\n{\n  'rc': 0,\n  'data': {...},\n  'msg': \"Successful Call\"\n}\n```\n\n其中 `rc` 是自定义的结果标志，server 用来告诉我们该请求的逻辑处理是否成功（此时 `rc = 0`）。`data`是这个请求需要的 json 数据。`msg`一般用来存放错误提示信息。\n\n于是我们创建了一个通用类来封装所有的 `Response`。\n\n```java\npublic class JsonDataResponse<T> {\n  @SerializedName(\"rc\")\n  private int rc;\n\n  @SerializedName(\"msg\")\n  private String msg;\n\n  @SerializedName(\"data\")\n  T data;\n  \n  public int getRc() { return rc; }\n  \n  public T getData() { return data; }\n} \n```\n\n于是，我们的请求变成如下：\n\n```java\n@Get(\"/{id}\")\nObservable<JsonDataResponse<User>> getUser(@Path(\"id\") long id);\n```\n\n```java\nuserApi.getUser(1)\n  .compose(RxUtil.normalSchedulers())\n  .subscribe(new Action1<JsonDataResponse<User>>() {\n    @Override\n    public void call(JsonDataResponse<User> response) {\n\t\tif (response.getRc() == 0) {\n          User user = response.getData();\n          // handle user\n\t\t} else {\n          Toast.makeToast(context, response.getMsg())\n\t\t}\n    }\n  }, new Action1<Throwable>() {\n    @Override\n    public void call(Throwable throwable) {\n\t\t// handle throwable\n    }\n  });\n```\n\n#### 4. 异常处理\n\n上面已经能完成正常的网络请求了，但是，却还没有对错误进行处理。\n\n一次网络请求中，可能发生以下几种错误：\n\n- 没有网络\n- 网络正常，但 http 请求失败，即 http 状态码不在 `[200, 300)` 之间，如`404`、`500`等\n- 网络正常，http 请求成功，但是 server 在处理请求时出了问题，使得返回结果的 `rc != 0`\n\n不同的错误，我们希望给用户不同的提示，并且统计这些错误。\n\n目前我们的网络请求里已经能够处理第三种情况，另外两种都在 `throwable` 里面，我们可以通过判断 `throwable` 是 `IOException` 还是 `retrofit2.HttpException` 来区分这两种情况。\n\n因此，我们可得到如下异常处理代码：\n\n```java\nuserApi.getUser(1)\n  .compose(RxUtil.normalSchedulers())\n  .subscribe(new Action1<JsonDataResponse<User>>() {\n    @Override\n    public void call(JsonDataResponse<User> response) {\n\t\tif (response.getRc() == 0) {\n          User user = response.getData();\n          // handle user\n          handleUser();\n\t\t} else {\n          // such as: customized errorMsg: \"cannot find this user\".\n          Toast.makeToast(context, response.getMsg(), Toast.LENGTH_SHORT).show();\n\t\t}\n    }\n  }, new Action1<Throwable>() {\n    @Override\n    public void call(Throwable throwable) {\n        String errorMsg = \"\";\n\t\tif (throwable instanceof IOException) {\n          // io Exception\n          errorMsg = \"Please check your network status\";\n\t\t} else if (throwable instanceof HttpException) {\n          HttpException httpException = (HttpException) throwable;\n          // http error.\n          errorMsg = httpException.response(); \n\t\t} else {\n          errorMsg = \"unknown error\";\n\t\t}\n        Toast.makeToast(...);\n    }\n  });\n```\n\n#### 5. 封装异常处理代码\n\n当然，我们并不想在每一个网络请求里都写上面一大段代码来处理 `error`，那样太傻了。比如上面 `getUser()` 请求，我希望只要写 `handleUser()` 这个方法，至于是网络问题还是 server 自己问题我都不想每次去 handle。\n\n接下来我们来封装上面两个 `Action` 。我们可以自定义两个 `Action`:\n\n```java\nWebSuccessAction<T extends JsonDataResponse> implements Action1<T> \n```\n\n```java\nWebFailureAction implements Action1<Throwable>\n```\n\n其中，`WebSuccessAction` 用来处理一切正常（网络正常，请求正常，`rc=0`）后的处理，`WebFailureAction` 用来统一处理上面`三种 error`。\n\n实现如下：\n\n```java\nclass WebSuccessAction<T extends JsonDataResponse> implements Action1<T> {\n  @Override\n  public void call(T response) {\n    int rc = response.getRc();\n    if (rc != 0) {\n      throw new ResponseCodeError(extendedResponse.getMessage());\n    }\n    onSuccess(extendedResponse);\n  }\n\n  public abstract void onSuccess(T extendedResponse);\n}\n```\n\n```java\n// (rc != 0) Error\nclass ResponseCodeError extends RuntimeException {\n  public ResponseCodeError(String detailMessage) {\n    super(detailMessage);\n  }\n}\n```\n\n在 `WebSuccessAction` 里，我们把 `rc != 0` 这种情况转化成 `ResponseCodeError` 并抛出给 `WebFailureAction` 去统一处理。\n\n```java\nclass WebFailAction implements Action1<Throwable> {\n  @Override\n  public void call(Throwable throwable) {\n    String errorMsg = \"\";\n    if (throwable instanceof IOException) {\n      errorMsg = \"Please check your network status\";\n    } else if (throwable instanceof HttpException) {\n      HttpException httpException = (HttpException) throwable;\n      // such as: \"server internal error\".\n      errorMsg = httpException.response(); \n    } else {\n      errorMsg = \"unknown error\";\n    }\n    Toast.makeToast(...);\n  }\n}\n```\n\n有了上面两个自定义 `Action` 后，我们就可以把前面 `getUser()` 请求转化如下：\n\n```java\nuserApi.getUser(1)\n  .compose(RxUtil.normalSchedulers())\n  .subscribe(new WebSuccessAction<JsonDataResponse<User>>() {\n      @Override\n      public void onSuccess(JsonDataResponse<User> response) {\n    \thandleUser(response.getUser());\n      }\n    }, new WebFailAction())\n```\n\nBingo! 至此我们能够用非常简洁的方式来执行网络操作，而且完全不用担心异常处理。\n\n\n\n## 内存优化实践\n\n在内存优化方面，Google 官方文档里能找到非常多的学习资料，例如常见的内存泄漏、[bitmap官方最佳实践](https://developer.android.com/training/displaying-bitmaps/manage-memory.html)。而且 Android studio 里也集成了很多有效的工具如 [Heap Viewer](https://developer.android.com/studio/profile/heap-viewer-walkthru.html), [Memory Monitor](https://developer.android.com/studio/profile/am-memory.html) 和 [Hierarchy Viewer](https://developer.android.com/studio/profile/hierarchy-viewer.html) 等等。\n\n下面，本文将从其它角度出发，来对内存作进一步优化。\n\n#### 1. 当Activity关闭时，立即取消掉网络请求结果处理。\n\n这一点很容易被忽略掉。大家最常用的做法是在 `Activity` 执行网络操作，当 `Http Response` 回来后直接进行UI渲染，却并不会去判断此时 `Activity` 是否仍然存在，即用户是否已经离开了当时的页面。\n\n那么，有什么方法能够让每个网络请求都自动监听 Activity(Fragment) 的 lifecycle 事件并且当特定 lifecycle 事件发生时，`自动中断`掉网络请求的继续执行呢？\n\n首先来看下我们的网络请求代码：\n\n```java\nuserApi.getUser(1)\n  .compose(RxUtil.normalSchedulers())\n  .subscribe(new WebSuccessAction<JsonDataResponse<User>>() {\n      @Override\n      public void onSuccess(JsonDataResponse<User> response) {\n    \thandleUser(response.getUser());\n      }\n    }, new WebFailAction())\n```\n\n我们希望达到的是，当 `Activity` 进入 `onStop` 时立即停掉网络请求的后续处理。\n\n这里我们参考了 [RxLifecycle](https://github.com/trello/RxLifecycle) 的实现方式，之所以没有直接使用 [RxLifecycle](https://github.com/trello/RxLifecycle) 是因为它必须我们的 BaseActivity 继承其提供的 [RxActivity](https://github.com/trello/RxLifecycle/blob/master/rxlifecycle-components/src/main/java/com/trello/rxlifecycle/components/RxActivity.java) ，而 RxActivity 并未继承我们需要的 `AppCompatActivity`。因此本人只能在学习其源码后，自己重新实现一套，并做了一些改动以更符合我们自己的应用场景。\n\n具体实现如下：\n\n- 首先，我们在 BaseActivity 里，利用 RxJava 提供的 `PublishSubject` 把所有 lifecycle event 发送出来。\n\n  ```java\n  class BaseActivity extends AppCompatActivity {\n    protected final PublishSubject<ActivityLifeCycleEvent> lifecycleSubject = PublishSubject.create();\n    \n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n      super.onCreate(savedInstanceState);\n\n      lifecycleSubject.onNext(ActivityLifeCycleEvent.CREATE);\n    }\n    \n    @Override\n    protected void onDestroy() {\n      lifecycleSubject.onNext(ActivityLifeCycleEvent.DESTROY);\n      \n      super.onDestroy();\n    }\n    \n    @Override\n    protected void onStop() {\n      lifecycleSubject.onNext(ActivityLifeCycleEvent.STOP);\n\n      super.onStop();\n    }\n  }\n  ```\n\n- 然后，在 `BaseActivity` 里，提供 `bindUntilEvent(LifeCycleEvent)` 方法\n\n  ```java\n  class BaseActivity extends AppCompatActivity {\n    \n    @NonNull\n    @Override\n    public <T> Observable.Transformer<T, T> bindUntilEvent(@NonNull final ActivityLifeCycleEvent event) {\n      return new Observable.Transformer<T, T>() {\n        @Override\n        public Observable<T> call(Observable<T> sourceObservable) {\n          Observable<ActivityLifeCycleEvent> o =\n              lifecycleSubject.takeFirst(activityLifeCycleEvent -> {\n                return activityLifeCycleEvent.equals(event);\n              });\n          return sourceObservable.takeUntil(o);\n        }\n      };\n    }\n  }\n  ```\n\n  这个方法可以用于每一个网络请求 Observable 中，当它监听到特定的 lifecycle event 时，就会自动让网络请求 Observable 终止掉，不会再去监听网络请求结果。\n\n- 具体使用如下：\n\n  ```java\n  userApi.getUser(1)\n    .compose(bindUntilEvent(ActivityLifeCycleEvent.PAUSE))\n    .compose(RxUtil.normalSchedulers())\n    .subscribe(new WebSuccessAction<JsonDataResponse<User>>() {\n      @Override\n        public void onSuccess(JsonDataResponse<User> response) {\n          handleUser(response.getUser());\n        }\n    }, new WebFailAction())\n  ```\n\n  利用 `.compose(bindUntilEvent(ActivityLifeCycleEvent.STOP))` 来监听 Activity 的 Stop 事件并终止 `userApi.getUser(1)` 的 `subscription`，从而防止内存泄漏。\n\n#### 2. 图片优化实践\n\nAndroid开发者都知道，每个app的可用内存时有限的，一旦内存占用太多或者在主线程突然请求较大内存，很有可能发生 OOM 问题。而其中，图片又是占用内存的大头，因此我们必须采取多种方法来进行优化。\n\n多数情况下我们是从 server 获取一张高清图片下来，然后在内存里进行裁剪成需要的大小来进行显示。这里面存在两个问题，\n\n1：假设我们只需要一张小图，而server取回来的图如果比较大，那就会浪费带宽和内存。\n\n2：如果直接在主线程去为图片请求大块空间，很容易由于系统难于快速分配而 OOM；\n\n比较理想的情况是：需要显示多大的图片，就向server请求多大的图片，既节省用户带宽流量，更减少内存的占用，减小 OOM 的机率。\n\n为了实现 server 端的图片Resize，我们采用了 [thumbor](https://github.com/thumbor/thumbor) 来提供图片 Resize 的功能。android端只需要提供一个原图片 URL 和需要的 size 信息，就可以得到一张 Resize 好的图片资源文件。具体server端实现这里就不细讲了，感兴趣的读者可以阅读官方文档。\n\n这里介绍下我们在 Android 端的实现，以 Picasso 为栗子。\n\n- 首先要引入 Square 提供的 [pollexor](https://github.com/square/pollexor) 工具，它可以让我们更简便的创建 thumbor 的规范 URI，参考如下：\n\n  ```java\n  thumbor.buildImage(\"http://example.com/image.png\")\n      .resize(48, 48)\n      .toUrl()\n  ```\n\n- 然后，利用 Picasso 提供的 requestTransformer 来实时获取当前需要显示的图片的真实尺寸，同时设置图片格式为 WebP，这种格式的图片可以保持图片质量的同时具有更小的体积：\n\n  ```java\n  Picasso picasso = new Picasso.Builder(context).requestTransformer(new Picasso.RequestTransformer() {\n        @Override\n        public Request transformRequest(Request request) {\n          String modifiedUrl = URLEncoder.encode(originUrl);\n          ThumborUrlBuilder thumborUrlBuilder = thumbor.buildImage(modifiedUrl);\n          String url = thumborUrlBuilder.resize(request.targetWidth, request.targetHeight)\n              .filter(ThumborUrlBuilder.format(ThumborUrlBuilder.ImageFormat.WEBP))\n              .toUrl();\n          Timber.i(\"SponsorAd Image Resize url to \" + url);\n          return request.buildUpon().setUri(Uri.parse(url)).build();\n        }\n      }).build();\n  ```\n\n- 利用修改后的 picasso 对象来请求图片\n\n  ```java\n  picasso.load(originUrl).fit().centerCrop().into(imageView);\n  ```\n\n利用上面这种方法，我们可以为不同的 ImageView 计算显示需要的真实尺寸，然后去请求一张尺寸匹配的图片下来，节约带宽，减小内存开销。\n\n当然，在应用这种方法的时候，不要忘记考虑服务器的负载情况，毕竟这种方案意味着每张图片会被生成各种尺寸的小图缓存起来，而且Android设备分辨率不同，即使是同一个 ImageView，真实的宽高 Pixel 值也会不同，从而生成不同的小图。\n\n\n\n## 在App和Library中集成依赖注入\n\n依赖注入框架 [Dagger](https://github.com/square/dagger) 我们很早就开始用了，从早期的 Dagger1 到现在的 Dagger2。虽然 Dagger 本身较为陡峭的学习曲线使得不少人止步，不过一旦用过，根本停不下来。\n\n如果只是在 App 里使用 Dagger 相对比较简单，不过，我们还需要在 `Community` 和 `Base-Android` 两个公用 Library 里也集成 Dagger，这就需要费点功夫了。\n\n下面我来逐步讲解下我们是如何将 Dagger 同时集成进 App 和 Library 中。\n\n#### 1. 在App里集成Dagger\n\n首先需要在 `GlowApplication` 里生成一个全局的 `AppComponent`\n\n```java\n@Singleton\n@Component(modules = AppModule.class)\npublic interface AppComponent {\n  void inject(MainActivity mainActivity);\n}\n```\n\n创建 `AppModule`\n\n```java\n@Module\npublic class AppModule {\n  private final LexieApplication lexieApplication;\n\n  public AppModule(LexieApplication lexieApplication) {\n    this.lexieApplication = lexieApplication;\n  }\n  \n  @Provides Context applicationContext() {\n    return lexieApplication;\n  }\n  \n  // mock tool object\n  @Provides Tool provideTool() {\n    return new Tool();\n  }\n}\n```\n\n集成进 `Application`\n\n```java\nclass GlowApplication extends Application {\n  private AppComponent appComponent;\n  \n  @Override\n  public void onCreate() {\n    appComponent = DaggerAppComponent.builder()\n        .appModule(new AppModule(this))\n        .build();\n  }\n  \n  public static AppComponent getAppComponent() {\n    return appComponent;\n  }\n}\n```\n\n在 `MainActivity`中使用`inject` 一个 `tool` 对象\n\n```java\nclass MainActivity extends Activity {\n  @Inject Tool tool;\n  \n  @Override\n  public void onCreate() {\n    GlowApplication.getAppComponent().inject(this);\n  }\n}\n```\n\n#### 2. 在 Library 中集成 Dagger\n\n（下面以公用Library：Community为例子）\n\n逆向思维下，先设想应用场景：即 Dagger 已经集成好了，那么我们应该可以按如下方式在 `CommunityActivity` 里 `inject` 一个 `tool` 对象。\n\n```java\nclass CommunityActivity extends Activity {\n  @Inject Tool tool;\n  \n  @Override\n  public void onCreate() {\n    GlowApplication.getAppComponent().inject(this);\n  }\n}\n```\n\n关键在于： `GlowApplication.getAppComponent().inject(this);` 这一句。\n\n那么问题来了：\n\n**对于一个 Library 而言，它是无法拿到 GlowApplication 对象的，因为作为一个被别人调用的 Library，它甚至不知道这个上层 class 的存在**\n\n为了解决这个问题，我们在`community`里定义一个公用接口作为`中间桥梁`，让`GlowApplication`实现这个公共接口即可。\n\n```java\n// 在Community定义接口CommunityComponentProvider\npublic interface CommunityComponentProvider {\n  AppComponent getAppComponent();\n}\n```\n\n```java\n// 每个app的Application类都实现这个接口来提供AppComponent\nclass GlowApplication implements CommunityComponentProvider {\n  AppComponent getAppComponent() {\n    return appComponent;\n  }\n}\n```\n\n然后 `CommunityActivity`就可以实现如下：\n\n```java\nclass CommunityActivity extends Activity {\n  @Inject Tool tool;\n  \n  @Override\n  public void onCreate() {\n    Context applicationContext = getApplicationContext();\n    CommunityComponentProvider provider = (CommunityComponentProvider) applicationContext;\n    provider.getAppComponent().inject(this);\n  }\n}\n```\n\n#### 3. 从 AppComponent 抽离 CommunityComponent\n\n```java\nprovider.getAppComponent().inject(this);\n```\n\n这一句里我们已经实现前半句 `provider.getAppComponent()` 了，但后半句的实现呢？\n\n正常情况下，我们要把\n\n```java\nvoid inject(CommunityActivity communityActivity);\n```\n\n放入 `AppComponent` 中\n\n```java\n@Singleton\n@Component(modules = AppModule.class)\npublic interface AppComponent {\n  void inject(MainActivity mainActivity);\n  \n  // 加在这里\n  void inject(CommunityActivity communityActivity);\n}\n```\n\n其实这样我们就已经几乎完成了整个 Library 和 App 的依赖注入了。\n\n但细心的朋友应该发现里面存在一个小问题，那就是\n\n```java\nvoid inject(CommunityActivity communityActivity);\n```\n\n这句代码如果放入了 `App` 里的 `AppComponent` 里，那就意味着我们也需要在另外三个 `App` 里的 `AppComponent` 都加上一句相同的代码？这样可以吗？\n\n理论上当然是可行的。但是，从单一职责的角度来考虑，`AppComponent` 只需要负责 `App` 层的 `inject` 就行，我们不应该把属于 `Community` 的 `inject` 放到`App` 里，这样的代码太ugly，而且更重要的是，随着 Community 越来越多 Activity 需要 inject ，每个 inject 都要在各个 App 里重复加，这太烦了，也太笨了。\n\n因此，我们采用了一个简洁有效的方法来改进。\n\n在 `Community` 里创建一个 `CommunityComponent`，所有属于 `Community` 的`inject` 直接写在 `CommunityComponent` 里，不需要 `App` 再去关心。与此同时，为了保持前面 `provider.getAppComponent()` 仍然有效，我们让 `AppComponent` 继承 `CommunityComponent`。\n\n实现代码如下：\n\n```java\nclass AppComponent extends CommunityComponent {...}\n```\n\n在 `Community` 里\n\n```java\nclass CommunityComponent {\n  void inject(CommunityActivity communityActivity);\n}\n```\n\n```java\nclass CommunityActivity extends Activity {\n  @Inject Tool tool;\n  \n  @Override\n  public void onCreate() {\n    Context applicationContext = getApplicationContext();\n    CommunityComponentProvider provider = (CommunityComponentProvider) applicationContext;\n    provider.getAppComponent().inject(this);\n  }\n}\n```\n\n![依赖注入](http://upload-images.jianshu.io/upload_images/281665-483c8a864c09503d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nBingo! 至此我们已经能够优雅简洁地在 App 和 Library 里同时应用依赖注入了。\n\n\n\n## 小结\n\n由于篇幅有限，本文暂时先从网络层、内存优化和依赖注入方面进行讲解，之后会再考虑从 Logging模块、数据同步模块、Deep Linking模块、多Library的Gradle发布管理、持续集成和崩溃监测模块等进行讲解。\n\n谢谢。\n\nwingjay\n\n\n[我的Github](https://github.com/wingjay): <https://github.com/wingjay> \n[微博 iam_wingjay](http://weibo.com/u/1625892654): <http://weibo.com/u/1625892654>\n\n如果有问题，可以给我留言或发邮件<mailto:yinjiesh@126.com>","source":"_posts/干货-Glow-Android-优化实践.md","raw":"title: '[干货] Glow Android 优化实践'\ndate: 2016-11-02 19:58:15\ncategories:\n  - Android\ntags: Android\ncommentIssueId: 12\n---\n\n> 分享下自己在实际工作中积累的技术经验。\n\n<!-- more -->\n\n了解 Glow 的朋友应该知道，我们主营四款 App，分别是Eve、Glow、Nuture和Baby。作为创业公司，我们的四款 App 都处于高速开发中，平均每个 Android App 由两人负责开发，包括 Android 和 Server 开发，在满足 PM 各种需求的同时，我们的session crash free率保持不低于 99.8%，其中两款 App 接近 100%。\n\n本文将对 Glow 当前 Android 对现有工具的探索及优化作出讲解，希望对读者有所启发。\n\n## 整体结构概览\n\n由于架构都是为了实际业务服务，因此在深入讲解前，需要先展示 Android 端的大体结构：\n\n ![Glow Android 整体结构](http://upload-images.jianshu.io/upload_images/281665-6a05f7e014dc6234.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们有四个 Android App，它们共用同一个 Community 社区，最底层是 Base-Library，存放公用的模块组件，如支付模块，Logging模块等等。\n\n下面，我将依次从以下几个方面进行讲解：\n\n- 网络层优化\n- 内存优化实践\n- 在App和Library中集成依赖注入\n- etc.\n\n\n\n\n## 网络层优化\n\n#### 1. Retrofit2 + OkHttp3 + RxJava\n\n上面这套结构是目前最为流行的网络层架构，可以帮我们写出简洁而稳定的网络请求代码，比起以前复杂的异步回调、主次线程切换等代码更为易用，而且能支持 `https` 请求。\n\n基本用法如下:\n\n```java\nUserApi userApi = retrofit.create(UserApi.class);  \n```\n\n```java\n@Get(\"/{id}\")\nObservable<User> getUser(@Path(\"id\") long id);\n```\n\n```java\nuserApi.getUser(1)\n  .subscribeOn(Schedulers.io())\n  .observeOn(AndroidSchedulers.mainThread())\n  .subscribe(new Action1<User>() {\n    @Override\n    public void call(User user) {\n\t\t// handle user\n    }\n  }, new Action1<Throwable>() {\n    @Override\n    public void call(Throwable throwable) {\n\t\t// handle throwable\n    }\n  });\n```\n\n这只是通用做法。下面我们要根据实际情况进行优化。\n\n#### 2. 封装线程切换代码\n\n上面的代码中可以看到，为了执行网络请求，我们会利用`RxJava`提供的`Schedulers`工具来方便切换线程。\n\n```java\n  .subscribeOn(Schedulers.io())\n  .observeOn(AndroidSchedulers.mainThread())\n```\n\n上面的代码的作用是：让网络请求进入 `io线程` 执行，并将返回结果转入 `UI线程` 去进行渲染。\n\n不过，我们 app 有非常多的网络请求，而且除了`网络请求`，其他的`数据库操作` 或者 `文件读写操作` 都需要一样的线程切换。因此，为了代码复用，我们利用 `RxJava` 提供的 `Transformer` 来进行封装。\n\n```java\n// RxUtil.java  \npublic static <T> Observable.Transformer<T, T> normalSchedulers() {\n  return new Observable.Transformer<T, T>() {\n    @Override\n    public Observable<T> call(Observable<T> source) {\n      return source.subscribeOn(Schedulers.io())\n        .observeOn(AndroidSchedulers.mainThread());\n    }\n  };\n}\n```\n\n然后，我们可以把网络请求代码转化为\n\n```java\nuserApi.getUser(1)\n  .compose(RxUtil.normalSchedulers())\n  .subscribe(...)\n```\n\n这虽然只是很简单的改进，但能让我们的代码更简洁，更不易出错。\n\n#### 3. 封装响应结果 JsonDataResponse\n\n我们 server 的所有返回结果都符合如下格式:\n\n```json\n{\n  'rc': 0,\n  'data': {...},\n  'msg': \"Successful Call\"\n}\n```\n\n其中 `rc` 是自定义的结果标志，server 用来告诉我们该请求的逻辑处理是否成功（此时 `rc = 0`）。`data`是这个请求需要的 json 数据。`msg`一般用来存放错误提示信息。\n\n于是我们创建了一个通用类来封装所有的 `Response`。\n\n```java\npublic class JsonDataResponse<T> {\n  @SerializedName(\"rc\")\n  private int rc;\n\n  @SerializedName(\"msg\")\n  private String msg;\n\n  @SerializedName(\"data\")\n  T data;\n  \n  public int getRc() { return rc; }\n  \n  public T getData() { return data; }\n} \n```\n\n于是，我们的请求变成如下：\n\n```java\n@Get(\"/{id}\")\nObservable<JsonDataResponse<User>> getUser(@Path(\"id\") long id);\n```\n\n```java\nuserApi.getUser(1)\n  .compose(RxUtil.normalSchedulers())\n  .subscribe(new Action1<JsonDataResponse<User>>() {\n    @Override\n    public void call(JsonDataResponse<User> response) {\n\t\tif (response.getRc() == 0) {\n          User user = response.getData();\n          // handle user\n\t\t} else {\n          Toast.makeToast(context, response.getMsg())\n\t\t}\n    }\n  }, new Action1<Throwable>() {\n    @Override\n    public void call(Throwable throwable) {\n\t\t// handle throwable\n    }\n  });\n```\n\n#### 4. 异常处理\n\n上面已经能完成正常的网络请求了，但是，却还没有对错误进行处理。\n\n一次网络请求中，可能发生以下几种错误：\n\n- 没有网络\n- 网络正常，但 http 请求失败，即 http 状态码不在 `[200, 300)` 之间，如`404`、`500`等\n- 网络正常，http 请求成功，但是 server 在处理请求时出了问题，使得返回结果的 `rc != 0`\n\n不同的错误，我们希望给用户不同的提示，并且统计这些错误。\n\n目前我们的网络请求里已经能够处理第三种情况，另外两种都在 `throwable` 里面，我们可以通过判断 `throwable` 是 `IOException` 还是 `retrofit2.HttpException` 来区分这两种情况。\n\n因此，我们可得到如下异常处理代码：\n\n```java\nuserApi.getUser(1)\n  .compose(RxUtil.normalSchedulers())\n  .subscribe(new Action1<JsonDataResponse<User>>() {\n    @Override\n    public void call(JsonDataResponse<User> response) {\n\t\tif (response.getRc() == 0) {\n          User user = response.getData();\n          // handle user\n          handleUser();\n\t\t} else {\n          // such as: customized errorMsg: \"cannot find this user\".\n          Toast.makeToast(context, response.getMsg(), Toast.LENGTH_SHORT).show();\n\t\t}\n    }\n  }, new Action1<Throwable>() {\n    @Override\n    public void call(Throwable throwable) {\n        String errorMsg = \"\";\n\t\tif (throwable instanceof IOException) {\n          // io Exception\n          errorMsg = \"Please check your network status\";\n\t\t} else if (throwable instanceof HttpException) {\n          HttpException httpException = (HttpException) throwable;\n          // http error.\n          errorMsg = httpException.response(); \n\t\t} else {\n          errorMsg = \"unknown error\";\n\t\t}\n        Toast.makeToast(...);\n    }\n  });\n```\n\n#### 5. 封装异常处理代码\n\n当然，我们并不想在每一个网络请求里都写上面一大段代码来处理 `error`，那样太傻了。比如上面 `getUser()` 请求，我希望只要写 `handleUser()` 这个方法，至于是网络问题还是 server 自己问题我都不想每次去 handle。\n\n接下来我们来封装上面两个 `Action` 。我们可以自定义两个 `Action`:\n\n```java\nWebSuccessAction<T extends JsonDataResponse> implements Action1<T> \n```\n\n```java\nWebFailureAction implements Action1<Throwable>\n```\n\n其中，`WebSuccessAction` 用来处理一切正常（网络正常，请求正常，`rc=0`）后的处理，`WebFailureAction` 用来统一处理上面`三种 error`。\n\n实现如下：\n\n```java\nclass WebSuccessAction<T extends JsonDataResponse> implements Action1<T> {\n  @Override\n  public void call(T response) {\n    int rc = response.getRc();\n    if (rc != 0) {\n      throw new ResponseCodeError(extendedResponse.getMessage());\n    }\n    onSuccess(extendedResponse);\n  }\n\n  public abstract void onSuccess(T extendedResponse);\n}\n```\n\n```java\n// (rc != 0) Error\nclass ResponseCodeError extends RuntimeException {\n  public ResponseCodeError(String detailMessage) {\n    super(detailMessage);\n  }\n}\n```\n\n在 `WebSuccessAction` 里，我们把 `rc != 0` 这种情况转化成 `ResponseCodeError` 并抛出给 `WebFailureAction` 去统一处理。\n\n```java\nclass WebFailAction implements Action1<Throwable> {\n  @Override\n  public void call(Throwable throwable) {\n    String errorMsg = \"\";\n    if (throwable instanceof IOException) {\n      errorMsg = \"Please check your network status\";\n    } else if (throwable instanceof HttpException) {\n      HttpException httpException = (HttpException) throwable;\n      // such as: \"server internal error\".\n      errorMsg = httpException.response(); \n    } else {\n      errorMsg = \"unknown error\";\n    }\n    Toast.makeToast(...);\n  }\n}\n```\n\n有了上面两个自定义 `Action` 后，我们就可以把前面 `getUser()` 请求转化如下：\n\n```java\nuserApi.getUser(1)\n  .compose(RxUtil.normalSchedulers())\n  .subscribe(new WebSuccessAction<JsonDataResponse<User>>() {\n      @Override\n      public void onSuccess(JsonDataResponse<User> response) {\n    \thandleUser(response.getUser());\n      }\n    }, new WebFailAction())\n```\n\nBingo! 至此我们能够用非常简洁的方式来执行网络操作，而且完全不用担心异常处理。\n\n\n\n## 内存优化实践\n\n在内存优化方面，Google 官方文档里能找到非常多的学习资料，例如常见的内存泄漏、[bitmap官方最佳实践](https://developer.android.com/training/displaying-bitmaps/manage-memory.html)。而且 Android studio 里也集成了很多有效的工具如 [Heap Viewer](https://developer.android.com/studio/profile/heap-viewer-walkthru.html), [Memory Monitor](https://developer.android.com/studio/profile/am-memory.html) 和 [Hierarchy Viewer](https://developer.android.com/studio/profile/hierarchy-viewer.html) 等等。\n\n下面，本文将从其它角度出发，来对内存作进一步优化。\n\n#### 1. 当Activity关闭时，立即取消掉网络请求结果处理。\n\n这一点很容易被忽略掉。大家最常用的做法是在 `Activity` 执行网络操作，当 `Http Response` 回来后直接进行UI渲染，却并不会去判断此时 `Activity` 是否仍然存在，即用户是否已经离开了当时的页面。\n\n那么，有什么方法能够让每个网络请求都自动监听 Activity(Fragment) 的 lifecycle 事件并且当特定 lifecycle 事件发生时，`自动中断`掉网络请求的继续执行呢？\n\n首先来看下我们的网络请求代码：\n\n```java\nuserApi.getUser(1)\n  .compose(RxUtil.normalSchedulers())\n  .subscribe(new WebSuccessAction<JsonDataResponse<User>>() {\n      @Override\n      public void onSuccess(JsonDataResponse<User> response) {\n    \thandleUser(response.getUser());\n      }\n    }, new WebFailAction())\n```\n\n我们希望达到的是，当 `Activity` 进入 `onStop` 时立即停掉网络请求的后续处理。\n\n这里我们参考了 [RxLifecycle](https://github.com/trello/RxLifecycle) 的实现方式，之所以没有直接使用 [RxLifecycle](https://github.com/trello/RxLifecycle) 是因为它必须我们的 BaseActivity 继承其提供的 [RxActivity](https://github.com/trello/RxLifecycle/blob/master/rxlifecycle-components/src/main/java/com/trello/rxlifecycle/components/RxActivity.java) ，而 RxActivity 并未继承我们需要的 `AppCompatActivity`。因此本人只能在学习其源码后，自己重新实现一套，并做了一些改动以更符合我们自己的应用场景。\n\n具体实现如下：\n\n- 首先，我们在 BaseActivity 里，利用 RxJava 提供的 `PublishSubject` 把所有 lifecycle event 发送出来。\n\n  ```java\n  class BaseActivity extends AppCompatActivity {\n    protected final PublishSubject<ActivityLifeCycleEvent> lifecycleSubject = PublishSubject.create();\n    \n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n      super.onCreate(savedInstanceState);\n\n      lifecycleSubject.onNext(ActivityLifeCycleEvent.CREATE);\n    }\n    \n    @Override\n    protected void onDestroy() {\n      lifecycleSubject.onNext(ActivityLifeCycleEvent.DESTROY);\n      \n      super.onDestroy();\n    }\n    \n    @Override\n    protected void onStop() {\n      lifecycleSubject.onNext(ActivityLifeCycleEvent.STOP);\n\n      super.onStop();\n    }\n  }\n  ```\n\n- 然后，在 `BaseActivity` 里，提供 `bindUntilEvent(LifeCycleEvent)` 方法\n\n  ```java\n  class BaseActivity extends AppCompatActivity {\n    \n    @NonNull\n    @Override\n    public <T> Observable.Transformer<T, T> bindUntilEvent(@NonNull final ActivityLifeCycleEvent event) {\n      return new Observable.Transformer<T, T>() {\n        @Override\n        public Observable<T> call(Observable<T> sourceObservable) {\n          Observable<ActivityLifeCycleEvent> o =\n              lifecycleSubject.takeFirst(activityLifeCycleEvent -> {\n                return activityLifeCycleEvent.equals(event);\n              });\n          return sourceObservable.takeUntil(o);\n        }\n      };\n    }\n  }\n  ```\n\n  这个方法可以用于每一个网络请求 Observable 中，当它监听到特定的 lifecycle event 时，就会自动让网络请求 Observable 终止掉，不会再去监听网络请求结果。\n\n- 具体使用如下：\n\n  ```java\n  userApi.getUser(1)\n    .compose(bindUntilEvent(ActivityLifeCycleEvent.PAUSE))\n    .compose(RxUtil.normalSchedulers())\n    .subscribe(new WebSuccessAction<JsonDataResponse<User>>() {\n      @Override\n        public void onSuccess(JsonDataResponse<User> response) {\n          handleUser(response.getUser());\n        }\n    }, new WebFailAction())\n  ```\n\n  利用 `.compose(bindUntilEvent(ActivityLifeCycleEvent.STOP))` 来监听 Activity 的 Stop 事件并终止 `userApi.getUser(1)` 的 `subscription`，从而防止内存泄漏。\n\n#### 2. 图片优化实践\n\nAndroid开发者都知道，每个app的可用内存时有限的，一旦内存占用太多或者在主线程突然请求较大内存，很有可能发生 OOM 问题。而其中，图片又是占用内存的大头，因此我们必须采取多种方法来进行优化。\n\n多数情况下我们是从 server 获取一张高清图片下来，然后在内存里进行裁剪成需要的大小来进行显示。这里面存在两个问题，\n\n1：假设我们只需要一张小图，而server取回来的图如果比较大，那就会浪费带宽和内存。\n\n2：如果直接在主线程去为图片请求大块空间，很容易由于系统难于快速分配而 OOM；\n\n比较理想的情况是：需要显示多大的图片，就向server请求多大的图片，既节省用户带宽流量，更减少内存的占用，减小 OOM 的机率。\n\n为了实现 server 端的图片Resize，我们采用了 [thumbor](https://github.com/thumbor/thumbor) 来提供图片 Resize 的功能。android端只需要提供一个原图片 URL 和需要的 size 信息，就可以得到一张 Resize 好的图片资源文件。具体server端实现这里就不细讲了，感兴趣的读者可以阅读官方文档。\n\n这里介绍下我们在 Android 端的实现，以 Picasso 为栗子。\n\n- 首先要引入 Square 提供的 [pollexor](https://github.com/square/pollexor) 工具，它可以让我们更简便的创建 thumbor 的规范 URI，参考如下：\n\n  ```java\n  thumbor.buildImage(\"http://example.com/image.png\")\n      .resize(48, 48)\n      .toUrl()\n  ```\n\n- 然后，利用 Picasso 提供的 requestTransformer 来实时获取当前需要显示的图片的真实尺寸，同时设置图片格式为 WebP，这种格式的图片可以保持图片质量的同时具有更小的体积：\n\n  ```java\n  Picasso picasso = new Picasso.Builder(context).requestTransformer(new Picasso.RequestTransformer() {\n        @Override\n        public Request transformRequest(Request request) {\n          String modifiedUrl = URLEncoder.encode(originUrl);\n          ThumborUrlBuilder thumborUrlBuilder = thumbor.buildImage(modifiedUrl);\n          String url = thumborUrlBuilder.resize(request.targetWidth, request.targetHeight)\n              .filter(ThumborUrlBuilder.format(ThumborUrlBuilder.ImageFormat.WEBP))\n              .toUrl();\n          Timber.i(\"SponsorAd Image Resize url to \" + url);\n          return request.buildUpon().setUri(Uri.parse(url)).build();\n        }\n      }).build();\n  ```\n\n- 利用修改后的 picasso 对象来请求图片\n\n  ```java\n  picasso.load(originUrl).fit().centerCrop().into(imageView);\n  ```\n\n利用上面这种方法，我们可以为不同的 ImageView 计算显示需要的真实尺寸，然后去请求一张尺寸匹配的图片下来，节约带宽，减小内存开销。\n\n当然，在应用这种方法的时候，不要忘记考虑服务器的负载情况，毕竟这种方案意味着每张图片会被生成各种尺寸的小图缓存起来，而且Android设备分辨率不同，即使是同一个 ImageView，真实的宽高 Pixel 值也会不同，从而生成不同的小图。\n\n\n\n## 在App和Library中集成依赖注入\n\n依赖注入框架 [Dagger](https://github.com/square/dagger) 我们很早就开始用了，从早期的 Dagger1 到现在的 Dagger2。虽然 Dagger 本身较为陡峭的学习曲线使得不少人止步，不过一旦用过，根本停不下来。\n\n如果只是在 App 里使用 Dagger 相对比较简单，不过，我们还需要在 `Community` 和 `Base-Android` 两个公用 Library 里也集成 Dagger，这就需要费点功夫了。\n\n下面我来逐步讲解下我们是如何将 Dagger 同时集成进 App 和 Library 中。\n\n#### 1. 在App里集成Dagger\n\n首先需要在 `GlowApplication` 里生成一个全局的 `AppComponent`\n\n```java\n@Singleton\n@Component(modules = AppModule.class)\npublic interface AppComponent {\n  void inject(MainActivity mainActivity);\n}\n```\n\n创建 `AppModule`\n\n```java\n@Module\npublic class AppModule {\n  private final LexieApplication lexieApplication;\n\n  public AppModule(LexieApplication lexieApplication) {\n    this.lexieApplication = lexieApplication;\n  }\n  \n  @Provides Context applicationContext() {\n    return lexieApplication;\n  }\n  \n  // mock tool object\n  @Provides Tool provideTool() {\n    return new Tool();\n  }\n}\n```\n\n集成进 `Application`\n\n```java\nclass GlowApplication extends Application {\n  private AppComponent appComponent;\n  \n  @Override\n  public void onCreate() {\n    appComponent = DaggerAppComponent.builder()\n        .appModule(new AppModule(this))\n        .build();\n  }\n  \n  public static AppComponent getAppComponent() {\n    return appComponent;\n  }\n}\n```\n\n在 `MainActivity`中使用`inject` 一个 `tool` 对象\n\n```java\nclass MainActivity extends Activity {\n  @Inject Tool tool;\n  \n  @Override\n  public void onCreate() {\n    GlowApplication.getAppComponent().inject(this);\n  }\n}\n```\n\n#### 2. 在 Library 中集成 Dagger\n\n（下面以公用Library：Community为例子）\n\n逆向思维下，先设想应用场景：即 Dagger 已经集成好了，那么我们应该可以按如下方式在 `CommunityActivity` 里 `inject` 一个 `tool` 对象。\n\n```java\nclass CommunityActivity extends Activity {\n  @Inject Tool tool;\n  \n  @Override\n  public void onCreate() {\n    GlowApplication.getAppComponent().inject(this);\n  }\n}\n```\n\n关键在于： `GlowApplication.getAppComponent().inject(this);` 这一句。\n\n那么问题来了：\n\n**对于一个 Library 而言，它是无法拿到 GlowApplication 对象的，因为作为一个被别人调用的 Library，它甚至不知道这个上层 class 的存在**\n\n为了解决这个问题，我们在`community`里定义一个公用接口作为`中间桥梁`，让`GlowApplication`实现这个公共接口即可。\n\n```java\n// 在Community定义接口CommunityComponentProvider\npublic interface CommunityComponentProvider {\n  AppComponent getAppComponent();\n}\n```\n\n```java\n// 每个app的Application类都实现这个接口来提供AppComponent\nclass GlowApplication implements CommunityComponentProvider {\n  AppComponent getAppComponent() {\n    return appComponent;\n  }\n}\n```\n\n然后 `CommunityActivity`就可以实现如下：\n\n```java\nclass CommunityActivity extends Activity {\n  @Inject Tool tool;\n  \n  @Override\n  public void onCreate() {\n    Context applicationContext = getApplicationContext();\n    CommunityComponentProvider provider = (CommunityComponentProvider) applicationContext;\n    provider.getAppComponent().inject(this);\n  }\n}\n```\n\n#### 3. 从 AppComponent 抽离 CommunityComponent\n\n```java\nprovider.getAppComponent().inject(this);\n```\n\n这一句里我们已经实现前半句 `provider.getAppComponent()` 了，但后半句的实现呢？\n\n正常情况下，我们要把\n\n```java\nvoid inject(CommunityActivity communityActivity);\n```\n\n放入 `AppComponent` 中\n\n```java\n@Singleton\n@Component(modules = AppModule.class)\npublic interface AppComponent {\n  void inject(MainActivity mainActivity);\n  \n  // 加在这里\n  void inject(CommunityActivity communityActivity);\n}\n```\n\n其实这样我们就已经几乎完成了整个 Library 和 App 的依赖注入了。\n\n但细心的朋友应该发现里面存在一个小问题，那就是\n\n```java\nvoid inject(CommunityActivity communityActivity);\n```\n\n这句代码如果放入了 `App` 里的 `AppComponent` 里，那就意味着我们也需要在另外三个 `App` 里的 `AppComponent` 都加上一句相同的代码？这样可以吗？\n\n理论上当然是可行的。但是，从单一职责的角度来考虑，`AppComponent` 只需要负责 `App` 层的 `inject` 就行，我们不应该把属于 `Community` 的 `inject` 放到`App` 里，这样的代码太ugly，而且更重要的是，随着 Community 越来越多 Activity 需要 inject ，每个 inject 都要在各个 App 里重复加，这太烦了，也太笨了。\n\n因此，我们采用了一个简洁有效的方法来改进。\n\n在 `Community` 里创建一个 `CommunityComponent`，所有属于 `Community` 的`inject` 直接写在 `CommunityComponent` 里，不需要 `App` 再去关心。与此同时，为了保持前面 `provider.getAppComponent()` 仍然有效，我们让 `AppComponent` 继承 `CommunityComponent`。\n\n实现代码如下：\n\n```java\nclass AppComponent extends CommunityComponent {...}\n```\n\n在 `Community` 里\n\n```java\nclass CommunityComponent {\n  void inject(CommunityActivity communityActivity);\n}\n```\n\n```java\nclass CommunityActivity extends Activity {\n  @Inject Tool tool;\n  \n  @Override\n  public void onCreate() {\n    Context applicationContext = getApplicationContext();\n    CommunityComponentProvider provider = (CommunityComponentProvider) applicationContext;\n    provider.getAppComponent().inject(this);\n  }\n}\n```\n\n![依赖注入](http://upload-images.jianshu.io/upload_images/281665-483c8a864c09503d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nBingo! 至此我们已经能够优雅简洁地在 App 和 Library 里同时应用依赖注入了。\n\n\n\n## 小结\n\n由于篇幅有限，本文暂时先从网络层、内存优化和依赖注入方面进行讲解，之后会再考虑从 Logging模块、数据同步模块、Deep Linking模块、多Library的Gradle发布管理、持续集成和崩溃监测模块等进行讲解。\n\n谢谢。\n\nwingjay\n\n\n[我的Github](https://github.com/wingjay): <https://github.com/wingjay> \n[微博 iam_wingjay](http://weibo.com/u/1625892654): <http://weibo.com/u/1625892654>\n\n如果有问题，可以给我留言或发邮件<mailto:yinjiesh@126.com>","slug":"干货-Glow-Android-优化实践","published":1,"updated":"2018-11-26T06:56:27.486Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplsjl005k3dn8hnaz4shy","content":"<blockquote>\n<p>分享下自己在实际工作中积累的技术经验。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>了解 Glow 的朋友应该知道，我们主营四款 App，分别是 Eve、Glow、Nuture 和 Baby。作为创业公司，我们的四款 App 都处于高速开发中，平均每个 Android App 由两人负责开发，包括 Android 和 Server 开发，在满足 PM 各种需求的同时，我们的 session crash free 率保持不低于 99.8%，其中两款 App 接近 100%。</p>\n<p>本文将对 Glow 当前 Android 对现有工具的探索及优化作出讲解，希望对读者有所启发。</p>\n<h2 id=\"整体结构概览\"><a href=\"# 整体结构概览\" class=\"headerlink\" title=\"整体结构概览\"></a>整体结构概览 </h2><p> 由于架构都是为了实际业务服务，因此在深入讲解前，需要先展示 Android 端的大体结构：</p>\n<p> <img src=\"http://upload-images.jianshu.io/upload_images/281665-6a05f7e014dc6234.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Glow Android 整体结构\"></p>\n<p>我们有四个 Android App，它们共用同一个 Community 社区，最底层是 Base-Library，存放公用的模块组件，如支付模块，Logging 模块等等。</p>\n<p>下面，我将依次从以下几个方面进行讲解：</p>\n<ul>\n<li>网络层优化</li>\n<li>内存优化实践</li>\n<li>在 App 和 Library 中集成依赖注入</li>\n<li>etc.</li>\n</ul>\n<h2 id=\"网络层优化\"><a href=\"# 网络层优化\" class=\"headerlink\" title=\"网络层优化\"></a>网络层优化 </h2><h4 id=\"1-Retrofit2-OkHttp3-RxJava\"><a href=\"#1-Retrofit2-OkHttp3-RxJava\" class=\"headerlink\" title=\"1. Retrofit2 + OkHttp3 + RxJava\"></a>1. Retrofit2 + OkHttp3 + RxJava</h4><p> 上面这套结构是目前最为流行的网络层架构，可以帮我们写出简洁而稳定的网络请求代码，比起以前复杂的异步回调、主次线程切换等代码更为易用，而且能支持 <code>https</code> 请求。</p>\n<p>基本用法如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">UserApi userApi = retrofit.create(UserApi.class);</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Get</span>(<span class=\"string\">\"/&#123;id&#125;\"</span>)</div><div class=\"line\"><span class=\"function\">Observable&lt;User&gt; <span class=\"title\">getUser</span><span class=\"params\">(@Path(<span class=\"string\">\"id\"</span>)</span> <span class=\"keyword\">long</span> id)</span>;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">userApi.getUser(<span class=\"number\">1</span>)</div><div class=\"line\">  .subscribeOn(Schedulers.io())</div><div class=\"line\">  .observeOn(AndroidSchedulers.mainThread())</div><div class=\"line\">  .subscribe(<span class=\"keyword\">new</span> Action1&lt;User&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(User user)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// handle user</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;, <span class=\"keyword\">new</span> Action1&lt;Throwable&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Throwable throwable)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// handle throwable</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure>\n<p>这只是通用做法。下面我们要根据实际情况进行优化。</p>\n<h4 id=\"2- 封装线程切换代码\"><a href=\"#2- 封装线程切换代码\" class=\"headerlink\" title=\"2. 封装线程切换代码\"></a>2. 封装线程切换代码 </h4><p> 上面的代码中可以看到，为了执行网络请求，我们会利用 <code>RxJava</code> 提供的 <code>Schedulers</code> 工具来方便切换线程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">.subscribeOn(Schedulers.io())</div><div class=\"line\">.observeOn(AndroidSchedulers.mainThread())</div></pre></td></tr></table></figure>\n<p>上面的代码的作用是：让网络请求进入 <code>io 线程</code> 执行，并将返回结果转入 <code>UI 线程</code> 去进行渲染。</p>\n<p>不过，我们 app 有非常多的网络请求，而且除了 <code> 网络请求 </code>，其他的<code> 数据库操作 </code> 或者 <code> 文件读写操作</code> 都需要一样的线程切换。因此，为了代码复用，我们利用 <code>RxJava</code> 提供的 <code>Transformer</code> 来进行封装。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// RxUtil.java  </span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; Observable.<span class=\"function\">Transformer&lt;T, T&gt; <span class=\"title\">normalSchedulers</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Observable.Transformer&lt;T, T&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Observable&lt;T&gt; <span class=\"title\">call</span><span class=\"params\">(Observable&lt;T&gt; source)</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> source.subscribeOn(Schedulers.io())</div><div class=\"line\">        .observeOn(AndroidSchedulers.mainThread());</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后，我们可以把网络请求代码转化为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">userApi.getUser(<span class=\"number\">1</span>)</div><div class=\"line\">  .compose(RxUtil.normalSchedulers())</div><div class=\"line\">  .subscribe(...)</div></pre></td></tr></table></figure>\n<p>这虽然只是很简单的改进，但能让我们的代码更简洁，更不易出错。</p>\n<h4 id=\"3- 封装响应结果 -JsonDataResponse\"><a href=\"#3- 封装响应结果 -JsonDataResponse\" class=\"headerlink\" title=\"3. 封装响应结果 JsonDataResponse\"></a>3. 封装响应结果 JsonDataResponse</h4><p>我们 server 的所有返回结果都符合如下格式:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  'rc': 0,</div><div class=\"line\">  'data': &#123;...&#125;,</div><div class=\"line\">  'msg': \"Successful Call\"</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中 <code>rc</code> 是自定义的结果标志，server 用来告诉我们该请求的逻辑处理是否成功（此时 <code>rc = 0</code>）。<code>data</code>是这个请求需要的 json 数据。<code>msg</code>一般用来存放错误提示信息。</p>\n<p>于是我们创建了一个通用类来封装所有的 <code>Response</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JsonDataResponse</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@SerializedName</span>(<span class=\"string\">\"rc\"</span>)</div><div class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> rc;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@SerializedName</span>(<span class=\"string\">\"msg\"</span>)</div><div class=\"line\">  <span class=\"keyword\">private</span> String msg;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@SerializedName</span>(<span class=\"string\">\"data\"</span>)</div><div class=\"line\">  T data;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getRc</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> rc; &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getData</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> data; &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>于是，我们的请求变成如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Get</span>(<span class=\"string\">\"/&#123;id&#125;\"</span>)</div><div class=\"line\">Observable&lt;JsonDataResponse&lt;User&gt;&gt; getUser(<span class=\"meta\">@Path</span>(<span class=\"string\">\"id\"</span>) <span class=\"keyword\">long</span> id);</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">userApi.getUser(<span class=\"number\">1</span>)</div><div class=\"line\">  .compose(RxUtil.normalSchedulers())</div><div class=\"line\">  .subscribe(<span class=\"keyword\">new</span> Action1&lt;JsonDataResponse&lt;User&gt;&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(JsonDataResponse&lt;User&gt; response)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (response.getRc() == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">          User user = response.getData();</div><div class=\"line\">          <span class=\"comment\">// handle user</span></div><div class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          Toast.makeToast(context, response.getMsg())</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;, <span class=\"keyword\">new</span> Action1&lt;Throwable&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Throwable throwable)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// handle throwable</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"4- 异常处理\"><a href=\"#4- 异常处理\" class=\"headerlink\" title=\"4. 异常处理\"></a>4. 异常处理 </h4><p> 上面已经能完成正常的网络请求了，但是，却还没有对错误进行处理。</p>\n<p>一次网络请求中，可能发生以下几种错误：</p>\n<ul>\n<li>没有网络</li>\n<li>网络正常，但 http 请求失败，即 http 状态码不在 <code>[200, 300)</code> 之间，如 <code>404</code>、<code>500</code> 等</li>\n<li>网络正常，http 请求成功，但是 server 在处理请求时出了问题，使得返回结果的 <code>rc != 0</code></li>\n</ul>\n<p>不同的错误，我们希望给用户不同的提示，并且统计这些错误。</p>\n<p>目前我们的网络请求里已经能够处理第三种情况，另外两种都在 <code>throwable</code> 里面，我们可以通过判断 <code>throwable</code> 是 <code>IOException</code> 还是 <code>retrofit2.HttpException</code> 来区分这两种情况。</p>\n<p>因此，我们可得到如下异常处理代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">userApi.getUser(<span class=\"number\">1</span>)</div><div class=\"line\">  .compose(RxUtil.normalSchedulers())</div><div class=\"line\">  .subscribe(<span class=\"keyword\">new</span> Action1&lt;JsonDataResponse&lt;User&gt;&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(JsonDataResponse&lt;User&gt; response)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (response.getRc() == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">          User user = response.getData();</div><div class=\"line\">          <span class=\"comment\">// handle user</span></div><div class=\"line\">          handleUser();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          <span class=\"comment\">// such as: customized errorMsg: \"cannot find this user\".</span></div><div class=\"line\">          Toast.makeToast(context, response.getMsg(), Toast.LENGTH_SHORT).show();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;, <span class=\"keyword\">new</span> Action1&lt;Throwable&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Throwable throwable)</span> </span>&#123;</div><div class=\"line\">        String errorMsg = <span class=\"string\">\"\"</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (throwable <span class=\"keyword\">instanceof</span> IOException) &#123;</div><div class=\"line\">          <span class=\"comment\">// io Exception</span></div><div class=\"line\">          errorMsg = <span class=\"string\">\"Please check your network status\"</span>;</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (throwable <span class=\"keyword\">instanceof</span> HttpException) &#123;</div><div class=\"line\">          HttpException httpException = (HttpException) throwable;</div><div class=\"line\">          <span class=\"comment\">// http error.</span></div><div class=\"line\">          errorMsg = httpException.response(); </div><div class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          errorMsg = <span class=\"string\">\"unknown error\"</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">        Toast.makeToast(...);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"5- 封装异常处理代码\"><a href=\"#5- 封装异常处理代码\" class=\"headerlink\" title=\"5. 封装异常处理代码\"></a>5. 封装异常处理代码 </h4><p> 当然，我们并不想在每一个网络请求里都写上面一大段代码来处理 <code>error</code>，那样太傻了。比如上面 <code>getUser()</code> 请求，我希望只要写 <code>handleUser()</code> 这个方法，至于是网络问题还是 server 自己问题我都不想每次去 handle。</p>\n<p>接下来我们来封装上面两个 <code>Action</code> 。我们可以自定义两个 <code>Action</code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">WebSuccessAction&lt;T extends JsonDataResponse&gt; implements Action1&lt;T&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">WebFailureAction implements Action1&lt;Throwable&gt;</div></pre></td></tr></table></figure>\n<p>其中，<code>WebSuccessAction</code> 用来处理一切正常（网络正常，请求正常，<code>rc=0</code>）后的处理，<code>WebFailureAction</code> 用来统一处理上面 <code> 三种 error</code>。</p>\n<p>实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebSuccessAction</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">JsonDataResponse</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Action1</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(T response)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> rc = response.getRc();</div><div class=\"line\">    <span class=\"keyword\">if</span> (rc != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ResponseCodeError(extendedResponse.getMessage());</div><div class=\"line\">    &#125;</div><div class=\"line\">    onSuccess(extendedResponse);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(T extendedResponse)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// (rc != 0) Error</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResponseCodeError</span> <span class=\"keyword\">extends</span> <span class=\"title\">RuntimeException</span> </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ResponseCodeError</span><span class=\"params\">(String detailMessage)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(detailMessage);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在 <code>WebSuccessAction</code> 里，我们把 <code>rc != 0</code> 这种情况转化成 <code>ResponseCodeError</code> 并抛出给 <code>WebFailureAction</code> 去统一处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebFailAction</span> <span class=\"keyword\">implements</span> <span class=\"title\">Action1</span>&lt;<span class=\"title\">Throwable</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Throwable throwable)</span> </span>&#123;</div><div class=\"line\">    String errorMsg = <span class=\"string\">\"\"</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (throwable <span class=\"keyword\">instanceof</span> IOException) &#123;</div><div class=\"line\">      errorMsg = <span class=\"string\">\"Please check your network status\"</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (throwable <span class=\"keyword\">instanceof</span> HttpException) &#123;</div><div class=\"line\">      HttpException httpException = (HttpException) throwable;</div><div class=\"line\">      <span class=\"comment\">// such as:\"server internal error\".</span></div><div class=\"line\">      errorMsg = httpException.response(); </div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      errorMsg = <span class=\"string\">\"unknown error\"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    Toast.makeToast(...);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>有了上面两个自定义 <code>Action</code> 后，我们就可以把前面 <code>getUser()</code> 请求转化如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">userApi.getUser(<span class=\"number\">1</span>)</div><div class=\"line\">  .compose(RxUtil.normalSchedulers())</div><div class=\"line\">  .subscribe(<span class=\"keyword\">new</span> WebSuccessAction&lt;JsonDataResponse&lt;User&gt;&gt;() &#123;</div><div class=\"line\">      <span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(JsonDataResponse&lt;User&gt; response)</span> </span>&#123;</div><div class=\"line\">    \thandleUser(response.getUser());</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;, <span class=\"keyword\">new</span> WebFailAction())</div></pre></td></tr></table></figure>\n<p>Bingo! 至此我们能够用非常简洁的方式来执行网络操作，而且完全不用担心异常处理。</p>\n<h2 id=\"内存优化实践\"><a href=\"# 内存优化实践\" class=\"headerlink\" title=\"内存优化实践\"></a>内存优化实践 </h2><p> 在内存优化方面，Google 官方文档里能找到非常多的学习资料，例如常见的内存泄漏、<a href=\"https://developer.android.com/training/displaying-bitmaps/manage-memory.html\" target=\"_blank\" rel=\"external\">bitmap 官方最佳实践</a>。而且 Android studio 里也集成了很多有效的工具如 <a href=\"https://developer.android.com/studio/profile/heap-viewer-walkthru.html\" target=\"_blank\" rel=\"external\">Heap Viewer</a>, <a href=\"https://developer.android.com/studio/profile/am-memory.html\" target=\"_blank\" rel=\"external\">Memory Monitor</a> 和 <a href=\"https://developer.android.com/studio/profile/hierarchy-viewer.html\" target=\"_blank\" rel=\"external\">Hierarchy Viewer</a> 等等。</p>\n<p>下面，本文将从其它角度出发，来对内存作进一步优化。</p>\n<h4 id=\"1- 当 Activity 关闭时，立即取消掉网络请求结果处理。\"><a href=\"#1- 当 Activity 关闭时，立即取消掉网络请求结果处理。\" class=\"headerlink\" title=\"1. 当 Activity 关闭时，立即取消掉网络请求结果处理。\"></a>1. 当 Activity 关闭时，立即取消掉网络请求结果处理。</h4><p>这一点很容易被忽略掉。大家最常用的做法是在 <code>Activity</code> 执行网络操作，当 <code>Http Response</code> 回来后直接进行 UI 渲染，却并不会去判断此时 <code>Activity</code> 是否仍然存在，即用户是否已经离开了当时的页面。</p>\n<p>那么，有什么方法能够让每个网络请求都自动监听 Activity(Fragment) 的 lifecycle 事件并且当特定 lifecycle 事件发生时，<code>自动中断 </code> 掉网络请求的继续执行呢？</p>\n<p>首先来看下我们的网络请求代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">userApi.getUser(<span class=\"number\">1</span>)</div><div class=\"line\">  .compose(RxUtil.normalSchedulers())</div><div class=\"line\">  .subscribe(<span class=\"keyword\">new</span> WebSuccessAction&lt;JsonDataResponse&lt;User&gt;&gt;() &#123;</div><div class=\"line\">      <span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(JsonDataResponse&lt;User&gt; response)</span> </span>&#123;</div><div class=\"line\">    \thandleUser(response.getUser());</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;, <span class=\"keyword\">new</span> WebFailAction())</div></pre></td></tr></table></figure>\n<p>我们希望达到的是，当 <code>Activity</code> 进入 <code>onStop</code> 时立即停掉网络请求的后续处理。</p>\n<p>这里我们参考了 <a href=\"https://github.com/trello/RxLifecycle\" target=\"_blank\" rel=\"external\">RxLifecycle</a> 的实现方式，之所以没有直接使用 <a href=\"https://github.com/trello/RxLifecycle\" target=\"_blank\" rel=\"external\">RxLifecycle</a> 是因为它必须我们的 BaseActivity 继承其提供的 <a href=\"https://github.com/trello/RxLifecycle/blob/master/rxlifecycle-components/src/main/java/com/trello/rxlifecycle/components/RxActivity.java\" target=\"_blank\" rel=\"external\">RxActivity</a> ，而 RxActivity 并未继承我们需要的 <code>AppCompatActivity</code>。因此本人只能在学习其源码后，自己重新实现一套，并做了一些改动以更符合我们自己的应用场景。</p>\n<p>具体实现如下：</p>\n<ul>\n<li><p>首先，我们在 BaseActivity 里，利用 RxJava 提供的 <code>PublishSubject</code> 把所有 lifecycle event 发送出来。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> PublishSubject&lt;ActivityLifeCycleEvent&gt; lifecycleSubject = PublishSubject.create();</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\"></div><div class=\"line\">    lifecycleSubject.onNext(ActivityLifeCycleEvent.CREATE);</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    lifecycleSubject.onNext(ActivityLifeCycleEvent.DESTROY);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">super</span>.onDestroy();</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStop</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    lifecycleSubject.onNext(ActivityLifeCycleEvent.STOP);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">super</span>.onStop();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>然后，在 <code>BaseActivity</code> 里，提供 <code>bindUntilEvent(LifeCycleEvent)</code> 方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@NonNull</span></div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"keyword\">public</span> &lt;T&gt; Observable.<span class=\"function\">Transformer&lt;T, T&gt; <span class=\"title\">bindUntilEvent</span><span class=\"params\">(@NonNull <span class=\"keyword\">final</span> ActivityLifeCycleEvent event)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Observable.Transformer&lt;T, T&gt;() &#123;</div><div class=\"line\">      <span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> Observable&lt;T&gt; <span class=\"title\">call</span><span class=\"params\">(Observable&lt;T&gt; sourceObservable)</span> </span>&#123;</div><div class=\"line\">        Observable&lt;ActivityLifeCycleEvent&gt; o =</div><div class=\"line\">            lifecycleSubject.takeFirst(activityLifeCycleEvent -&gt; &#123;</div><div class=\"line\">              <span class=\"keyword\">return</span> activityLifeCycleEvent.equals(event);</div><div class=\"line\">            &#125;);</div><div class=\"line\">        <span class=\"keyword\">return</span> sourceObservable.takeUntil(o);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法可以用于每一个网络请求 Observable 中，当它监听到特定的 lifecycle event 时，就会自动让网络请求 Observable 终止掉，不会再去监听网络请求结果。</p>\n</li>\n<li><p>具体使用如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">userApi.getUser(<span class=\"number\">1</span>)</div><div class=\"line\">  .compose(bindUntilEvent(ActivityLifeCycleEvent.PAUSE))</div><div class=\"line\">  .compose(RxUtil.normalSchedulers())</div><div class=\"line\">  .subscribe(<span class=\"keyword\">new</span> WebSuccessAction&lt;JsonDataResponse&lt;User&gt;&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(JsonDataResponse&lt;User&gt; response)</span> </span>&#123;</div><div class=\"line\">        handleUser(response.getUser());</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;, <span class=\"keyword\">new</span> WebFailAction())</div></pre></td></tr></table></figure>\n<p>利用 <code>.compose(bindUntilEvent(ActivityLifeCycleEvent.STOP))</code> 来监听 Activity 的 Stop 事件并终止 <code>userApi.getUser(1)</code> 的 <code>subscription</code>，从而防止内存泄漏。</p>\n</li>\n</ul>\n<h4 id=\"2- 图片优化实践\"><a href=\"#2- 图片优化实践\" class=\"headerlink\" title=\"2. 图片优化实践\"></a>2. 图片优化实践</h4><p>Android 开发者都知道，每个 app 的可用内存时有限的，一旦内存占用太多或者在主线程突然请求较大内存，很有可能发生 OOM 问题。而其中，图片又是占用内存的大头，因此我们必须采取多种方法来进行优化。</p>\n<p>多数情况下我们是从 server 获取一张高清图片下来，然后在内存里进行裁剪成需要的大小来进行显示。这里面存在两个问题，</p>\n<p>1：假设我们只需要一张小图，而 server 取回来的图如果比较大，那就会浪费带宽和内存。</p>\n<p>2：如果直接在主线程去为图片请求大块空间，很容易由于系统难于快速分配而 OOM；</p>\n<p>比较理想的情况是：需要显示多大的图片，就向 server 请求多大的图片，既节省用户带宽流量，更减少内存的占用，减小 OOM 的机率。</p>\n<p>为了实现 server 端的图片 Resize，我们采用了 <a href=\"https://github.com/thumbor/thumbor\" target=\"_blank\" rel=\"external\">thumbor</a> 来提供图片 Resize 的功能。android 端只需要提供一个原图片 URL 和需要的 size 信息，就可以得到一张 Resize 好的图片资源文件。具体 server 端实现这里就不细讲了，感兴趣的读者可以阅读官方文档。</p>\n<p>这里介绍下我们在 Android 端的实现，以 Picasso 为栗子。</p>\n<ul>\n<li><p>首先要引入 Square 提供的 <a href=\"https://github.com/square/pollexor\" target=\"_blank\" rel=\"external\">pollexor</a> 工具，它可以让我们更简便的创建 thumbor 的规范 URI，参考如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">thumbor.buildImage(<span class=\"string\">\"http://example.com/image.png\"</span>)</div><div class=\"line\">    .resize(<span class=\"number\">48</span>, <span class=\"number\">48</span>)</div><div class=\"line\">    .toUrl()</div></pre></td></tr></table></figure>\n</li>\n<li><p>然后，利用 Picasso 提供的 requestTransformer 来实时获取当前需要显示的图片的真实尺寸，同时设置图片格式为 WebP，这种格式的图片可以保持图片质量的同时具有更小的体积：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">Picasso picasso = <span class=\"keyword\">new</span> Picasso.Builder(context).requestTransformer(<span class=\"keyword\">new</span> Picasso.RequestTransformer() &#123;</div><div class=\"line\">      <span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> Request <span class=\"title\">transformRequest</span><span class=\"params\">(Request request)</span> </span>&#123;</div><div class=\"line\">        String modifiedUrl = URLEncoder.encode(originUrl);</div><div class=\"line\">        ThumborUrlBuilder thumborUrlBuilder = thumbor.buildImage(modifiedUrl);</div><div class=\"line\">        String url = thumborUrlBuilder.resize(request.targetWidth, request.targetHeight)</div><div class=\"line\">            .filter(ThumborUrlBuilder.format(ThumborUrlBuilder.ImageFormat.WEBP))</div><div class=\"line\">            .toUrl();</div><div class=\"line\">        Timber.i(<span class=\"string\">\"SponsorAd Image Resize url to\"</span> + url);</div><div class=\"line\">        <span class=\"keyword\">return</span> request.buildUpon().setUri(Uri.parse(url)).build();</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;).build();</div></pre></td></tr></table></figure>\n</li>\n<li><p>利用修改后的 picasso 对象来请求图片</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">picasso.load(originUrl).fit().centerCrop().into(imageView);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>利用上面这种方法，我们可以为不同的 ImageView 计算显示需要的真实尺寸，然后去请求一张尺寸匹配的图片下来，节约带宽，减小内存开销。</p>\n<p>当然，在应用这种方法的时候，不要忘记考虑服务器的负载情况，毕竟这种方案意味着每张图片会被生成各种尺寸的小图缓存起来，而且 Android 设备分辨率不同，即使是同一个 ImageView，真实的宽高 Pixel 值也会不同，从而生成不同的小图。</p>\n<h2 id=\"在 App 和 Library 中集成依赖注入\"><a href=\"# 在 App 和 Library 中集成依赖注入\" class=\"headerlink\" title=\"在 App 和 Library 中集成依赖注入\"></a>在 App 和 Library 中集成依赖注入 </h2><p> 依赖注入框架 <a href=\"https://github.com/square/dagger\" target=\"_blank\" rel=\"external\">Dagger</a> 我们很早就开始用了，从早期的 Dagger1 到现在的 Dagger2。虽然 Dagger 本身较为陡峭的学习曲线使得不少人止步，不过一旦用过，根本停不下来。</p>\n<p>如果只是在 App 里使用 Dagger 相对比较简单，不过，我们还需要在 <code>Community</code> 和 <code>Base-Android</code> 两个公用 Library 里也集成 Dagger，这就需要费点功夫了。</p>\n<p>下面我来逐步讲解下我们是如何将 Dagger 同时集成进 App 和 Library 中。</p>\n<h4 id=\"1- 在 App 里集成 Dagger\"><a href=\"#1- 在 App 里集成 Dagger\" class=\"headerlink\" title=\"1. 在 App 里集成 Dagger\"></a>1. 在 App 里集成 Dagger</h4><p>首先需要在 <code>GlowApplication</code> 里生成一个全局的 <code>AppComponent</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Singleton</span></div><div class=\"line\"><span class=\"meta\">@Component</span>(modules = AppModule.class)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AppComponent</span> </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inject</span><span class=\"params\">(MainActivity mainActivity)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>创建 <code>AppModule</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Module</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppModule</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LexieApplication lexieApplication;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AppModule</span><span class=\"params\">(LexieApplication lexieApplication)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.lexieApplication = lexieApplication;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@Provides</span> <span class=\"function\">Context <span class=\"title\">applicationContext</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> lexieApplication;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// mock tool object</span></div><div class=\"line\">  <span class=\"meta\">@Provides</span> <span class=\"function\">Tool <span class=\"title\">provideTool</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Tool();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>集成进 <code>Application</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GlowApplication</span> <span class=\"keyword\">extends</span> <span class=\"title\">Application</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">private</span> AppComponent appComponent;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    appComponent = DaggerAppComponent.builder()</div><div class=\"line\">        .appModule(<span class=\"keyword\">new</span> AppModule(<span class=\"keyword\">this</span>))</div><div class=\"line\">        .build();</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> AppComponent <span class=\"title\">getAppComponent</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> appComponent;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在 <code>MainActivity</code>中使用<code>inject</code> 一个 <code>tool</code> 对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Inject</span> Tool tool;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    GlowApplication.getAppComponent().inject(<span class=\"keyword\">this</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"2- 在 -Library- 中集成 -Dagger\"><a href=\"#2- 在 -Library- 中集成 -Dagger\" class=\"headerlink\" title=\"2. 在 Library 中集成 Dagger\"></a>2. 在 Library 中集成 Dagger</h4><p>（下面以公用 Library：Community 为例子）</p>\n<p>逆向思维下，先设想应用场景：即 Dagger 已经集成好了，那么我们应该可以按如下方式在 <code>CommunityActivity</code> 里 <code>inject</code> 一个 <code>tool</code> 对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CommunityActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Inject</span> Tool tool;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    GlowApplication.getAppComponent().inject(<span class=\"keyword\">this</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>关键在于： <code>GlowApplication.getAppComponent().inject(this);</code> 这一句。</p>\n<p>那么问题来了：</p>\n<p><strong>对于一个 Library 而言，它是无法拿到 GlowApplication 对象的，因为作为一个被别人调用的 Library，它甚至不知道这个上层 class 的存在</strong></p>\n<p>为了解决这个问题，我们在 <code>community</code> 里定义一个公用接口作为 <code> 中间桥梁 </code>，让<code>GlowApplication</code> 实现这个公共接口即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 在 Community 定义接口 CommunityComponentProvider</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CommunityComponentProvider</span> </span>&#123;</div><div class=\"line\">  <span class=\"function\">AppComponent <span class=\"title\">getAppComponent</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 每个 app 的 Application 类都实现这个接口来提供 AppComponent</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GlowApplication</span> <span class=\"keyword\">implements</span> <span class=\"title\">CommunityComponentProvider</span> </span>&#123;</div><div class=\"line\">  <span class=\"function\">AppComponent <span class=\"title\">getAppComponent</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> appComponent;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后 <code>CommunityActivity</code>就可以实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CommunityActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Inject</span> Tool tool;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    Context applicationContext = getApplicationContext();</div><div class=\"line\">    CommunityComponentProvider provider = (CommunityComponentProvider) applicationContext;</div><div class=\"line\">    provider.getAppComponent().inject(<span class=\"keyword\">this</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3- 从 -AppComponent- 抽离 -CommunityComponent\"><a href=\"#3- 从 -AppComponent- 抽离 -CommunityComponent\" class=\"headerlink\" title=\"3. 从 AppComponent 抽离 CommunityComponent\"></a>3. 从 AppComponent 抽离 CommunityComponent</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">provider.getAppComponent().inject(<span class=\"keyword\">this</span>);</div></pre></td></tr></table></figure>\n<p>这一句里我们已经实现前半句 <code>provider.getAppComponent()</code> 了，但后半句的实现呢？</p>\n<p>正常情况下，我们要把</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inject</span><span class=\"params\">(CommunityActivity communityActivity)</span></span>;</div></pre></td></tr></table></figure>\n<p>放入 <code>AppComponent</code> 中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Singleton</span></div><div class=\"line\"><span class=\"meta\">@Component</span>(modules = AppModule.class)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AppComponent</span> </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inject</span><span class=\"params\">(MainActivity mainActivity)</span></span>;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 加在这里</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inject</span><span class=\"params\">(CommunityActivity communityActivity)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其实这样我们就已经几乎完成了整个 Library 和 App 的依赖注入了。</p>\n<p>但细心的朋友应该发现里面存在一个小问题，那就是</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inject</span><span class=\"params\">(CommunityActivity communityActivity)</span></span>;</div></pre></td></tr></table></figure>\n<p>这句代码如果放入了 <code>App</code> 里的 <code>AppComponent</code> 里，那就意味着我们也需要在另外三个 <code>App</code> 里的 <code>AppComponent</code> 都加上一句相同的代码？这样可以吗？</p>\n<p>理论上当然是可行的。但是，从单一职责的角度来考虑，<code>AppComponent</code> 只需要负责 <code>App</code> 层的 <code>inject</code> 就行，我们不应该把属于 <code>Community</code> 的 <code>inject</code> 放到<code>App</code> 里，这样的代码太 ugly，而且更重要的是，随着 Community 越来越多 Activity 需要 inject ，每个 inject 都要在各个 App 里重复加，这太烦了，也太笨了。</p>\n<p>因此，我们采用了一个简洁有效的方法来改进。</p>\n<p>在 <code>Community</code> 里创建一个 <code>CommunityComponent</code>，所有属于 <code>Community</code> 的<code>inject</code> 直接写在 <code>CommunityComponent</code> 里，不需要 <code>App</code> 再去关心。与此同时，为了保持前面 <code>provider.getAppComponent()</code> 仍然有效，我们让 <code>AppComponent</code> 继承 <code>CommunityComponent</code>。</p>\n<p>实现代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">CommunityComponent</span> </span>&#123;...&#125;</div></pre></td></tr></table></figure>\n<p>在 <code>Community</code> 里</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CommunityComponent</span> </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inject</span><span class=\"params\">(CommunityActivity communityActivity)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CommunityActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Inject</span> Tool tool;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    Context applicationContext = getApplicationContext();</div><div class=\"line\">    CommunityComponentProvider provider = (CommunityComponentProvider) applicationContext;</div><div class=\"line\">    provider.getAppComponent().inject(<span class=\"keyword\">this</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/281665-483c8a864c09503d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"依赖注入\"></p>\n<p>Bingo! 至此我们已经能够优雅简洁地在 App 和 Library 里同时应用依赖注入了。</p>\n<h2 id=\"小结\"><a href=\"# 小结\" class=\"headerlink\" title=\"小结\"></a>小结 </h2><p> 由于篇幅有限，本文暂时先从网络层、内存优化和依赖注入方面进行讲解，之后会再考虑从 Logging 模块、数据同步模块、Deep Linking 模块、多 Library 的 Gradle 发布管理、持续集成和崩溃监测模块等进行讲解。</p>\n<p>谢谢。</p>\n<p>wingjay</p>\n<p><a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\">我的 Github</a>: <a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\">https://github.com/wingjay</a><br><a href=\"http://weibo.com/u/1625892654\" target=\"_blank\" rel=\"external\">微博 iam_wingjay</a>: <a href=\"http://weibo.com/u/1625892654\" target=\"_blank\" rel=\"external\">http://weibo.com/u/1625892654</a></p>\n<p>如果有问题，可以给我留言或发邮件<a href=\"&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#121;&#x69;&#x6e;&#106;&#105;&#x65;&#115;&#104;&#64;&#49;&#50;&#x36;&#x2e;&#x63;&#111;&#109;\">&#121;&#x69;&#x6e;&#106;&#105;&#x65;&#115;&#104;&#64;&#49;&#50;&#x36;&#x2e;&#x63;&#111;&#109;</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>分享下自己在实际工作中积累的技术经验。</p>\n</blockquote>","more":"<p>了解 Glow 的朋友应该知道，我们主营四款 App，分别是Eve、Glow、Nuture和Baby。作为创业公司，我们的四款 App 都处于高速开发中，平均每个 Android App 由两人负责开发，包括 Android 和 Server 开发，在满足 PM 各种需求的同时，我们的session crash free率保持不低于 99.8%，其中两款 App 接近 100%。</p>\n<p>本文将对 Glow 当前 Android 对现有工具的探索及优化作出讲解，希望对读者有所启发。</p>\n<h2 id=\"整体结构概览\"><a href=\"#整体结构概览\" class=\"headerlink\" title=\"整体结构概览\"></a>整体结构概览</h2><p>由于架构都是为了实际业务服务，因此在深入讲解前，需要先展示 Android 端的大体结构：</p>\n<p> <img src=\"http://upload-images.jianshu.io/upload_images/281665-6a05f7e014dc6234.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Glow Android 整体结构\"></p>\n<p>我们有四个 Android App，它们共用同一个 Community 社区，最底层是 Base-Library，存放公用的模块组件，如支付模块，Logging模块等等。</p>\n<p>下面，我将依次从以下几个方面进行讲解：</p>\n<ul>\n<li>网络层优化</li>\n<li>内存优化实践</li>\n<li>在App和Library中集成依赖注入</li>\n<li>etc.</li>\n</ul>\n<h2 id=\"网络层优化\"><a href=\"#网络层优化\" class=\"headerlink\" title=\"网络层优化\"></a>网络层优化</h2><h4 id=\"1-Retrofit2-OkHttp3-RxJava\"><a href=\"#1-Retrofit2-OkHttp3-RxJava\" class=\"headerlink\" title=\"1. Retrofit2 + OkHttp3 + RxJava\"></a>1. Retrofit2 + OkHttp3 + RxJava</h4><p>上面这套结构是目前最为流行的网络层架构，可以帮我们写出简洁而稳定的网络请求代码，比起以前复杂的异步回调、主次线程切换等代码更为易用，而且能支持 <code>https</code> 请求。</p>\n<p>基本用法如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">UserApi userApi = retrofit.create(UserApi.class);</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Get</span>(<span class=\"string\">\"/&#123;id&#125;\"</span>)</div><div class=\"line\"><span class=\"function\">Observable&lt;User&gt; <span class=\"title\">getUser</span><span class=\"params\">(@Path(<span class=\"string\">\"id\"</span>)</span> <span class=\"keyword\">long</span> id)</span>;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">userApi.getUser(<span class=\"number\">1</span>)</div><div class=\"line\">  .subscribeOn(Schedulers.io())</div><div class=\"line\">  .observeOn(AndroidSchedulers.mainThread())</div><div class=\"line\">  .subscribe(<span class=\"keyword\">new</span> Action1&lt;User&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(User user)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// handle user</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;, <span class=\"keyword\">new</span> Action1&lt;Throwable&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Throwable throwable)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// handle throwable</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure>\n<p>这只是通用做法。下面我们要根据实际情况进行优化。</p>\n<h4 id=\"2-封装线程切换代码\"><a href=\"#2-封装线程切换代码\" class=\"headerlink\" title=\"2. 封装线程切换代码\"></a>2. 封装线程切换代码</h4><p>上面的代码中可以看到，为了执行网络请求，我们会利用<code>RxJava</code>提供的<code>Schedulers</code>工具来方便切换线程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">.subscribeOn(Schedulers.io())</div><div class=\"line\">.observeOn(AndroidSchedulers.mainThread())</div></pre></td></tr></table></figure>\n<p>上面的代码的作用是：让网络请求进入 <code>io线程</code> 执行，并将返回结果转入 <code>UI线程</code> 去进行渲染。</p>\n<p>不过，我们 app 有非常多的网络请求，而且除了<code>网络请求</code>，其他的<code>数据库操作</code> 或者 <code>文件读写操作</code> 都需要一样的线程切换。因此，为了代码复用，我们利用 <code>RxJava</code> 提供的 <code>Transformer</code> 来进行封装。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// RxUtil.java  </span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; Observable.<span class=\"function\">Transformer&lt;T, T&gt; <span class=\"title\">normalSchedulers</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Observable.Transformer&lt;T, T&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Observable&lt;T&gt; <span class=\"title\">call</span><span class=\"params\">(Observable&lt;T&gt; source)</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> source.subscribeOn(Schedulers.io())</div><div class=\"line\">        .observeOn(AndroidSchedulers.mainThread());</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后，我们可以把网络请求代码转化为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">userApi.getUser(<span class=\"number\">1</span>)</div><div class=\"line\">  .compose(RxUtil.normalSchedulers())</div><div class=\"line\">  .subscribe(...)</div></pre></td></tr></table></figure>\n<p>这虽然只是很简单的改进，但能让我们的代码更简洁，更不易出错。</p>\n<h4 id=\"3-封装响应结果-JsonDataResponse\"><a href=\"#3-封装响应结果-JsonDataResponse\" class=\"headerlink\" title=\"3. 封装响应结果 JsonDataResponse\"></a>3. 封装响应结果 JsonDataResponse</h4><p>我们 server 的所有返回结果都符合如下格式:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  'rc': 0,</div><div class=\"line\">  'data': &#123;...&#125;,</div><div class=\"line\">  'msg': \"Successful Call\"</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中 <code>rc</code> 是自定义的结果标志，server 用来告诉我们该请求的逻辑处理是否成功（此时 <code>rc = 0</code>）。<code>data</code>是这个请求需要的 json 数据。<code>msg</code>一般用来存放错误提示信息。</p>\n<p>于是我们创建了一个通用类来封装所有的 <code>Response</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JsonDataResponse</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@SerializedName</span>(<span class=\"string\">\"rc\"</span>)</div><div class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> rc;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@SerializedName</span>(<span class=\"string\">\"msg\"</span>)</div><div class=\"line\">  <span class=\"keyword\">private</span> String msg;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@SerializedName</span>(<span class=\"string\">\"data\"</span>)</div><div class=\"line\">  T data;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getRc</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> rc; &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getData</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> data; &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>于是，我们的请求变成如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Get</span>(<span class=\"string\">\"/&#123;id&#125;\"</span>)</div><div class=\"line\">Observable&lt;JsonDataResponse&lt;User&gt;&gt; getUser(<span class=\"meta\">@Path</span>(<span class=\"string\">\"id\"</span>) <span class=\"keyword\">long</span> id);</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">userApi.getUser(<span class=\"number\">1</span>)</div><div class=\"line\">  .compose(RxUtil.normalSchedulers())</div><div class=\"line\">  .subscribe(<span class=\"keyword\">new</span> Action1&lt;JsonDataResponse&lt;User&gt;&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(JsonDataResponse&lt;User&gt; response)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (response.getRc() == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">          User user = response.getData();</div><div class=\"line\">          <span class=\"comment\">// handle user</span></div><div class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          Toast.makeToast(context, response.getMsg())</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;, <span class=\"keyword\">new</span> Action1&lt;Throwable&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Throwable throwable)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// handle throwable</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"4-异常处理\"><a href=\"#4-异常处理\" class=\"headerlink\" title=\"4. 异常处理\"></a>4. 异常处理</h4><p>上面已经能完成正常的网络请求了，但是，却还没有对错误进行处理。</p>\n<p>一次网络请求中，可能发生以下几种错误：</p>\n<ul>\n<li>没有网络</li>\n<li>网络正常，但 http 请求失败，即 http 状态码不在 <code>[200, 300)</code> 之间，如<code>404</code>、<code>500</code>等</li>\n<li>网络正常，http 请求成功，但是 server 在处理请求时出了问题，使得返回结果的 <code>rc != 0</code></li>\n</ul>\n<p>不同的错误，我们希望给用户不同的提示，并且统计这些错误。</p>\n<p>目前我们的网络请求里已经能够处理第三种情况，另外两种都在 <code>throwable</code> 里面，我们可以通过判断 <code>throwable</code> 是 <code>IOException</code> 还是 <code>retrofit2.HttpException</code> 来区分这两种情况。</p>\n<p>因此，我们可得到如下异常处理代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">userApi.getUser(<span class=\"number\">1</span>)</div><div class=\"line\">  .compose(RxUtil.normalSchedulers())</div><div class=\"line\">  .subscribe(<span class=\"keyword\">new</span> Action1&lt;JsonDataResponse&lt;User&gt;&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(JsonDataResponse&lt;User&gt; response)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (response.getRc() == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">          User user = response.getData();</div><div class=\"line\">          <span class=\"comment\">// handle user</span></div><div class=\"line\">          handleUser();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          <span class=\"comment\">// such as: customized errorMsg: \"cannot find this user\".</span></div><div class=\"line\">          Toast.makeToast(context, response.getMsg(), Toast.LENGTH_SHORT).show();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;, <span class=\"keyword\">new</span> Action1&lt;Throwable&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Throwable throwable)</span> </span>&#123;</div><div class=\"line\">        String errorMsg = <span class=\"string\">\"\"</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (throwable <span class=\"keyword\">instanceof</span> IOException) &#123;</div><div class=\"line\">          <span class=\"comment\">// io Exception</span></div><div class=\"line\">          errorMsg = <span class=\"string\">\"Please check your network status\"</span>;</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (throwable <span class=\"keyword\">instanceof</span> HttpException) &#123;</div><div class=\"line\">          HttpException httpException = (HttpException) throwable;</div><div class=\"line\">          <span class=\"comment\">// http error.</span></div><div class=\"line\">          errorMsg = httpException.response(); </div><div class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          errorMsg = <span class=\"string\">\"unknown error\"</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">        Toast.makeToast(...);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"5-封装异常处理代码\"><a href=\"#5-封装异常处理代码\" class=\"headerlink\" title=\"5. 封装异常处理代码\"></a>5. 封装异常处理代码</h4><p>当然，我们并不想在每一个网络请求里都写上面一大段代码来处理 <code>error</code>，那样太傻了。比如上面 <code>getUser()</code> 请求，我希望只要写 <code>handleUser()</code> 这个方法，至于是网络问题还是 server 自己问题我都不想每次去 handle。</p>\n<p>接下来我们来封装上面两个 <code>Action</code> 。我们可以自定义两个 <code>Action</code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">WebSuccessAction&lt;T extends JsonDataResponse&gt; implements Action1&lt;T&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">WebFailureAction implements Action1&lt;Throwable&gt;</div></pre></td></tr></table></figure>\n<p>其中，<code>WebSuccessAction</code> 用来处理一切正常（网络正常，请求正常，<code>rc=0</code>）后的处理，<code>WebFailureAction</code> 用来统一处理上面<code>三种 error</code>。</p>\n<p>实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebSuccessAction</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">JsonDataResponse</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Action1</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(T response)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> rc = response.getRc();</div><div class=\"line\">    <span class=\"keyword\">if</span> (rc != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ResponseCodeError(extendedResponse.getMessage());</div><div class=\"line\">    &#125;</div><div class=\"line\">    onSuccess(extendedResponse);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(T extendedResponse)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// (rc != 0) Error</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResponseCodeError</span> <span class=\"keyword\">extends</span> <span class=\"title\">RuntimeException</span> </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ResponseCodeError</span><span class=\"params\">(String detailMessage)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(detailMessage);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在 <code>WebSuccessAction</code> 里，我们把 <code>rc != 0</code> 这种情况转化成 <code>ResponseCodeError</code> 并抛出给 <code>WebFailureAction</code> 去统一处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebFailAction</span> <span class=\"keyword\">implements</span> <span class=\"title\">Action1</span>&lt;<span class=\"title\">Throwable</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Throwable throwable)</span> </span>&#123;</div><div class=\"line\">    String errorMsg = <span class=\"string\">\"\"</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (throwable <span class=\"keyword\">instanceof</span> IOException) &#123;</div><div class=\"line\">      errorMsg = <span class=\"string\">\"Please check your network status\"</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (throwable <span class=\"keyword\">instanceof</span> HttpException) &#123;</div><div class=\"line\">      HttpException httpException = (HttpException) throwable;</div><div class=\"line\">      <span class=\"comment\">// such as: \"server internal error\".</span></div><div class=\"line\">      errorMsg = httpException.response(); </div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      errorMsg = <span class=\"string\">\"unknown error\"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    Toast.makeToast(...);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>有了上面两个自定义 <code>Action</code> 后，我们就可以把前面 <code>getUser()</code> 请求转化如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">userApi.getUser(<span class=\"number\">1</span>)</div><div class=\"line\">  .compose(RxUtil.normalSchedulers())</div><div class=\"line\">  .subscribe(<span class=\"keyword\">new</span> WebSuccessAction&lt;JsonDataResponse&lt;User&gt;&gt;() &#123;</div><div class=\"line\">      <span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(JsonDataResponse&lt;User&gt; response)</span> </span>&#123;</div><div class=\"line\">    \thandleUser(response.getUser());</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;, <span class=\"keyword\">new</span> WebFailAction())</div></pre></td></tr></table></figure>\n<p>Bingo! 至此我们能够用非常简洁的方式来执行网络操作，而且完全不用担心异常处理。</p>\n<h2 id=\"内存优化实践\"><a href=\"#内存优化实践\" class=\"headerlink\" title=\"内存优化实践\"></a>内存优化实践</h2><p>在内存优化方面，Google 官方文档里能找到非常多的学习资料，例如常见的内存泄漏、<a href=\"https://developer.android.com/training/displaying-bitmaps/manage-memory.html\" target=\"_blank\" rel=\"external\">bitmap官方最佳实践</a>。而且 Android studio 里也集成了很多有效的工具如 <a href=\"https://developer.android.com/studio/profile/heap-viewer-walkthru.html\" target=\"_blank\" rel=\"external\">Heap Viewer</a>, <a href=\"https://developer.android.com/studio/profile/am-memory.html\" target=\"_blank\" rel=\"external\">Memory Monitor</a> 和 <a href=\"https://developer.android.com/studio/profile/hierarchy-viewer.html\" target=\"_blank\" rel=\"external\">Hierarchy Viewer</a> 等等。</p>\n<p>下面，本文将从其它角度出发，来对内存作进一步优化。</p>\n<h4 id=\"1-当Activity关闭时，立即取消掉网络请求结果处理。\"><a href=\"#1-当Activity关闭时，立即取消掉网络请求结果处理。\" class=\"headerlink\" title=\"1. 当Activity关闭时，立即取消掉网络请求结果处理。\"></a>1. 当Activity关闭时，立即取消掉网络请求结果处理。</h4><p>这一点很容易被忽略掉。大家最常用的做法是在 <code>Activity</code> 执行网络操作，当 <code>Http Response</code> 回来后直接进行UI渲染，却并不会去判断此时 <code>Activity</code> 是否仍然存在，即用户是否已经离开了当时的页面。</p>\n<p>那么，有什么方法能够让每个网络请求都自动监听 Activity(Fragment) 的 lifecycle 事件并且当特定 lifecycle 事件发生时，<code>自动中断</code>掉网络请求的继续执行呢？</p>\n<p>首先来看下我们的网络请求代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">userApi.getUser(<span class=\"number\">1</span>)</div><div class=\"line\">  .compose(RxUtil.normalSchedulers())</div><div class=\"line\">  .subscribe(<span class=\"keyword\">new</span> WebSuccessAction&lt;JsonDataResponse&lt;User&gt;&gt;() &#123;</div><div class=\"line\">      <span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(JsonDataResponse&lt;User&gt; response)</span> </span>&#123;</div><div class=\"line\">    \thandleUser(response.getUser());</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;, <span class=\"keyword\">new</span> WebFailAction())</div></pre></td></tr></table></figure>\n<p>我们希望达到的是，当 <code>Activity</code> 进入 <code>onStop</code> 时立即停掉网络请求的后续处理。</p>\n<p>这里我们参考了 <a href=\"https://github.com/trello/RxLifecycle\" target=\"_blank\" rel=\"external\">RxLifecycle</a> 的实现方式，之所以没有直接使用 <a href=\"https://github.com/trello/RxLifecycle\" target=\"_blank\" rel=\"external\">RxLifecycle</a> 是因为它必须我们的 BaseActivity 继承其提供的 <a href=\"https://github.com/trello/RxLifecycle/blob/master/rxlifecycle-components/src/main/java/com/trello/rxlifecycle/components/RxActivity.java\" target=\"_blank\" rel=\"external\">RxActivity</a> ，而 RxActivity 并未继承我们需要的 <code>AppCompatActivity</code>。因此本人只能在学习其源码后，自己重新实现一套，并做了一些改动以更符合我们自己的应用场景。</p>\n<p>具体实现如下：</p>\n<ul>\n<li><p>首先，我们在 BaseActivity 里，利用 RxJava 提供的 <code>PublishSubject</code> 把所有 lifecycle event 发送出来。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> PublishSubject&lt;ActivityLifeCycleEvent&gt; lifecycleSubject = PublishSubject.create();</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\"></div><div class=\"line\">    lifecycleSubject.onNext(ActivityLifeCycleEvent.CREATE);</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    lifecycleSubject.onNext(ActivityLifeCycleEvent.DESTROY);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">super</span>.onDestroy();</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStop</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    lifecycleSubject.onNext(ActivityLifeCycleEvent.STOP);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">super</span>.onStop();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>然后，在 <code>BaseActivity</code> 里，提供 <code>bindUntilEvent(LifeCycleEvent)</code> 方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@NonNull</span></div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"keyword\">public</span> &lt;T&gt; Observable.<span class=\"function\">Transformer&lt;T, T&gt; <span class=\"title\">bindUntilEvent</span><span class=\"params\">(@NonNull <span class=\"keyword\">final</span> ActivityLifeCycleEvent event)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Observable.Transformer&lt;T, T&gt;() &#123;</div><div class=\"line\">      <span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> Observable&lt;T&gt; <span class=\"title\">call</span><span class=\"params\">(Observable&lt;T&gt; sourceObservable)</span> </span>&#123;</div><div class=\"line\">        Observable&lt;ActivityLifeCycleEvent&gt; o =</div><div class=\"line\">            lifecycleSubject.takeFirst(activityLifeCycleEvent -&gt; &#123;</div><div class=\"line\">              <span class=\"keyword\">return</span> activityLifeCycleEvent.equals(event);</div><div class=\"line\">            &#125;);</div><div class=\"line\">        <span class=\"keyword\">return</span> sourceObservable.takeUntil(o);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法可以用于每一个网络请求 Observable 中，当它监听到特定的 lifecycle event 时，就会自动让网络请求 Observable 终止掉，不会再去监听网络请求结果。</p>\n</li>\n<li><p>具体使用如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">userApi.getUser(<span class=\"number\">1</span>)</div><div class=\"line\">  .compose(bindUntilEvent(ActivityLifeCycleEvent.PAUSE))</div><div class=\"line\">  .compose(RxUtil.normalSchedulers())</div><div class=\"line\">  .subscribe(<span class=\"keyword\">new</span> WebSuccessAction&lt;JsonDataResponse&lt;User&gt;&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(JsonDataResponse&lt;User&gt; response)</span> </span>&#123;</div><div class=\"line\">        handleUser(response.getUser());</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;, <span class=\"keyword\">new</span> WebFailAction())</div></pre></td></tr></table></figure>\n<p>利用 <code>.compose(bindUntilEvent(ActivityLifeCycleEvent.STOP))</code> 来监听 Activity 的 Stop 事件并终止 <code>userApi.getUser(1)</code> 的 <code>subscription</code>，从而防止内存泄漏。</p>\n</li>\n</ul>\n<h4 id=\"2-图片优化实践\"><a href=\"#2-图片优化实践\" class=\"headerlink\" title=\"2. 图片优化实践\"></a>2. 图片优化实践</h4><p>Android开发者都知道，每个app的可用内存时有限的，一旦内存占用太多或者在主线程突然请求较大内存，很有可能发生 OOM 问题。而其中，图片又是占用内存的大头，因此我们必须采取多种方法来进行优化。</p>\n<p>多数情况下我们是从 server 获取一张高清图片下来，然后在内存里进行裁剪成需要的大小来进行显示。这里面存在两个问题，</p>\n<p>1：假设我们只需要一张小图，而server取回来的图如果比较大，那就会浪费带宽和内存。</p>\n<p>2：如果直接在主线程去为图片请求大块空间，很容易由于系统难于快速分配而 OOM；</p>\n<p>比较理想的情况是：需要显示多大的图片，就向server请求多大的图片，既节省用户带宽流量，更减少内存的占用，减小 OOM 的机率。</p>\n<p>为了实现 server 端的图片Resize，我们采用了 <a href=\"https://github.com/thumbor/thumbor\" target=\"_blank\" rel=\"external\">thumbor</a> 来提供图片 Resize 的功能。android端只需要提供一个原图片 URL 和需要的 size 信息，就可以得到一张 Resize 好的图片资源文件。具体server端实现这里就不细讲了，感兴趣的读者可以阅读官方文档。</p>\n<p>这里介绍下我们在 Android 端的实现，以 Picasso 为栗子。</p>\n<ul>\n<li><p>首先要引入 Square 提供的 <a href=\"https://github.com/square/pollexor\" target=\"_blank\" rel=\"external\">pollexor</a> 工具，它可以让我们更简便的创建 thumbor 的规范 URI，参考如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">thumbor.buildImage(<span class=\"string\">\"http://example.com/image.png\"</span>)</div><div class=\"line\">    .resize(<span class=\"number\">48</span>, <span class=\"number\">48</span>)</div><div class=\"line\">    .toUrl()</div></pre></td></tr></table></figure>\n</li>\n<li><p>然后，利用 Picasso 提供的 requestTransformer 来实时获取当前需要显示的图片的真实尺寸，同时设置图片格式为 WebP，这种格式的图片可以保持图片质量的同时具有更小的体积：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">Picasso picasso = <span class=\"keyword\">new</span> Picasso.Builder(context).requestTransformer(<span class=\"keyword\">new</span> Picasso.RequestTransformer() &#123;</div><div class=\"line\">      <span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> Request <span class=\"title\">transformRequest</span><span class=\"params\">(Request request)</span> </span>&#123;</div><div class=\"line\">        String modifiedUrl = URLEncoder.encode(originUrl);</div><div class=\"line\">        ThumborUrlBuilder thumborUrlBuilder = thumbor.buildImage(modifiedUrl);</div><div class=\"line\">        String url = thumborUrlBuilder.resize(request.targetWidth, request.targetHeight)</div><div class=\"line\">            .filter(ThumborUrlBuilder.format(ThumborUrlBuilder.ImageFormat.WEBP))</div><div class=\"line\">            .toUrl();</div><div class=\"line\">        Timber.i(<span class=\"string\">\"SponsorAd Image Resize url to \"</span> + url);</div><div class=\"line\">        <span class=\"keyword\">return</span> request.buildUpon().setUri(Uri.parse(url)).build();</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;).build();</div></pre></td></tr></table></figure>\n</li>\n<li><p>利用修改后的 picasso 对象来请求图片</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">picasso.load(originUrl).fit().centerCrop().into(imageView);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>利用上面这种方法，我们可以为不同的 ImageView 计算显示需要的真实尺寸，然后去请求一张尺寸匹配的图片下来，节约带宽，减小内存开销。</p>\n<p>当然，在应用这种方法的时候，不要忘记考虑服务器的负载情况，毕竟这种方案意味着每张图片会被生成各种尺寸的小图缓存起来，而且Android设备分辨率不同，即使是同一个 ImageView，真实的宽高 Pixel 值也会不同，从而生成不同的小图。</p>\n<h2 id=\"在App和Library中集成依赖注入\"><a href=\"#在App和Library中集成依赖注入\" class=\"headerlink\" title=\"在App和Library中集成依赖注入\"></a>在App和Library中集成依赖注入</h2><p>依赖注入框架 <a href=\"https://github.com/square/dagger\" target=\"_blank\" rel=\"external\">Dagger</a> 我们很早就开始用了，从早期的 Dagger1 到现在的 Dagger2。虽然 Dagger 本身较为陡峭的学习曲线使得不少人止步，不过一旦用过，根本停不下来。</p>\n<p>如果只是在 App 里使用 Dagger 相对比较简单，不过，我们还需要在 <code>Community</code> 和 <code>Base-Android</code> 两个公用 Library 里也集成 Dagger，这就需要费点功夫了。</p>\n<p>下面我来逐步讲解下我们是如何将 Dagger 同时集成进 App 和 Library 中。</p>\n<h4 id=\"1-在App里集成Dagger\"><a href=\"#1-在App里集成Dagger\" class=\"headerlink\" title=\"1. 在App里集成Dagger\"></a>1. 在App里集成Dagger</h4><p>首先需要在 <code>GlowApplication</code> 里生成一个全局的 <code>AppComponent</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Singleton</span></div><div class=\"line\"><span class=\"meta\">@Component</span>(modules = AppModule.class)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AppComponent</span> </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inject</span><span class=\"params\">(MainActivity mainActivity)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>创建 <code>AppModule</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Module</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppModule</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LexieApplication lexieApplication;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AppModule</span><span class=\"params\">(LexieApplication lexieApplication)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.lexieApplication = lexieApplication;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@Provides</span> <span class=\"function\">Context <span class=\"title\">applicationContext</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> lexieApplication;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// mock tool object</span></div><div class=\"line\">  <span class=\"meta\">@Provides</span> <span class=\"function\">Tool <span class=\"title\">provideTool</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Tool();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>集成进 <code>Application</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GlowApplication</span> <span class=\"keyword\">extends</span> <span class=\"title\">Application</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">private</span> AppComponent appComponent;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    appComponent = DaggerAppComponent.builder()</div><div class=\"line\">        .appModule(<span class=\"keyword\">new</span> AppModule(<span class=\"keyword\">this</span>))</div><div class=\"line\">        .build();</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> AppComponent <span class=\"title\">getAppComponent</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> appComponent;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在 <code>MainActivity</code>中使用<code>inject</code> 一个 <code>tool</code> 对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Inject</span> Tool tool;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    GlowApplication.getAppComponent().inject(<span class=\"keyword\">this</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"2-在-Library-中集成-Dagger\"><a href=\"#2-在-Library-中集成-Dagger\" class=\"headerlink\" title=\"2. 在 Library 中集成 Dagger\"></a>2. 在 Library 中集成 Dagger</h4><p>（下面以公用Library：Community为例子）</p>\n<p>逆向思维下，先设想应用场景：即 Dagger 已经集成好了，那么我们应该可以按如下方式在 <code>CommunityActivity</code> 里 <code>inject</code> 一个 <code>tool</code> 对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CommunityActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Inject</span> Tool tool;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    GlowApplication.getAppComponent().inject(<span class=\"keyword\">this</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>关键在于： <code>GlowApplication.getAppComponent().inject(this);</code> 这一句。</p>\n<p>那么问题来了：</p>\n<p><strong>对于一个 Library 而言，它是无法拿到 GlowApplication 对象的，因为作为一个被别人调用的 Library，它甚至不知道这个上层 class 的存在</strong></p>\n<p>为了解决这个问题，我们在<code>community</code>里定义一个公用接口作为<code>中间桥梁</code>，让<code>GlowApplication</code>实现这个公共接口即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 在Community定义接口CommunityComponentProvider</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CommunityComponentProvider</span> </span>&#123;</div><div class=\"line\">  <span class=\"function\">AppComponent <span class=\"title\">getAppComponent</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 每个app的Application类都实现这个接口来提供AppComponent</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GlowApplication</span> <span class=\"keyword\">implements</span> <span class=\"title\">CommunityComponentProvider</span> </span>&#123;</div><div class=\"line\">  <span class=\"function\">AppComponent <span class=\"title\">getAppComponent</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> appComponent;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后 <code>CommunityActivity</code>就可以实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CommunityActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Inject</span> Tool tool;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    Context applicationContext = getApplicationContext();</div><div class=\"line\">    CommunityComponentProvider provider = (CommunityComponentProvider) applicationContext;</div><div class=\"line\">    provider.getAppComponent().inject(<span class=\"keyword\">this</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3-从-AppComponent-抽离-CommunityComponent\"><a href=\"#3-从-AppComponent-抽离-CommunityComponent\" class=\"headerlink\" title=\"3. 从 AppComponent 抽离 CommunityComponent\"></a>3. 从 AppComponent 抽离 CommunityComponent</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">provider.getAppComponent().inject(<span class=\"keyword\">this</span>);</div></pre></td></tr></table></figure>\n<p>这一句里我们已经实现前半句 <code>provider.getAppComponent()</code> 了，但后半句的实现呢？</p>\n<p>正常情况下，我们要把</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inject</span><span class=\"params\">(CommunityActivity communityActivity)</span></span>;</div></pre></td></tr></table></figure>\n<p>放入 <code>AppComponent</code> 中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Singleton</span></div><div class=\"line\"><span class=\"meta\">@Component</span>(modules = AppModule.class)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AppComponent</span> </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inject</span><span class=\"params\">(MainActivity mainActivity)</span></span>;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 加在这里</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inject</span><span class=\"params\">(CommunityActivity communityActivity)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其实这样我们就已经几乎完成了整个 Library 和 App 的依赖注入了。</p>\n<p>但细心的朋友应该发现里面存在一个小问题，那就是</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inject</span><span class=\"params\">(CommunityActivity communityActivity)</span></span>;</div></pre></td></tr></table></figure>\n<p>这句代码如果放入了 <code>App</code> 里的 <code>AppComponent</code> 里，那就意味着我们也需要在另外三个 <code>App</code> 里的 <code>AppComponent</code> 都加上一句相同的代码？这样可以吗？</p>\n<p>理论上当然是可行的。但是，从单一职责的角度来考虑，<code>AppComponent</code> 只需要负责 <code>App</code> 层的 <code>inject</code> 就行，我们不应该把属于 <code>Community</code> 的 <code>inject</code> 放到<code>App</code> 里，这样的代码太ugly，而且更重要的是，随着 Community 越来越多 Activity 需要 inject ，每个 inject 都要在各个 App 里重复加，这太烦了，也太笨了。</p>\n<p>因此，我们采用了一个简洁有效的方法来改进。</p>\n<p>在 <code>Community</code> 里创建一个 <code>CommunityComponent</code>，所有属于 <code>Community</code> 的<code>inject</code> 直接写在 <code>CommunityComponent</code> 里，不需要 <code>App</code> 再去关心。与此同时，为了保持前面 <code>provider.getAppComponent()</code> 仍然有效，我们让 <code>AppComponent</code> 继承 <code>CommunityComponent</code>。</p>\n<p>实现代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">CommunityComponent</span> </span>&#123;...&#125;</div></pre></td></tr></table></figure>\n<p>在 <code>Community</code> 里</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CommunityComponent</span> </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inject</span><span class=\"params\">(CommunityActivity communityActivity)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CommunityActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Inject</span> Tool tool;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    Context applicationContext = getApplicationContext();</div><div class=\"line\">    CommunityComponentProvider provider = (CommunityComponentProvider) applicationContext;</div><div class=\"line\">    provider.getAppComponent().inject(<span class=\"keyword\">this</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/281665-483c8a864c09503d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"依赖注入\"></p>\n<p>Bingo! 至此我们已经能够优雅简洁地在 App 和 Library 里同时应用依赖注入了。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>由于篇幅有限，本文暂时先从网络层、内存优化和依赖注入方面进行讲解，之后会再考虑从 Logging模块、数据同步模块、Deep Linking模块、多Library的Gradle发布管理、持续集成和崩溃监测模块等进行讲解。</p>\n<p>谢谢。</p>\n<p>wingjay</p>\n<p><a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\">我的Github</a>: <a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\">https://github.com/wingjay</a><br><a href=\"http://weibo.com/u/1625892654\" target=\"_blank\" rel=\"external\">微博 iam_wingjay</a>: <a href=\"http://weibo.com/u/1625892654\" target=\"_blank\" rel=\"external\">http://weibo.com/u/1625892654</a></p>\n<p>如果有问题，可以给我留言或发邮件<a href=\"&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#121;&#x69;&#x6e;&#106;&#105;&#x65;&#115;&#104;&#64;&#49;&#50;&#x36;&#x2e;&#x63;&#111;&#109;\">&#121;&#x69;&#x6e;&#106;&#105;&#x65;&#115;&#104;&#64;&#49;&#50;&#x36;&#x2e;&#x63;&#111;&#109;</a></p>","sticky":0},{"title":"写给移动开发者的 React Native 指南","date":"2017-03-14T04:07:06.000Z","commentIssueId":10,"_content":"\n> React Native 所代表的跨平台、动态更新技术已经引起了全世界开发者关注，而且这种技术势必会是未来的需求和潮流。React Native 不一定会成功，但至少目前 React Native 已经是这一领域的领跑者。\n\n<!-- more -->\n\n\n### 前言\nReact Native 诞生于 2015 年，名副其实的富二代，主要使命是为父出征，与 Apple 和 Google 抗衡，为开发者带去一套跨平台、动态更新的 Javascript 框架，口号是：Learn once, write anywhere：Build mobile apps with React。在试图推翻 Android 和 iOS 压制的同时，还提携了一把自家兄弟：React。\n\n从诞生之日 React Native 就充满了期待和争议。期待是无数开发者希望不用忍受频繁发版的噩梦，也不用同时为两个平台开发业务逻辑几无差别的两个 App；争议是 React Native 真的能以一己之力救大众于水火吗？React Native 在跨平台时还能保持良好的用户体验吗？\n\n当然我们知道，这种问题向来都是仁者见仁，智者见智。比起一味的疑惑、争论，还不如来好好看看这货究竟是个啥？甚至自己动手来玩一把。\n\n本文主要针对两类读者：\n- 想要入门 RN 的人，在阅读官方文档前先对 RN 形成一个整体的印象\n- 对 RN 心存好奇，在犹豫是否要入坑的开发者，可以通过本文对 RN 更客观全面的认识\n\n\n### 目录\n- React Native 好在哪\n  - 跨平台＋动态更新\n  - 代码复用\n  - RN vs Weex\n  - RN vs Hybrid\n  - RN 劣势\n- React Native 运行机制\n- RN 开发环境搭建\n- 引入 React Native\n  - Build from Scratch\n  - 集成到已有项目\n- Javascript、React 及 ES6、JSX 语法\n- UI 层\n- 网络请求层\n- Debugging 调试\n  - In-App 报错\n  - Console.log\n  - 大杀器：Chrome 逐行调试\n- 从 JS 调用 Native 方法或显示自定义 Native View\n  - Native Modules：JS 里直接调用 Native(Java/Swift) 方法\n  - Native UI Component：JS 里直接调用自定义的 Native View\n- React Native 适合你吗？\n- 为什么要写这篇文章\n\n### React Native 好在哪\n下面我们来看下 Hybrid 及 React Native 等开发模式包含了哪些常规移动开发所不具备的优势。\n\n##### 1. 跨平台＋动态更新\n传统的客户端开发模式是怎样的呢？\n\nAndroid 与 iOS Team 分别编写客户端代码，打包，分发到 Play Store 和 Apple Store，通过更新 JSON 数据来更新页面。\n\n不过，当客户端发生严重问题而服务器上无法 quick fix 时，就不得不重新发版。\n\n对国外 Android 市场而言还好，因为能通过 Play Store 快速更新；国内 Android 市场则由于分发渠道太杂，很难及时把新版本立即推送给所有用户，当然这也是为何热修复技术在国内盛行而国外冷清的原因；而 Apple Store 则需要一定的审核时间，而且最近又在抓 iOS 热修复框架如 JsPatch、Rollout 等。\n\n相比而言，Hybrid 和 RN/Weex 模式除了能下发 Json 数据来刷新界面内容，更能直接下发业务逻辑代码，直接实现整体 App 的更新。而且，它们不用在乎 Android 和 iOS 两个平台，因为一份 JS 代码写好后，把 JS Bundle 放在服务器上，所有的客户端立即更新。\n\n##### 2. 代码复用\n一般而言，同一款产品的 Android 和 iOS 两端除 UI 有些许不同外，多数业务逻辑几乎完全一致，这便造成了人力的浪费。\n\n而最近 Instagram 的官博 [React Native at Instagram](https://engineering.instagram.com/react-native-at-instagram-dd828a9a90c7#.ugk9ncjyz) 一文中已经提到，利用 RN (React Native 缩写，下同) 开发的 feature 可以实现 `85% - 99%` 的代码复用率。这意味着我们可以用更少的人力成本来达到相同的效果。\n\n##### 3. RN  vs Weex \n实现上面的效果有两种开发框架：混合开发框架 Cordova 和基于 Javascript 的 React-Native、Weex 框架。\n\n下面我从自己的实践经验出发做些比较，也欢迎读者提出自己看法。\n\n最开始觉得 RN 的学习成本比较大，所以首先考虑了 [Weex 框架](https://github.com/alibaba/weex)，据说是阿里巴巴良心出品。不过在尝试后不得不选择了放弃，原因有这几点：\n- Bug 较多。我们最先测试了`最基本`的 ListView，在 iOS 运行良好，而同样的 Demo 代码到了 Android 这边的`下拉刷新`就出现了问题，这使得我们开始警惕；\n- 社区、文档弱，GitHub Issue 基本是中文。当然我毫无歧视中文之意。我认为，**一套项目开源是真正意义是希望借助开源社区的力量，一起来完善改进，因此要优先推崇英文，使项目国际化，得到全世界开发者的共同支持，这样才是可持续的模式。**而 Weex 的 [Issue](https://github.com/alibaba/weex/issues) 里放眼望去基本 90% 都是中文，无论提问者还是**项目维护者**。这一点直接把国外优秀的开发者拒之门外，也很难让我看到多么长远的未来。\n下面是摘取的 RN 里的一则中文 issue：\n\n![**Issue is for bug report, not for Q&A**](http://upload-images.jianshu.io/upload_images/281665-fdd239b44898ea4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- Contributor 差别。因为上面一点，[Weex 的 Contributor](https://github.com/apache/incubator-weex/graphs/contributors) 只有 91 个人，而 [React-Native 的 Contributor](https://github.com/facebook/react-native/graphs/contributors) 有 1214 人。Contributor 是用来干嘛的？除了支持新功能，还有就是修复 bug 啊。Weex/RN 都是希望一统 Android + iOS 的，这么伟大的目标，这么艰巨的工程，不是几个人可以轻轻松松搞定的。 \n- 公司背景（来自YY）。大家都知道 RN 来自 Facebook，Weex 来自阿里巴巴。如果想一窥它们的未来，需要先想一下这种技术对他们各自的意义。大家都清楚，Facebook、Google、Apple 是当今当之无愧的巨头，在移动互联网这波浪潮里，Google 掌握了 Android 法器，Apple 控制了 iOS 神器，Facebook 呢？并没有这些系统级入口。当然 Windows 的经历也让 Facebook 并不那么倾向去开发一个新的移动操作系统来竞争。那怎么办？React Native 应运而生，打出的口号就是： **Learn once, write anywhere**。什么意思，没错，就是明确告诉你学一次就可以同时开发两个平台了。这一点可一直都是移动端开发人员和创业公司的理想。有人说了，Apple 这么强势，RN 要是太嚣张，分分钟把你禁掉。这时我们就要来看看 RN 的 [Showcase](http://facebook.github.io/react-native/showcase.html) 了，哪些 App 应用了 RN 呢？Facebook, Instagram, Airbnb, Walmart, QQ, 京东等，这回 Apple 要禁 RN 就要稍微掂量下这些大厂的意见吧。\n\n当然，我是很希望国内也能推出优质的开源项目来和国外大厂抗衡的，不过真正优质的大型开源项目往往除了开发者的个人能力，和公司的战略和制度关系也很大。\n\n\n##### 4. RN vs Hybrid\n这里的 Hybrid 开发主要针对 Cordova 框架，其实在放弃 Weex 之后我们还是没考虑 RN，而是转过去了解 Cordova，不过做了大致了解后也放弃了。主要硬伤有两点：\n- 性能短板。大家知道 Hybrid 是基于 WebView 的，在 Android 上的性能缺陷非常明显；而 RN 是利用 JSCore 转化成 Native 运行的，性能相对而言好不少；\n- 用户体验。了解移动产品的人都知道用户体验的重要性，RN 的体验和原生的几乎没有差别，而 Webview 的实现是网页开发思路，体验会相差很大。\n\n**性能和用户体验是移动 App 的命根子。**\n\n因此，综合考虑下来，我们还是决定相信 Facebook 并采用 RN。\n\n##### 5. RN 劣势\n上面我提到了 RN 的一些优势，不过作为开发者更加需要明确其劣势，我总结了下大概有以下几点劣势：\n- 学习成本。Weex 的写法就是类似常规的 Html/JS，对于前端人员来说很容易上手，就算了非前端人员来说也花不了多久。而 RN 是在 React.js 上进行改进形成的一套语法，和常规前端差别较大，因此需要好几天的学习适应。当然我觉得优秀的程序员的基本素质之一就是能快速学习、练习并熟练一种新语言的。我个人的话大概花了两三天的时间已经能完成一套涵盖网络、JS与Native通信的页面了，对于 React.js 语法也上手很快。\n- 安装包 Size。对于 iOS 而言影响不算很大，对于 Android 来说，我尝试后发现引入 RN 会给 apk 带来 6MB 左右的增幅，不过利用 `split apk` 的技术就能缩小到到 1MB 左右的增幅。\n- 首次加载耗时。大家知道 RN 需要从服务器下载 JS bundle，然后在本地转化成 Native code 运行的，所以在第一次打开 App 时需要花费一些时间进行下载和刷新。当然我们可以在发布 client 时内置一个写好的 js 文件在本地作缓存用。\n\n\n### 二、React Native 运行机制\n对于一个用 RN 搭建的移动 App，在启动后会从服务器下载最新的 JS Bundle 文件，然后由本地 JavascriptCore 引擎对 JS 文件进行解析，并利用 Bridge 映射到对应的 Native 方法和 UI 控件。得到的效果是：\n1. 同样的 RN 代码，下发到 Android 和 iOS 不同平台中，会自动调用对应 Native 的 UI 控件，保证了各平台用户体验的连贯性；\n2. 开发者就算是移动端小白，只要有 Web 基础，通过编写一套 RN 端代码就可以同时完成 Android 与 iOS App 的开发；\n3. 由于可以利用 JS bundle 同时下发数据和业务逻辑，这意味着你可以像 Web 开发一样，实时迭代更新你的移动端 App，无需在了解各自平台的热修复技术；\n4. Native Modules，这是 RN 强大的一个扩展性，允许你通过简单的代码就能实现在 JS 里直接调用你自己的 Native 方法；\n5. Native Components，如果你自己实现了一些复杂的 Native UI 组件，而这些组件尚未被 RN 支持，你可以利用 Native Components 快速把原生组件引入到 RN 中并可以直接在 JS 里更新这些组件的状态。\n\n\n\n### 三、RN 开发环境搭建\n首先 IDE 方面，RN 推荐了一些工具：\n- [Nuclide](https://nuclide.io/) 是 Facebook 内部用来开发 RN 的工具，Debug 功能强大。只不过这是一款 [Atom](https://github.com/atom/atom) 的插件，意味着你必须先安装 Atom，再来安装这款开发插件；\n- [Deco](https://www.decosoftware.com/) 是专为开发 RN 诞生的工具，可以快速搜索开源的第三方 RN 组件并直接插入到代码中，用 MacOS 的同学可以尝试下。我本人最开始也是试用这个，上手简单、小巧简洁。不足的是功能有点简单，无论是 Debug 功能还是代码检查之类的都不具备；\n- [Sublime](https://www.sublimetext.com/) 可以通过第三方包来达到不错的开发效率，各方面还算可圈可点；\n- [Visual Studio](https://code.visualstudio.com/) 这款也是蛮强大的 IDE，之前有用过的小伙伴可以试一下。\n\n本人的话目前采用的是 `Sublime`，因为个人常用 Sublime，而且第三方插件很丰富，轻量方便。下面简单说下配置，感兴趣的小伙伴可以看下。\n1. [Babel](https://packagecontrol.io/packages/Babel) 用来高亮 React JSX 语法，支持 ES6，而 React-Native 就是搭建在 [React.js](https://facebook.github.io/react/) 基础上的；\n2. [React-Native-Snippets](https://github.com/Shrugs/react-native-snippets) 可以快速生成 RN 的一些模版代码；\n3. [ESLint](http://eslint.cn/docs/user-guide/configuring) 超级强大的 Lint 工具，支持 ES6、JSX 语法检查，而且还有 React 和 RN 的插件，比纯粹的 JSXHint/JSLint 都强大；\n\n当然，用 Atom 的小伙伴自然要首先考虑 [Nuclide](https://nuclide.io/)。\n\n### 四、引入 React Native\n引入 RN 有两种方法：从零构建；集成到已有项目。\n\n##### 1. Build from Scratch \n先说第一种，从零开始构建，比较简单，遵循官方文档 [Getting Started](http://facebook.github.io/react-native/releases/0.42/docs/getting-started.html) 基于你自己的操作系统和平台一步步安装相关的依赖，然后利用如下命令：\n```\nreact-native init AwesomeProject\n```\n你就创建好一个 RN 工程项目了，结构如下：\n\n![RN 目录结构](http://upload-images.jianshu.io/upload_images/281665-8691544719a34a57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n里面有四个文件夹：\n- `android` / `ios`：各自存放了一个相关平台的工程 project，可以直接下拉 JS Bundle 并运行，对于移动端小白而言可以不用管里面的具体实现；\n- `node_modules`：里面是自动生成的 `node` 依赖之类的文件，通过读取 `package.json` 里的配置来生成；\n- `js`：这个文件夹最为重要，我们的开发都在这个文件夹里，把写好的 `js` 文件打包下发给 client 就会自动生效。\n\n\n##### 2. 集成到已有项目\n有很多公司是希望在现有 App 的基础上集成 `RN` 来开发一些特定的 Feature，这种情况就不能参考上面的方法了。在 RN 的官方文档里有一节 [Integration with Existing Apps](http://facebook.github.io/react-native/releases/0.42/docs/integration-with-existing-apps.html) , 只需要按照一步步做即可。\n\n以 Android 为例，大概要做以下几步：\n1. 添加 `gradle` 依赖：`compile \"com.facebook.react:react-native:+\" // From node_modules.`；\n2. 创建空的 `Activity` ，指定 `JS bundle` 和入口 `Component` 名字即会自动在这个 `Activity` 里去加载 `JS bundle` 文件；\n3. 在 Activity 里监听 onBackPressed 事件，用来与 JS 端协作处理返回键点击事件。\n4. 启动 server，运行 App 即可。\n\n总之需要说明的是，即使是移动端小白，也可以遵循文档里的指示完成这一步。接下来的大部分时间只要关心 JS 端开发就行了。\n\n### 五、Javascript、React 及 ES6、JSX 语法\n我们知道 RN 采用了 React 和 ES6 的语法，所以我们必须先对这些语法有一定了解才能去读 RN 的代码。\n\n关于 `Javascript`，我推荐 W3School 里的 [JS语法](http://www.w3school.com.cn/js/) 和 MDN 里的 [JS手册](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript)，大家只要对一些基础语法做些了解就可以。\n\n关于 `React`，我推荐 [阮一峰](http://www.ruanyifeng.com/) 写的 [React 入门实例教程](http://www.ruanyifeng.com/blog/2015/03/react.html)，基本上把文章读一遍，再自己动手写一遍，就能理会到 React 的大致用法了。\n\n关于 `ES6`、`ES7`、`JSX`等，感兴趣的可以看一下 RN 文档中 [Javascript Environment](http://facebook.github.io/react-native/releases/0.42/docs/javascript-environment.html) 里提到的支持的方法，需要时再来查询也可以。也可以看 `Babel` 出的 [Learn ES2015 手册](https://babeljs.io/learn-es2015/)。\n\n\n这里有一个很不错的 GitHub 项目，帮助你通过交互性的例子来快速上手语法知识：[React Native Express](http://www.reactnativeexpress.com/)。\n\n### 六、UI 层\n简单熟悉了 `React` 语法后，基本能正常阅读 RN 的示例代码了。\n\n正式开发 App 的第一步当然就是写 UI 界面了，由于 RN 已经封装好了一套 JS 的 UI 组件，这些组件会自动在 Android/iOS 端调用对应的原生 UI 组件，因此我们只需要熟悉这些 UI 组件的用法及属性、回调方法即可。\n\n我们可以在文档的 [Components](http://facebook.github.io/react-native/releases/0.42/docs/getting-started.html) 看到不少组件，比如`View, Text, Button, Image, Switch`, 还有我们用的最多的 `ScrollView` 和 `ListView`。\n\n在读文档时，我们可以先通过一边写代码一边读文档的方式进行，RN 非常贴心，直接在 Web 里嵌入了模拟器，我们只要修改编辑框里的代码，立即就能在右边的模拟器看到效果。这极大的降低了我们的学习成本。\n![Text Component](http://upload-images.jianshu.io/upload_images/281665-09965625af9b3a49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n另外，在学习一个组件时，我们要区分哪个属性是某个平台特有的。比如下面两个 Text 的属性：`textBreakStrategy` 只会在 Android 上生效，而 `adjustsFontSizeToFit` 只可以用在 iOS 上。\n\n![Platform Specific Properties](http://upload-images.jianshu.io/upload_images/281665-c8f4990d8334f3ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后，如果你希望在 Android 和 iOS 里显示不同的内容怎么办呢？RN 里有一节是[Platform Specific Code](http://facebook.github.io/react-native/releases/0.42/docs/platform-specific-code.html)，可以有如下几种形式来进行区分：\n```\nif (Platform.OS === 'ios') {\n  // stuff for ios\n} else {\n  // stuff for android\n}\n```\n\n除此之外，UI 组件的用法学习就很类似常规的 Html 标签了，只要知道其使用方式即可，甚至需要用的时候再来查文档也行。\n\n### 七、网络请求层 \n学完上面的我们已经能够写出 UI 界面了，而且这套界面已经能够在不同平台上转化成各自平台的 Native UI 了。然后，我们就需要去网络层请求真实数据了。\n\nRN 里提供了 [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) 来进行实现。举个例子，你想要通过 GET 方法去请求数据并转化成 JSON，可以通过如下代码实现：\n```\nfetch('https://facebook.github.io/react-native/movies.json')\n      .then((response) => response.json())\n      .then((responseJson) => {\n        return responseJson.movies;\n      })\n      .catch((error) => {\n        console.error(error);\n      });\n```\n熟悉 Reactive 编程的伙伴应该对这样的语法不陌生，比如 Android 上的 [RxJava](https://github.com/ReactiveX/RxJava)； iOS 上的 [RxSwift](https://github.com/ReactiveX/RxSwift)；Web 上的 [RxJS](https://github.com/Reactive-Extensions/RxJS)。上面 function 的功能就是：请求网址 `https://facebook.github.io/react-native/movies.json`，把返回的 Response 转化成 JSON object，取出 JSON object 里的 `movies` 字段。同时，如果发生 error 会被 catch 住。\n\n当然，上面是最基本的 GET 请求，Fetch API 还支持自定义 Headers，更换 Method，添加 Body 等。\n```\nfetch('https://mywebsite.com/endpoint/', {\n  method: 'POST',\n  headers: {\n    'Accept': 'application/json',\n    'Content-Type': 'application/json',\n  },\n  body: JSON.stringify({\n    firstParam: 'yourValue',\n    secondParam: 'yourOtherValue',\n  })\n})\n```\n上面构建了一个基本的 POST 请求，添加了自己的 Headers:`Accept`和`Content-Type`，添加了 Body。\n\n因此看下来，RN 里的网络请求不仅具备了 Reactive 编程的简洁，也能自定义常规的 Http 请求，写法简单。\n\n除了 Fetch API 之外，RN 还内置了 [XMLHttpRequest API(俗称 AJAX)](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest)，而且支持[TCP 全双工通信方式 WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)。\n\n### 八、Debugging 调试\n调试是很多程序员非常关注的一个环节，因为 RN 是用 JS 写完后到 Native 解释成 Native 方法来执行的，因此如果能快速调试 JS 代码是非常重要的一环。\n\n最开始 RN 的调试功能比较弱，不过现在的 Debugging 功能在我看来还是很不错的。一般来讲可以有以下几个调试方式：\n\n#####1. In-App 报错\nRN 里默认集成了 In-App 的错误提示方式，即在 App 运行过程中会弹出全屏的报错信息呈现给你，而你也可以通过阅读具体的错误信息快速找到错误原因。通过点击这个错误信息里的某一行，会立即自动打开对应的代码。\n![In-App Error](http://upload-images.jianshu.io/upload_images/281665-6531d24c41982690.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#####2. Console.log\n在开发 Client 时，我们一般都会用 `Log.log()` 来打印一些运行时变量的值，然后实时查看打印出来的 log 来调试，在 RN 也一样，你只要在 JS 里写一句 `console.log('this is log data')`，就会自动在 Client 的常规 log 里能看到，比如 Android 的 `adb logcat` 里就会自动打印出`'this is log data'`一行。\n\n#####3. 大杀器：Chrome 逐行调试\n这个杀器的最牛逼之处就是可以像 Client 一样，逐行调试代码！\n\n我们来看下面一张图。从左往右。先是文件目录，我们选中了 `index.js` 文件夹，然后第二个 Tab，是 `index.js` 的内容。这里关键的是我可以直接选中某一行代码设断点。当 Client 运行到这一行时，就会在第三个 Tab 里打印出运行时环境及变量。我们可以看到 `props` 里就有我们传进去的变量值。\n\n![Chrome Debug](http://upload-images.jianshu.io/upload_images/281665-d2fb4470d8ae27b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n有了以上几种调试方式，我们几乎可以和常规的 Native 开发一样来调试 RN 代码了，不得不说 RN Team 确实牛 x 啊！\n\n### 九、从 JS 调用 Native 方法或显示自定义 Native View\n这又是另一个牛 x 之处啊。\n\n很多人觉得 RN 限制太多，只能支持有限的 View 组件和有限的方法，难以发挥 Client 的最大性能。简单点说，在 Client 可以绘制复杂的 View，可以调用高性能 C++ 等底层代码，但 RN 却做不到。\n\n于是，RN 里提出了 `Native Modules` 和 `Native UI Component` 两种技术。\n\n#####Native Modules：JS 里直接调用 Native(Java/Swift) 方法\n所谓 Native Modules，就是自己在 Client 写好了某些方法，由于某些原因这些方法不太方便或者无法搬到 RN 里面，那么，我们可以在 Client 把这些方法暴露出来给 RN，然后在 JS 里可以像 import 普通的 module 一样把这些 Native Modules 引入进去，直接调用。\n\n具体的实现方法可以参考文档 [iOS Native Modules](http://facebook.github.io/react-native/releases/0.42/docs/native-modules-ios.html) 和 [Android Native Modules](http://facebook.github.io/react-native/releases/0.42/docs/native-modules-android.html)。\n\n\n#####Native UI Component：JS 里直接调用自定义的 Native View\n很多时候我们在写 Client 时，为了实现 Designer 天马行空的设计，常常需要自定义 View，即自己绘制某些系统并不提供的特定 UI。可想而知，这些 View 肯定不会出现在 RN 的 UI Component 里。\n\n那么，我们就需要首先在 Native 层自己写好一个自定义 View，然后利用`Native UI Component` 技术把这个 View 及其中某些 public 方法暴露给 RN，那么 RN 就能直接 import 进来并显示了。\n\n具体的实现方法可以参考文档 [iOS Native UI Component](http://facebook.github.io/react-native/releases/0.42/docs/native-components-ios.html) 和 [Android Native UI Component](http://facebook.github.io/react-native/releases/0.42/docs/native-components-android.html)。\n\n**如果读过文档不是很理解的小伙伴可以留言，我再 post 一些 demo 代码上来**\n\n### 十、React Native 适合你吗？\n这里借鉴下前段时间旧金山的 React Native 会议上的一些优劣总结给读者以参考。当然不一定对，仅供参考。\n\nRN 的优点：\n- 跨平台\n- 原生的用户体验\n- 开发者体验好\n- 动态更新代码逻辑\n- 社区强大\n- 有个好爹\n\nRN 的缺点：\n- 不够成熟\n- 不够稳定\n- 生态系统在搭建中\n- 优质的 App 需要时间打磨\n- 偶尔需要写 Native 代码(也就是 JS + Swift + Java)\n\n适合下面这些人/公司：\n- 你对 JS/React 有一定了解\n- Web 开发人员比 Mobile 开发人员多\n- 有意愿投资精力给 RN\n- App 设计不是特别区分 Android 和 iOS\n- 希望热更新\n\n下面这些人要稍微考虑下：\n- 完全不了解 JS/React\n- 已经有现成的 Android/iOS team\n- App 设计严格遵守 Android、iOS各自设计规范\n- 不想要投入时间／金钱给 RN\n\n### 十一、为什么要写这篇文章\n几个月前我对 React Native 也非常不看好，当然现在也没有说非常看好。或者说，写这篇文章毫无为 React Native 布道之意。\n\n接触 React Native 主要是因为业务需要，PM 希望能够随时改动某块变化较大的模块，常规的开发提交流程往往需要较长的时间，而热修复技术本身并未得到 Google 和 Apple 的官方认可，也就是随时可能因破坏生态安全之名被取缔。\n\n因此才考虑去了解 Hybrid 开发和 JS Native 开发模式，在了解过程中，又由于性能差、用户体验不好而放弃 Hybrid，由于社区不完善、Bug 较多等原因放弃 Weex，最终才选择了 React Native，开始学习 React、JSX等语法。\n\n目前使用下来对 React Native 的一些个人感受：\n1. 学习门槛并没有开始想象那么高。大概只花了两三天时间就熟悉了 Javascript、React 框架、JSX语法，然后就开始着手业务开发。\n2. 对 Android App 的影响。React Native 会给 Android 端带来 `6MB` 左右的 size 增幅，不过在采用了 `split apk` 后就只有 `1MB` 左右增幅。\n3. Debug 功能比较完善，至少不用担心发生问题后不知从哪下手。\n4. 性能还行。最初担心的是 React Native 性能不好，但自己上手后，并没有明显感觉到很明显的 React Native 对 App 性能的负面影响，无论是 iOS 还是 Android，当然，这一点还在继续考察中。\n5. 动态部署真的很不错。以前每次写好代码都要花不少时间来编译运行，而现在只要写一份代码，就可以同时在 Android 和 iOS 实时更新了，这无疑节省了生命。\n5. 有待完善。当然，React Native 中确实还存在着不少问题，生态系统也还不够完善。不过我相信，这只是时间问题。\n\n关于React Native一直以来都有很多争议。\n\n不过我想说的是，**React Native 所代表的跨平台、动态更新技术已经引起了全世界开发者关注，而且这种技术势必会是未来的需求和潮流。React Native 不一定会成功，但至少目前 React Native 已经是这一领域的领跑者。**\n\n而写这篇文章的目的，就是希望告诉更多开发者，**React Native 并不完美，但值得一试。**\n\n谢谢。\n\nwingjay\n\n\n[我的Github](https://github.com/wingjay): <https://github.com/wingjay> \n[微博 iam_wingjay](http://weibo.com/u/1625892654): <http://weibo.com/u/1625892654>\n\n如果有问题，可以给我留言或发邮件<mailto:yinjiesh@126.com>","source":"_posts/写给移动开发者的-React-Native-指南.md","raw":"title: 写给移动开发者的 React Native 指南\ndate: 2017-03-14 12:07:06\ncategories:\n  - React Native\ntags: React Native\ncommentIssueId: 10\n---\n\n> React Native 所代表的跨平台、动态更新技术已经引起了全世界开发者关注，而且这种技术势必会是未来的需求和潮流。React Native 不一定会成功，但至少目前 React Native 已经是这一领域的领跑者。\n\n<!-- more -->\n\n\n### 前言\nReact Native 诞生于 2015 年，名副其实的富二代，主要使命是为父出征，与 Apple 和 Google 抗衡，为开发者带去一套跨平台、动态更新的 Javascript 框架，口号是：Learn once, write anywhere：Build mobile apps with React。在试图推翻 Android 和 iOS 压制的同时，还提携了一把自家兄弟：React。\n\n从诞生之日 React Native 就充满了期待和争议。期待是无数开发者希望不用忍受频繁发版的噩梦，也不用同时为两个平台开发业务逻辑几无差别的两个 App；争议是 React Native 真的能以一己之力救大众于水火吗？React Native 在跨平台时还能保持良好的用户体验吗？\n\n当然我们知道，这种问题向来都是仁者见仁，智者见智。比起一味的疑惑、争论，还不如来好好看看这货究竟是个啥？甚至自己动手来玩一把。\n\n本文主要针对两类读者：\n- 想要入门 RN 的人，在阅读官方文档前先对 RN 形成一个整体的印象\n- 对 RN 心存好奇，在犹豫是否要入坑的开发者，可以通过本文对 RN 更客观全面的认识\n\n\n### 目录\n- React Native 好在哪\n  - 跨平台＋动态更新\n  - 代码复用\n  - RN vs Weex\n  - RN vs Hybrid\n  - RN 劣势\n- React Native 运行机制\n- RN 开发环境搭建\n- 引入 React Native\n  - Build from Scratch\n  - 集成到已有项目\n- Javascript、React 及 ES6、JSX 语法\n- UI 层\n- 网络请求层\n- Debugging 调试\n  - In-App 报错\n  - Console.log\n  - 大杀器：Chrome 逐行调试\n- 从 JS 调用 Native 方法或显示自定义 Native View\n  - Native Modules：JS 里直接调用 Native(Java/Swift) 方法\n  - Native UI Component：JS 里直接调用自定义的 Native View\n- React Native 适合你吗？\n- 为什么要写这篇文章\n\n### React Native 好在哪\n下面我们来看下 Hybrid 及 React Native 等开发模式包含了哪些常规移动开发所不具备的优势。\n\n##### 1. 跨平台＋动态更新\n传统的客户端开发模式是怎样的呢？\n\nAndroid 与 iOS Team 分别编写客户端代码，打包，分发到 Play Store 和 Apple Store，通过更新 JSON 数据来更新页面。\n\n不过，当客户端发生严重问题而服务器上无法 quick fix 时，就不得不重新发版。\n\n对国外 Android 市场而言还好，因为能通过 Play Store 快速更新；国内 Android 市场则由于分发渠道太杂，很难及时把新版本立即推送给所有用户，当然这也是为何热修复技术在国内盛行而国外冷清的原因；而 Apple Store 则需要一定的审核时间，而且最近又在抓 iOS 热修复框架如 JsPatch、Rollout 等。\n\n相比而言，Hybrid 和 RN/Weex 模式除了能下发 Json 数据来刷新界面内容，更能直接下发业务逻辑代码，直接实现整体 App 的更新。而且，它们不用在乎 Android 和 iOS 两个平台，因为一份 JS 代码写好后，把 JS Bundle 放在服务器上，所有的客户端立即更新。\n\n##### 2. 代码复用\n一般而言，同一款产品的 Android 和 iOS 两端除 UI 有些许不同外，多数业务逻辑几乎完全一致，这便造成了人力的浪费。\n\n而最近 Instagram 的官博 [React Native at Instagram](https://engineering.instagram.com/react-native-at-instagram-dd828a9a90c7#.ugk9ncjyz) 一文中已经提到，利用 RN (React Native 缩写，下同) 开发的 feature 可以实现 `85% - 99%` 的代码复用率。这意味着我们可以用更少的人力成本来达到相同的效果。\n\n##### 3. RN  vs Weex \n实现上面的效果有两种开发框架：混合开发框架 Cordova 和基于 Javascript 的 React-Native、Weex 框架。\n\n下面我从自己的实践经验出发做些比较，也欢迎读者提出自己看法。\n\n最开始觉得 RN 的学习成本比较大，所以首先考虑了 [Weex 框架](https://github.com/alibaba/weex)，据说是阿里巴巴良心出品。不过在尝试后不得不选择了放弃，原因有这几点：\n- Bug 较多。我们最先测试了`最基本`的 ListView，在 iOS 运行良好，而同样的 Demo 代码到了 Android 这边的`下拉刷新`就出现了问题，这使得我们开始警惕；\n- 社区、文档弱，GitHub Issue 基本是中文。当然我毫无歧视中文之意。我认为，**一套项目开源是真正意义是希望借助开源社区的力量，一起来完善改进，因此要优先推崇英文，使项目国际化，得到全世界开发者的共同支持，这样才是可持续的模式。**而 Weex 的 [Issue](https://github.com/alibaba/weex/issues) 里放眼望去基本 90% 都是中文，无论提问者还是**项目维护者**。这一点直接把国外优秀的开发者拒之门外，也很难让我看到多么长远的未来。\n下面是摘取的 RN 里的一则中文 issue：\n\n![**Issue is for bug report, not for Q&A**](http://upload-images.jianshu.io/upload_images/281665-fdd239b44898ea4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- Contributor 差别。因为上面一点，[Weex 的 Contributor](https://github.com/apache/incubator-weex/graphs/contributors) 只有 91 个人，而 [React-Native 的 Contributor](https://github.com/facebook/react-native/graphs/contributors) 有 1214 人。Contributor 是用来干嘛的？除了支持新功能，还有就是修复 bug 啊。Weex/RN 都是希望一统 Android + iOS 的，这么伟大的目标，这么艰巨的工程，不是几个人可以轻轻松松搞定的。 \n- 公司背景（来自YY）。大家都知道 RN 来自 Facebook，Weex 来自阿里巴巴。如果想一窥它们的未来，需要先想一下这种技术对他们各自的意义。大家都清楚，Facebook、Google、Apple 是当今当之无愧的巨头，在移动互联网这波浪潮里，Google 掌握了 Android 法器，Apple 控制了 iOS 神器，Facebook 呢？并没有这些系统级入口。当然 Windows 的经历也让 Facebook 并不那么倾向去开发一个新的移动操作系统来竞争。那怎么办？React Native 应运而生，打出的口号就是： **Learn once, write anywhere**。什么意思，没错，就是明确告诉你学一次就可以同时开发两个平台了。这一点可一直都是移动端开发人员和创业公司的理想。有人说了，Apple 这么强势，RN 要是太嚣张，分分钟把你禁掉。这时我们就要来看看 RN 的 [Showcase](http://facebook.github.io/react-native/showcase.html) 了，哪些 App 应用了 RN 呢？Facebook, Instagram, Airbnb, Walmart, QQ, 京东等，这回 Apple 要禁 RN 就要稍微掂量下这些大厂的意见吧。\n\n当然，我是很希望国内也能推出优质的开源项目来和国外大厂抗衡的，不过真正优质的大型开源项目往往除了开发者的个人能力，和公司的战略和制度关系也很大。\n\n\n##### 4. RN vs Hybrid\n这里的 Hybrid 开发主要针对 Cordova 框架，其实在放弃 Weex 之后我们还是没考虑 RN，而是转过去了解 Cordova，不过做了大致了解后也放弃了。主要硬伤有两点：\n- 性能短板。大家知道 Hybrid 是基于 WebView 的，在 Android 上的性能缺陷非常明显；而 RN 是利用 JSCore 转化成 Native 运行的，性能相对而言好不少；\n- 用户体验。了解移动产品的人都知道用户体验的重要性，RN 的体验和原生的几乎没有差别，而 Webview 的实现是网页开发思路，体验会相差很大。\n\n**性能和用户体验是移动 App 的命根子。**\n\n因此，综合考虑下来，我们还是决定相信 Facebook 并采用 RN。\n\n##### 5. RN 劣势\n上面我提到了 RN 的一些优势，不过作为开发者更加需要明确其劣势，我总结了下大概有以下几点劣势：\n- 学习成本。Weex 的写法就是类似常规的 Html/JS，对于前端人员来说很容易上手，就算了非前端人员来说也花不了多久。而 RN 是在 React.js 上进行改进形成的一套语法，和常规前端差别较大，因此需要好几天的学习适应。当然我觉得优秀的程序员的基本素质之一就是能快速学习、练习并熟练一种新语言的。我个人的话大概花了两三天的时间已经能完成一套涵盖网络、JS与Native通信的页面了，对于 React.js 语法也上手很快。\n- 安装包 Size。对于 iOS 而言影响不算很大，对于 Android 来说，我尝试后发现引入 RN 会给 apk 带来 6MB 左右的增幅，不过利用 `split apk` 的技术就能缩小到到 1MB 左右的增幅。\n- 首次加载耗时。大家知道 RN 需要从服务器下载 JS bundle，然后在本地转化成 Native code 运行的，所以在第一次打开 App 时需要花费一些时间进行下载和刷新。当然我们可以在发布 client 时内置一个写好的 js 文件在本地作缓存用。\n\n\n### 二、React Native 运行机制\n对于一个用 RN 搭建的移动 App，在启动后会从服务器下载最新的 JS Bundle 文件，然后由本地 JavascriptCore 引擎对 JS 文件进行解析，并利用 Bridge 映射到对应的 Native 方法和 UI 控件。得到的效果是：\n1. 同样的 RN 代码，下发到 Android 和 iOS 不同平台中，会自动调用对应 Native 的 UI 控件，保证了各平台用户体验的连贯性；\n2. 开发者就算是移动端小白，只要有 Web 基础，通过编写一套 RN 端代码就可以同时完成 Android 与 iOS App 的开发；\n3. 由于可以利用 JS bundle 同时下发数据和业务逻辑，这意味着你可以像 Web 开发一样，实时迭代更新你的移动端 App，无需在了解各自平台的热修复技术；\n4. Native Modules，这是 RN 强大的一个扩展性，允许你通过简单的代码就能实现在 JS 里直接调用你自己的 Native 方法；\n5. Native Components，如果你自己实现了一些复杂的 Native UI 组件，而这些组件尚未被 RN 支持，你可以利用 Native Components 快速把原生组件引入到 RN 中并可以直接在 JS 里更新这些组件的状态。\n\n\n\n### 三、RN 开发环境搭建\n首先 IDE 方面，RN 推荐了一些工具：\n- [Nuclide](https://nuclide.io/) 是 Facebook 内部用来开发 RN 的工具，Debug 功能强大。只不过这是一款 [Atom](https://github.com/atom/atom) 的插件，意味着你必须先安装 Atom，再来安装这款开发插件；\n- [Deco](https://www.decosoftware.com/) 是专为开发 RN 诞生的工具，可以快速搜索开源的第三方 RN 组件并直接插入到代码中，用 MacOS 的同学可以尝试下。我本人最开始也是试用这个，上手简单、小巧简洁。不足的是功能有点简单，无论是 Debug 功能还是代码检查之类的都不具备；\n- [Sublime](https://www.sublimetext.com/) 可以通过第三方包来达到不错的开发效率，各方面还算可圈可点；\n- [Visual Studio](https://code.visualstudio.com/) 这款也是蛮强大的 IDE，之前有用过的小伙伴可以试一下。\n\n本人的话目前采用的是 `Sublime`，因为个人常用 Sublime，而且第三方插件很丰富，轻量方便。下面简单说下配置，感兴趣的小伙伴可以看下。\n1. [Babel](https://packagecontrol.io/packages/Babel) 用来高亮 React JSX 语法，支持 ES6，而 React-Native 就是搭建在 [React.js](https://facebook.github.io/react/) 基础上的；\n2. [React-Native-Snippets](https://github.com/Shrugs/react-native-snippets) 可以快速生成 RN 的一些模版代码；\n3. [ESLint](http://eslint.cn/docs/user-guide/configuring) 超级强大的 Lint 工具，支持 ES6、JSX 语法检查，而且还有 React 和 RN 的插件，比纯粹的 JSXHint/JSLint 都强大；\n\n当然，用 Atom 的小伙伴自然要首先考虑 [Nuclide](https://nuclide.io/)。\n\n### 四、引入 React Native\n引入 RN 有两种方法：从零构建；集成到已有项目。\n\n##### 1. Build from Scratch \n先说第一种，从零开始构建，比较简单，遵循官方文档 [Getting Started](http://facebook.github.io/react-native/releases/0.42/docs/getting-started.html) 基于你自己的操作系统和平台一步步安装相关的依赖，然后利用如下命令：\n```\nreact-native init AwesomeProject\n```\n你就创建好一个 RN 工程项目了，结构如下：\n\n![RN 目录结构](http://upload-images.jianshu.io/upload_images/281665-8691544719a34a57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n里面有四个文件夹：\n- `android` / `ios`：各自存放了一个相关平台的工程 project，可以直接下拉 JS Bundle 并运行，对于移动端小白而言可以不用管里面的具体实现；\n- `node_modules`：里面是自动生成的 `node` 依赖之类的文件，通过读取 `package.json` 里的配置来生成；\n- `js`：这个文件夹最为重要，我们的开发都在这个文件夹里，把写好的 `js` 文件打包下发给 client 就会自动生效。\n\n\n##### 2. 集成到已有项目\n有很多公司是希望在现有 App 的基础上集成 `RN` 来开发一些特定的 Feature，这种情况就不能参考上面的方法了。在 RN 的官方文档里有一节 [Integration with Existing Apps](http://facebook.github.io/react-native/releases/0.42/docs/integration-with-existing-apps.html) , 只需要按照一步步做即可。\n\n以 Android 为例，大概要做以下几步：\n1. 添加 `gradle` 依赖：`compile \"com.facebook.react:react-native:+\" // From node_modules.`；\n2. 创建空的 `Activity` ，指定 `JS bundle` 和入口 `Component` 名字即会自动在这个 `Activity` 里去加载 `JS bundle` 文件；\n3. 在 Activity 里监听 onBackPressed 事件，用来与 JS 端协作处理返回键点击事件。\n4. 启动 server，运行 App 即可。\n\n总之需要说明的是，即使是移动端小白，也可以遵循文档里的指示完成这一步。接下来的大部分时间只要关心 JS 端开发就行了。\n\n### 五、Javascript、React 及 ES6、JSX 语法\n我们知道 RN 采用了 React 和 ES6 的语法，所以我们必须先对这些语法有一定了解才能去读 RN 的代码。\n\n关于 `Javascript`，我推荐 W3School 里的 [JS语法](http://www.w3school.com.cn/js/) 和 MDN 里的 [JS手册](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript)，大家只要对一些基础语法做些了解就可以。\n\n关于 `React`，我推荐 [阮一峰](http://www.ruanyifeng.com/) 写的 [React 入门实例教程](http://www.ruanyifeng.com/blog/2015/03/react.html)，基本上把文章读一遍，再自己动手写一遍，就能理会到 React 的大致用法了。\n\n关于 `ES6`、`ES7`、`JSX`等，感兴趣的可以看一下 RN 文档中 [Javascript Environment](http://facebook.github.io/react-native/releases/0.42/docs/javascript-environment.html) 里提到的支持的方法，需要时再来查询也可以。也可以看 `Babel` 出的 [Learn ES2015 手册](https://babeljs.io/learn-es2015/)。\n\n\n这里有一个很不错的 GitHub 项目，帮助你通过交互性的例子来快速上手语法知识：[React Native Express](http://www.reactnativeexpress.com/)。\n\n### 六、UI 层\n简单熟悉了 `React` 语法后，基本能正常阅读 RN 的示例代码了。\n\n正式开发 App 的第一步当然就是写 UI 界面了，由于 RN 已经封装好了一套 JS 的 UI 组件，这些组件会自动在 Android/iOS 端调用对应的原生 UI 组件，因此我们只需要熟悉这些 UI 组件的用法及属性、回调方法即可。\n\n我们可以在文档的 [Components](http://facebook.github.io/react-native/releases/0.42/docs/getting-started.html) 看到不少组件，比如`View, Text, Button, Image, Switch`, 还有我们用的最多的 `ScrollView` 和 `ListView`。\n\n在读文档时，我们可以先通过一边写代码一边读文档的方式进行，RN 非常贴心，直接在 Web 里嵌入了模拟器，我们只要修改编辑框里的代码，立即就能在右边的模拟器看到效果。这极大的降低了我们的学习成本。\n![Text Component](http://upload-images.jianshu.io/upload_images/281665-09965625af9b3a49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n另外，在学习一个组件时，我们要区分哪个属性是某个平台特有的。比如下面两个 Text 的属性：`textBreakStrategy` 只会在 Android 上生效，而 `adjustsFontSizeToFit` 只可以用在 iOS 上。\n\n![Platform Specific Properties](http://upload-images.jianshu.io/upload_images/281665-c8f4990d8334f3ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后，如果你希望在 Android 和 iOS 里显示不同的内容怎么办呢？RN 里有一节是[Platform Specific Code](http://facebook.github.io/react-native/releases/0.42/docs/platform-specific-code.html)，可以有如下几种形式来进行区分：\n```\nif (Platform.OS === 'ios') {\n  // stuff for ios\n} else {\n  // stuff for android\n}\n```\n\n除此之外，UI 组件的用法学习就很类似常规的 Html 标签了，只要知道其使用方式即可，甚至需要用的时候再来查文档也行。\n\n### 七、网络请求层 \n学完上面的我们已经能够写出 UI 界面了，而且这套界面已经能够在不同平台上转化成各自平台的 Native UI 了。然后，我们就需要去网络层请求真实数据了。\n\nRN 里提供了 [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) 来进行实现。举个例子，你想要通过 GET 方法去请求数据并转化成 JSON，可以通过如下代码实现：\n```\nfetch('https://facebook.github.io/react-native/movies.json')\n      .then((response) => response.json())\n      .then((responseJson) => {\n        return responseJson.movies;\n      })\n      .catch((error) => {\n        console.error(error);\n      });\n```\n熟悉 Reactive 编程的伙伴应该对这样的语法不陌生，比如 Android 上的 [RxJava](https://github.com/ReactiveX/RxJava)； iOS 上的 [RxSwift](https://github.com/ReactiveX/RxSwift)；Web 上的 [RxJS](https://github.com/Reactive-Extensions/RxJS)。上面 function 的功能就是：请求网址 `https://facebook.github.io/react-native/movies.json`，把返回的 Response 转化成 JSON object，取出 JSON object 里的 `movies` 字段。同时，如果发生 error 会被 catch 住。\n\n当然，上面是最基本的 GET 请求，Fetch API 还支持自定义 Headers，更换 Method，添加 Body 等。\n```\nfetch('https://mywebsite.com/endpoint/', {\n  method: 'POST',\n  headers: {\n    'Accept': 'application/json',\n    'Content-Type': 'application/json',\n  },\n  body: JSON.stringify({\n    firstParam: 'yourValue',\n    secondParam: 'yourOtherValue',\n  })\n})\n```\n上面构建了一个基本的 POST 请求，添加了自己的 Headers:`Accept`和`Content-Type`，添加了 Body。\n\n因此看下来，RN 里的网络请求不仅具备了 Reactive 编程的简洁，也能自定义常规的 Http 请求，写法简单。\n\n除了 Fetch API 之外，RN 还内置了 [XMLHttpRequest API(俗称 AJAX)](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest)，而且支持[TCP 全双工通信方式 WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)。\n\n### 八、Debugging 调试\n调试是很多程序员非常关注的一个环节，因为 RN 是用 JS 写完后到 Native 解释成 Native 方法来执行的，因此如果能快速调试 JS 代码是非常重要的一环。\n\n最开始 RN 的调试功能比较弱，不过现在的 Debugging 功能在我看来还是很不错的。一般来讲可以有以下几个调试方式：\n\n#####1. In-App 报错\nRN 里默认集成了 In-App 的错误提示方式，即在 App 运行过程中会弹出全屏的报错信息呈现给你，而你也可以通过阅读具体的错误信息快速找到错误原因。通过点击这个错误信息里的某一行，会立即自动打开对应的代码。\n![In-App Error](http://upload-images.jianshu.io/upload_images/281665-6531d24c41982690.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#####2. Console.log\n在开发 Client 时，我们一般都会用 `Log.log()` 来打印一些运行时变量的值，然后实时查看打印出来的 log 来调试，在 RN 也一样，你只要在 JS 里写一句 `console.log('this is log data')`，就会自动在 Client 的常规 log 里能看到，比如 Android 的 `adb logcat` 里就会自动打印出`'this is log data'`一行。\n\n#####3. 大杀器：Chrome 逐行调试\n这个杀器的最牛逼之处就是可以像 Client 一样，逐行调试代码！\n\n我们来看下面一张图。从左往右。先是文件目录，我们选中了 `index.js` 文件夹，然后第二个 Tab，是 `index.js` 的内容。这里关键的是我可以直接选中某一行代码设断点。当 Client 运行到这一行时，就会在第三个 Tab 里打印出运行时环境及变量。我们可以看到 `props` 里就有我们传进去的变量值。\n\n![Chrome Debug](http://upload-images.jianshu.io/upload_images/281665-d2fb4470d8ae27b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n有了以上几种调试方式，我们几乎可以和常规的 Native 开发一样来调试 RN 代码了，不得不说 RN Team 确实牛 x 啊！\n\n### 九、从 JS 调用 Native 方法或显示自定义 Native View\n这又是另一个牛 x 之处啊。\n\n很多人觉得 RN 限制太多，只能支持有限的 View 组件和有限的方法，难以发挥 Client 的最大性能。简单点说，在 Client 可以绘制复杂的 View，可以调用高性能 C++ 等底层代码，但 RN 却做不到。\n\n于是，RN 里提出了 `Native Modules` 和 `Native UI Component` 两种技术。\n\n#####Native Modules：JS 里直接调用 Native(Java/Swift) 方法\n所谓 Native Modules，就是自己在 Client 写好了某些方法，由于某些原因这些方法不太方便或者无法搬到 RN 里面，那么，我们可以在 Client 把这些方法暴露出来给 RN，然后在 JS 里可以像 import 普通的 module 一样把这些 Native Modules 引入进去，直接调用。\n\n具体的实现方法可以参考文档 [iOS Native Modules](http://facebook.github.io/react-native/releases/0.42/docs/native-modules-ios.html) 和 [Android Native Modules](http://facebook.github.io/react-native/releases/0.42/docs/native-modules-android.html)。\n\n\n#####Native UI Component：JS 里直接调用自定义的 Native View\n很多时候我们在写 Client 时，为了实现 Designer 天马行空的设计，常常需要自定义 View，即自己绘制某些系统并不提供的特定 UI。可想而知，这些 View 肯定不会出现在 RN 的 UI Component 里。\n\n那么，我们就需要首先在 Native 层自己写好一个自定义 View，然后利用`Native UI Component` 技术把这个 View 及其中某些 public 方法暴露给 RN，那么 RN 就能直接 import 进来并显示了。\n\n具体的实现方法可以参考文档 [iOS Native UI Component](http://facebook.github.io/react-native/releases/0.42/docs/native-components-ios.html) 和 [Android Native UI Component](http://facebook.github.io/react-native/releases/0.42/docs/native-components-android.html)。\n\n**如果读过文档不是很理解的小伙伴可以留言，我再 post 一些 demo 代码上来**\n\n### 十、React Native 适合你吗？\n这里借鉴下前段时间旧金山的 React Native 会议上的一些优劣总结给读者以参考。当然不一定对，仅供参考。\n\nRN 的优点：\n- 跨平台\n- 原生的用户体验\n- 开发者体验好\n- 动态更新代码逻辑\n- 社区强大\n- 有个好爹\n\nRN 的缺点：\n- 不够成熟\n- 不够稳定\n- 生态系统在搭建中\n- 优质的 App 需要时间打磨\n- 偶尔需要写 Native 代码(也就是 JS + Swift + Java)\n\n适合下面这些人/公司：\n- 你对 JS/React 有一定了解\n- Web 开发人员比 Mobile 开发人员多\n- 有意愿投资精力给 RN\n- App 设计不是特别区分 Android 和 iOS\n- 希望热更新\n\n下面这些人要稍微考虑下：\n- 完全不了解 JS/React\n- 已经有现成的 Android/iOS team\n- App 设计严格遵守 Android、iOS各自设计规范\n- 不想要投入时间／金钱给 RN\n\n### 十一、为什么要写这篇文章\n几个月前我对 React Native 也非常不看好，当然现在也没有说非常看好。或者说，写这篇文章毫无为 React Native 布道之意。\n\n接触 React Native 主要是因为业务需要，PM 希望能够随时改动某块变化较大的模块，常规的开发提交流程往往需要较长的时间，而热修复技术本身并未得到 Google 和 Apple 的官方认可，也就是随时可能因破坏生态安全之名被取缔。\n\n因此才考虑去了解 Hybrid 开发和 JS Native 开发模式，在了解过程中，又由于性能差、用户体验不好而放弃 Hybrid，由于社区不完善、Bug 较多等原因放弃 Weex，最终才选择了 React Native，开始学习 React、JSX等语法。\n\n目前使用下来对 React Native 的一些个人感受：\n1. 学习门槛并没有开始想象那么高。大概只花了两三天时间就熟悉了 Javascript、React 框架、JSX语法，然后就开始着手业务开发。\n2. 对 Android App 的影响。React Native 会给 Android 端带来 `6MB` 左右的 size 增幅，不过在采用了 `split apk` 后就只有 `1MB` 左右增幅。\n3. Debug 功能比较完善，至少不用担心发生问题后不知从哪下手。\n4. 性能还行。最初担心的是 React Native 性能不好，但自己上手后，并没有明显感觉到很明显的 React Native 对 App 性能的负面影响，无论是 iOS 还是 Android，当然，这一点还在继续考察中。\n5. 动态部署真的很不错。以前每次写好代码都要花不少时间来编译运行，而现在只要写一份代码，就可以同时在 Android 和 iOS 实时更新了，这无疑节省了生命。\n5. 有待完善。当然，React Native 中确实还存在着不少问题，生态系统也还不够完善。不过我相信，这只是时间问题。\n\n关于React Native一直以来都有很多争议。\n\n不过我想说的是，**React Native 所代表的跨平台、动态更新技术已经引起了全世界开发者关注，而且这种技术势必会是未来的需求和潮流。React Native 不一定会成功，但至少目前 React Native 已经是这一领域的领跑者。**\n\n而写这篇文章的目的，就是希望告诉更多开发者，**React Native 并不完美，但值得一试。**\n\n谢谢。\n\nwingjay\n\n\n[我的Github](https://github.com/wingjay): <https://github.com/wingjay> \n[微博 iam_wingjay](http://weibo.com/u/1625892654): <http://weibo.com/u/1625892654>\n\n如果有问题，可以给我留言或发邮件<mailto:yinjiesh@126.com>","slug":"写给移动开发者的-React-Native-指南","published":1,"updated":"2018-11-26T06:56:27.484Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxcplsk900653dn8ntcvz7a8","content":"<blockquote>\n<p>React Native 所代表的跨平台、动态更新技术已经引起了全世界开发者关注，而且这种技术势必会是未来的需求和潮流。React Native 不一定会成功，但至少目前 React Native 已经是这一领域的领跑者。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"前言\"><a href=\"# 前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>React Native 诞生于 2015 年，名副其实的富二代，主要使命是为父出征，与 Apple 和 Google 抗衡，为开发者带去一套跨平台、动态更新的 Javascript 框架，口号是：Learn once, write anywhere：Build mobile apps with React。在试图推翻 Android 和 iOS 压制的同时，还提携了一把自家兄弟：React。</p>\n<p>从诞生之日 React Native 就充满了期待和争议。期待是无数开发者希望不用忍受频繁发版的噩梦，也不用同时为两个平台开发业务逻辑几无差别的两个 App；争议是 React Native 真的能以一己之力救大众于水火吗？React Native 在跨平台时还能保持良好的用户体验吗？</p>\n<p>当然我们知道，这种问题向来都是仁者见仁，智者见智。比起一味的疑惑、争论，还不如来好好看看这货究竟是个啥？甚至自己动手来玩一把。</p>\n<p>本文主要针对两类读者：</p>\n<ul>\n<li>想要入门 RN 的人，在阅读官方文档前先对 RN 形成一个整体的印象</li>\n<li>对 RN 心存好奇，在犹豫是否要入坑的开发者，可以通过本文对 RN 更客观全面的认识</li>\n</ul>\n<h3 id=\"目录\"><a href=\"# 目录\" class=\"headerlink\" title=\"目录\"></a>目录</h3><ul>\n<li>React Native 好在哪<ul>\n<li>跨平台＋动态更新</li>\n<li>代码复用</li>\n<li>RN vs Weex</li>\n<li>RN vs Hybrid</li>\n<li>RN 劣势</li>\n</ul>\n</li>\n<li>React Native 运行机制</li>\n<li>RN 开发环境搭建</li>\n<li>引入 React Native<ul>\n<li>Build from Scratch</li>\n<li>集成到已有项目</li>\n</ul>\n</li>\n<li>Javascript、React 及 ES6、JSX 语法</li>\n<li>UI 层</li>\n<li>网络请求层</li>\n<li>Debugging 调试<ul>\n<li>In-App 报错</li>\n<li>Console.log</li>\n<li>大杀器：Chrome 逐行调试</li>\n</ul>\n</li>\n<li>从 JS 调用 Native 方法或显示自定义 Native View<ul>\n<li>Native Modules：JS 里直接调用 Native(Java/Swift) 方法</li>\n<li>Native UI Component：JS 里直接调用自定义的 Native View</li>\n</ul>\n</li>\n<li>React Native 适合你吗？</li>\n<li>为什么要写这篇文章</li>\n</ul>\n<h3 id=\"React-Native- 好在哪\"><a href=\"#React-Native- 好在哪\" class=\"headerlink\" title=\"React Native 好在哪\"></a>React Native 好在哪 </h3><p> 下面我们来看下 Hybrid 及 React Native 等开发模式包含了哪些常规移动开发所不具备的优势。</p>\n<h5 id=\"1- 跨平台＋动态更新\"><a href=\"#1- 跨平台＋动态更新\" class=\"headerlink\" title=\"1. 跨平台＋动态更新\"></a>1. 跨平台＋动态更新 </h5><p> 传统的客户端开发模式是怎样的呢？</p>\n<p>Android 与 iOS Team 分别编写客户端代码，打包，分发到 Play Store 和 Apple Store，通过更新 JSON 数据来更新页面。</p>\n<p>不过，当客户端发生严重问题而服务器上无法 quick fix 时，就不得不重新发版。</p>\n<p>对国外 Android 市场而言还好，因为能通过 Play Store 快速更新；国内 Android 市场则由于分发渠道太杂，很难及时把新版本立即推送给所有用户，当然这也是为何热修复技术在国内盛行而国外冷清的原因；而 Apple Store 则需要一定的审核时间，而且最近又在抓 iOS 热修复框架如 JsPatch、Rollout 等。</p>\n<p>相比而言，Hybrid 和 RN/Weex 模式除了能下发 Json 数据来刷新界面内容，更能直接下发业务逻辑代码，直接实现整体 App 的更新。而且，它们不用在乎 Android 和 iOS 两个平台，因为一份 JS 代码写好后，把 JS Bundle 放在服务器上，所有的客户端立即更新。</p>\n<h5 id=\"2- 代码复用\"><a href=\"#2- 代码复用\" class=\"headerlink\" title=\"2. 代码复用\"></a>2. 代码复用 </h5><p> 一般而言，同一款产品的 Android 和 iOS 两端除 UI 有些许不同外，多数业务逻辑几乎完全一致，这便造成了人力的浪费。</p>\n<p>而最近 Instagram 的官博 <a href=\"https://engineering.instagram.com/react-native-at-instagram-dd828a9a90c7#.ugk9ncjyz\" target=\"_blank\" rel=\"external\">React Native at Instagram</a> 一文中已经提到，利用 RN (React Native 缩写，下同) 开发的 feature 可以实现 <code>85% - 99%</code> 的代码复用率。这意味着我们可以用更少的人力成本来达到相同的效果。</p>\n<h5 id=\"3-RN-vs-Weex\"><a href=\"#3-RN-vs-Weex\" class=\"headerlink\" title=\"3. RN  vs Weex\"></a>3. RN  vs Weex</h5><p>实现上面的效果有两种开发框架：混合开发框架 Cordova 和基于 Javascript 的 React-Native、Weex 框架。</p>\n<p>下面我从自己的实践经验出发做些比较，也欢迎读者提出自己看法。</p>\n<p>最开始觉得 RN 的学习成本比较大，所以首先考虑了 <a href=\"https://github.com/alibaba/weex\" target=\"_blank\" rel=\"external\">Weex 框架</a>，据说是阿里巴巴良心出品。不过在尝试后不得不选择了放弃，原因有这几点：</p>\n<ul>\n<li>Bug 较多。我们最先测试了 <code> 最基本 </code> 的 ListView，在 iOS 运行良好，而同样的 Demo 代码到了 Android 这边的 <code> 下拉刷新 </code> 就出现了问题，这使得我们开始警惕；</li>\n<li>社区、文档弱，GitHub Issue 基本是中文。当然我毫无歧视中文之意。我认为，<strong>一套项目开源是真正意义是希望借助开源社区的力量，一起来完善改进，因此要优先推崇英文，使项目国际化，得到全世界开发者的共同支持，这样才是可持续的模式。</strong>而 Weex 的 <a href=\"https://github.com/alibaba/weex/issues\" target=\"_blank\" rel=\"external\">Issue</a> 里放眼望去基本 90% 都是中文，无论提问者还是 <strong> 项目维护者 </strong>。这一点直接把国外优秀的开发者拒之门外，也很难让我看到多么长远的未来。<br> 下面是摘取的 RN 里的一则中文 issue：</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/281665-fdd239b44898ea4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"**Issue is for bug report, not for Q&amp;A**\"></p>\n<ul>\n<li>Contributor 差别。因为上面一点，<a href=\"https://github.com/apache/incubator-weex/graphs/contributors\" target=\"_blank\" rel=\"external\">Weex 的 Contributor</a> 只有 91 个人，而 <a href=\"https://github.com/facebook/react-native/graphs/contributors\" target=\"_blank\" rel=\"external\">React-Native 的 Contributor</a> 有 1214 人。Contributor 是用来干嘛的？除了支持新功能，还有就是修复 bug 啊。Weex/RN 都是希望一统 Android + iOS 的，这么伟大的目标，这么艰巨的工程，不是几个人可以轻轻松松搞定的。 </li>\n<li>公司背景（来自 YY）。大家都知道 RN 来自 Facebook，Weex 来自阿里巴巴。如果想一窥它们的未来，需要先想一下这种技术对他们各自的意义。大家都清楚，Facebook、Google、Apple 是当今当之无愧的巨头，在移动互联网这波浪潮里，Google 掌握了 Android 法器，Apple 控制了 iOS 神器，Facebook 呢？并没有这些系统级入口。当然 Windows 的经历也让 Facebook 并不那么倾向去开发一个新的移动操作系统来竞争。那怎么办？React Native 应运而生，打出的口号就是： <strong>Learn once, write anywhere</strong>。什么意思，没错，就是明确告诉你学一次就可以同时开发两个平台了。这一点可一直都是移动端开发人员和创业公司的理想。有人说了，Apple 这么强势，RN 要是太嚣张，分分钟把你禁掉。这时我们就要来看看 RN 的 <a href=\"http://facebook.github.io/react-native/showcase.html\" target=\"_blank\" rel=\"external\">Showcase</a> 了，哪些 App 应用了 RN 呢？Facebook, Instagram, Airbnb, Walmart, QQ, 京东等，这回 Apple 要禁 RN 就要稍微掂量下这些大厂的意见吧。</li>\n</ul>\n<p>当然，我是很希望国内也能推出优质的开源项目来和国外大厂抗衡的，不过真正优质的大型开源项目往往除了开发者的个人能力，和公司的战略和制度关系也很大。</p>\n<h5 id=\"4-RN-vs-Hybrid\"><a href=\"#4-RN-vs-Hybrid\" class=\"headerlink\" title=\"4. RN vs Hybrid\"></a>4. RN vs Hybrid</h5><p>这里的 Hybrid 开发主要针对 Cordova 框架，其实在放弃 Weex 之后我们还是没考虑 RN，而是转过去了解 Cordova，不过做了大致了解后也放弃了。主要硬伤有两点：</p>\n<ul>\n<li>性能短板。大家知道 Hybrid 是基于 WebView 的，在 Android 上的性能缺陷非常明显；而 RN 是利用 JSCore 转化成 Native 运行的，性能相对而言好不少；</li>\n<li>用户体验。了解移动产品的人都知道用户体验的重要性，RN 的体验和原生的几乎没有差别，而 Webview 的实现是网页开发思路，体验会相差很大。</li>\n</ul>\n<p><strong>性能和用户体验是移动 App 的命根子。</strong></p>\n<p>因此，综合考虑下来，我们还是决定相信 Facebook 并采用 RN。</p>\n<h5 id=\"5-RN- 劣势\"><a href=\"#5-RN- 劣势\" class=\"headerlink\" title=\"5. RN 劣势\"></a>5. RN 劣势 </h5><p> 上面我提到了 RN 的一些优势，不过作为开发者更加需要明确其劣势，我总结了下大概有以下几点劣势：</p>\n<ul>\n<li>学习成本。Weex 的写法就是类似常规的 Html/JS，对于前端人员来说很容易上手，就算了非前端人员来说也花不了多久。而 RN 是在 React.js 上进行改进形成的一套语法，和常规前端差别较大，因此需要好几天的学习适应。当然我觉得优秀的程序员的基本素质之一就是能快速学习、练习并熟练一种新语言的。我个人的话大概花了两三天的时间已经能完成一套涵盖网络、JS 与 Native 通信的页面了，对于 React.js 语法也上手很快。</li>\n<li>安装包 Size。对于 iOS 而言影响不算很大，对于 Android 来说，我尝试后发现引入 RN 会给 apk 带来 6MB 左右的增幅，不过利用 <code>split apk</code> 的技术就能缩小到到 1MB 左右的增幅。</li>\n<li>首次加载耗时。大家知道 RN 需要从服务器下载 JS bundle，然后在本地转化成 Native code 运行的，所以在第一次打开 App 时需要花费一些时间进行下载和刷新。当然我们可以在发布 client 时内置一个写好的 js 文件在本地作缓存用。</li>\n</ul>\n<h3 id=\"二、React-Native- 运行机制\"><a href=\"# 二、React-Native- 运行机制\" class=\"headerlink\" title=\"二、React Native 运行机制\"></a>二、React Native 运行机制 </h3><p> 对于一个用 RN 搭建的移动 App，在启动后会从服务器下载最新的 JS Bundle 文件，然后由本地 JavascriptCore 引擎对 JS 文件进行解析，并利用 Bridge 映射到对应的 Native 方法和 UI 控件。得到的效果是：</p>\n<ol>\n<li>同样的 RN 代码，下发到 Android 和 iOS 不同平台中，会自动调用对应 Native 的 UI 控件，保证了各平台用户体验的连贯性；</li>\n<li>开发者就算是移动端小白，只要有 Web 基础，通过编写一套 RN 端代码就可以同时完成 Android 与 iOS App 的开发；</li>\n<li>由于可以利用 JS bundle 同时下发数据和业务逻辑，这意味着你可以像 Web 开发一样，实时迭代更新你的移动端 App，无需在了解各自平台的热修复技术；</li>\n<li>Native Modules，这是 RN 强大的一个扩展性，允许你通过简单的代码就能实现在 JS 里直接调用你自己的 Native 方法；</li>\n<li>Native Components，如果你自己实现了一些复杂的 Native UI 组件，而这些组件尚未被 RN 支持，你可以利用 Native Components 快速把原生组件引入到 RN 中并可以直接在 JS 里更新这些组件的状态。</li>\n</ol>\n<h3 id=\"三、RN- 开发环境搭建\"><a href=\"# 三、RN- 开发环境搭建\" class=\"headerlink\" title=\"三、RN 开发环境搭建\"></a>三、RN 开发环境搭建 </h3><p> 首先 IDE 方面，RN 推荐了一些工具：</p>\n<ul>\n<li><a href=\"https://nuclide.io/\" target=\"_blank\" rel=\"external\">Nuclide</a> 是 Facebook 内部用来开发 RN 的工具，Debug 功能强大。只不过这是一款 <a href=\"https://github.com/atom/atom\" target=\"_blank\" rel=\"external\">Atom</a> 的插件，意味着你必须先安装 Atom，再来安装这款开发插件；</li>\n<li><a href=\"https://www.decosoftware.com/\" target=\"_blank\" rel=\"external\">Deco</a> 是专为开发 RN 诞生的工具，可以快速搜索开源的第三方 RN 组件并直接插入到代码中，用 MacOS 的同学可以尝试下。我本人最开始也是试用这个，上手简单、小巧简洁。不足的是功能有点简单，无论是 Debug 功能还是代码检查之类的都不具备；</li>\n<li><a href=\"https://www.sublimetext.com/\" target=\"_blank\" rel=\"external\">Sublime</a> 可以通过第三方包来达到不错的开发效率，各方面还算可圈可点；</li>\n<li><a href=\"https://code.visualstudio.com/\" target=\"_blank\" rel=\"external\">Visual Studio</a> 这款也是蛮强大的 IDE，之前有用过的小伙伴可以试一下。</li>\n</ul>\n<p>本人的话目前采用的是 <code>Sublime</code>，因为个人常用 Sublime，而且第三方插件很丰富，轻量方便。下面简单说下配置，感兴趣的小伙伴可以看下。</p>\n<ol>\n<li><a href=\"https://packagecontrol.io/packages/Babel\" target=\"_blank\" rel=\"external\">Babel</a> 用来高亮 React JSX 语法，支持 ES6，而 React-Native 就是搭建在 <a href=\"https://facebook.github.io/react/\" target=\"_blank\" rel=\"external\">React.js</a> 基础上的；</li>\n<li><a href=\"https://github.com/Shrugs/react-native-snippets\" target=\"_blank\" rel=\"external\">React-Native-Snippets</a> 可以快速生成 RN 的一些模版代码；</li>\n<li><a href=\"http://eslint.cn/docs/user-guide/configuring\" target=\"_blank\" rel=\"external\">ESLint</a> 超级强大的 Lint 工具，支持 ES6、JSX 语法检查，而且还有 React 和 RN 的插件，比纯粹的 JSXHint/JSLint 都强大；</li>\n</ol>\n<p>当然，用 Atom 的小伙伴自然要首先考虑 <a href=\"https://nuclide.io/\" target=\"_blank\" rel=\"external\">Nuclide</a>。</p>\n<h3 id=\"四、引入 -React-Native\"><a href=\"# 四、引入 -React-Native\" class=\"headerlink\" title=\"四、引入 React Native\"></a>四、引入 React Native</h3><p>引入 RN 有两种方法：从零构建；集成到已有项目。</p>\n<h5 id=\"1-Build-from-Scratch\"><a href=\"#1-Build-from-Scratch\" class=\"headerlink\" title=\"1. Build from Scratch\"></a>1. Build from Scratch</h5><p>先说第一种，从零开始构建，比较简单，遵循官方文档 <a href=\"http://facebook.github.io/react-native/releases/0.42/docs/getting-started.html\" target=\"_blank\" rel=\"external\">Getting Started</a> 基于你自己的操作系统和平台一步步安装相关的依赖，然后利用如下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">react-native init AwesomeProject</div></pre></td></tr></table></figure></p>\n<p>你就创建好一个 RN 工程项目了，结构如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/281665-8691544719a34a57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"RN 目录结构\"></p>\n<p>里面有四个文件夹：</p>\n<ul>\n<li><code>android</code> / <code>ios</code>：各自存放了一个相关平台的工程 project，可以直接下拉 JS Bundle 并运行，对于移动端小白而言可以不用管里面的具体实现；</li>\n<li><code>node_modules</code>：里面是自动生成的 <code>node</code> 依赖之类的文件，通过读取 <code>package.json</code> 里的配置来生成；</li>\n<li><code>js</code>：这个文件夹最为重要，我们的开发都在这个文件夹里，把写好的 <code>js</code> 文件打包下发给 client 就会自动生效。</li>\n</ul>\n<h5 id=\"2- 集成到已有项目\"><a href=\"#2- 集成到已有项目\" class=\"headerlink\" title=\"2. 集成到已有项目\"></a>2. 集成到已有项目 </h5><p> 有很多公司是希望在现有 App 的基础上集成 <code>RN</code> 来开发一些特定的 Feature，这种情况就不能参考上面的方法了。在 RN 的官方文档里有一节 <a href=\"http://facebook.github.io/react-native/releases/0.42/docs/integration-with-existing-apps.html\" target=\"_blank\" rel=\"external\">Integration with Existing Apps</a> , 只需要按照一步步做即可。</p>\n<p>以 Android 为例，大概要做以下几步：</p>\n<ol>\n<li>添加 <code>gradle</code> 依赖：<code>compile &quot;com.facebook.react:react-native:+&quot; // From node_modules.</code>；</li>\n<li>创建空的 <code>Activity</code> ，指定 <code>JS bundle</code> 和入口 <code>Component</code> 名字即会自动在这个 <code>Activity</code> 里去加载 <code>JS bundle</code> 文件；</li>\n<li>在 Activity 里监听 onBackPressed 事件，用来与 JS 端协作处理返回键点击事件。</li>\n<li>启动 server，运行 App 即可。</li>\n</ol>\n<p>总之需要说明的是，即使是移动端小白，也可以遵循文档里的指示完成这一步。接下来的大部分时间只要关心 JS 端开发就行了。</p>\n<h3 id=\"五、Javascript、React- 及 -ES6、JSX- 语法\"><a href=\"# 五、Javascript、React- 及 -ES6、JSX- 语法\" class=\"headerlink\" title=\"五、Javascript、React 及 ES6、JSX 语法\"></a>五、Javascript、React 及 ES6、JSX 语法 </h3><p> 我们知道 RN 采用了 React 和 ES6 的语法，所以我们必须先对这些语法有一定了解才能去读 RN 的代码。</p>\n<p>关于 <code>Javascript</code>，我推荐 W3School 里的 <a href=\"http://www.w3school.com.cn/js/\" target=\"_blank\" rel=\"external\">JS 语法</a> 和 MDN 里的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript\" target=\"_blank\" rel=\"external\">JS 手册</a>，大家只要对一些基础语法做些了解就可以。</p>\n<p>关于 <code>React</code>，我推荐 <a href=\"http://www.ruanyifeng.com/\" target=\"_blank\" rel=\"external\">阮一峰</a> 写的 <a href=\"http://www.ruanyifeng.com/blog/2015/03/react.html\" target=\"_blank\" rel=\"external\">React 入门实例教程</a>，基本上把文章读一遍，再自己动手写一遍，就能理会到 React 的大致用法了。</p>\n<p>关于 <code>ES6</code>、<code>ES7</code>、<code>JSX</code>等，感兴趣的可以看一下 RN 文档中 <a href=\"http://facebook.github.io/react-native/releases/0.42/docs/javascript-environment.html\" target=\"_blank\" rel=\"external\">Javascript Environment</a> 里提到的支持的方法，需要时再来查询也可以。也可以看 <code>Babel</code> 出的 <a href=\"https://babeljs.io/learn-es2015/\" target=\"_blank\" rel=\"external\">Learn ES2015 手册</a>。</p>\n<p>这里有一个很不错的 GitHub 项目，帮助你通过交互性的例子来快速上手语法知识：<a href=\"http://www.reactnativeexpress.com/\" target=\"_blank\" rel=\"external\">React Native Express</a>。</p>\n<h3 id=\"六、UI- 层\"><a href=\"# 六、UI- 层\" class=\"headerlink\" title=\"六、UI 层\"></a>六、UI 层 </h3><p> 简单熟悉了 <code>React</code> 语法后，基本能正常阅读 RN 的示例代码了。</p>\n<p>正式开发 App 的第一步当然就是写 UI 界面了，由于 RN 已经封装好了一套 JS 的 UI 组件，这些组件会自动在 Android/iOS 端调用对应的原生 UI 组件，因此我们只需要熟悉这些 UI 组件的用法及属性、回调方法即可。</p>\n<p>我们可以在文档的 <a href=\"http://facebook.github.io/react-native/releases/0.42/docs/getting-started.html\" target=\"_blank\" rel=\"external\">Components</a> 看到不少组件，比如<code>View, Text, Button, Image, Switch</code>, 还有我们用的最多的 <code>ScrollView</code> 和 <code>ListView</code>。</p>\n<p>在读文档时，我们可以先通过一边写代码一边读文档的方式进行，RN 非常贴心，直接在 Web 里嵌入了模拟器，我们只要修改编辑框里的代码，立即就能在右边的模拟器看到效果。这极大的降低了我们的学习成本。<br><img src=\"http://upload-images.jianshu.io/upload_images/281665-09965625af9b3a49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Text Component\"></p>\n<p>另外，在学习一个组件时，我们要区分哪个属性是某个平台特有的。比如下面两个 Text 的属性：<code>textBreakStrategy</code> 只会在 Android 上生效，而 <code>adjustsFontSizeToFit</code> 只可以用在 iOS 上。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/281665-c8f4990d8334f3ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Platform Specific Properties\"></p>\n<p>然后，如果你希望在 Android 和 iOS 里显示不同的内容怎么办呢？RN 里有一节是<a href=\"http://facebook.github.io/react-native/releases/0.42/docs/platform-specific-code.html\" target=\"_blank\" rel=\"external\">Platform Specific Code</a>，可以有如下几种形式来进行区分：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (Platform.OS === &apos;ios&apos;) &#123;</div><div class=\"line\">  // stuff for ios</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">  // stuff for android</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>除此之外，UI 组件的用法学习就很类似常规的 Html 标签了，只要知道其使用方式即可，甚至需要用的时候再来查文档也行。</p>\n<h3 id=\"七、网络请求层\"><a href=\"# 七、网络请求层\" class=\"headerlink\" title=\"七、网络请求层\"></a>七、网络请求层 </h3><p> 学完上面的我们已经能够写出 UI 界面了，而且这套界面已经能够在不同平台上转化成各自平台的 Native UI 了。然后，我们就需要去网络层请求真实数据了。</p>\n<p>RN 里提供了 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\" target=\"_blank\" rel=\"external\">Fetch API</a> 来进行实现。举个例子，你想要通过 GET 方法去请求数据并转化成 JSON，可以通过如下代码实现：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">fetch(&apos;https://facebook.github.io/react-native/movies.json&apos;)</div><div class=\"line\">      .then((response) =&gt; response.json())</div><div class=\"line\">      .then((responseJson) =&gt; &#123;</div><div class=\"line\">        return responseJson.movies;</div><div class=\"line\">      &#125;)</div><div class=\"line\">      .catch((error) =&gt; &#123;</div><div class=\"line\">        console.error(error);</div><div class=\"line\">      &#125;);</div></pre></td></tr></table></figure></p>\n<p>熟悉 Reactive 编程的伙伴应该对这样的语法不陌生，比如 Android 上的 <a href=\"https://github.com/ReactiveX/RxJava\" target=\"_blank\" rel=\"external\">RxJava</a>； iOS 上的 <a href=\"https://github.com/ReactiveX/RxSwift\" target=\"_blank\" rel=\"external\">RxSwift</a>；Web 上的 <a href=\"https://github.com/Reactive-Extensions/RxJS\" target=\"_blank\" rel=\"external\">RxJS</a>。上面 function 的功能就是：请求网址 <code>https://facebook.github.io/react-native/movies.json</code>，把返回的 Response 转化成 JSON object，取出 JSON object 里的 <code>movies</code> 字段。同时，如果发生 error 会被 catch 住。</p>\n<p>当然，上面是最基本的 GET 请求，Fetch API 还支持自定义 Headers，更换 Method，添加 Body 等。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">fetch(&apos;https://mywebsite.com/endpoint/&apos;, &#123;</div><div class=\"line\">  method: &apos;POST&apos;,</div><div class=\"line\">  headers: &#123;</div><div class=\"line\">    &apos;Accept&apos;: &apos;application/json&apos;,</div><div class=\"line\">    &apos;Content-Type&apos;: &apos;application/json&apos;,</div><div class=\"line\">  &#125;,</div><div class=\"line\">  body: JSON.stringify(&#123;</div><div class=\"line\">    firstParam: &apos;yourValue&apos;,</div><div class=\"line\">    secondParam: &apos;yourOtherValue&apos;,</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>上面构建了一个基本的 POST 请求，添加了自己的 Headers:<code>Accept</code>和<code>Content-Type</code>，添加了 Body。</p>\n<p>因此看下来，RN 里的网络请求不仅具备了 Reactive 编程的简洁，也能自定义常规的 Http 请求，写法简单。</p>\n<p>除了 Fetch API 之外，RN 还内置了 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\" target=\"_blank\" rel=\"external\">XMLHttpRequest API(俗称 AJAX)</a>，而且支持<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\" target=\"_blank\" rel=\"external\">TCP 全双工通信方式 WebSocket</a>。</p>\n<h3 id=\"八、Debugging- 调试\"><a href=\"# 八、Debugging- 调试\" class=\"headerlink\" title=\"八、Debugging 调试\"></a>八、Debugging 调试 </h3><p> 调试是很多程序员非常关注的一个环节，因为 RN 是用 JS 写完后到 Native 解释成 Native 方法来执行的，因此如果能快速调试 JS 代码是非常重要的一环。</p>\n<p>最开始 RN 的调试功能比较弱，不过现在的 Debugging 功能在我看来还是很不错的。一般来讲可以有以下几个调试方式：</p>\n<p>#####1. In-App 报错<br>RN 里默认集成了 In-App 的错误提示方式，即在 App 运行过程中会弹出全屏的报错信息呈现给你，而你也可以通过阅读具体的错误信息快速找到错误原因。通过点击这个错误信息里的某一行，会立即自动打开对应的代码。<br><img src=\"http://upload-images.jianshu.io/upload_images/281665-6531d24c41982690.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"In-App Error\"></p>\n<p>#####2. Console.log<br>在开发 Client 时，我们一般都会用 <code>Log.log()</code> 来打印一些运行时变量的值，然后实时查看打印出来的 log 来调试，在 RN 也一样，你只要在 JS 里写一句 <code>console.log(&#39;this is log data&#39;)</code>，就会自动在 Client 的常规 log 里能看到，比如 Android 的 <code>adb logcat</code> 里就会自动打印出 <code>&#39;this is log data&#39;</code> 一行。</p>\n<p>#####3. 大杀器：Chrome 逐行调试 <br> 这个杀器的最牛逼之处就是可以像 Client 一样，逐行调试代码！</p>\n<p>我们来看下面一张图。从左往右。先是文件目录，我们选中了 <code>index.js</code> 文件夹，然后第二个 Tab，是 <code>index.js</code> 的内容。这里关键的是我可以直接选中某一行代码设断点。当 Client 运行到这一行时，就会在第三个 Tab 里打印出运行时环境及变量。我们可以看到 <code>props</code> 里就有我们传进去的变量值。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/281665-d2fb4470d8ae27b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Chrome Debug\"></p>\n<p>有了以上几种调试方式，我们几乎可以和常规的 Native 开发一样来调试 RN 代码了，不得不说 RN Team 确实牛 x 啊！</p>\n<h3 id=\"九、从 -JS- 调用 -Native- 方法或显示自定义 -Native-View\"><a href=\"# 九、从 -JS- 调用 -Native- 方法或显示自定义 -Native-View\" class=\"headerlink\" title=\"九、从 JS 调用 Native 方法或显示自定义 Native View\"></a>九、从 JS 调用 Native 方法或显示自定义 Native View</h3><p>这又是另一个牛 x 之处啊。</p>\n<p>很多人觉得 RN 限制太多，只能支持有限的 View 组件和有限的方法，难以发挥 Client 的最大性能。简单点说，在 Client 可以绘制复杂的 View，可以调用高性能 C++ 等底层代码，但 RN 却做不到。</p>\n<p>于是，RN 里提出了 <code>Native Modules</code> 和 <code>Native UI Component</code> 两种技术。</p>\n<p>#####Native Modules：JS 里直接调用 Native(Java/Swift) 方法 <br> 所谓 Native Modules，就是自己在 Client 写好了某些方法，由于某些原因这些方法不太方便或者无法搬到 RN 里面，那么，我们可以在 Client 把这些方法暴露出来给 RN，然后在 JS 里可以像 import 普通的 module 一样把这些 Native Modules 引入进去，直接调用。</p>\n<p>具体的实现方法可以参考文档 <a href=\"http://facebook.github.io/react-native/releases/0.42/docs/native-modules-ios.html\" target=\"_blank\" rel=\"external\">iOS Native Modules</a> 和 <a href=\"http://facebook.github.io/react-native/releases/0.42/docs/native-modules-android.html\" target=\"_blank\" rel=\"external\">Android Native Modules</a>。</p>\n<p>#####Native UI Component：JS 里直接调用自定义的 Native View<br>很多时候我们在写 Client 时，为了实现 Designer 天马行空的设计，常常需要自定义 View，即自己绘制某些系统并不提供的特定 UI。可想而知，这些 View 肯定不会出现在 RN 的 UI Component 里。</p>\n<p>那么，我们就需要首先在 Native 层自己写好一个自定义 View，然后利用<code>Native UI Component</code> 技术把这个 View 及其中某些 public 方法暴露给 RN，那么 RN 就能直接 import 进来并显示了。</p>\n<p>具体的实现方法可以参考文档 <a href=\"http://facebook.github.io/react-native/releases/0.42/docs/native-components-ios.html\" target=\"_blank\" rel=\"external\">iOS Native UI Component</a> 和 <a href=\"http://facebook.github.io/react-native/releases/0.42/docs/native-components-android.html\" target=\"_blank\" rel=\"external\">Android Native UI Component</a>。</p>\n<p><strong>如果读过文档不是很理解的小伙伴可以留言，我再 post 一些 demo 代码上来</strong></p>\n<h3 id=\"十、React-Native- 适合你吗？\"><a href=\"# 十、React-Native- 适合你吗？\" class=\"headerlink\" title=\"十、React Native 适合你吗？\"></a>十、React Native 适合你吗？</h3><p>这里借鉴下前段时间旧金山的 React Native 会议上的一些优劣总结给读者以参考。当然不一定对，仅供参考。</p>\n<p>RN 的优点：</p>\n<ul>\n<li>跨平台</li>\n<li>原生的用户体验</li>\n<li>开发者体验好</li>\n<li>动态更新代码逻辑</li>\n<li>社区强大</li>\n<li>有个好爹</li>\n</ul>\n<p>RN 的缺点：</p>\n<ul>\n<li>不够成熟</li>\n<li>不够稳定</li>\n<li>生态系统在搭建中</li>\n<li>优质的 App 需要时间打磨</li>\n<li>偶尔需要写 Native 代码(也就是 JS + Swift + Java)</li>\n</ul>\n<p>适合下面这些人 / 公司：</p>\n<ul>\n<li>你对 JS/React 有一定了解</li>\n<li>Web 开发人员比 Mobile 开发人员多</li>\n<li>有意愿投资精力给 RN</li>\n<li>App 设计不是特别区分 Android 和 iOS</li>\n<li>希望热更新</li>\n</ul>\n<p>下面这些人要稍微考虑下：</p>\n<ul>\n<li>完全不了解 JS/React</li>\n<li>已经有现成的 Android/iOS team</li>\n<li>App 设计严格遵守 Android、iOS 各自设计规范</li>\n<li>不想要投入时间／金钱给 RN</li>\n</ul>\n<h3 id=\"十一、为什么要写这篇文章\"><a href=\"# 十一、为什么要写这篇文章\" class=\"headerlink\" title=\"十一、为什么要写这篇文章\"></a>十一、为什么要写这篇文章 </h3><p> 几个月前我对 React Native 也非常不看好，当然现在也没有说非常看好。或者说，写这篇文章毫无为 React Native 布道之意。</p>\n<p>接触 React Native 主要是因为业务需要，PM 希望能够随时改动某块变化较大的模块，常规的开发提交流程往往需要较长的时间，而热修复技术本身并未得到 Google 和 Apple 的官方认可，也就是随时可能因破坏生态安全之名被取缔。</p>\n<p>因此才考虑去了解 Hybrid 开发和 JS Native 开发模式，在了解过程中，又由于性能差、用户体验不好而放弃 Hybrid，由于社区不完善、Bug 较多等原因放弃 Weex，最终才选择了 React Native，开始学习 React、JSX 等语法。</p>\n<p>目前使用下来对 React Native 的一些个人感受：</p>\n<ol>\n<li>学习门槛并没有开始想象那么高。大概只花了两三天时间就熟悉了 Javascript、React 框架、JSX 语法，然后就开始着手业务开发。</li>\n<li>对 Android App 的影响。React Native 会给 Android 端带来 <code>6MB</code> 左右的 size 增幅，不过在采用了 <code>split apk</code> 后就只有 <code>1MB</code> 左右增幅。</li>\n<li>Debug 功能比较完善，至少不用担心发生问题后不知从哪下手。</li>\n<li>性能还行。最初担心的是 React Native 性能不好，但自己上手后，并没有明显感觉到很明显的 React Native 对 App 性能的负面影响，无论是 iOS 还是 Android，当然，这一点还在继续考察中。</li>\n<li>动态部署真的很不错。以前每次写好代码都要花不少时间来编译运行，而现在只要写一份代码，就可以同时在 Android 和 iOS 实时更新了，这无疑节省了生命。</li>\n<li>有待完善。当然，React Native 中确实还存在着不少问题，生态系统也还不够完善。不过我相信，这只是时间问题。</li>\n</ol>\n<p>关于 React Native 一直以来都有很多争议。</p>\n<p>不过我想说的是，<strong>React Native 所代表的跨平台、动态更新技术已经引起了全世界开发者关注，而且这种技术势必会是未来的需求和潮流。React Native 不一定会成功，但至少目前 React Native 已经是这一领域的领跑者。</strong></p>\n<p>而写这篇文章的目的，就是希望告诉更多开发者，<strong>React Native 并不完美，但值得一试。</strong></p>\n<p>谢谢。</p>\n<p>wingjay</p>\n<p><a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\">我的 Github</a>: <a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\">https://github.com/wingjay</a><br><a href=\"http://weibo.com/u/1625892654\" target=\"_blank\" rel=\"external\">微博 iam_wingjay</a>: <a href=\"http://weibo.com/u/1625892654\" target=\"_blank\" rel=\"external\">http://weibo.com/u/1625892654</a></p>\n<p>如果有问题，可以给我留言或发邮件<a href=\"&#109;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#x79;&#105;&#110;&#x6a;&#105;&#x65;&#115;&#x68;&#x40;&#x31;&#x32;&#x36;&#x2e;&#x63;&#x6f;&#109;\">&#x79;&#105;&#110;&#x6a;&#105;&#x65;&#115;&#x68;&#x40;&#x31;&#x32;&#x36;&#x2e;&#x63;&#x6f;&#109;</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>React Native 所代表的跨平台、动态更新技术已经引起了全世界开发者关注，而且这种技术势必会是未来的需求和潮流。React Native 不一定会成功，但至少目前 React Native 已经是这一领域的领跑者。</p>\n</blockquote>","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>React Native 诞生于 2015 年，名副其实的富二代，主要使命是为父出征，与 Apple 和 Google 抗衡，为开发者带去一套跨平台、动态更新的 Javascript 框架，口号是：Learn once, write anywhere：Build mobile apps with React。在试图推翻 Android 和 iOS 压制的同时，还提携了一把自家兄弟：React。</p>\n<p>从诞生之日 React Native 就充满了期待和争议。期待是无数开发者希望不用忍受频繁发版的噩梦，也不用同时为两个平台开发业务逻辑几无差别的两个 App；争议是 React Native 真的能以一己之力救大众于水火吗？React Native 在跨平台时还能保持良好的用户体验吗？</p>\n<p>当然我们知道，这种问题向来都是仁者见仁，智者见智。比起一味的疑惑、争论，还不如来好好看看这货究竟是个啥？甚至自己动手来玩一把。</p>\n<p>本文主要针对两类读者：</p>\n<ul>\n<li>想要入门 RN 的人，在阅读官方文档前先对 RN 形成一个整体的印象</li>\n<li>对 RN 心存好奇，在犹豫是否要入坑的开发者，可以通过本文对 RN 更客观全面的认识</li>\n</ul>\n<h3 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h3><ul>\n<li>React Native 好在哪<ul>\n<li>跨平台＋动态更新</li>\n<li>代码复用</li>\n<li>RN vs Weex</li>\n<li>RN vs Hybrid</li>\n<li>RN 劣势</li>\n</ul>\n</li>\n<li>React Native 运行机制</li>\n<li>RN 开发环境搭建</li>\n<li>引入 React Native<ul>\n<li>Build from Scratch</li>\n<li>集成到已有项目</li>\n</ul>\n</li>\n<li>Javascript、React 及 ES6、JSX 语法</li>\n<li>UI 层</li>\n<li>网络请求层</li>\n<li>Debugging 调试<ul>\n<li>In-App 报错</li>\n<li>Console.log</li>\n<li>大杀器：Chrome 逐行调试</li>\n</ul>\n</li>\n<li>从 JS 调用 Native 方法或显示自定义 Native View<ul>\n<li>Native Modules：JS 里直接调用 Native(Java/Swift) 方法</li>\n<li>Native UI Component：JS 里直接调用自定义的 Native View</li>\n</ul>\n</li>\n<li>React Native 适合你吗？</li>\n<li>为什么要写这篇文章</li>\n</ul>\n<h3 id=\"React-Native-好在哪\"><a href=\"#React-Native-好在哪\" class=\"headerlink\" title=\"React Native 好在哪\"></a>React Native 好在哪</h3><p>下面我们来看下 Hybrid 及 React Native 等开发模式包含了哪些常规移动开发所不具备的优势。</p>\n<h5 id=\"1-跨平台＋动态更新\"><a href=\"#1-跨平台＋动态更新\" class=\"headerlink\" title=\"1. 跨平台＋动态更新\"></a>1. 跨平台＋动态更新</h5><p>传统的客户端开发模式是怎样的呢？</p>\n<p>Android 与 iOS Team 分别编写客户端代码，打包，分发到 Play Store 和 Apple Store，通过更新 JSON 数据来更新页面。</p>\n<p>不过，当客户端发生严重问题而服务器上无法 quick fix 时，就不得不重新发版。</p>\n<p>对国外 Android 市场而言还好，因为能通过 Play Store 快速更新；国内 Android 市场则由于分发渠道太杂，很难及时把新版本立即推送给所有用户，当然这也是为何热修复技术在国内盛行而国外冷清的原因；而 Apple Store 则需要一定的审核时间，而且最近又在抓 iOS 热修复框架如 JsPatch、Rollout 等。</p>\n<p>相比而言，Hybrid 和 RN/Weex 模式除了能下发 Json 数据来刷新界面内容，更能直接下发业务逻辑代码，直接实现整体 App 的更新。而且，它们不用在乎 Android 和 iOS 两个平台，因为一份 JS 代码写好后，把 JS Bundle 放在服务器上，所有的客户端立即更新。</p>\n<h5 id=\"2-代码复用\"><a href=\"#2-代码复用\" class=\"headerlink\" title=\"2. 代码复用\"></a>2. 代码复用</h5><p>一般而言，同一款产品的 Android 和 iOS 两端除 UI 有些许不同外，多数业务逻辑几乎完全一致，这便造成了人力的浪费。</p>\n<p>而最近 Instagram 的官博 <a href=\"https://engineering.instagram.com/react-native-at-instagram-dd828a9a90c7#.ugk9ncjyz\" target=\"_blank\" rel=\"external\">React Native at Instagram</a> 一文中已经提到，利用 RN (React Native 缩写，下同) 开发的 feature 可以实现 <code>85% - 99%</code> 的代码复用率。这意味着我们可以用更少的人力成本来达到相同的效果。</p>\n<h5 id=\"3-RN-vs-Weex\"><a href=\"#3-RN-vs-Weex\" class=\"headerlink\" title=\"3. RN  vs Weex\"></a>3. RN  vs Weex</h5><p>实现上面的效果有两种开发框架：混合开发框架 Cordova 和基于 Javascript 的 React-Native、Weex 框架。</p>\n<p>下面我从自己的实践经验出发做些比较，也欢迎读者提出自己看法。</p>\n<p>最开始觉得 RN 的学习成本比较大，所以首先考虑了 <a href=\"https://github.com/alibaba/weex\" target=\"_blank\" rel=\"external\">Weex 框架</a>，据说是阿里巴巴良心出品。不过在尝试后不得不选择了放弃，原因有这几点：</p>\n<ul>\n<li>Bug 较多。我们最先测试了<code>最基本</code>的 ListView，在 iOS 运行良好，而同样的 Demo 代码到了 Android 这边的<code>下拉刷新</code>就出现了问题，这使得我们开始警惕；</li>\n<li>社区、文档弱，GitHub Issue 基本是中文。当然我毫无歧视中文之意。我认为，<strong>一套项目开源是真正意义是希望借助开源社区的力量，一起来完善改进，因此要优先推崇英文，使项目国际化，得到全世界开发者的共同支持，这样才是可持续的模式。</strong>而 Weex 的 <a href=\"https://github.com/alibaba/weex/issues\" target=\"_blank\" rel=\"external\">Issue</a> 里放眼望去基本 90% 都是中文，无论提问者还是<strong>项目维护者</strong>。这一点直接把国外优秀的开发者拒之门外，也很难让我看到多么长远的未来。<br>下面是摘取的 RN 里的一则中文 issue：</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/281665-fdd239b44898ea4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"**Issue is for bug report, not for Q&amp;A**\"></p>\n<ul>\n<li>Contributor 差别。因为上面一点，<a href=\"https://github.com/apache/incubator-weex/graphs/contributors\" target=\"_blank\" rel=\"external\">Weex 的 Contributor</a> 只有 91 个人，而 <a href=\"https://github.com/facebook/react-native/graphs/contributors\" target=\"_blank\" rel=\"external\">React-Native 的 Contributor</a> 有 1214 人。Contributor 是用来干嘛的？除了支持新功能，还有就是修复 bug 啊。Weex/RN 都是希望一统 Android + iOS 的，这么伟大的目标，这么艰巨的工程，不是几个人可以轻轻松松搞定的。 </li>\n<li>公司背景（来自YY）。大家都知道 RN 来自 Facebook，Weex 来自阿里巴巴。如果想一窥它们的未来，需要先想一下这种技术对他们各自的意义。大家都清楚，Facebook、Google、Apple 是当今当之无愧的巨头，在移动互联网这波浪潮里，Google 掌握了 Android 法器，Apple 控制了 iOS 神器，Facebook 呢？并没有这些系统级入口。当然 Windows 的经历也让 Facebook 并不那么倾向去开发一个新的移动操作系统来竞争。那怎么办？React Native 应运而生，打出的口号就是： <strong>Learn once, write anywhere</strong>。什么意思，没错，就是明确告诉你学一次就可以同时开发两个平台了。这一点可一直都是移动端开发人员和创业公司的理想。有人说了，Apple 这么强势，RN 要是太嚣张，分分钟把你禁掉。这时我们就要来看看 RN 的 <a href=\"http://facebook.github.io/react-native/showcase.html\" target=\"_blank\" rel=\"external\">Showcase</a> 了，哪些 App 应用了 RN 呢？Facebook, Instagram, Airbnb, Walmart, QQ, 京东等，这回 Apple 要禁 RN 就要稍微掂量下这些大厂的意见吧。</li>\n</ul>\n<p>当然，我是很希望国内也能推出优质的开源项目来和国外大厂抗衡的，不过真正优质的大型开源项目往往除了开发者的个人能力，和公司的战略和制度关系也很大。</p>\n<h5 id=\"4-RN-vs-Hybrid\"><a href=\"#4-RN-vs-Hybrid\" class=\"headerlink\" title=\"4. RN vs Hybrid\"></a>4. RN vs Hybrid</h5><p>这里的 Hybrid 开发主要针对 Cordova 框架，其实在放弃 Weex 之后我们还是没考虑 RN，而是转过去了解 Cordova，不过做了大致了解后也放弃了。主要硬伤有两点：</p>\n<ul>\n<li>性能短板。大家知道 Hybrid 是基于 WebView 的，在 Android 上的性能缺陷非常明显；而 RN 是利用 JSCore 转化成 Native 运行的，性能相对而言好不少；</li>\n<li>用户体验。了解移动产品的人都知道用户体验的重要性，RN 的体验和原生的几乎没有差别，而 Webview 的实现是网页开发思路，体验会相差很大。</li>\n</ul>\n<p><strong>性能和用户体验是移动 App 的命根子。</strong></p>\n<p>因此，综合考虑下来，我们还是决定相信 Facebook 并采用 RN。</p>\n<h5 id=\"5-RN-劣势\"><a href=\"#5-RN-劣势\" class=\"headerlink\" title=\"5. RN 劣势\"></a>5. RN 劣势</h5><p>上面我提到了 RN 的一些优势，不过作为开发者更加需要明确其劣势，我总结了下大概有以下几点劣势：</p>\n<ul>\n<li>学习成本。Weex 的写法就是类似常规的 Html/JS，对于前端人员来说很容易上手，就算了非前端人员来说也花不了多久。而 RN 是在 React.js 上进行改进形成的一套语法，和常规前端差别较大，因此需要好几天的学习适应。当然我觉得优秀的程序员的基本素质之一就是能快速学习、练习并熟练一种新语言的。我个人的话大概花了两三天的时间已经能完成一套涵盖网络、JS与Native通信的页面了，对于 React.js 语法也上手很快。</li>\n<li>安装包 Size。对于 iOS 而言影响不算很大，对于 Android 来说，我尝试后发现引入 RN 会给 apk 带来 6MB 左右的增幅，不过利用 <code>split apk</code> 的技术就能缩小到到 1MB 左右的增幅。</li>\n<li>首次加载耗时。大家知道 RN 需要从服务器下载 JS bundle，然后在本地转化成 Native code 运行的，所以在第一次打开 App 时需要花费一些时间进行下载和刷新。当然我们可以在发布 client 时内置一个写好的 js 文件在本地作缓存用。</li>\n</ul>\n<h3 id=\"二、React-Native-运行机制\"><a href=\"#二、React-Native-运行机制\" class=\"headerlink\" title=\"二、React Native 运行机制\"></a>二、React Native 运行机制</h3><p>对于一个用 RN 搭建的移动 App，在启动后会从服务器下载最新的 JS Bundle 文件，然后由本地 JavascriptCore 引擎对 JS 文件进行解析，并利用 Bridge 映射到对应的 Native 方法和 UI 控件。得到的效果是：</p>\n<ol>\n<li>同样的 RN 代码，下发到 Android 和 iOS 不同平台中，会自动调用对应 Native 的 UI 控件，保证了各平台用户体验的连贯性；</li>\n<li>开发者就算是移动端小白，只要有 Web 基础，通过编写一套 RN 端代码就可以同时完成 Android 与 iOS App 的开发；</li>\n<li>由于可以利用 JS bundle 同时下发数据和业务逻辑，这意味着你可以像 Web 开发一样，实时迭代更新你的移动端 App，无需在了解各自平台的热修复技术；</li>\n<li>Native Modules，这是 RN 强大的一个扩展性，允许你通过简单的代码就能实现在 JS 里直接调用你自己的 Native 方法；</li>\n<li>Native Components，如果你自己实现了一些复杂的 Native UI 组件，而这些组件尚未被 RN 支持，你可以利用 Native Components 快速把原生组件引入到 RN 中并可以直接在 JS 里更新这些组件的状态。</li>\n</ol>\n<h3 id=\"三、RN-开发环境搭建\"><a href=\"#三、RN-开发环境搭建\" class=\"headerlink\" title=\"三、RN 开发环境搭建\"></a>三、RN 开发环境搭建</h3><p>首先 IDE 方面，RN 推荐了一些工具：</p>\n<ul>\n<li><a href=\"https://nuclide.io/\" target=\"_blank\" rel=\"external\">Nuclide</a> 是 Facebook 内部用来开发 RN 的工具，Debug 功能强大。只不过这是一款 <a href=\"https://github.com/atom/atom\" target=\"_blank\" rel=\"external\">Atom</a> 的插件，意味着你必须先安装 Atom，再来安装这款开发插件；</li>\n<li><a href=\"https://www.decosoftware.com/\" target=\"_blank\" rel=\"external\">Deco</a> 是专为开发 RN 诞生的工具，可以快速搜索开源的第三方 RN 组件并直接插入到代码中，用 MacOS 的同学可以尝试下。我本人最开始也是试用这个，上手简单、小巧简洁。不足的是功能有点简单，无论是 Debug 功能还是代码检查之类的都不具备；</li>\n<li><a href=\"https://www.sublimetext.com/\" target=\"_blank\" rel=\"external\">Sublime</a> 可以通过第三方包来达到不错的开发效率，各方面还算可圈可点；</li>\n<li><a href=\"https://code.visualstudio.com/\" target=\"_blank\" rel=\"external\">Visual Studio</a> 这款也是蛮强大的 IDE，之前有用过的小伙伴可以试一下。</li>\n</ul>\n<p>本人的话目前采用的是 <code>Sublime</code>，因为个人常用 Sublime，而且第三方插件很丰富，轻量方便。下面简单说下配置，感兴趣的小伙伴可以看下。</p>\n<ol>\n<li><a href=\"https://packagecontrol.io/packages/Babel\" target=\"_blank\" rel=\"external\">Babel</a> 用来高亮 React JSX 语法，支持 ES6，而 React-Native 就是搭建在 <a href=\"https://facebook.github.io/react/\" target=\"_blank\" rel=\"external\">React.js</a> 基础上的；</li>\n<li><a href=\"https://github.com/Shrugs/react-native-snippets\" target=\"_blank\" rel=\"external\">React-Native-Snippets</a> 可以快速生成 RN 的一些模版代码；</li>\n<li><a href=\"http://eslint.cn/docs/user-guide/configuring\" target=\"_blank\" rel=\"external\">ESLint</a> 超级强大的 Lint 工具，支持 ES6、JSX 语法检查，而且还有 React 和 RN 的插件，比纯粹的 JSXHint/JSLint 都强大；</li>\n</ol>\n<p>当然，用 Atom 的小伙伴自然要首先考虑 <a href=\"https://nuclide.io/\" target=\"_blank\" rel=\"external\">Nuclide</a>。</p>\n<h3 id=\"四、引入-React-Native\"><a href=\"#四、引入-React-Native\" class=\"headerlink\" title=\"四、引入 React Native\"></a>四、引入 React Native</h3><p>引入 RN 有两种方法：从零构建；集成到已有项目。</p>\n<h5 id=\"1-Build-from-Scratch\"><a href=\"#1-Build-from-Scratch\" class=\"headerlink\" title=\"1. Build from Scratch\"></a>1. Build from Scratch</h5><p>先说第一种，从零开始构建，比较简单，遵循官方文档 <a href=\"http://facebook.github.io/react-native/releases/0.42/docs/getting-started.html\" target=\"_blank\" rel=\"external\">Getting Started</a> 基于你自己的操作系统和平台一步步安装相关的依赖，然后利用如下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">react-native init AwesomeProject</div></pre></td></tr></table></figure></p>\n<p>你就创建好一个 RN 工程项目了，结构如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/281665-8691544719a34a57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"RN 目录结构\"></p>\n<p>里面有四个文件夹：</p>\n<ul>\n<li><code>android</code> / <code>ios</code>：各自存放了一个相关平台的工程 project，可以直接下拉 JS Bundle 并运行，对于移动端小白而言可以不用管里面的具体实现；</li>\n<li><code>node_modules</code>：里面是自动生成的 <code>node</code> 依赖之类的文件，通过读取 <code>package.json</code> 里的配置来生成；</li>\n<li><code>js</code>：这个文件夹最为重要，我们的开发都在这个文件夹里，把写好的 <code>js</code> 文件打包下发给 client 就会自动生效。</li>\n</ul>\n<h5 id=\"2-集成到已有项目\"><a href=\"#2-集成到已有项目\" class=\"headerlink\" title=\"2. 集成到已有项目\"></a>2. 集成到已有项目</h5><p>有很多公司是希望在现有 App 的基础上集成 <code>RN</code> 来开发一些特定的 Feature，这种情况就不能参考上面的方法了。在 RN 的官方文档里有一节 <a href=\"http://facebook.github.io/react-native/releases/0.42/docs/integration-with-existing-apps.html\" target=\"_blank\" rel=\"external\">Integration with Existing Apps</a> , 只需要按照一步步做即可。</p>\n<p>以 Android 为例，大概要做以下几步：</p>\n<ol>\n<li>添加 <code>gradle</code> 依赖：<code>compile &quot;com.facebook.react:react-native:+&quot; // From node_modules.</code>；</li>\n<li>创建空的 <code>Activity</code> ，指定 <code>JS bundle</code> 和入口 <code>Component</code> 名字即会自动在这个 <code>Activity</code> 里去加载 <code>JS bundle</code> 文件；</li>\n<li>在 Activity 里监听 onBackPressed 事件，用来与 JS 端协作处理返回键点击事件。</li>\n<li>启动 server，运行 App 即可。</li>\n</ol>\n<p>总之需要说明的是，即使是移动端小白，也可以遵循文档里的指示完成这一步。接下来的大部分时间只要关心 JS 端开发就行了。</p>\n<h3 id=\"五、Javascript、React-及-ES6、JSX-语法\"><a href=\"#五、Javascript、React-及-ES6、JSX-语法\" class=\"headerlink\" title=\"五、Javascript、React 及 ES6、JSX 语法\"></a>五、Javascript、React 及 ES6、JSX 语法</h3><p>我们知道 RN 采用了 React 和 ES6 的语法，所以我们必须先对这些语法有一定了解才能去读 RN 的代码。</p>\n<p>关于 <code>Javascript</code>，我推荐 W3School 里的 <a href=\"http://www.w3school.com.cn/js/\" target=\"_blank\" rel=\"external\">JS语法</a> 和 MDN 里的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript\" target=\"_blank\" rel=\"external\">JS手册</a>，大家只要对一些基础语法做些了解就可以。</p>\n<p>关于 <code>React</code>，我推荐 <a href=\"http://www.ruanyifeng.com/\" target=\"_blank\" rel=\"external\">阮一峰</a> 写的 <a href=\"http://www.ruanyifeng.com/blog/2015/03/react.html\" target=\"_blank\" rel=\"external\">React 入门实例教程</a>，基本上把文章读一遍，再自己动手写一遍，就能理会到 React 的大致用法了。</p>\n<p>关于 <code>ES6</code>、<code>ES7</code>、<code>JSX</code>等，感兴趣的可以看一下 RN 文档中 <a href=\"http://facebook.github.io/react-native/releases/0.42/docs/javascript-environment.html\" target=\"_blank\" rel=\"external\">Javascript Environment</a> 里提到的支持的方法，需要时再来查询也可以。也可以看 <code>Babel</code> 出的 <a href=\"https://babeljs.io/learn-es2015/\" target=\"_blank\" rel=\"external\">Learn ES2015 手册</a>。</p>\n<p>这里有一个很不错的 GitHub 项目，帮助你通过交互性的例子来快速上手语法知识：<a href=\"http://www.reactnativeexpress.com/\" target=\"_blank\" rel=\"external\">React Native Express</a>。</p>\n<h3 id=\"六、UI-层\"><a href=\"#六、UI-层\" class=\"headerlink\" title=\"六、UI 层\"></a>六、UI 层</h3><p>简单熟悉了 <code>React</code> 语法后，基本能正常阅读 RN 的示例代码了。</p>\n<p>正式开发 App 的第一步当然就是写 UI 界面了，由于 RN 已经封装好了一套 JS 的 UI 组件，这些组件会自动在 Android/iOS 端调用对应的原生 UI 组件，因此我们只需要熟悉这些 UI 组件的用法及属性、回调方法即可。</p>\n<p>我们可以在文档的 <a href=\"http://facebook.github.io/react-native/releases/0.42/docs/getting-started.html\" target=\"_blank\" rel=\"external\">Components</a> 看到不少组件，比如<code>View, Text, Button, Image, Switch</code>, 还有我们用的最多的 <code>ScrollView</code> 和 <code>ListView</code>。</p>\n<p>在读文档时，我们可以先通过一边写代码一边读文档的方式进行，RN 非常贴心，直接在 Web 里嵌入了模拟器，我们只要修改编辑框里的代码，立即就能在右边的模拟器看到效果。这极大的降低了我们的学习成本。<br><img src=\"http://upload-images.jianshu.io/upload_images/281665-09965625af9b3a49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Text Component\"></p>\n<p>另外，在学习一个组件时，我们要区分哪个属性是某个平台特有的。比如下面两个 Text 的属性：<code>textBreakStrategy</code> 只会在 Android 上生效，而 <code>adjustsFontSizeToFit</code> 只可以用在 iOS 上。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/281665-c8f4990d8334f3ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Platform Specific Properties\"></p>\n<p>然后，如果你希望在 Android 和 iOS 里显示不同的内容怎么办呢？RN 里有一节是<a href=\"http://facebook.github.io/react-native/releases/0.42/docs/platform-specific-code.html\" target=\"_blank\" rel=\"external\">Platform Specific Code</a>，可以有如下几种形式来进行区分：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (Platform.OS === &apos;ios&apos;) &#123;</div><div class=\"line\">  // stuff for ios</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">  // stuff for android</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>除此之外，UI 组件的用法学习就很类似常规的 Html 标签了，只要知道其使用方式即可，甚至需要用的时候再来查文档也行。</p>\n<h3 id=\"七、网络请求层\"><a href=\"#七、网络请求层\" class=\"headerlink\" title=\"七、网络请求层\"></a>七、网络请求层</h3><p>学完上面的我们已经能够写出 UI 界面了，而且这套界面已经能够在不同平台上转化成各自平台的 Native UI 了。然后，我们就需要去网络层请求真实数据了。</p>\n<p>RN 里提供了 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\" target=\"_blank\" rel=\"external\">Fetch API</a> 来进行实现。举个例子，你想要通过 GET 方法去请求数据并转化成 JSON，可以通过如下代码实现：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">fetch(&apos;https://facebook.github.io/react-native/movies.json&apos;)</div><div class=\"line\">      .then((response) =&gt; response.json())</div><div class=\"line\">      .then((responseJson) =&gt; &#123;</div><div class=\"line\">        return responseJson.movies;</div><div class=\"line\">      &#125;)</div><div class=\"line\">      .catch((error) =&gt; &#123;</div><div class=\"line\">        console.error(error);</div><div class=\"line\">      &#125;);</div></pre></td></tr></table></figure></p>\n<p>熟悉 Reactive 编程的伙伴应该对这样的语法不陌生，比如 Android 上的 <a href=\"https://github.com/ReactiveX/RxJava\" target=\"_blank\" rel=\"external\">RxJava</a>； iOS 上的 <a href=\"https://github.com/ReactiveX/RxSwift\" target=\"_blank\" rel=\"external\">RxSwift</a>；Web 上的 <a href=\"https://github.com/Reactive-Extensions/RxJS\" target=\"_blank\" rel=\"external\">RxJS</a>。上面 function 的功能就是：请求网址 <code>https://facebook.github.io/react-native/movies.json</code>，把返回的 Response 转化成 JSON object，取出 JSON object 里的 <code>movies</code> 字段。同时，如果发生 error 会被 catch 住。</p>\n<p>当然，上面是最基本的 GET 请求，Fetch API 还支持自定义 Headers，更换 Method，添加 Body 等。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">fetch(&apos;https://mywebsite.com/endpoint/&apos;, &#123;</div><div class=\"line\">  method: &apos;POST&apos;,</div><div class=\"line\">  headers: &#123;</div><div class=\"line\">    &apos;Accept&apos;: &apos;application/json&apos;,</div><div class=\"line\">    &apos;Content-Type&apos;: &apos;application/json&apos;,</div><div class=\"line\">  &#125;,</div><div class=\"line\">  body: JSON.stringify(&#123;</div><div class=\"line\">    firstParam: &apos;yourValue&apos;,</div><div class=\"line\">    secondParam: &apos;yourOtherValue&apos;,</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>上面构建了一个基本的 POST 请求，添加了自己的 Headers:<code>Accept</code>和<code>Content-Type</code>，添加了 Body。</p>\n<p>因此看下来，RN 里的网络请求不仅具备了 Reactive 编程的简洁，也能自定义常规的 Http 请求，写法简单。</p>\n<p>除了 Fetch API 之外，RN 还内置了 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\" target=\"_blank\" rel=\"external\">XMLHttpRequest API(俗称 AJAX)</a>，而且支持<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\" target=\"_blank\" rel=\"external\">TCP 全双工通信方式 WebSocket</a>。</p>\n<h3 id=\"八、Debugging-调试\"><a href=\"#八、Debugging-调试\" class=\"headerlink\" title=\"八、Debugging 调试\"></a>八、Debugging 调试</h3><p>调试是很多程序员非常关注的一个环节，因为 RN 是用 JS 写完后到 Native 解释成 Native 方法来执行的，因此如果能快速调试 JS 代码是非常重要的一环。</p>\n<p>最开始 RN 的调试功能比较弱，不过现在的 Debugging 功能在我看来还是很不错的。一般来讲可以有以下几个调试方式：</p>\n<p>#####1. In-App 报错<br>RN 里默认集成了 In-App 的错误提示方式，即在 App 运行过程中会弹出全屏的报错信息呈现给你，而你也可以通过阅读具体的错误信息快速找到错误原因。通过点击这个错误信息里的某一行，会立即自动打开对应的代码。<br><img src=\"http://upload-images.jianshu.io/upload_images/281665-6531d24c41982690.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"In-App Error\"></p>\n<p>#####2. Console.log<br>在开发 Client 时，我们一般都会用 <code>Log.log()</code> 来打印一些运行时变量的值，然后实时查看打印出来的 log 来调试，在 RN 也一样，你只要在 JS 里写一句 <code>console.log(&#39;this is log data&#39;)</code>，就会自动在 Client 的常规 log 里能看到，比如 Android 的 <code>adb logcat</code> 里就会自动打印出<code>&#39;this is log data&#39;</code>一行。</p>\n<p>#####3. 大杀器：Chrome 逐行调试<br>这个杀器的最牛逼之处就是可以像 Client 一样，逐行调试代码！</p>\n<p>我们来看下面一张图。从左往右。先是文件目录，我们选中了 <code>index.js</code> 文件夹，然后第二个 Tab，是 <code>index.js</code> 的内容。这里关键的是我可以直接选中某一行代码设断点。当 Client 运行到这一行时，就会在第三个 Tab 里打印出运行时环境及变量。我们可以看到 <code>props</code> 里就有我们传进去的变量值。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/281665-d2fb4470d8ae27b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Chrome Debug\"></p>\n<p>有了以上几种调试方式，我们几乎可以和常规的 Native 开发一样来调试 RN 代码了，不得不说 RN Team 确实牛 x 啊！</p>\n<h3 id=\"九、从-JS-调用-Native-方法或显示自定义-Native-View\"><a href=\"#九、从-JS-调用-Native-方法或显示自定义-Native-View\" class=\"headerlink\" title=\"九、从 JS 调用 Native 方法或显示自定义 Native View\"></a>九、从 JS 调用 Native 方法或显示自定义 Native View</h3><p>这又是另一个牛 x 之处啊。</p>\n<p>很多人觉得 RN 限制太多，只能支持有限的 View 组件和有限的方法，难以发挥 Client 的最大性能。简单点说，在 Client 可以绘制复杂的 View，可以调用高性能 C++ 等底层代码，但 RN 却做不到。</p>\n<p>于是，RN 里提出了 <code>Native Modules</code> 和 <code>Native UI Component</code> 两种技术。</p>\n<p>#####Native Modules：JS 里直接调用 Native(Java/Swift) 方法<br>所谓 Native Modules，就是自己在 Client 写好了某些方法，由于某些原因这些方法不太方便或者无法搬到 RN 里面，那么，我们可以在 Client 把这些方法暴露出来给 RN，然后在 JS 里可以像 import 普通的 module 一样把这些 Native Modules 引入进去，直接调用。</p>\n<p>具体的实现方法可以参考文档 <a href=\"http://facebook.github.io/react-native/releases/0.42/docs/native-modules-ios.html\" target=\"_blank\" rel=\"external\">iOS Native Modules</a> 和 <a href=\"http://facebook.github.io/react-native/releases/0.42/docs/native-modules-android.html\" target=\"_blank\" rel=\"external\">Android Native Modules</a>。</p>\n<p>#####Native UI Component：JS 里直接调用自定义的 Native View<br>很多时候我们在写 Client 时，为了实现 Designer 天马行空的设计，常常需要自定义 View，即自己绘制某些系统并不提供的特定 UI。可想而知，这些 View 肯定不会出现在 RN 的 UI Component 里。</p>\n<p>那么，我们就需要首先在 Native 层自己写好一个自定义 View，然后利用<code>Native UI Component</code> 技术把这个 View 及其中某些 public 方法暴露给 RN，那么 RN 就能直接 import 进来并显示了。</p>\n<p>具体的实现方法可以参考文档 <a href=\"http://facebook.github.io/react-native/releases/0.42/docs/native-components-ios.html\" target=\"_blank\" rel=\"external\">iOS Native UI Component</a> 和 <a href=\"http://facebook.github.io/react-native/releases/0.42/docs/native-components-android.html\" target=\"_blank\" rel=\"external\">Android Native UI Component</a>。</p>\n<p><strong>如果读过文档不是很理解的小伙伴可以留言，我再 post 一些 demo 代码上来</strong></p>\n<h3 id=\"十、React-Native-适合你吗？\"><a href=\"#十、React-Native-适合你吗？\" class=\"headerlink\" title=\"十、React Native 适合你吗？\"></a>十、React Native 适合你吗？</h3><p>这里借鉴下前段时间旧金山的 React Native 会议上的一些优劣总结给读者以参考。当然不一定对，仅供参考。</p>\n<p>RN 的优点：</p>\n<ul>\n<li>跨平台</li>\n<li>原生的用户体验</li>\n<li>开发者体验好</li>\n<li>动态更新代码逻辑</li>\n<li>社区强大</li>\n<li>有个好爹</li>\n</ul>\n<p>RN 的缺点：</p>\n<ul>\n<li>不够成熟</li>\n<li>不够稳定</li>\n<li>生态系统在搭建中</li>\n<li>优质的 App 需要时间打磨</li>\n<li>偶尔需要写 Native 代码(也就是 JS + Swift + Java)</li>\n</ul>\n<p>适合下面这些人/公司：</p>\n<ul>\n<li>你对 JS/React 有一定了解</li>\n<li>Web 开发人员比 Mobile 开发人员多</li>\n<li>有意愿投资精力给 RN</li>\n<li>App 设计不是特别区分 Android 和 iOS</li>\n<li>希望热更新</li>\n</ul>\n<p>下面这些人要稍微考虑下：</p>\n<ul>\n<li>完全不了解 JS/React</li>\n<li>已经有现成的 Android/iOS team</li>\n<li>App 设计严格遵守 Android、iOS各自设计规范</li>\n<li>不想要投入时间／金钱给 RN</li>\n</ul>\n<h3 id=\"十一、为什么要写这篇文章\"><a href=\"#十一、为什么要写这篇文章\" class=\"headerlink\" title=\"十一、为什么要写这篇文章\"></a>十一、为什么要写这篇文章</h3><p>几个月前我对 React Native 也非常不看好，当然现在也没有说非常看好。或者说，写这篇文章毫无为 React Native 布道之意。</p>\n<p>接触 React Native 主要是因为业务需要，PM 希望能够随时改动某块变化较大的模块，常规的开发提交流程往往需要较长的时间，而热修复技术本身并未得到 Google 和 Apple 的官方认可，也就是随时可能因破坏生态安全之名被取缔。</p>\n<p>因此才考虑去了解 Hybrid 开发和 JS Native 开发模式，在了解过程中，又由于性能差、用户体验不好而放弃 Hybrid，由于社区不完善、Bug 较多等原因放弃 Weex，最终才选择了 React Native，开始学习 React、JSX等语法。</p>\n<p>目前使用下来对 React Native 的一些个人感受：</p>\n<ol>\n<li>学习门槛并没有开始想象那么高。大概只花了两三天时间就熟悉了 Javascript、React 框架、JSX语法，然后就开始着手业务开发。</li>\n<li>对 Android App 的影响。React Native 会给 Android 端带来 <code>6MB</code> 左右的 size 增幅，不过在采用了 <code>split apk</code> 后就只有 <code>1MB</code> 左右增幅。</li>\n<li>Debug 功能比较完善，至少不用担心发生问题后不知从哪下手。</li>\n<li>性能还行。最初担心的是 React Native 性能不好，但自己上手后，并没有明显感觉到很明显的 React Native 对 App 性能的负面影响，无论是 iOS 还是 Android，当然，这一点还在继续考察中。</li>\n<li>动态部署真的很不错。以前每次写好代码都要花不少时间来编译运行，而现在只要写一份代码，就可以同时在 Android 和 iOS 实时更新了，这无疑节省了生命。</li>\n<li>有待完善。当然，React Native 中确实还存在着不少问题，生态系统也还不够完善。不过我相信，这只是时间问题。</li>\n</ol>\n<p>关于React Native一直以来都有很多争议。</p>\n<p>不过我想说的是，<strong>React Native 所代表的跨平台、动态更新技术已经引起了全世界开发者关注，而且这种技术势必会是未来的需求和潮流。React Native 不一定会成功，但至少目前 React Native 已经是这一领域的领跑者。</strong></p>\n<p>而写这篇文章的目的，就是希望告诉更多开发者，<strong>React Native 并不完美，但值得一试。</strong></p>\n<p>谢谢。</p>\n<p>wingjay</p>\n<p><a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\">我的Github</a>: <a href=\"https://github.com/wingjay\" target=\"_blank\" rel=\"external\">https://github.com/wingjay</a><br><a href=\"http://weibo.com/u/1625892654\" target=\"_blank\" rel=\"external\">微博 iam_wingjay</a>: <a href=\"http://weibo.com/u/1625892654\" target=\"_blank\" rel=\"external\">http://weibo.com/u/1625892654</a></p>\n<p>如果有问题，可以给我留言或发邮件<a href=\"&#109;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#x79;&#105;&#110;&#x6a;&#105;&#x65;&#115;&#x68;&#x40;&#x31;&#x32;&#x36;&#x2e;&#x63;&#x6f;&#109;\">&#x79;&#105;&#110;&#x6a;&#105;&#x65;&#115;&#x68;&#x40;&#x31;&#x32;&#x36;&#x2e;&#x63;&#x6f;&#109;</a></p>","sticky":0}],"PostAsset":[],"PostCategory":[{"post_id":"cjxcplsgo00093dn82a5ephae","category_id":"cjxcplsgr000e3dn82jqzs8hx","_id":"cjxcplsgw000m3dn87kc7n4e9"},{"post_id":"cjxcplsgs000h3dn8mmkfszoo","category_id":"cjxcplsgr000e3dn82jqzs8hx","_id":"cjxcplsgx000q3dn8ngsa3mvt"},{"post_id":"cjxcplsgt000k3dn89w7fx7pp","category_id":"cjxcplsgr000e3dn82jqzs8hx","_id":"cjxcplsgy000t3dn8yrv0qqdb"},{"post_id":"cjxcplsgp000c3dn8y3a6c7xf","category_id":"cjxcplsgt000i3dn8me7aqht1","_id":"cjxcplsh0000x3dn8okhryvb5"},{"post_id":"cjxcplsgx000p3dn8nu86dwhe","category_id":"cjxcplsgr000e3dn82jqzs8hx","_id":"cjxcplsh100113dn88ztn880u"},{"post_id":"cjxcplsgk00053dn8hdxyzemz","category_id":"cjxcplsgn00083dn8ywgyzidd","_id":"cjxcplsh200153dn8kgdbezgb"},{"post_id":"cjxcplsgk00053dn8hdxyzemz","category_id":"cjxcplsgw000n3dn8wionfvvk","_id":"cjxcplsh300183dn85laatytn"},{"post_id":"cjxcplsgz000w3dn84vfzg0y9","category_id":"cjxcplsgr000e3dn82jqzs8hx","_id":"cjxcplsh4001b3dn8t0od1mds"},{"post_id":"cjxcplsgr000d3dn841i2sxre","category_id":"cjxcplsgt000i3dn8me7aqht1","_id":"cjxcplsh5001e3dn84kkzyor5"},{"post_id":"cjxcplsgv000l3dn8itqt92ab","category_id":"cjxcplsh4001a3dn86estxal2","_id":"cjxcplsh6001k3dn8y19kenbt"},{"post_id":"cjxcplsh100103dn817mk112f","category_id":"cjxcplsh6001l3dn8yg0jfe0o","_id":"cjxcplsh7001r3dn83h2m3z8j"},{"post_id":"cjxcplsh200143dn8nh69xj4z","category_id":"cjxcplsh4001a3dn86estxal2","_id":"cjxcplsh8001u3dn8kdiiajrx"},{"post_id":"cjxcplsgs000g3dn82j36ht1z","category_id":"cjxcplsh200133dn8bw6vgf10","_id":"cjxcplsh9001x3dn873iq7ffr"},{"post_id":"cjxcplsgs000g3dn82j36ht1z","category_id":"cjxcplsh7001s3dn89onx8wqg","_id":"cjxcplsh9001y3dn8guzusc80"},{"post_id":"cjxcplsgy000s3dn87nkonqzq","category_id":"cjxcplsh200133dn8bw6vgf10","_id":"cjxcplsh9001z3dn8i6hlfz8n"},{"post_id":"cjxcplsgy000s3dn87nkonqzq","category_id":"cjxcplsh7001s3dn89onx8wqg","_id":"cjxcplsh900203dn87xgqqn37"},{"post_id":"cjxcplsht00213dn8vcmo5skd","category_id":"cjxcplsh200133dn8bw6vgf10","_id":"cjxcplshv00263dn8iezb1ii1"},{"post_id":"cjxcplsht00223dn8sceth1g4","category_id":"cjxcplsh200133dn8bw6vgf10","_id":"cjxcplsi0002f3dn8i6nhssip"},{"post_id":"cjxcplsht00223dn8sceth1g4","category_id":"cjxcplshw00283dn8cd312bqw","_id":"cjxcplsi2002j3dn8ffj9rb14"},{"post_id":"cjxcplshy002d3dn8pu401bk9","category_id":"cjxcplshy002c3dn8esip8heb","_id":"cjxcplsi3002l3dn828kcel6c"},{"post_id":"cjxcplshu00243dn8tcvza4ao","category_id":"cjxcplshy002c3dn8esip8heb","_id":"cjxcplsi4002p3dn85zsom4zd"},{"post_id":"cjxcplsi1002i3dn8fw6hjh1w","category_id":"cjxcplshy002c3dn8esip8heb","_id":"cjxcplsi5002s3dn8eq5309lb"},{"post_id":"cjxcplshv00273dn8stu4ln11","category_id":"cjxcplshy002c3dn8esip8heb","_id":"cjxcplsi6002x3dn8lc2lguks"},{"post_id":"cjxcplsi2002k3dn88ayzwdq1","category_id":"cjxcplshy002c3dn8esip8heb","_id":"cjxcplsi700303dn8j1p24fr8"},{"post_id":"cjxcplsi4002o3dn8im65h72w","category_id":"cjxcplsh200133dn8bw6vgf10","_id":"cjxcplsi800353dn8qzom74o2"},{"post_id":"cjxcplsi4002o3dn8im65h72w","category_id":"cjxcplshw00283dn8cd312bqw","_id":"cjxcplsi900383dn8b6d721ep"},{"post_id":"cjxcplshw00293dn86hetq87e","category_id":"cjxcplshy002c3dn8esip8heb","_id":"cjxcplsia003d3dn8hzok1wiq"},{"post_id":"cjxcplshx002a3dn88yfg2mv7","category_id":"cjxcplshy002c3dn8esip8heb","_id":"cjxcplsic003g3dn8hytr7dbl"},{"post_id":"cjxcplsi7002z3dn8v2p1ymyv","category_id":"cjxcplsh6001l3dn8yg0jfe0o","_id":"cjxcplsic003j3dn8vlv44dj9"},{"post_id":"cjxcplshz002e3dn80qy9srhw","category_id":"cjxcplsh200133dn8bw6vgf10","_id":"cjxcplsid003m3dn8z1plfgyq"},{"post_id":"cjxcplshz002e3dn80qy9srhw","category_id":"cjxcplsi800323dn8gf1uyg31","_id":"cjxcplsif003p3dn8h542j3fv"},{"post_id":"cjxcplsia003c3dn8yzk4q6op","category_id":"cjxcplsh200133dn8bw6vgf10","_id":"cjxcplsif003s3dn8i2pz0bem"},{"post_id":"cjxcplsi6002w3dn8toyria3y","category_id":"cjxcplsh200133dn8bw6vgf10","_id":"cjxcplsif003u3dn8yw04hyvn"},{"post_id":"cjxcplsi6002w3dn8toyria3y","category_id":"cjxcplsi800323dn8gf1uyg31","_id":"cjxcplsig003y3dn8omd4skmf"},{"post_id":"cjxcplsib003f3dn8mz6zbflj","category_id":"cjxcplsh200133dn8bw6vgf10","_id":"cjxcplsih00463dn8u9u8waf1"},{"post_id":"cjxcplsib003f3dn8mz6zbflj","category_id":"cjxcplsig00413dn8v7tjxn34","_id":"cjxcplsii004a3dn8izmo10hf"},{"post_id":"cjxcplsi900373dn8h6nqebat","category_id":"cjxcplsif003w3dn8igycly7n","_id":"cjxcplsij004i3dn846eevkxf"},{"post_id":"cjxcplsi900373dn8h6nqebat","category_id":"cjxcplsii004c3dn8owhv7fto","_id":"cjxcplsij004l3dn8pln5ze4h"},{"post_id":"cjxcplsi4002r3dn8c6e72keo","category_id":"cjxcplsia003a3dn8nzhq4flz","_id":"cjxcplsik004o3dn82d99xfbt"},{"post_id":"cjxcplsi4002r3dn8c6e72keo","category_id":"cjxcplsig00433dn85pukq9it","_id":"cjxcplsik004p3dn8b7rtrewr"},{"post_id":"cjxcplsi4002r3dn8c6e72keo","category_id":"cjxcplsii004g3dn8xm3pqwfi","_id":"cjxcplsik004r3dn8sc9vp7dw"},{"post_id":"cjxcplsi800343dn8c3v4lwt0","category_id":"cjxcplsid003o3dn86rlphq85","_id":"cjxcplsik004t3dn8pq6o2fql"},{"post_id":"cjxcplsi800343dn8c3v4lwt0","category_id":"cjxcplsih00483dn8yp0j3xrd","_id":"cjxcplsil004w3dn83ljqo2dp"},{"post_id":"cjxcplsi800343dn8c3v4lwt0","category_id":"cjxcplsij004k3dn83nxopzjx","_id":"cjxcplsim004y3dn8vcp0zqpc"},{"post_id":"cjxcplsji005g3dn8vpi8szl4","category_id":"cjxcplsh200133dn8bw6vgf10","_id":"cjxcplsjl005l3dn8n77yvxk8"},{"post_id":"cjxcplsji005g3dn8vpi8szl4","category_id":"cjxcplshw00283dn8cd312bqw","_id":"cjxcplsjm005n3dn87o967jvf"},{"post_id":"cjxcplsjj005h3dn8k9jmrw62","category_id":"cjxcplsh200133dn8bw6vgf10","_id":"cjxcplsjm005q3dn8baopoqqk"},{"post_id":"cjxcplsjj005h3dn8k9jmrw62","category_id":"cjxcplsi800323dn8gf1uyg31","_id":"cjxcplsjm005s3dn84p0813sb"},{"post_id":"cjxcplsjk005j3dn8y4mxc76q","category_id":"cjxcplsh200133dn8bw6vgf10","_id":"cjxcplsjn005v3dn8u0ctdmgg"},{"post_id":"cjxcplsjk005j3dn8y4mxc76q","category_id":"cjxcplsi800323dn8gf1uyg31","_id":"cjxcplsjn005x3dn8o74aa6s8"},{"post_id":"cjxcplsjl005k3dn8hnaz4shy","category_id":"cjxcplsh200133dn8bw6vgf10","_id":"cjxcplsjn005z3dn8mucsv0hm"},{"post_id":"cjxcplsk900653dn8ntcvz7a8","category_id":"cjxcplska00663dn8hkga270v","_id":"cjxcplskb00693dn8jyrud26i"}],"PostTag":[{"post_id":"cjxcplsgd00003dn8oll1zbom","tag_id":"cjxcplsgj00043dn838vto5b3","_id":"cjxcplsgp000b3dn83y1xgtz4"},{"post_id":"cjxcplsgk00053dn8hdxyzemz","tag_id":"cjxcplsgp000a3dn85zvdgbqz","_id":"cjxcplsgy000r3dn8gy7uuq2m"},{"post_id":"cjxcplsgk00053dn8hdxyzemz","tag_id":"cjxcplsgr000f3dn8bkgldauf","_id":"cjxcplsgz000u3dn874bixpkx"},{"post_id":"cjxcplsgk00053dn8hdxyzemz","tag_id":"cjxcplsgt000j3dn8smlbyloo","_id":"cjxcplsh1000z3dn8duoxflfg"},{"post_id":"cjxcplsgv000l3dn8itqt92ab","tag_id":"cjxcplsgj00043dn838vto5b3","_id":"cjxcplsh100123dn8atl52x9h"},{"post_id":"cjxcplsgx000p3dn8nu86dwhe","tag_id":"cjxcplsgj00043dn838vto5b3","_id":"cjxcplsh300173dn8a74igt9c"},{"post_id":"cjxcplsgl00073dn8y93ic0ci","tag_id":"cjxcplsgx000o3dn8rx8piimk","_id":"cjxcplsh400193dn8oq57xitx"},{"post_id":"cjxcplsh100103dn817mk112f","tag_id":"cjxcplsgj00043dn838vto5b3","_id":"cjxcplsh4001d3dn8kj4cwgx2"},{"post_id":"cjxcplsgp000c3dn8y3a6c7xf","tag_id":"cjxcplsh0000y3dn82rh2siy9","_id":"cjxcplsh5001f3dn8j3503dcx"},{"post_id":"cjxcplsh200143dn8nh69xj4z","tag_id":"cjxcplsgj00043dn838vto5b3","_id":"cjxcplsh5001i3dn8f3avgppm"},{"post_id":"cjxcplsgr000d3dn841i2sxre","tag_id":"cjxcplsh0000y3dn82rh2siy9","_id":"cjxcplsh6001j3dn8ifs6czv5"},{"post_id":"cjxcplsgs000g3dn82j36ht1z","tag_id":"cjxcplsh4001c3dn8gnvxfymb","_id":"cjxcplsh6001m3dn8ox12h47t"},{"post_id":"cjxcplsgs000h3dn8mmkfszoo","tag_id":"cjxcplsh5001h3dn8ll0dja0t","_id":"cjxcplsh6001o3dn8bxn0nd1v"},{"post_id":"cjxcplsgy000s3dn87nkonqzq","tag_id":"cjxcplsh6001n3dn81qgcnks2","_id":"cjxcplsh8001t3dn8p2n9hd3s"},{"post_id":"cjxcplsgy000s3dn87nkonqzq","tag_id":"cjxcplsh7001q3dn8ethnrw8d","_id":"cjxcplsh8001w3dn8zlbz56vu"},{"post_id":"cjxcplsht00213dn8vcmo5skd","tag_id":"cjxcplsh4001c3dn8gnvxfymb","_id":"cjxcplshu00233dn8gxpionvd"},{"post_id":"cjxcplsht00223dn8sceth1g4","tag_id":"cjxcplsh4001c3dn8gnvxfymb","_id":"cjxcplsi4002q3dn830kqfrij"},{"post_id":"cjxcplsht00223dn8sceth1g4","tag_id":"cjxcplshv00253dn83xcezlv9","_id":"cjxcplsi5002t3dn8kxxlepgk"},{"post_id":"cjxcplsht00223dn8sceth1g4","tag_id":"cjxcplshy002b3dn88alzhvck","_id":"cjxcplsi7002y3dn8iro4xz7v"},{"post_id":"cjxcplsht00223dn8sceth1g4","tag_id":"cjxcplsi1002g3dn8ff02zpmy","_id":"cjxcplsi800313dn8091lyup0"},{"post_id":"cjxcplsi4002o3dn8im65h72w","tag_id":"cjxcplsh4001c3dn8gnvxfymb","_id":"cjxcplsi900363dn8k5bovgeu"},{"post_id":"cjxcplsi4002o3dn8im65h72w","tag_id":"cjxcplshv00253dn83xcezlv9","_id":"cjxcplsia00393dn86u8o7eoy"},{"post_id":"cjxcplshu00243dn8tcvza4ao","tag_id":"cjxcplsi3002n3dn8nvaqx7xu","_id":"cjxcplsib003e3dn8elxp2r2x"},{"post_id":"cjxcplshu00243dn8tcvza4ao","tag_id":"cjxcplsgp000a3dn85zvdgbqz","_id":"cjxcplsic003h3dn8q8nqlxtu"},{"post_id":"cjxcplshv00273dn8stu4ln11","tag_id":"cjxcplsi3002n3dn8nvaqx7xu","_id":"cjxcplsid003l3dn8sxyg8lq8"},{"post_id":"cjxcplsib003f3dn8mz6zbflj","tag_id":"cjxcplsh4001c3dn8gnvxfymb","_id":"cjxcplsid003n3dn8vhit3bgc"},{"post_id":"cjxcplshw00293dn86hetq87e","tag_id":"cjxcplsi3002n3dn8nvaqx7xu","_id":"cjxcplsif003r3dn8xojctbea"},{"post_id":"cjxcplshw00293dn86hetq87e","tag_id":"cjxcplsia003b3dn8v2szgmca","_id":"cjxcplsif003t3dn8zupr68a1"},{"post_id":"cjxcplshx002a3dn88yfg2mv7","tag_id":"cjxcplsi3002n3dn8nvaqx7xu","_id":"cjxcplsig003x3dn8wppofcm2"},{"post_id":"cjxcplshy002d3dn8pu401bk9","tag_id":"cjxcplsi3002n3dn8nvaqx7xu","_id":"cjxcplsig003z3dn8zjj9wlas"},{"post_id":"cjxcplshz002e3dn80qy9srhw","tag_id":"cjxcplsh4001c3dn8gnvxfymb","_id":"cjxcplsih00443dn8rb308632"},{"post_id":"cjxcplshz002e3dn80qy9srhw","tag_id":"cjxcplsif003v3dn8n7obazph","_id":"cjxcplsih00453dn8c5ugvter"},{"post_id":"cjxcplshz002e3dn80qy9srhw","tag_id":"cjxcplsig00403dn876a602wg","_id":"cjxcplsih00493dn86l3as0yq"},{"post_id":"cjxcplsi1002i3dn8fw6hjh1w","tag_id":"cjxcplsi3002n3dn8nvaqx7xu","_id":"cjxcplsii004d3dn8259vdpxx"},{"post_id":"cjxcplsi1002i3dn8fw6hjh1w","tag_id":"cjxcplsia003b3dn8v2szgmca","_id":"cjxcplsii004e3dn8v1pd40hu"},{"post_id":"cjxcplsi2002k3dn88ayzwdq1","tag_id":"cjxcplsi3002n3dn8nvaqx7xu","_id":"cjxcplsij004j3dn82dmgbkgt"},{"post_id":"cjxcplsi2002k3dn88ayzwdq1","tag_id":"cjxcplsii004f3dn8xc0hffj7","_id":"cjxcplsij004m3dn8qgohauxf"},{"post_id":"cjxcplsi4002r3dn8c6e72keo","tag_id":"cjxcplsij004h3dn8thpn2i2t","_id":"cjxcplsik004s3dn8wua6n1rp"},{"post_id":"cjxcplsi4002r3dn8c6e72keo","tag_id":"cjxcplsik004n3dn83ol4gvh7","_id":"cjxcplsil004u3dn83bcf6dv7"},{"post_id":"cjxcplsi6002w3dn8toyria3y","tag_id":"cjxcplsh4001c3dn8gnvxfymb","_id":"cjxcplsim004x3dn8jzels38s"},{"post_id":"cjxcplsi6002w3dn8toyria3y","tag_id":"cjxcplsig00403dn876a602wg","_id":"cjxcplsin004z3dn8kxue85zi"},{"post_id":"cjxcplsi7002z3dn8v2p1ymyv","tag_id":"cjxcplsil004v3dn8zdzf3crh","_id":"cjxcplsin00513dn8fpzxxx3x"},{"post_id":"cjxcplsi7002z3dn8v2p1ymyv","tag_id":"cjxcplsgj00043dn838vto5b3","_id":"cjxcplsin00523dn8va2vure4"},{"post_id":"cjxcplsi900373dn8h6nqebat","tag_id":"cjxcplsin00503dn8wvifhb0o","_id":"cjxcplsip00583dn8slp0vbm8"},{"post_id":"cjxcplsi900373dn8h6nqebat","tag_id":"cjxcplsin00533dn8j4exrpjn","_id":"cjxcplsip00593dn83045mux8"},{"post_id":"cjxcplsi900373dn8h6nqebat","tag_id":"cjxcplsin00543dn8rdy3gv8r","_id":"cjxcplsip005a3dn8648f59hf"},{"post_id":"cjxcplsi900373dn8h6nqebat","tag_id":"cjxcplsik004n3dn83ol4gvh7","_id":"cjxcplsip005b3dn8rb0hsd73"},{"post_id":"cjxcplsi900373dn8h6nqebat","tag_id":"cjxcplsij004h3dn8thpn2i2t","_id":"cjxcplsip005c3dn8t9ck02uj"},{"post_id":"cjxcplsia003c3dn8yzk4q6op","tag_id":"cjxcplsh4001c3dn8gnvxfymb","_id":"cjxcplsip005d3dn8wtho6j8c"},{"post_id":"cjxcplsia003c3dn8yzk4q6op","tag_id":"cjxcplsio00573dn8lg2utuoh","_id":"cjxcplsip005e3dn8wmmznjqd"},{"post_id":"cjxcplsia003c3dn8yzk4q6op","tag_id":"cjxcplsi3002n3dn8nvaqx7xu","_id":"cjxcplsip005f3dn8pr04unuh"},{"post_id":"cjxcplsjk005j3dn8y4mxc76q","tag_id":"cjxcplsh4001c3dn8gnvxfymb","_id":"cjxcplsjl005m3dn8ebrvwxaw"},{"post_id":"cjxcplsjk005j3dn8y4mxc76q","tag_id":"cjxcplsig00403dn876a602wg","_id":"cjxcplsjm005p3dn867lja3jp"},{"post_id":"cjxcplsjl005k3dn8hnaz4shy","tag_id":"cjxcplsh4001c3dn8gnvxfymb","_id":"cjxcplsjm005r3dn8dtgqswcc"},{"post_id":"cjxcplsji005g3dn8vpi8szl4","tag_id":"cjxcplsh4001c3dn8gnvxfymb","_id":"cjxcplsjn005u3dn8aj28w2k6"},{"post_id":"cjxcplsji005g3dn8vpi8szl4","tag_id":"cjxcplshv00253dn83xcezlv9","_id":"cjxcplsjn005w3dn8jgrmu0ap"},{"post_id":"cjxcplsji005g3dn8vpi8szl4","tag_id":"cjxcplsjk005i3dn8c60x2hl9","_id":"cjxcplsjn005y3dn8dqxzsr32"},{"post_id":"cjxcplsji005g3dn8vpi8szl4","tag_id":"cjxcplsi1002g3dn8ff02zpmy","_id":"cjxcplsjn00603dn83g7vwowz"},{"post_id":"cjxcplsjj005h3dn8k9jmrw62","tag_id":"cjxcplsh4001c3dn8gnvxfymb","_id":"cjxcplsjn00613dn82ee0e675"},{"post_id":"cjxcplsjj005h3dn8k9jmrw62","tag_id":"cjxcplsig00403dn876a602wg","_id":"cjxcplsjo00623dn8tahkgbud"},{"post_id":"cjxcplsjj005h3dn8k9jmrw62","tag_id":"cjxcplsjm005o3dn81cpebvc3","_id":"cjxcplsjp00633dn8cwu91xu7"},{"post_id":"cjxcplsjj005h3dn8k9jmrw62","tag_id":"cjxcplsjm005t3dn8tik2k3oz","_id":"cjxcplsjp00643dn871zk4a8w"},{"post_id":"cjxcplsk900653dn8ntcvz7a8","tag_id":"cjxcplska00673dn82u8w8kqe","_id":"cjxcplskb00683dn8vn5ozwbq"}],"Tag":[{"name":"随笔","_id":"cjxcplsgj00043dn838vto5b3"},{"name":"动态代理","_id":"cjxcplsgp000a3dn85zvdgbqz"},{"name":"装饰器","_id":"cjxcplsgr000f3dn8bkgldauf"},{"name":"面向切面编程","_id":"cjxcplsgt000j3dn8smlbyloo"},{"name":"welcome","_id":"cjxcplsgx000o3dn8rx8piimk"},{"name":"摄影","_id":"cjxcplsh0000y3dn82rh2siy9"},{"name":"Android","_id":"cjxcplsh4001c3dn8gnvxfymb"},{"name":"学习计划","_id":"cjxcplsh5001h3dn8ll0dja0t"},{"name":"cool","_id":"cjxcplsh6001n3dn81qgcnks2"},{"name":"动效","_id":"cjxcplsh7001q3dn8ethnrw8d"},{"name":"架构","_id":"cjxcplshv00253dn83xcezlv9"},{"name":"高可用","_id":"cjxcplshy002b3dn88alzhvck"},{"name":"网络","_id":"cjxcplsi1002g3dn8ff02zpmy"},{"name":"Java","_id":"cjxcplsi3002n3dn8nvaqx7xu"},{"name":"Annotation","_id":"cjxcplsia003b3dn8v2szgmca"},{"name":"RxJava","_id":"cjxcplsif003v3dn8n7obazph"},{"name":"带你学开源项目","_id":"cjxcplsig00403dn876a602wg"},{"name":"多线程","_id":"cjxcplsii004f3dn8xc0hffj7"},{"name":"一天变cool","_id":"cjxcplsij004h3dn8thpn2i2t"},{"name":"个人博客","_id":"cjxcplsik004n3dn83ol4gvh7"},{"name":"Goodbye2015 Hi 2016","_id":"cjxcplsil004v3dn8zdzf3crh"},{"name":"GitHub","_id":"cjxcplsin00503dn8wvifhb0o"},{"name":"Blog","_id":"cjxcplsin00533dn8j4exrpjn"},{"name":"Hexo","_id":"cjxcplsin00543dn8rdy3gv8r"},{"name":"Lifecycle","_id":"cjxcplsio00573dn8lg2utuoh"},{"name":"长连接","_id":"cjxcplsjk005i3dn8c60x2hl9"},{"name":"内存泄漏","_id":"cjxcplsjm005o3dn81cpebvc3"},{"name":"性能优化","_id":"cjxcplsjm005t3dn8tik2k3oz"},{"name":"React Native","_id":"cjxcplska00673dn82u8w8kqe"}]}}